webpackJsonp([66299565496031],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _GraphQLError = __webpack_require__(57);
	
	Object.defineProperty(exports, 'GraphQLError', {
	  enumerable: true,
	  get: function get() {
	    return _GraphQLError.GraphQLError;
	  }
	});
	
	var _syntaxError = __webpack_require__(610);
	
	Object.defineProperty(exports, 'syntaxError', {
	  enumerable: true,
	  get: function get() {
	    return _syntaxError.syntaxError;
	  }
	});
	
	var _locatedError = __webpack_require__(259);
	
	Object.defineProperty(exports, 'locatedError', {
	  enumerable: true,
	  get: function get() {
	    return _locatedError.locatedError;
	  }
	});
	
	var _formatError = __webpack_require__(609);
	
	Object.defineProperty(exports, 'formatError', {
	  enumerable: true,
	  get: function get() {
	    return _formatError.formatError;
	  }
	});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .
	
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.CodeMirror = factory());
	}(this, (function () { 'use strict';
	
	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	var userAgent = navigator.userAgent;
	var platform = navigator.platform;
	
	var gecko = /gecko\/\d/i.test(userAgent);
	var ie_upto10 = /MSIE \d/.test(userAgent);
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	var edge = /Edge\/(\d+)/.exec(userAgent);
	var ie = ie_upto10 || ie_11up || edge;
	var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	var webkit = !edge && /WebKit\//.test(userAgent);
	var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	var chrome = !edge && /Chrome\//.test(userAgent);
	var presto = /Opera\//.test(userAgent);
	var safari = /Apple Computer/.test(navigator.vendor);
	var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	var phantom = /PhantomJS/.test(userAgent);
	
	var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	var android = /Android/.test(userAgent);
	// This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	var mac = ios || /Mac/.test(platform);
	var chromeOS = /\bCrOS\b/.test(userAgent);
	var windows = /win/i.test(platform);
	
	var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	if (presto_version) { presto_version = Number(presto_version[1]); }
	if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	var captureRightClick = gecko || (ie && ie_version >= 9);
	
	function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
	
	var rmClass = function(node, cls) {
	  var current = node.className;
	  var match = classTest(cls).exec(current);
	  if (match) {
	    var after = current.slice(match.index + match[0].length);
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	  }
	};
	
	function removeChildren(e) {
	  for (var count = e.childNodes.length; count > 0; --count)
	    { e.removeChild(e.firstChild); }
	  return e
	}
	
	function removeChildrenAndAdd(parent, e) {
	  return removeChildren(parent).appendChild(e)
	}
	
	function elt(tag, content, className, style) {
	  var e = document.createElement(tag);
	  if (className) { e.className = className; }
	  if (style) { e.style.cssText = style; }
	  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	  return e
	}
	// wrapper for elt, which removes the elt from the accessibility tree
	function eltP(tag, content, className, style) {
	  var e = elt(tag, content, className, style);
	  e.setAttribute("role", "presentation");
	  return e
	}
	
	var range;
	if (document.createRange) { range = function(node, start, end, endNode) {
	  var r = document.createRange();
	  r.setEnd(endNode || node, end);
	  r.setStart(node, start);
	  return r
	}; }
	else { range = function(node, start, end) {
	  var r = document.body.createTextRange();
	  try { r.moveToElementText(node.parentNode); }
	  catch(e) { return r }
	  r.collapse(true);
	  r.moveEnd("character", end);
	  r.moveStart("character", start);
	  return r
	}; }
	
	function contains(parent, child) {
	  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	    { child = child.parentNode; }
	  if (parent.contains)
	    { return parent.contains(child) }
	  do {
	    if (child.nodeType == 11) { child = child.host; }
	    if (child == parent) { return true }
	  } while (child = child.parentNode)
	}
	
	function activeElt() {
	  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	  // IE < 10 will throw when accessed while the page is loading or in an iframe.
	  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	  var activeElement;
	  try {
	    activeElement = document.activeElement;
	  } catch(e) {
	    activeElement = document.body || null;
	  }
	  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	    { activeElement = activeElement.shadowRoot.activeElement; }
	  return activeElement
	}
	
	function addClass(node, cls) {
	  var current = node.className;
	  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	}
	function joinClasses(a, b) {
	  var as = a.split(" ");
	  for (var i = 0; i < as.length; i++)
	    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	  return b
	}
	
	var selectInput = function(node) { node.select(); };
	if (ios) // Mobile Safari apparently has a bug where select() is broken.
	  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	else if (ie) // Suppress mysterious IE10 errors
	  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }
	
	function bind(f) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  return function(){return f.apply(null, args)}
	}
	
	function copyObj(obj, target, overwrite) {
	  if (!target) { target = {}; }
	  for (var prop in obj)
	    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	      { target[prop] = obj[prop]; } }
	  return target
	}
	
	// Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	function countColumn(string, end, tabSize, startIndex, startValue) {
	  if (end == null) {
	    end = string.search(/[^\s\u00a0]/);
	    if (end == -1) { end = string.length; }
	  }
	  for (var i = startIndex || 0, n = startValue || 0;;) {
	    var nextTab = string.indexOf("\t", i);
	    if (nextTab < 0 || nextTab >= end)
	      { return n + (end - i) }
	    n += nextTab - i;
	    n += tabSize - (n % tabSize);
	    i = nextTab + 1;
	  }
	}
	
	var Delayed = function() {this.id = null;};
	Delayed.prototype.set = function (ms, f) {
	  clearTimeout(this.id);
	  this.id = setTimeout(f, ms);
	};
	
	function indexOf(array, elt) {
	  for (var i = 0; i < array.length; ++i)
	    { if (array[i] == elt) { return i } }
	  return -1
	}
	
	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap = 30;
	
	// Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass = {toString: function(){return "CodeMirror.Pass"}};
	
	// Reused option objects for setSelection & friends
	var sel_dontScroll = {scroll: false};
	var sel_mouse = {origin: "*mouse"};
	var sel_move = {origin: "+move"};
	
	// The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	function findColumn(string, goal, tabSize) {
	  for (var pos = 0, col = 0;;) {
	    var nextTab = string.indexOf("\t", pos);
	    if (nextTab == -1) { nextTab = string.length; }
	    var skipped = nextTab - pos;
	    if (nextTab == string.length || col + skipped >= goal)
	      { return pos + Math.min(skipped, goal - col) }
	    col += nextTab - pos;
	    col += tabSize - (col % tabSize);
	    pos = nextTab + 1;
	    if (col >= goal) { return pos }
	  }
	}
	
	var spaceStrs = [""];
	function spaceStr(n) {
	  while (spaceStrs.length <= n)
	    { spaceStrs.push(lst(spaceStrs) + " "); }
	  return spaceStrs[n]
	}
	
	function lst(arr) { return arr[arr.length-1] }
	
	function map(array, f) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	  return out
	}
	
	function insertSorted(array, value, score) {
	  var pos = 0, priority = score(value);
	  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	  array.splice(pos, 0, value);
	}
	
	function nothing() {}
	
	function createObj(base, props) {
	  var inst;
	  if (Object.create) {
	    inst = Object.create(base);
	  } else {
	    nothing.prototype = base;
	    inst = new nothing();
	  }
	  if (props) { copyObj(props, inst); }
	  return inst
	}
	
	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	function isWordCharBasic(ch) {
	  return /\w/.test(ch) || ch > "\x80" &&
	    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	}
	function isWordChar(ch, helper) {
	  if (!helper) { return isWordCharBasic(ch) }
	  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	  return helper.test(ch)
	}
	
	function isEmpty(obj) {
	  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	  return true
	}
	
	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
	
	// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	function skipExtendingChars(str, pos, dir) {
	  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	  return pos
	}
	
	// Returns the value from the range [`from`; `to`] that satisfies
	// `pred` and is closest to `from`. Assumes that at least `to`
	// satisfies `pred`. Supports `from` being greater than `to`.
	function findFirst(pred, from, to) {
	  // At any point we are certain `to` satisfies `pred`, don't know
	  // whether `from` does.
	  var dir = from > to ? -1 : 1;
	  for (;;) {
	    if (from == to) { return from }
	    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
	    if (mid == from) { return pred(mid) ? from : to }
	    if (pred(mid)) { to = mid; }
	    else { from = mid + dir; }
	  }
	}
	
	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.
	
	function Display(place, doc, input) {
	  var d = this;
	  this.input = input;
	
	  // Covers bottom-right square when both scrollbars are present.
	  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	  d.scrollbarFiller.setAttribute("cm-not-content", "true");
	  // Covers bottom of gutter when coverGutterNextToScrollbar is on
	  // and h scrollbar is present.
	  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	  d.gutterFiller.setAttribute("cm-not-content", "true");
	  // Will contain the actual code, positioned to cover the viewport.
	  d.lineDiv = eltP("div", null, "CodeMirror-code");
	  // Elements are added to these to represent selection and cursors.
	  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	  // A visibility: hidden element used to find the size of things.
	  d.measure = elt("div", null, "CodeMirror-measure");
	  // When lines outside of the viewport are measured, they are drawn in this.
	  d.lineMeasure = elt("div", null, "CodeMirror-measure");
	  // Wraps everything that needs to exist inside the vertically-padded coordinate system
	  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                    null, "position: relative; outline: none");
	  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	  // Moved around its parent to cover visible view.
	  d.mover = elt("div", [lines], null, "position: relative");
	  // Set to the height of the document, allowing scrolling.
	  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	  d.sizerWidth = null;
	  // Behavior of elts with overflow: auto and padding is
	  // inconsistent across browsers. This is used to ensure the
	  // scrollable area is big enough.
	  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	  // Will contain the gutters, if any.
	  d.gutters = elt("div", null, "CodeMirror-gutters");
	  d.lineGutter = null;
	  // Actual scrollable element.
	  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	  d.scroller.setAttribute("tabIndex", "-1");
	  // The element in which the editor lives.
	  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
	
	  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }
	
	  if (place) {
	    if (place.appendChild) { place.appendChild(d.wrapper); }
	    else { place(d.wrapper); }
	  }
	
	  // Current rendered range (may be bigger than the view window).
	  d.viewFrom = d.viewTo = doc.first;
	  d.reportedViewFrom = d.reportedViewTo = doc.first;
	  // Information about the rendered lines.
	  d.view = [];
	  d.renderedView = null;
	  // Holds info about a single rendered line when it was rendered
	  // for measurement, while not in view.
	  d.externalMeasured = null;
	  // Empty space (in pixels) above the view
	  d.viewOffset = 0;
	  d.lastWrapHeight = d.lastWrapWidth = 0;
	  d.updateLineNumbers = null;
	
	  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	  d.scrollbarsClipped = false;
	
	  // Used to only resize the line number gutter when necessary (when
	  // the amount of lines crosses a boundary that makes its width change)
	  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	  // Set to true when a non-horizontal-scrolling line widget is
	  // added. As an optimization, line widget aligning is skipped when
	  // this is false.
	  d.alignWidgets = false;
	
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	
	  // Tracks the maximum line length so that the horizontal scrollbar
	  // can be kept static when scrolling.
	  d.maxLine = null;
	  d.maxLineLength = 0;
	  d.maxLineChanged = false;
	
	  // Used for measuring wheel scrolling granularity
	  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
	
	  // True when shift is held down.
	  d.shift = false;
	
	  // Used to track whether anything happened since the context menu
	  // was opened.
	  d.selForContextMenu = null;
	
	  d.activeTouch = null;
	
	  input.init(d);
	}
	
	// Find the line object corresponding to the given line number.
	function getLine(doc, n) {
	  n -= doc.first;
	  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	  var chunk = doc;
	  while (!chunk.lines) {
	    for (var i = 0;; ++i) {
	      var child = chunk.children[i], sz = child.chunkSize();
	      if (n < sz) { chunk = child; break }
	      n -= sz;
	    }
	  }
	  return chunk.lines[n]
	}
	
	// Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc, start, end) {
	  var out = [], n = start.line;
	  doc.iter(start.line, end.line + 1, function (line) {
	    var text = line.text;
	    if (n == end.line) { text = text.slice(0, end.ch); }
	    if (n == start.line) { text = text.slice(start.ch); }
	    out.push(text);
	    ++n;
	  });
	  return out
	}
	// Get the lines between from and to, as array of strings.
	function getLines(doc, from, to) {
	  var out = [];
	  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	  return out
	}
	
	// Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line, height) {
	  var diff = height - line.height;
	  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	}
	
	// Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line) {
	  if (line.parent == null) { return null }
	  var cur = line.parent, no = indexOf(cur.lines, line);
	  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	    for (var i = 0;; ++i) {
	      if (chunk.children[i] == cur) { break }
	      no += chunk.children[i].chunkSize();
	    }
	  }
	  return no + cur.first
	}
	
	// Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk, h) {
	  var n = chunk.first;
	  outer: do {
	    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	      var child = chunk.children[i$1], ch = child.height;
	      if (h < ch) { chunk = child; continue outer }
	      h -= ch;
	      n += child.chunkSize();
	    }
	    return n
	  } while (!chunk.lines)
	  var i = 0;
	  for (; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i], lh = line.height;
	    if (h < lh) { break }
	    h -= lh;
	  }
	  return n + i
	}
	
	function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
	
	function lineNumberFor(options, i) {
	  return String(options.lineNumberFormatter(i + options.firstLineNumber))
	}
	
	// A Pos instance represents a position within the text.
	function Pos(line, ch, sticky) {
	  if ( sticky === void 0 ) sticky = null;
	
	  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	  this.line = line;
	  this.ch = ch;
	  this.sticky = sticky;
	}
	
	// Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
	
	function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }
	
	function copyPos(x) {return Pos(x.line, x.ch)}
	function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
	
	// Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	function clipPos(doc, pos) {
	  if (pos.line < doc.first) { return Pos(doc.first, 0) }
	  var last = doc.first + doc.size - 1;
	  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	  return clipToLen(pos, getLine(doc, pos.line).text.length)
	}
	function clipToLen(pos, linelen) {
	  var ch = pos.ch;
	  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	  else if (ch < 0) { return Pos(pos.line, 0) }
	  else { return pos }
	}
	function clipPosArray(doc, array) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	  return out
	}
	
	// Optimize some code when these features are not used.
	var sawReadOnlySpans = false;
	var sawCollapsedSpans = false;
	
	function seeReadOnlySpans() {
	  sawReadOnlySpans = true;
	}
	
	function seeCollapsedSpans() {
	  sawCollapsedSpans = true;
	}
	
	// TEXTMARKER SPANS
	
	function MarkedSpan(marker, from, to) {
	  this.marker = marker;
	  this.from = from; this.to = to;
	}
	
	// Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans, marker) {
	  if (spans) { for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.marker == marker) { return span }
	  } }
	}
	// Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans, span) {
	  var r;
	  for (var i = 0; i < spans.length; ++i)
	    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	  return r
	}
	// Add a span to a line.
	function addMarkedSpan(line, span) {
	  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	  span.marker.attachLine(line);
	}
	
	// Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old, startCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	    }
	  } }
	  return nw
	}
	function markedSpansAfter(old, endCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                            span.to == null ? null : span.to - endCh));
	    }
	  } }
	  return nw
	}
	
	// Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc, change) {
	  if (change.full) { return null }
	  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	  if (!oldFirst && !oldLast) { return null }
	
	  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	  // Get the spans that 'stick out' on both sides
	  var first = markedSpansBefore(oldFirst, startCh, isInsert);
	  var last = markedSpansAfter(oldLast, endCh, isInsert);
	
	  // Next, merge those two ends
	  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	  if (first) {
	    // Fix up .to properties of first
	    for (var i = 0; i < first.length; ++i) {
	      var span = first[i];
	      if (span.to == null) {
	        var found = getMarkedSpanFor(last, span.marker);
	        if (!found) { span.to = startCh; }
	        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	      }
	    }
	  }
	  if (last) {
	    // Fix up .from in last (or move them into first in case of sameLine)
	    for (var i$1 = 0; i$1 < last.length; ++i$1) {
	      var span$1 = last[i$1];
	      if (span$1.to != null) { span$1.to += offset; }
	      if (span$1.from == null) {
	        var found$1 = getMarkedSpanFor(first, span$1.marker);
	        if (!found$1) {
	          span$1.from = offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      } else {
	        span$1.from += offset;
	        if (sameLine) { (first || (first = [])).push(span$1); }
	      }
	    }
	  }
	  // Make sure we didn't create any zero-length spans
	  if (first) { first = clearEmptySpans(first); }
	  if (last && last != first) { last = clearEmptySpans(last); }
	
	  var newMarkers = [first];
	  if (!sameLine) {
	    // Fill gap with whole-line-spans
	    var gap = change.text.length - 2, gapMarkers;
	    if (gap > 0 && first)
	      { for (var i$2 = 0; i$2 < first.length; ++i$2)
	        { if (first[i$2].to == null)
	          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	    for (var i$3 = 0; i$3 < gap; ++i$3)
	      { newMarkers.push(gapMarkers); }
	    newMarkers.push(last);
	  }
	  return newMarkers
	}
	
	// Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans) {
	  for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	      { spans.splice(i--, 1); }
	  }
	  if (!spans.length) { return null }
	  return spans
	}
	
	// Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc, from, to) {
	  var markers = null;
	  doc.iter(from.line, to.line + 1, function (line) {
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var mark = line.markedSpans[i].marker;
	      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	        { (markers || (markers = [])).push(mark); }
	    } }
	  });
	  if (!markers) { return null }
	  var parts = [{from: from, to: to}];
	  for (var i = 0; i < markers.length; ++i) {
	    var mk = markers[i], m = mk.find(0);
	    for (var j = 0; j < parts.length; ++j) {
	      var p = parts[j];
	      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	        { newParts.push({from: p.from, to: m.from}); }
	      if (dto > 0 || !mk.inclusiveRight && !dto)
	        { newParts.push({from: m.to, to: p.to}); }
	      parts.splice.apply(parts, newParts);
	      j += newParts.length - 3;
	    }
	  }
	  return parts
	}
	
	// Connect or disconnect spans from a line.
	function detachMarkedSpans(line) {
	  var spans = line.markedSpans;
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.detachLine(line); }
	  line.markedSpans = null;
	}
	function attachMarkedSpans(line, spans) {
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.attachLine(line); }
	  line.markedSpans = spans;
	}
	
	// Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
	
	// Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a, b) {
	  var lenDiff = a.lines.length - b.lines.length;
	  if (lenDiff != 0) { return lenDiff }
	  var aPos = a.find(), bPos = b.find();
	  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	  if (fromCmp) { return -fromCmp }
	  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	  if (toCmp) { return toCmp }
	  return b.id - a.id
	}
	
	// Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line, start) {
	  var sps = sawCollapsedSpans && line.markedSpans, found;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	      { found = sp.marker; }
	  } }
	  return found
	}
	function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
	
	// Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
	  var line = getLine(doc, lineNo$$1);
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var i = 0; i < sps.length; ++i) {
	    var sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    var found = sp.marker.find(0);
	    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	      { return true }
	  } }
	}
	
	// A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line) {
	  var merged;
	  while (merged = collapsedSpanAtStart(line))
	    { line = merged.find(-1, true).line; }
	  return line
	}
	
	function visualLineEnd(line) {
	  var merged;
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return line
	}
	
	// Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line) {
	  var merged, lines;
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    ;(lines || (lines = [])).push(line);
	  }
	  return lines
	}
	
	// Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc, lineN) {
	  var line = getLine(doc, lineN), vis = visualLine(line);
	  if (line == vis) { return lineN }
	  return lineNo(vis)
	}
	
	// Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc, lineN) {
	  if (lineN > doc.lastLine()) { return lineN }
	  var line = getLine(doc, lineN), merged;
	  if (!lineIsHidden(doc, line)) { return lineN }
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return lineNo(line) + 1
	}
	
	// Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc, line) {
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    if (sp.from == null) { return true }
	    if (sp.marker.widgetNode) { continue }
	    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	      { return true }
	  } }
	}
	function lineIsHiddenInner(doc, line, span) {
	  if (span.to == null) {
	    var end = span.marker.find(1, true);
	    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	  }
	  if (span.marker.inclusiveRight && span.to == line.text.length)
	    { return true }
	  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	    sp = line.markedSpans[i];
	    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	        (sp.to == null || sp.to != span.from) &&
	        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	        lineIsHiddenInner(doc, line, sp)) { return true }
	  }
	}
	
	// Find the height above the given line.
	function heightAtLine(lineObj) {
	  lineObj = visualLine(lineObj);
	
	  var h = 0, chunk = lineObj.parent;
	  for (var i = 0; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i];
	    if (line == lineObj) { break }
	    else { h += line.height; }
	  }
	  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	      var cur = p.children[i$1];
	      if (cur == chunk) { break }
	      else { h += cur.height; }
	    }
	  }
	  return h
	}
	
	// Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line) {
	  if (line.height == 0) { return 0 }
	  var len = line.text.length, merged, cur = line;
	  while (merged = collapsedSpanAtStart(cur)) {
	    var found = merged.find(0, true);
	    cur = found.from.line;
	    len += found.from.ch - found.to.ch;
	  }
	  cur = line;
	  while (merged = collapsedSpanAtEnd(cur)) {
	    var found$1 = merged.find(0, true);
	    len -= cur.text.length - found$1.from.ch;
	    cur = found$1.to.line;
	    len += cur.text.length - found$1.to.ch;
	  }
	  return len
	}
	
	// Find the longest line in the document.
	function findMaxLine(cm) {
	  var d = cm.display, doc = cm.doc;
	  d.maxLine = getLine(doc, doc.first);
	  d.maxLineLength = lineLength(d.maxLine);
	  d.maxLineChanged = true;
	  doc.iter(function (line) {
	    var len = lineLength(line);
	    if (len > d.maxLineLength) {
	      d.maxLineLength = len;
	      d.maxLine = line;
	    }
	  });
	}
	
	// BIDI HELPERS
	
	function iterateBidiSections(order, from, to, f) {
	  if (!order) { return f(from, to, "ltr", 0) }
	  var found = false;
	  for (var i = 0; i < order.length; ++i) {
	    var part = order[i];
	    if (part.from < to && part.to > from || from == to && part.to == from) {
	      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	      found = true;
	    }
	  }
	  if (!found) { f(from, to, "ltr"); }
	}
	
	var bidiOther = null;
	function getBidiPartAt(order, ch, sticky) {
	  var found;
	  bidiOther = null;
	  for (var i = 0; i < order.length; ++i) {
	    var cur = order[i];
	    if (cur.from < ch && cur.to > ch) { return i }
	    if (cur.to == ch) {
	      if (cur.from != cur.to && sticky == "before") { found = i; }
	      else { bidiOther = i; }
	    }
	    if (cur.from == ch) {
	      if (cur.from != cur.to && sticky != "before") { found = i; }
	      else { bidiOther = i; }
	    }
	  }
	  return found != null ? found : bidiOther
	}
	
	// Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.
	
	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals
	
	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering = (function() {
	  // Character types for codepoints 0 to 0xff
	  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	  // Character types for codepoints 0x600 to 0x6f9
	  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	  function charType(code) {
	    if (code <= 0xf7) { return lowTypes.charAt(code) }
	    else if (0x590 <= code && code <= 0x5f4) { return "R" }
	    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	    else if (0x2000 <= code && code <= 0x200b) { return "w" }
	    else if (code == 0x200c) { return "b" }
	    else { return "L" }
	  }
	
	  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
	
	  function BidiSpan(level, from, to) {
	    this.level = level;
	    this.from = from; this.to = to;
	  }
	
	  return function(str, direction) {
	    var outerType = direction == "ltr" ? "L" : "R";
	
	    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	    var len = str.length, types = [];
	    for (var i = 0; i < len; ++i)
	      { types.push(charType(str.charCodeAt(i))); }
	
	    // W1. Examine each non-spacing mark (NSM) in the level run, and
	    // change the type of the NSM to the type of the previous
	    // character. If the NSM is at the start of the level run, it will
	    // get the type of sor.
	    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	      var type = types[i$1];
	      if (type == "m") { types[i$1] = prev; }
	      else { prev = type; }
	    }
	
	    // W2. Search backwards from each instance of a European number
	    // until the first strong type (R, L, AL, or sor) is found. If an
	    // AL is found, change the type of the European number to Arabic
	    // number.
	    // W3. Change all ALs to R.
	    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	      var type$1 = types[i$2];
	      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	    }
	
	    // W4. A single European separator between two European numbers
	    // changes to a European number. A single common separator between
	    // two numbers of the same type changes to that type.
	    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	      var type$2 = types[i$3];
	      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	      else if (type$2 == "," && prev$1 == types[i$3+1] &&
	               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	      prev$1 = type$2;
	    }
	
	    // W5. A sequence of European terminators adjacent to European
	    // numbers changes to all European numbers.
	    // W6. Otherwise, separators and terminators change to Other
	    // Neutral.
	    for (var i$4 = 0; i$4 < len; ++i$4) {
	      var type$3 = types[i$4];
	      if (type$3 == ",") { types[i$4] = "N"; }
	      else if (type$3 == "%") {
	        var end = (void 0);
	        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	        for (var j = i$4; j < end; ++j) { types[j] = replace; }
	        i$4 = end - 1;
	      }
	    }
	
	    // W7. Search backwards from each instance of a European number
	    // until the first strong type (R, L, or sor) is found. If an L is
	    // found, then change the type of the European number to L.
	    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	      var type$4 = types[i$5];
	      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	      else if (isStrong.test(type$4)) { cur$1 = type$4; }
	    }
	
	    // N1. A sequence of neutrals takes the direction of the
	    // surrounding strong text if the text on both sides has the same
	    // direction. European and Arabic numbers act as if they were R in
	    // terms of their influence on neutrals. Start-of-level-run (sor)
	    // and end-of-level-run (eor) are used at level run boundaries.
	    // N2. Any remaining neutrals take the embedding direction.
	    for (var i$6 = 0; i$6 < len; ++i$6) {
	      if (isNeutral.test(types[i$6])) {
	        var end$1 = (void 0);
	        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	        var before = (i$6 ? types[i$6-1] : outerType) == "L";
	        var after = (end$1 < len ? types[end$1] : outerType) == "L";
	        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	        i$6 = end$1 - 1;
	      }
	    }
	
	    // Here we depart from the documented algorithm, in order to avoid
	    // building up an actual levels array. Since there are only three
	    // levels (0, 1, 2) in an implementation that doesn't take
	    // explicit embedding into account, we can build up the order on
	    // the fly, without following the level-based algorithm.
	    var order = [], m;
	    for (var i$7 = 0; i$7 < len;) {
	      if (countsAsLeft.test(types[i$7])) {
	        var start = i$7;
	        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	        order.push(new BidiSpan(0, start, i$7));
	      } else {
	        var pos = i$7, at = order.length;
	        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	        for (var j$2 = pos; j$2 < i$7;) {
	          if (countsAsNum.test(types[j$2])) {
	            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
	            var nstart = j$2;
	            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	            pos = j$2;
	          } else { ++j$2; }
	        }
	        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	      }
	    }
	    if (direction == "ltr") {
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	    }
	
	    return direction == "rtl" ? order.reverse() : order
	  }
	})();
	
	// Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line, direction) {
	  var order = line.order;
	  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	  return order
	}
	
	// EVENT HANDLING
	
	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.
	
	var noHandlers = [];
	
	var on = function(emitter, type, f) {
	  if (emitter.addEventListener) {
	    emitter.addEventListener(type, f, false);
	  } else if (emitter.attachEvent) {
	    emitter.attachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers || (emitter._handlers = {});
	    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
	  }
	};
	
	function getHandlers(emitter, type) {
	  return emitter._handlers && emitter._handlers[type] || noHandlers
	}
	
	function off(emitter, type, f) {
	  if (emitter.removeEventListener) {
	    emitter.removeEventListener(type, f, false);
	  } else if (emitter.detachEvent) {
	    emitter.detachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
	    if (arr) {
	      var index = indexOf(arr, f);
	      if (index > -1)
	        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	    }
	  }
	}
	
	function signal(emitter, type /*, values...*/) {
	  var handlers = getHandlers(emitter, type);
	  if (!handlers.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2);
	  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	}
	
	// The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm, e, override) {
	  if (typeof e == "string")
	    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	  signal(cm, override || e.type, cm, e);
	  return e_defaultPrevented(e) || e.codemirrorIgnore
	}
	
	function signalCursorActivity(cm) {
	  var arr = cm._handlers && cm._handlers.cursorActivity;
	  if (!arr) { return }
	  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	    { set.push(arr[i]); } }
	}
	
	function hasHandler(emitter, type) {
	  return getHandlers(emitter, type).length > 0
	}
	
	// Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor) {
	  ctor.prototype.on = function(type, f) {on(this, type, f);};
	  ctor.prototype.off = function(type, f) {off(this, type, f);};
	}
	
	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.
	
	function e_preventDefault(e) {
	  if (e.preventDefault) { e.preventDefault(); }
	  else { e.returnValue = false; }
	}
	function e_stopPropagation(e) {
	  if (e.stopPropagation) { e.stopPropagation(); }
	  else { e.cancelBubble = true; }
	}
	function e_defaultPrevented(e) {
	  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	}
	function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
	
	function e_target(e) {return e.target || e.srcElement}
	function e_button(e) {
	  var b = e.which;
	  if (b == null) {
	    if (e.button & 1) { b = 1; }
	    else if (e.button & 2) { b = 3; }
	    else if (e.button & 4) { b = 2; }
	  }
	  if (mac && e.ctrlKey && b == 1) { b = 3; }
	  return b
	}
	
	// Detect drag-and-drop
	var dragAndDrop = function() {
	  // There is *some* kind of drag-and-drop support in IE6-8, but I
	  // couldn't get it to work yet.
	  if (ie && ie_version < 9) { return false }
	  var div = elt('div');
	  return "draggable" in div || "dragDrop" in div
	}();
	
	var zwspSupported;
	function zeroWidthElement(measure) {
	  if (zwspSupported == null) {
	    var test = elt("span", "\u200b");
	    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	    if (measure.firstChild.offsetHeight != 0)
	      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	  }
	  var node = zwspSupported ? elt("span", "\u200b") :
	    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	  node.setAttribute("cm-text", "");
	  return node
	}
	
	// Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects;
	function hasBadBidiRects(measure) {
	  if (badBidiRects != null) { return badBidiRects }
	  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	  var r0 = range(txt, 0, 1).getBoundingClientRect();
	  var r1 = range(txt, 1, 2).getBoundingClientRect();
	  removeChildren(measure);
	  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	  return badBidiRects = (r1.right - r0.right < 3)
	}
	
	// See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	  var pos = 0, result = [], l = string.length;
	  while (pos <= l) {
	    var nl = string.indexOf("\n", pos);
	    if (nl == -1) { nl = string.length; }
	    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	    var rt = line.indexOf("\r");
	    if (rt != -1) {
	      result.push(line.slice(0, rt));
	      pos += rt + 1;
	    } else {
	      result.push(line);
	      pos = nl + 1;
	    }
	  }
	  return result
	} : function (string) { return string.split(/\r\n?|\n/); };
	
	var hasSelection = window.getSelection ? function (te) {
	  try { return te.selectionStart != te.selectionEnd }
	  catch(e) { return false }
	} : function (te) {
	  var range$$1;
	  try {range$$1 = te.ownerDocument.selection.createRange();}
	  catch(e) {}
	  if (!range$$1 || range$$1.parentElement() != te) { return false }
	  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
	};
	
	var hasCopyEvent = (function () {
	  var e = elt("div");
	  if ("oncopy" in e) { return true }
	  e.setAttribute("oncopy", "return;");
	  return typeof e.oncopy == "function"
	})();
	
	var badZoomedRects = null;
	function hasBadZoomedRects(measure) {
	  if (badZoomedRects != null) { return badZoomedRects }
	  var node = removeChildrenAndAdd(measure, elt("span", "x"));
	  var normal = node.getBoundingClientRect();
	  var fromRange = range(node, 0, 1).getBoundingClientRect();
	  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	}
	
	// Known modes, by name and by MIME
	var modes = {};
	var mimeModes = {};
	
	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	function defineMode(name, mode) {
	  if (arguments.length > 2)
	    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	  modes[name] = mode;
	}
	
	function defineMIME(mime, spec) {
	  mimeModes[mime] = spec;
	}
	
	// Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	function resolveMode(spec) {
	  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	    spec = mimeModes[spec];
	  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	    var found = mimeModes[spec.name];
	    if (typeof found == "string") { found = {name: found}; }
	    spec = createObj(found, spec);
	    spec.name = found.name;
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	    return resolveMode("application/xml")
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	    return resolveMode("application/json")
	  }
	  if (typeof spec == "string") { return {name: spec} }
	  else { return spec || {name: "null"} }
	}
	
	// Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	function getMode(options, spec) {
	  spec = resolveMode(spec);
	  var mfactory = modes[spec.name];
	  if (!mfactory) { return getMode(options, "text/plain") }
	  var modeObj = mfactory(options, spec);
	  if (modeExtensions.hasOwnProperty(spec.name)) {
	    var exts = modeExtensions[spec.name];
	    for (var prop in exts) {
	      if (!exts.hasOwnProperty(prop)) { continue }
	      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	      modeObj[prop] = exts[prop];
	    }
	  }
	  modeObj.name = spec.name;
	  if (spec.helperType) { modeObj.helperType = spec.helperType; }
	  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	    { modeObj[prop$1] = spec.modeProps[prop$1]; } }
	
	  return modeObj
	}
	
	// This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions = {};
	function extendMode(mode, properties) {
	  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	  copyObj(properties, exts);
	}
	
	function copyState(mode, state) {
	  if (state === true) { return state }
	  if (mode.copyState) { return mode.copyState(state) }
	  var nstate = {};
	  for (var n in state) {
	    var val = state[n];
	    if (val instanceof Array) { val = val.concat([]); }
	    nstate[n] = val;
	  }
	  return nstate
	}
	
	// Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	function innerMode(mode, state) {
	  var info;
	  while (mode.innerMode) {
	    info = mode.innerMode(state);
	    if (!info || info.mode == mode) { break }
	    state = info.state;
	    mode = info.mode;
	  }
	  return info || {mode: mode, state: state}
	}
	
	function startState(mode, a1, a2) {
	  return mode.startState ? mode.startState(a1, a2) : true
	}
	
	// STRING STREAM
	
	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.
	
	var StringStream = function(string, tabSize, lineOracle) {
	  this.pos = this.start = 0;
	  this.string = string;
	  this.tabSize = tabSize || 8;
	  this.lastColumnPos = this.lastColumnValue = 0;
	  this.lineStart = 0;
	  this.lineOracle = lineOracle;
	};
	
	StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	StringStream.prototype.next = function () {
	  if (this.pos < this.string.length)
	    { return this.string.charAt(this.pos++) }
	};
	StringStream.prototype.eat = function (match) {
	  var ch = this.string.charAt(this.pos);
	  var ok;
	  if (typeof match == "string") { ok = ch == match; }
	  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	  if (ok) {++this.pos; return ch}
	};
	StringStream.prototype.eatWhile = function (match) {
	  var start = this.pos;
	  while (this.eat(match)){}
	  return this.pos > start
	};
	StringStream.prototype.eatSpace = function () {
	    var this$1 = this;
	
	  var start = this.pos;
	  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
	  return this.pos > start
	};
	StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	StringStream.prototype.skipTo = function (ch) {
	  var found = this.string.indexOf(ch, this.pos);
	  if (found > -1) {this.pos = found; return true}
	};
	StringStream.prototype.backUp = function (n) {this.pos -= n;};
	StringStream.prototype.column = function () {
	  if (this.lastColumnPos < this.start) {
	    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	    this.lastColumnPos = this.start;
	  }
	  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.indentation = function () {
	  return countColumn(this.string, null, this.tabSize) -
	    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	  if (typeof pattern == "string") {
	    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	    var substr = this.string.substr(this.pos, pattern.length);
	    if (cased(substr) == cased(pattern)) {
	      if (consume !== false) { this.pos += pattern.length; }
	      return true
	    }
	  } else {
	    var match = this.string.slice(this.pos).match(pattern);
	    if (match && match.index > 0) { return null }
	    if (match && consume !== false) { this.pos += match[0].length; }
	    return match
	  }
	};
	StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	StringStream.prototype.hideFirstChars = function (n, inner) {
	  this.lineStart += n;
	  try { return inner() }
	  finally { this.lineStart -= n; }
	};
	StringStream.prototype.lookAhead = function (n) {
	  var oracle = this.lineOracle;
	  return oracle && oracle.lookAhead(n)
	};
	StringStream.prototype.baseToken = function () {
	  var oracle = this.lineOracle;
	  return oracle && oracle.baseToken(this.pos)
	};
	
	var SavedContext = function(state, lookAhead) {
	  this.state = state;
	  this.lookAhead = lookAhead;
	};
	
	var Context = function(doc, state, line, lookAhead) {
	  this.state = state;
	  this.doc = doc;
	  this.line = line;
	  this.maxLookAhead = lookAhead || 0;
	  this.baseTokens = null;
	  this.baseTokenPos = 1;
	};
	
	Context.prototype.lookAhead = function (n) {
	  var line = this.doc.getLine(this.line + n);
	  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
	  return line
	};
	
	Context.prototype.baseToken = function (n) {
	    var this$1 = this;
	
	  if (!this.baseTokens) { return null }
	  while (this.baseTokens[this.baseTokenPos] <= n)
	    { this$1.baseTokenPos += 2; }
	  var type = this.baseTokens[this.baseTokenPos + 1];
	  return {type: type && type.replace(/( |^)overlay .*/, ""),
	          size: this.baseTokens[this.baseTokenPos] - n}
	};
	
	Context.prototype.nextLine = function () {
	  this.line++;
	  if (this.maxLookAhead > 0) { this.maxLookAhead--; }
	};
	
	Context.fromSaved = function (doc, saved, line) {
	  if (saved instanceof SavedContext)
	    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
	  else
	    { return new Context(doc, copyState(doc.mode, saved), line) }
	};
	
	Context.prototype.save = function (copy) {
	  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
	};
	
	
	// Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm, line, context, forceToEnd) {
	  // A styles array always starts with a number identifying the
	  // mode/overlays that it is based on (for easy invalidation).
	  var st = [cm.state.modeGen], lineClasses = {};
	  // Compute the base array of styles
	  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
	          lineClasses, forceToEnd);
	  var state = context.state;
	
	  // Run overlays, adjust style array.
	  var loop = function ( o ) {
	    context.baseTokens = st;
	    var overlay = cm.state.overlays[o], i = 1, at = 0;
	    context.state = true;
	    runMode(cm, line.text, overlay.mode, context, function (end, style) {
	      var start = i;
	      // Ensure there's a token end at the current position, and that i points at it
	      while (at < end) {
	        var i_end = st[i];
	        if (i_end > end)
	          { st.splice(i, 1, end, st[i+1], i_end); }
	        i += 2;
	        at = Math.min(end, i_end);
	      }
	      if (!style) { return }
	      if (overlay.opaque) {
	        st.splice(start, i - start, end, "overlay " + style);
	        i = start + 2;
	      } else {
	        for (; start < i; start += 2) {
	          var cur = st[start+1];
	          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	        }
	      }
	    }, lineClasses);
	    context.state = state;
	    context.baseTokens = null;
	    context.baseTokenPos = 1;
	  };
	
	  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
	
	  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	}
	
	function getLineStyles(cm, line, updateFrontier) {
	  if (!line.styles || line.styles[0] != cm.state.modeGen) {
	    var context = getContextBefore(cm, lineNo(line));
	    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	    var result = highlightLine(cm, line, context);
	    if (resetState) { context.state = resetState; }
	    line.stateAfter = context.save(!resetState);
	    line.styles = result.styles;
	    if (result.classes) { line.styleClasses = result.classes; }
	    else if (line.styleClasses) { line.styleClasses = null; }
	    if (updateFrontier === cm.doc.highlightFrontier)
	      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
	  }
	  return line.styles
	}
	
	function getContextBefore(cm, n, precise) {
	  var doc = cm.doc, display = cm.display;
	  if (!doc.mode.startState) { return new Context(doc, true, n) }
	  var start = findStartLine(cm, n, precise);
	  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
	
	  doc.iter(start, n, function (line) {
	    processLine(cm, line.text, context);
	    var pos = context.line;
	    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	    context.nextLine();
	  });
	  if (precise) { doc.modeFrontier = context.line; }
	  return context
	}
	
	// Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm, text, context, startAt) {
	  var mode = cm.doc.mode;
	  var stream = new StringStream(text, cm.options.tabSize, context);
	  stream.start = stream.pos = startAt || 0;
	  if (text == "") { callBlankLine(mode, context.state); }
	  while (!stream.eol()) {
	    readToken(mode, stream, context.state);
	    stream.start = stream.pos;
	  }
	}
	
	function callBlankLine(mode, state) {
	  if (mode.blankLine) { return mode.blankLine(state) }
	  if (!mode.innerMode) { return }
	  var inner = innerMode(mode, state);
	  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	}
	
	function readToken(mode, stream, state, inner) {
	  for (var i = 0; i < 10; i++) {
	    if (inner) { inner[0] = innerMode(mode, state).mode; }
	    var style = mode.token(stream, state);
	    if (stream.pos > stream.start) { return style }
	  }
	  throw new Error("Mode " + mode.name + " failed to advance stream.")
	}
	
	var Token = function(stream, type, state) {
	  this.start = stream.start; this.end = stream.pos;
	  this.string = stream.current();
	  this.type = type || null;
	  this.state = state;
	};
	
	// Utility for getTokenAt and getLineTokens
	function takeToken(cm, pos, precise, asArray) {
	  var doc = cm.doc, mode = doc.mode, style;
	  pos = clipPos(doc, pos);
	  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
	  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
	  if (asArray) { tokens = []; }
	  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	    stream.start = stream.pos;
	    style = readToken(mode, stream, context.state);
	    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
	  }
	  return asArray ? tokens : new Token(stream, style, context.state)
	}
	
	function extractLineClasses(type, output) {
	  if (type) { for (;;) {
	    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	    if (!lineClass) { break }
	    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	    var prop = lineClass[1] ? "bgClass" : "textClass";
	    if (output[prop] == null)
	      { output[prop] = lineClass[2]; }
	    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	      { output[prop] += " " + lineClass[2]; }
	  } }
	  return type
	}
	
	// Run the given mode's parser over a line, calling f for each token.
	function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	  var flattenSpans = mode.flattenSpans;
	  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	  var curStart = 0, curStyle = null;
	  var stream = new StringStream(text, cm.options.tabSize, context), style;
	  var inner = cm.options.addModeClass && [null];
	  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
	  while (!stream.eol()) {
	    if (stream.pos > cm.options.maxHighlightLength) {
	      flattenSpans = false;
	      if (forceToEnd) { processLine(cm, text, context, stream.pos); }
	      stream.pos = text.length;
	      style = null;
	    } else {
	      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	    }
	    if (inner) {
	      var mName = inner[0].name;
	      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	    }
	    if (!flattenSpans || curStyle != style) {
	      while (curStart < stream.start) {
	        curStart = Math.min(stream.start, curStart + 5000);
	        f(curStart, curStyle);
	      }
	      curStyle = style;
	    }
	    stream.start = stream.pos;
	  }
	  while (curStart < stream.pos) {
	    // Webkit seems to refuse to render text nodes longer than 57444
	    // characters, and returns inaccurate measurements in nodes
	    // starting around 5000 chars.
	    var pos = Math.min(stream.pos, curStart + 5000);
	    f(pos, curStyle);
	    curStart = pos;
	  }
	}
	
	// Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm, n, precise) {
	  var minindent, minline, doc = cm.doc;
	  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	  for (var search = n; search > lim; --search) {
	    if (search <= doc.first) { return doc.first }
	    var line = getLine(doc, search - 1), after = line.stateAfter;
	    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
	      { return search }
	    var indented = countColumn(line.text, null, cm.options.tabSize);
	    if (minline == null || minindent > indented) {
	      minline = search - 1;
	      minindent = indented;
	    }
	  }
	  return minline
	}
	
	function retreatFrontier(doc, n) {
	  doc.modeFrontier = Math.min(doc.modeFrontier, n);
	  if (doc.highlightFrontier < n - 10) { return }
	  var start = doc.first;
	  for (var line = n - 1; line > start; line--) {
	    var saved = getLine(doc, line).stateAfter;
	    // change is on 3
	    // state on line 1 looked ahead 2 -- so saw 3
	    // test 1 + 2 < 3 should cover this
	    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	      start = line + 1;
	      break
	    }
	  }
	  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	}
	
	// LINE DATA STRUCTURE
	
	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	var Line = function(text, markedSpans, estimateHeight) {
	  this.text = text;
	  attachMarkedSpans(this, markedSpans);
	  this.height = estimateHeight ? estimateHeight(this) : 1;
	};
	
	Line.prototype.lineNo = function () { return lineNo(this) };
	eventMixin(Line);
	
	// Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line, text, markedSpans, estimateHeight) {
	  line.text = text;
	  if (line.stateAfter) { line.stateAfter = null; }
	  if (line.styles) { line.styles = null; }
	  if (line.order != null) { line.order = null; }
	  detachMarkedSpans(line);
	  attachMarkedSpans(line, markedSpans);
	  var estHeight = estimateHeight ? estimateHeight(line) : 1;
	  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	}
	
	// Detach a line from the document tree and its markers.
	function cleanUpLine(line) {
	  line.parent = null;
	  detachMarkedSpans(line);
	}
	
	// Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache = {};
	var styleToClassCacheWithMode = {};
	function interpretTokenStyle(style, options) {
	  if (!style || /^\s*$/.test(style)) { return null }
	  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	  return cache[style] ||
	    (cache[style] = style.replace(/\S+/g, "cm-$&"))
	}
	
	// Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm, lineView) {
	  // The padding-right forces the element to have a 'border', which
	  // is needed on Webkit to be able to get line-level bounding
	  // rectangles for it (in measureChar).
	  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                 col: 0, pos: 0, cm: cm,
	                 trailingSpace: false,
	                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	  lineView.measure = {};
	
	  // Iterate over the logical lines that make up this visual line.
	  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	    builder.pos = 0;
	    builder.addToken = buildToken;
	    // Optionally wire in some hacks into the token-rendering
	    // algorithm, to deal with browser quirks.
	    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	    builder.map = [];
	    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	    if (line.styleClasses) {
	      if (line.styleClasses.bgClass)
	        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	      if (line.styleClasses.textClass)
	        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	    }
	
	    // Ensure at least a single node is present, for measuring.
	    if (builder.map.length == 0)
	      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }
	
	    // Store the map and a cache object for the current logical line
	    if (i == 0) {
	      lineView.measure.map = builder.map;
	      lineView.measure.cache = {};
	    } else {
	      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	    }
	  }
	
	  // See issue #2901
	  if (webkit) {
	    var last = builder.content.lastChild;
	    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	      { builder.content.className = "cm-tab-wrap-hack"; }
	  }
	
	  signal(cm, "renderLine", cm, lineView.line, builder.pre);
	  if (builder.pre.className)
	    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }
	
	  return builder
	}
	
	function defaultSpecialCharPlaceholder(ch) {
	  var token = elt("span", "\u2022", "cm-invalidchar");
	  token.title = "\\u" + ch.charCodeAt(0).toString(16);
	  token.setAttribute("aria-label", token.title);
	  return token
	}
	
	// Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	  if (!text) { return }
	  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	  var special = builder.cm.state.specialChars, mustWrap = false;
	  var content;
	  if (!special.test(text)) {
	    builder.col += text.length;
	    content = document.createTextNode(displayText);
	    builder.map.push(builder.pos, builder.pos + text.length, content);
	    if (ie && ie_version < 9) { mustWrap = true; }
	    builder.pos += text.length;
	  } else {
	    content = document.createDocumentFragment();
	    var pos = 0;
	    while (true) {
	      special.lastIndex = pos;
	      var m = special.exec(text);
	      var skipped = m ? m.index - pos : text.length - pos;
	      if (skipped) {
	        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	        else { content.appendChild(txt); }
	        builder.map.push(builder.pos, builder.pos + skipped, txt);
	        builder.col += skipped;
	        builder.pos += skipped;
	      }
	      if (!m) { break }
	      pos += skipped + 1;
	      var txt$1 = (void 0);
	      if (m[0] == "\t") {
	        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	        txt$1.setAttribute("role", "presentation");
	        txt$1.setAttribute("cm-text", "\t");
	        builder.col += tabWidth;
	      } else if (m[0] == "\r" || m[0] == "\n") {
	        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	        txt$1.setAttribute("cm-text", m[0]);
	        builder.col += 1;
	      } else {
	        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	        txt$1.setAttribute("cm-text", m[0]);
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	        else { content.appendChild(txt$1); }
	        builder.col += 1;
	      }
	      builder.map.push(builder.pos, builder.pos + 1, txt$1);
	      builder.pos++;
	    }
	  }
	  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	  if (style || startStyle || endStyle || mustWrap || css) {
	    var fullStyle = style || "";
	    if (startStyle) { fullStyle += startStyle; }
	    if (endStyle) { fullStyle += endStyle; }
	    var token = elt("span", [content], fullStyle, css);
	    if (title) { token.title = title; }
	    return builder.content.appendChild(token)
	  }
	  builder.content.appendChild(content);
	}
	
	function splitSpaces(text, trailingBefore) {
	  if (text.length > 1 && !/  /.test(text)) { return text }
	  var spaceBefore = trailingBefore, result = "";
	  for (var i = 0; i < text.length; i++) {
	    var ch = text.charAt(i);
	    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	      { ch = "\u00a0"; }
	    result += ch;
	    spaceBefore = ch == " ";
	  }
	  return result
	}
	
	// Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner, order) {
	  return function (builder, text, style, startStyle, endStyle, title, css) {
	    style = style ? style + " cm-force-border" : "cm-force-border";
	    var start = builder.pos, end = start + text.length;
	    for (;;) {
	      // Find the part that overlaps with the start of this text
	      var part = (void 0);
	      for (var i = 0; i < order.length; i++) {
	        part = order[i];
	        if (part.to > start && part.from <= start) { break }
	      }
	      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
	      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	      startStyle = null;
	      text = text.slice(part.to - start);
	      start = part.to;
	    }
	  }
	}
	
	function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	  var widget = !ignoreWidget && marker.widgetNode;
	  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	    if (!widget)
	      { widget = builder.content.appendChild(document.createElement("span")); }
	    widget.setAttribute("cm-marker", marker.id);
	  }
	  if (widget) {
	    builder.cm.display.input.setUneditable(widget);
	    builder.content.appendChild(widget);
	  }
	  builder.pos += size;
	  builder.trailingSpace = false;
	}
	
	// Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line, builder, styles) {
	  var spans = line.markedSpans, allText = line.text, at = 0;
	  if (!spans) {
	    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	    return
	  }
	
	  var len = allText.length, pos = 0, i = 1, text = "", style, css;
	  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	  for (;;) {
	    if (nextChange == pos) { // Update current marker set
	      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	      collapsed = null; nextChange = Infinity;
	      var foundBookmarks = [], endStyles = (void 0);
	      for (var j = 0; j < spans.length; ++j) {
	        var sp = spans[j], m = sp.marker;
	        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	          foundBookmarks.push(m);
	        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	            nextChange = sp.to;
	            spanEndStyle = "";
	          }
	          if (m.className) { spanStyle += " " + m.className; }
	          if (m.css) { css = (css ? css + ";" : "") + m.css; }
	          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	          if (m.title && !title) { title = m.title; }
	          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	            { collapsed = sp; }
	        } else if (sp.from > pos && nextChange > sp.from) {
	          nextChange = sp.from;
	        }
	      }
	      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }
	
	      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	      if (collapsed && (collapsed.from || 0) == pos) {
	        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                           collapsed.marker, collapsed.from == null);
	        if (collapsed.to == null) { return }
	        if (collapsed.to == pos) { collapsed = false; }
	      }
	    }
	    if (pos >= len) { break }
	
	    var upto = Math.min(len, nextChange);
	    while (true) {
	      if (text) {
	        var end = pos + text.length;
	        if (!collapsed) {
	          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	        }
	        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	        pos = end;
	        spanStartStyle = "";
	      }
	      text = allText.slice(at, at = styles[i++]);
	      style = interpretTokenStyle(styles[i++], builder.cm.options);
	    }
	  }
	}
	
	
	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc, line, lineN) {
	  // The starting line
	  this.line = line;
	  // Continuing lines, if any
	  this.rest = visualLineContinued(line);
	  // Number of logical lines in this visual line
	  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	  this.node = this.text = null;
	  this.hidden = lineIsHidden(doc, line);
	}
	
	// Create a range of LineView objects for the given lines.
	function buildViewArray(cm, from, to) {
	  var array = [], nextPos;
	  for (var pos = from; pos < to; pos = nextPos) {
	    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	    nextPos = pos + view.size;
	    array.push(view);
	  }
	  return array
	}
	
	var operationGroup = null;
	
	function pushOperation(op) {
	  if (operationGroup) {
	    operationGroup.ops.push(op);
	  } else {
	    op.ownsGroup = operationGroup = {
	      ops: [op],
	      delayedCallbacks: []
	    };
	  }
	}
	
	function fireCallbacksForOps(group) {
	  // Calls delayed callbacks and cursorActivity handlers until no
	  // new ones appear
	  var callbacks = group.delayedCallbacks, i = 0;
	  do {
	    for (; i < callbacks.length; i++)
	      { callbacks[i].call(null); }
	    for (var j = 0; j < group.ops.length; j++) {
	      var op = group.ops[j];
	      if (op.cursorActivityHandlers)
	        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	    }
	  } while (i < callbacks.length)
	}
	
	function finishOperation(op, endCb) {
	  var group = op.ownsGroup;
	  if (!group) { return }
	
	  try { fireCallbacksForOps(group); }
	  finally {
	    operationGroup = null;
	    endCb(group);
	  }
	}
	
	var orphanDelayedCallbacks = null;
	
	// Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter, type /*, values...*/) {
	  var arr = getHandlers(emitter, type);
	  if (!arr.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2), list;
	  if (operationGroup) {
	    list = operationGroup.delayedCallbacks;
	  } else if (orphanDelayedCallbacks) {
	    list = orphanDelayedCallbacks;
	  } else {
	    list = orphanDelayedCallbacks = [];
	    setTimeout(fireOrphanDelayed, 0);
	  }
	  var loop = function ( i ) {
	    list.push(function () { return arr[i].apply(null, args); });
	  };
	
	  for (var i = 0; i < arr.length; ++i)
	    loop( i );
	}
	
	function fireOrphanDelayed() {
	  var delayed = orphanDelayedCallbacks;
	  orphanDelayedCallbacks = null;
	  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	}
	
	// When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm, lineView, lineN, dims) {
	  for (var j = 0; j < lineView.changes.length; j++) {
	    var type = lineView.changes[j];
	    if (type == "text") { updateLineText(cm, lineView); }
	    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	    else if (type == "class") { updateLineClasses(cm, lineView); }
	    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	  }
	  lineView.changes = null;
	}
	
	// Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView) {
	  if (lineView.node == lineView.text) {
	    lineView.node = elt("div", null, null, "position: relative");
	    if (lineView.text.parentNode)
	      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	    lineView.node.appendChild(lineView.text);
	    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	  }
	  return lineView.node
	}
	
	function updateLineBackground(cm, lineView) {
	  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	  if (cls) { cls += " CodeMirror-linebackground"; }
	  if (lineView.background) {
	    if (cls) { lineView.background.className = cls; }
	    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	  } else if (cls) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    cm.display.input.setUneditable(lineView.background);
	  }
	}
	
	// Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm, lineView) {
	  var ext = cm.display.externalMeasured;
	  if (ext && ext.line == lineView.line) {
	    cm.display.externalMeasured = null;
	    lineView.measure = ext.measure;
	    return ext.built
	  }
	  return buildLineContent(cm, lineView)
	}
	
	// Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm, lineView) {
	  var cls = lineView.text.className;
	  var built = getLineContent(cm, lineView);
	  if (lineView.text == lineView.node) { lineView.node = built.pre; }
	  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	  lineView.text = built.pre;
	  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	    lineView.bgClass = built.bgClass;
	    lineView.textClass = built.textClass;
	    updateLineClasses(cm, lineView);
	  } else if (cls) {
	    lineView.text.className = cls;
	  }
	}
	
	function updateLineClasses(cm, lineView) {
	  updateLineBackground(cm, lineView);
	  if (lineView.line.wrapClass)
	    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	  else if (lineView.node != lineView.text)
	    { lineView.node.className = ""; }
	  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	  lineView.text.className = textClass || "";
	}
	
	function updateLineGutter(cm, lineView, lineN, dims) {
	  if (lineView.gutter) {
	    lineView.node.removeChild(lineView.gutter);
	    lineView.gutter = null;
	  }
	  if (lineView.gutterBackground) {
	    lineView.node.removeChild(lineView.gutterBackground);
	    lineView.gutterBackground = null;
	  }
	  if (lineView.line.gutterClass) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(lineView.gutterBackground);
	    wrap.insertBefore(lineView.gutterBackground, lineView.text);
	  }
	  var markers = lineView.line.gutterMarkers;
	  if (cm.options.lineNumbers || markers) {
	    var wrap$1 = ensureLineWrapped(lineView);
	    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(gutterWrap);
	    wrap$1.insertBefore(gutterWrap, lineView.text);
	    if (lineView.line.gutterClass)
	      { gutterWrap.className += " " + lineView.line.gutterClass; }
	    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	      { lineView.lineNumber = gutterWrap.appendChild(
	        elt("div", lineNumberFor(cm.options, lineN),
	            "CodeMirror-linenumber CodeMirror-gutter-elt",
	            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
	      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	      if (found)
	        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	    } }
	  }
	}
	
	function updateLineWidgets(cm, lineView, dims) {
	  if (lineView.alignable) { lineView.alignable = null; }
	  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	    next = node.nextSibling;
	    if (node.className == "CodeMirror-linewidget")
	      { lineView.node.removeChild(node); }
	  }
	  insertLineWidgets(cm, lineView, dims);
	}
	
	// Build a line's DOM representation from scratch
	function buildLineElement(cm, lineView, lineN, dims) {
	  var built = getLineContent(cm, lineView);
	  lineView.text = lineView.node = built.pre;
	  if (built.bgClass) { lineView.bgClass = built.bgClass; }
	  if (built.textClass) { lineView.textClass = built.textClass; }
	
	  updateLineClasses(cm, lineView);
	  updateLineGutter(cm, lineView, lineN, dims);
	  insertLineWidgets(cm, lineView, dims);
	  return lineView.node
	}
	
	// A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm, lineView, dims) {
	  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	}
	
	function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	  if (!line.widgets) { return }
	  var wrap = ensureLineWrapped(lineView);
	  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	    positionLineWidget(widget, node, lineView, dims);
	    cm.display.input.setUneditable(node);
	    if (allowAbove && widget.above)
	      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	    else
	      { wrap.appendChild(node); }
	    signalLater(widget, "redraw");
	  }
	}
	
	function positionLineWidget(widget, node, lineView, dims) {
	  if (widget.noHScroll) {
	    (lineView.alignable || (lineView.alignable = [])).push(node);
	    var width = dims.wrapperWidth;
	    node.style.left = dims.fixedPos + "px";
	    if (!widget.coverGutter) {
	      width -= dims.gutterTotalWidth;
	      node.style.paddingLeft = dims.gutterTotalWidth + "px";
	    }
	    node.style.width = width + "px";
	  }
	  if (widget.coverGutter) {
	    node.style.zIndex = 5;
	    node.style.position = "relative";
	    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	  }
	}
	
	function widgetHeight(widget) {
	  if (widget.height != null) { return widget.height }
	  var cm = widget.doc.cm;
	  if (!cm) { return 0 }
	  if (!contains(document.body, widget.node)) {
	    var parentStyle = "position: relative;";
	    if (widget.coverGutter)
	      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	    if (widget.noHScroll)
	      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	  }
	  return widget.height = widget.node.parentNode.offsetHeight
	}
	
	// Return true when the given mouse event happened in a widget
	function eventInWidget(display, e) {
	  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	        (n.parentNode == display.sizer && n != display.mover))
	      { return true }
	  }
	}
	
	// POSITION MEASUREMENT
	
	function paddingTop(display) {return display.lineSpace.offsetTop}
	function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	function paddingH(display) {
	  if (display.cachedPaddingH) { return display.cachedPaddingH }
	  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	  return data
	}
	
	function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	function displayWidth(cm) {
	  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	}
	function displayHeight(cm) {
	  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	}
	
	// Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm, lineView, rect) {
	  var wrapping = cm.options.lineWrapping;
	  var curWidth = wrapping && displayWidth(cm);
	  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	    var heights = lineView.measure.heights = [];
	    if (wrapping) {
	      lineView.measure.width = curWidth;
	      var rects = lineView.text.firstChild.getClientRects();
	      for (var i = 0; i < rects.length - 1; i++) {
	        var cur = rects[i], next = rects[i + 1];
	        if (Math.abs(cur.bottom - next.bottom) > 2)
	          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	      }
	    }
	    heights.push(rect.bottom - rect.top);
	  }
	}
	
	// Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView, line, lineN) {
	  if (lineView.line == line)
	    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	  for (var i = 0; i < lineView.rest.length; i++)
	    { if (lineView.rest[i] == line)
	      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	    { if (lineNo(lineView.rest[i$1]) > lineN)
	      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	}
	
	// Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm, line) {
	  line = visualLine(line);
	  var lineN = lineNo(line);
	  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	  view.lineN = lineN;
	  var built = view.built = buildLineContent(cm, view);
	  view.text = built.pre;
	  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	  return view
	}
	
	// Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm, line, ch, bias) {
	  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	}
	
	// Find a line view that corresponds to the given line number.
	function findViewForLine(cm, lineN) {
	  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	    { return cm.display.view[findViewIndex(cm, lineN)] }
	  var ext = cm.display.externalMeasured;
	  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	    { return ext }
	}
	
	// Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm, line) {
	  var lineN = lineNo(line);
	  var view = findViewForLine(cm, lineN);
	  if (view && !view.text) {
	    view = null;
	  } else if (view && view.changes) {
	    updateLineForChanges(cm, view, lineN, getDimensions(cm));
	    cm.curOp.forceUpdate = true;
	  }
	  if (!view)
	    { view = updateExternalMeasurement(cm, line); }
	
	  var info = mapFromLineView(view, line, lineN);
	  return {
	    line: line, view: view, rect: null,
	    map: info.map, cache: info.cache, before: info.before,
	    hasHeights: false
	  }
	}
	
	// Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	  if (prepared.before) { ch = -1; }
	  var key = ch + (bias || ""), found;
	  if (prepared.cache.hasOwnProperty(key)) {
	    found = prepared.cache[key];
	  } else {
	    if (!prepared.rect)
	      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	    if (!prepared.hasHeights) {
	      ensureLineHeights(cm, prepared.view, prepared.rect);
	      prepared.hasHeights = true;
	    }
	    found = measureCharInner(cm, prepared, ch, bias);
	    if (!found.bogus) { prepared.cache[key] = found; }
	  }
	  return {left: found.left, right: found.right,
	          top: varHeight ? found.rtop : found.top,
	          bottom: varHeight ? found.rbottom : found.bottom}
	}
	
	var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
	
	function nodeAndOffsetInLineMap(map$$1, ch, bias) {
	  var node, start, end, collapse, mStart, mEnd;
	  // First, search the line map for the text node corresponding to,
	  // or closest to, the target character.
	  for (var i = 0; i < map$$1.length; i += 3) {
	    mStart = map$$1[i];
	    mEnd = map$$1[i + 1];
	    if (ch < mStart) {
	      start = 0; end = 1;
	      collapse = "left";
	    } else if (ch < mEnd) {
	      start = ch - mStart;
	      end = start + 1;
	    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
	      end = mEnd - mStart;
	      start = end - 1;
	      if (ch >= mEnd) { collapse = "right"; }
	    }
	    if (start != null) {
	      node = map$$1[i + 2];
	      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	        { collapse = bias; }
	      if (bias == "left" && start == 0)
	        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
	          node = map$$1[(i -= 3) + 2];
	          collapse = "left";
	        } }
	      if (bias == "right" && start == mEnd - mStart)
	        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
	          node = map$$1[(i += 3) + 2];
	          collapse = "right";
	        } }
	      break
	    }
	  }
	  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	}
	
	function getUsefulRect(rects, bias) {
	  var rect = nullRect;
	  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	    if ((rect = rects[i]).left != rect.right) { break }
	  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	    if ((rect = rects[i$1]).left != rect.right) { break }
	  } }
	  return rect
	}
	
	function measureCharInner(cm, prepared, ch, bias) {
	  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
	
	  var rect;
	  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	        { rect = node.parentNode.getBoundingClientRect(); }
	      else
	        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	      if (rect.left || rect.right || start == 0) { break }
	      end = start;
	      start = start - 1;
	      collapse = "right";
	    }
	    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	  } else { // If it is a widget, simply get the box for the whole widget.
	    if (start > 0) { collapse = bias = "right"; }
	    var rects;
	    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	    else
	      { rect = node.getBoundingClientRect(); }
	  }
	  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	    var rSpan = node.parentNode.getClientRects()[0];
	    if (rSpan)
	      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	    else
	      { rect = nullRect; }
	  }
	
	  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	  var mid = (rtop + rbot) / 2;
	  var heights = prepared.view.measure.heights;
	  var i = 0;
	  for (; i < heights.length - 1; i++)
	    { if (mid < heights[i]) { break } }
	  var top = i ? heights[i - 1] : 0, bot = heights[i];
	  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                top: top, bottom: bot};
	  if (!rect.left && !rect.right) { result.bogus = true; }
	  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }
	
	  return result
	}
	
	// Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure, rect) {
	  if (!window.screen || screen.logicalXDPI == null ||
	      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	    { return rect }
	  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	  return {left: rect.left * scaleX, right: rect.right * scaleX,
	          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	}
	
	function clearLineMeasurementCacheFor(lineView) {
	  if (lineView.measure) {
	    lineView.measure.cache = {};
	    lineView.measure.heights = null;
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { lineView.measure.caches[i] = {}; } }
	  }
	}
	
	function clearLineMeasurementCache(cm) {
	  cm.display.externalMeasure = null;
	  removeChildren(cm.display.lineMeasure);
	  for (var i = 0; i < cm.display.view.length; i++)
	    { clearLineMeasurementCacheFor(cm.display.view[i]); }
	}
	
	function clearCaches(cm) {
	  clearLineMeasurementCache(cm);
	  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	  cm.display.lineNumChars = null;
	}
	
	function pageScrollX() {
	  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	  // which causes page_Offset and bounding client rects to use
	  // different reference viewports and invalidate our calculations.
	  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
	  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
	}
	function pageScrollY() {
	  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
	  return window.pageYOffset || (document.documentElement || document.body).scrollTop
	}
	
	function widgetTopHeight(lineObj) {
	  var height = 0;
	  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
	    { height += widgetHeight(lineObj.widgets[i]); } } }
	  return height
	}
	
	// Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"./null (editor), "window",
	// or "page".
	function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	  if (!includeWidgets) {
	    var height = widgetTopHeight(lineObj);
	    rect.top += height; rect.bottom += height;
	  }
	  if (context == "line") { return rect }
	  if (!context) { context = "local"; }
	  var yOff = heightAtLine(lineObj);
	  if (context == "local") { yOff += paddingTop(cm.display); }
	  else { yOff -= cm.display.viewOffset; }
	  if (context == "page" || context == "window") {
	    var lOff = cm.display.lineSpace.getBoundingClientRect();
	    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	    rect.left += xOff; rect.right += xOff;
	  }
	  rect.top += yOff; rect.bottom += yOff;
	  return rect
	}
	
	// Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"./null.
	function fromCoordSystem(cm, coords, context) {
	  if (context == "div") { return coords }
	  var left = coords.left, top = coords.top;
	  // First move into "page" coordinate system
	  if (context == "page") {
	    left -= pageScrollX();
	    top -= pageScrollY();
	  } else if (context == "local" || !context) {
	    var localBox = cm.display.sizer.getBoundingClientRect();
	    left += localBox.left;
	    top += localBox.top;
	  }
	
	  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	}
	
	function charCoords(cm, pos, context, lineObj, bias) {
	  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	}
	
	// Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	// and after `char - 1` in writing order of `char - 1`
	// A cursor Pos(line, char, "after") is on the same visual line as `char`
	// and before `char` in writing order of `char`
	// Examples (upper-case letters are RTL, lower-case are LTR):
	//     Pos(0, 1, ...)
	//     before   after
	// ab     a|b     a|b
	// aB     a|B     aB|
	// Ab     |Ab     A|b
	// AB     B|A     B|A
	// Every position after the last character on a line is considered to stick
	// to the last character on the line.
	function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	  lineObj = lineObj || getLine(cm.doc, pos.line);
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  function get(ch, right) {
	    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	    if (right) { m.left = m.right; } else { m.right = m.left; }
	    return intoCoordSystem(cm, lineObj, m, context)
	  }
	  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	  if (ch >= lineObj.text.length) {
	    ch = lineObj.text.length;
	    sticky = "before";
	  } else if (ch <= 0) {
	    ch = 0;
	    sticky = "after";
	  }
	  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }
	
	  function getBidi(ch, partPos, invert) {
	    var part = order[partPos], right = part.level == 1;
	    return get(invert ? ch - 1 : ch, right != invert)
	  }
	  var partPos = getBidiPartAt(order, ch, sticky);
	  var other = bidiOther;
	  var val = getBidi(ch, partPos, sticky == "before");
	  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	  return val
	}
	
	// Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm, pos) {
	  var left = 0;
	  pos = clipPos(cm.doc, pos);
	  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	  var lineObj = getLine(cm.doc, pos.line);
	  var top = heightAtLine(lineObj) + paddingTop(cm.display);
	  return {left: left, right: left, top: top, bottom: top + lineObj.height}
	}
	
	// Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line, ch, sticky, outside, xRel) {
	  var pos = Pos(line, ch, sticky);
	  pos.xRel = xRel;
	  if (outside) { pos.outside = true; }
	  return pos
	}
	
	// Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm, x, y) {
	  var doc = cm.doc;
	  y += cm.display.viewOffset;
	  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
	  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	  if (lineN > last)
	    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
	  if (x < 0) { x = 0; }
	
	  var lineObj = getLine(doc, lineN);
	  for (;;) {
	    var found = coordsCharInner(cm, lineObj, lineN, x, y);
	    var merged = collapsedSpanAtEnd(lineObj);
	    var mergedPos = merged && merged.find(0, true);
	    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	      { lineN = lineNo(lineObj = mergedPos.to.line); }
	    else
	      { return found }
	  }
	}
	
	function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	  y -= widgetTopHeight(lineObj);
	  var end = lineObj.text.length;
	  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
	  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
	  return {begin: begin, end: end}
	}
	
	function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	}
	
	// Returns true if the given side of a box is after the given
	// coordinates, in top-to-bottom, left-to-right order.
	function boxIsAfter(box, x, y, left) {
	  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
	}
	
	function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
	  // Move y into line-local coordinate space
	  y -= heightAtLine(lineObj);
	  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	  // When directly calling `measureCharPrepared`, we have to adjust
	  // for the widgets at this line.
	  var widgetHeight$$1 = widgetTopHeight(lineObj);
	  var begin = 0, end = lineObj.text.length, ltr = true;
	
	  var order = getOrder(lineObj, cm.doc.direction);
	  // If the line isn't plain left-to-right text, first figure out
	  // which bidi section the coordinates fall into.
	  if (order) {
	    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
	                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
	    ltr = part.level != 1;
	    // The awkward -1 offsets are needed because findFirst (called
	    // on these below) will treat its first bound as inclusive,
	    // second as exclusive, but we want to actually address the
	    // characters in the part's range
	    begin = ltr ? part.from : part.to - 1;
	    end = ltr ? part.to : part.from - 1;
	  }
	
	  // A binary search to find the first character whose bounding box
	  // starts after the coordinates. If we run across any whose box wrap
	  // the coordinates, store that.
	  var chAround = null, boxAround = null;
	  var ch = findFirst(function (ch) {
	    var box = measureCharPrepared(cm, preparedMeasure, ch);
	    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
	    if (!boxIsAfter(box, x, y, false)) { return false }
	    if (box.top <= y && box.left <= x) {
	      chAround = ch;
	      boxAround = box;
	    }
	    return true
	  }, begin, end);
	
	  var baseX, sticky, outside = false;
	  // If a box around the coordinates was found, use that
	  if (boxAround) {
	    // Distinguish coordinates nearer to the left or right side of the box
	    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
	    ch = chAround + (atStart ? 0 : 1);
	    sticky = atStart ? "after" : "before";
	    baseX = atLeft ? boxAround.left : boxAround.right;
	  } else {
	    // (Adjust for extended bound, if necessary.)
	    if (!ltr && (ch == end || ch == begin)) { ch++; }
	    // To determine which side to associate with, get the box to the
	    // left of the character and compare it's vertical position to the
	    // coordinates
	    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
	      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
	      "after" : "before";
	    // Now get accurate coordinates for this place, in order to get a
	    // base X position
	    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
	    baseX = coords.left;
	    outside = y < coords.top || y >= coords.bottom;
	  }
	
	  ch = skipExtendingChars(lineObj.text, ch, 1);
	  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
	}
	
	function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
	  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	  // situation, we can take this ordering to correspond to the visual
	  // ordering. This finds the first part whose end is after the given
	  // coordinates.
	  var index = findFirst(function (i) {
	    var part = order[i], ltr = part.level != 1;
	    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
	                                   "line", lineObj, preparedMeasure), x, y, true)
	  }, 0, order.length - 1);
	  var part = order[index];
	  // If this isn't the first part, the part's start is also after
	  // the coordinates, and the coordinates aren't on the same line as
	  // that start, move one part back.
	  if (index > 0) {
	    var ltr = part.level != 1;
	    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
	                             "line", lineObj, preparedMeasure);
	    if (boxIsAfter(start, x, y, true) && start.top > y)
	      { part = order[index - 1]; }
	  }
	  return part
	}
	
	function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	  // In a wrapped line, rtl text on wrapping boundaries can do things
	  // that don't correspond to the ordering in our `order` array at
	  // all, so a binary search doesn't work, and we want to return a
	  // part that only spans one line so that the binary search in
	  // coordsCharInner is safe. As such, we first find the extent of the
	  // wrapped line, and then do a flat search in which we discard any
	  // spans that aren't on the line.
	  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	  var begin = ref.begin;
	  var end = ref.end;
	  if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
	  var part = null, closestDist = null;
	  for (var i = 0; i < order.length; i++) {
	    var p = order[i];
	    if (p.from >= end || p.to <= begin) { continue }
	    var ltr = p.level != 1;
	    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
	    // Weigh against spans ending before this, so that they are only
	    // picked if nothing ends after
	    var dist = endX < x ? x - endX + 1e9 : endX - x;
	    if (!part || closestDist > dist) {
	      part = p;
	      closestDist = dist;
	    }
	  }
	  if (!part) { part = order[order.length - 1]; }
	  // Clip the part to the wrapped line.
	  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
	  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
	  return part
	}
	
	var measureText;
	// Compute the default text height.
	function textHeight(display) {
	  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	  if (measureText == null) {
	    measureText = elt("pre");
	    // Measure a bunch of lines, for browsers that compute
	    // fractional heights.
	    for (var i = 0; i < 49; ++i) {
	      measureText.appendChild(document.createTextNode("x"));
	      measureText.appendChild(elt("br"));
	    }
	    measureText.appendChild(document.createTextNode("x"));
	  }
	  removeChildrenAndAdd(display.measure, measureText);
	  var height = measureText.offsetHeight / 50;
	  if (height > 3) { display.cachedTextHeight = height; }
	  removeChildren(display.measure);
	  return height || 1
	}
	
	// Compute the default character width.
	function charWidth(display) {
	  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	  var anchor = elt("span", "xxxxxxxxxx");
	  var pre = elt("pre", [anchor]);
	  removeChildrenAndAdd(display.measure, pre);
	  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	  if (width > 2) { display.cachedCharWidth = width; }
	  return width || 10
	}
	
	// Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm) {
	  var d = cm.display, left = {}, width = {};
	  var gutterLeft = d.gutters.clientLeft;
	  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	    width[cm.options.gutters[i]] = n.clientWidth;
	  }
	  return {fixedPos: compensateForHScroll(d),
	          gutterTotalWidth: d.gutters.offsetWidth,
	          gutterLeft: left,
	          gutterWidth: width,
	          wrapperWidth: d.wrapper.clientWidth}
	}
	
	// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display) {
	  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	}
	
	// Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm) {
	  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	  return function (line) {
	    if (lineIsHidden(cm.doc, line)) { return 0 }
	
	    var widgetsHeight = 0;
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	    } }
	
	    if (wrapping)
	      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	    else
	      { return widgetsHeight + th }
	  }
	}
	
	function estimateLineHeights(cm) {
	  var doc = cm.doc, est = estimateHeight(cm);
	  doc.iter(function (line) {
	    var estHeight = est(line);
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  });
	}
	
	// Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm, e, liberal, forRect) {
	  var display = cm.display;
	  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
	
	  var x, y, space = display.lineSpace.getBoundingClientRect();
	  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	  try { x = e.clientX - space.left; y = e.clientY - space.top; }
	  catch (e) { return null }
	  var coords = coordsChar(cm, x, y), line;
	  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	  }
	  return coords
	}
	
	// Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm, n) {
	  if (n >= cm.display.viewTo) { return null }
	  n -= cm.display.viewFrom;
	  if (n < 0) { return null }
	  var view = cm.display.view;
	  for (var i = 0; i < view.length; i++) {
	    n -= view[i].size;
	    if (n < 0) { return i }
	  }
	}
	
	function updateSelection(cm) {
	  cm.display.input.showSelection(cm.display.input.prepareSelection());
	}
	
	function prepareSelection(cm, primary) {
	  if ( primary === void 0 ) primary = true;
	
	  var doc = cm.doc, result = {};
	  var curFragment = result.cursors = document.createDocumentFragment();
	  var selFragment = result.selection = document.createDocumentFragment();
	
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    if (!primary && i == doc.sel.primIndex) { continue }
	    var range$$1 = doc.sel.ranges[i];
	    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
	    var collapsed = range$$1.empty();
	    if (collapsed || cm.options.showCursorWhenSelecting)
	      { drawSelectionCursor(cm, range$$1.head, curFragment); }
	    if (!collapsed)
	      { drawSelectionRange(cm, range$$1, selFragment); }
	  }
	  return result
	}
	
	// Draws a cursor for the given range
	function drawSelectionCursor(cm, head, output) {
	  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
	
	  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	  cursor.style.left = pos.left + "px";
	  cursor.style.top = pos.top + "px";
	  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
	
	  if (pos.other) {
	    // Secondary cursor, shown when on a 'jump' in bi-directional text
	    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	    otherCursor.style.display = "";
	    otherCursor.style.left = pos.other.left + "px";
	    otherCursor.style.top = pos.other.top + "px";
	    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	  }
	}
	
	function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }
	
	// Draws the given range as a highlighted selection
	function drawSelectionRange(cm, range$$1, output) {
	  var display = cm.display, doc = cm.doc;
	  var fragment = document.createDocumentFragment();
	  var padding = paddingH(cm.display), leftSide = padding.left;
	  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	  var docLTR = doc.direction == "ltr";
	
	  function add(left, top, width, bottom) {
	    if (top < 0) { top = 0; }
	    top = Math.round(top);
	    bottom = Math.round(bottom);
	    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	  }
	
	  function drawForLine(line, fromArg, toArg) {
	    var lineObj = getLine(doc, line);
	    var lineLen = lineObj.text.length;
	    var start, end;
	    function coords(ch, bias) {
	      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	    }
	
	    function wrapX(pos, dir, side) {
	      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	      var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
	      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	      return coords(ch, prop)[prop]
	    }
	
	    var order = getOrder(lineObj, doc.direction);
	    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	      var ltr = dir == "ltr";
	      var fromPos = coords(from, ltr ? "left" : "right");
	      var toPos = coords(to - 1, ltr ? "right" : "left");
	
	      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
	      var first = i == 0, last = !order || i == order.length - 1;
	      if (toPos.top - fromPos.top <= 3) { // Single line
	        var openLeft = (docLTR ? openStart : openEnd) && first;
	        var openRight = (docLTR ? openEnd : openStart) && last;
	        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	        add(left, fromPos.top, right - left, fromPos.bottom);
	      } else { // Multiple lines
	        var topLeft, topRight, botLeft, botRight;
	        if (ltr) {
	          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	        } else {
	          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	        }
	        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
	        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
	        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	      }
	
	      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
	      if (cmpCoords(toPos, start) < 0) { start = toPos; }
	      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
	      if (cmpCoords(toPos, end) < 0) { end = toPos; }
	    });
	    return {start: start, end: end}
	  }
	
	  var sFrom = range$$1.from(), sTo = range$$1.to();
	  if (sFrom.line == sTo.line) {
	    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	  } else {
	    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	    var singleVLine = visualLine(fromLine) == visualLine(toLine);
	    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	    if (singleVLine) {
	      if (leftEnd.top < rightStart.top - 2) {
	        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	      } else {
	        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	      }
	    }
	    if (leftEnd.bottom < rightStart.top)
	      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	  }
	
	  output.appendChild(fragment);
	}
	
	// Cursor-blinking
	function restartBlink(cm) {
	  if (!cm.state.focused) { return }
	  var display = cm.display;
	  clearInterval(display.blinker);
	  var on = true;
	  display.cursorDiv.style.visibility = "";
	  if (cm.options.cursorBlinkRate > 0)
	    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	      cm.options.cursorBlinkRate); }
	  else if (cm.options.cursorBlinkRate < 0)
	    { display.cursorDiv.style.visibility = "hidden"; }
	}
	
	function ensureFocus(cm) {
	  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	}
	
	function delayBlurEvent(cm) {
	  cm.state.delayingBlurEvent = true;
	  setTimeout(function () { if (cm.state.delayingBlurEvent) {
	    cm.state.delayingBlurEvent = false;
	    onBlur(cm);
	  } }, 100);
	}
	
	function onFocus(cm, e) {
	  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }
	
	  if (cm.options.readOnly == "nocursor") { return }
	  if (!cm.state.focused) {
	    signal(cm, "focus", cm, e);
	    cm.state.focused = true;
	    addClass(cm.display.wrapper, "CodeMirror-focused");
	    // This test prevents this from firing when a context
	    // menu is closed (since the input reset would kill the
	    // select-all detection hack)
	    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	      cm.display.input.reset();
	      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	    }
	    cm.display.input.receivedFocus();
	  }
	  restartBlink(cm);
	}
	function onBlur(cm, e) {
	  if (cm.state.delayingBlurEvent) { return }
	
	  if (cm.state.focused) {
	    signal(cm, "blur", cm, e);
	    cm.state.focused = false;
	    rmClass(cm.display.wrapper, "CodeMirror-focused");
	  }
	  clearInterval(cm.display.blinker);
	  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	}
	
	// Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm) {
	  var display = cm.display;
	  var prevBottom = display.lineDiv.offsetTop;
	  for (var i = 0; i < display.view.length; i++) {
	    var cur = display.view[i], height = (void 0);
	    if (cur.hidden) { continue }
	    if (ie && ie_version < 8) {
	      var bot = cur.node.offsetTop + cur.node.offsetHeight;
	      height = bot - prevBottom;
	      prevBottom = bot;
	    } else {
	      var box = cur.node.getBoundingClientRect();
	      height = box.bottom - box.top;
	    }
	    var diff = cur.line.height - height;
	    if (height < 2) { height = textHeight(display); }
	    if (diff > .005 || diff < -.005) {
	      updateLineHeight(cur.line, height);
	      updateWidgetHeight(cur.line);
	      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	        { updateWidgetHeight(cur.rest[j]); } }
	    }
	  }
	}
	
	// Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line) {
	  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
	    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }
	}
	
	// Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display, doc, viewport) {
	  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	  top = Math.floor(top - paddingTop(display));
	  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
	
	  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	  // forces those lines into the viewport (if possible).
	  if (viewport && viewport.ensure) {
	    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	    if (ensureFrom < from) {
	      from = ensureFrom;
	      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	      to = ensureTo;
	    }
	  }
	  return {from: from, to: Math.max(to, from + 1)}
	}
	
	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm) {
	  var display = cm.display, view = display.view;
	  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	  var gutterW = display.gutters.offsetWidth, left = comp + "px";
	  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	    if (cm.options.fixedGutter) {
	      if (view[i].gutter)
	        { view[i].gutter.style.left = left; }
	      if (view[i].gutterBackground)
	        { view[i].gutterBackground.style.left = left; }
	    }
	    var align = view[i].alignable;
	    if (align) { for (var j = 0; j < align.length; j++)
	      { align[j].style.left = left; } }
	  } }
	  if (cm.options.fixedGutter)
	    { display.gutters.style.left = (comp + gutterW) + "px"; }
	}
	
	// Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm) {
	  if (!cm.options.lineNumbers) { return false }
	  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	  if (last.length != display.lineNumChars) {
	    var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
	    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	    display.lineGutter.style.width = "";
	    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	    display.lineNumWidth = display.lineNumInnerWidth + padding;
	    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	    display.lineGutter.style.width = display.lineNumWidth + "px";
	    updateGutterSpace(cm);
	    return true
	  }
	  return false
	}
	
	// SCROLLING THINGS INTO VIEW
	
	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm, rect) {
	  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
	
	  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	  if (rect.top + box.top < 0) { doScroll = true; }
	  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	  if (doScroll != null && !phantom) {
	    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	    cm.display.lineSpace.appendChild(scrollNode);
	    scrollNode.scrollIntoView(doScroll);
	    cm.display.lineSpace.removeChild(scrollNode);
	  }
	}
	
	// Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm, pos, end, margin) {
	  if (margin == null) { margin = 0; }
	  var rect;
	  if (!cm.options.lineWrapping && pos == end) {
	    // Set pos and end to the cursor positions around the character pos sticks to
	    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	    // If pos == Pos(_, 0, "before"), pos and end are unchanged
	    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	  }
	  for (var limit = 0; limit < 5; limit++) {
	    var changed = false;
	    var coords = cursorCoords(cm, pos);
	    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	    rect = {left: Math.min(coords.left, endCoords.left),
	            top: Math.min(coords.top, endCoords.top) - margin,
	            right: Math.max(coords.left, endCoords.left),
	            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	    var scrollPos = calculateScrollPos(cm, rect);
	    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	    if (scrollPos.scrollTop != null) {
	      updateScrollTop(cm, scrollPos.scrollTop);
	      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	    }
	    if (scrollPos.scrollLeft != null) {
	      setScrollLeft(cm, scrollPos.scrollLeft);
	      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	    }
	    if (!changed) { break }
	  }
	  return rect
	}
	
	// Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm, rect) {
	  var scrollPos = calculateScrollPos(cm, rect);
	  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
	  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	}
	
	// Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm, rect) {
	  var display = cm.display, snapMargin = textHeight(cm.display);
	  if (rect.top < 0) { rect.top = 0; }
	  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	  var screen = displayHeight(cm), result = {};
	  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	  var docBottom = cm.doc.height + paddingVert(display);
	  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	  if (rect.top < screentop) {
	    result.scrollTop = atTop ? 0 : rect.top;
	  } else if (rect.bottom > screentop + screen) {
	    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	    if (newTop != screentop) { result.scrollTop = newTop; }
	  }
	
	  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	  var tooWide = rect.right - rect.left > screenw;
	  if (tooWide) { rect.right = rect.left + screenw; }
	  if (rect.left < 10)
	    { result.scrollLeft = 0; }
	  else if (rect.left < screenleft)
	    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	  else if (rect.right > screenw + screenleft - 3)
	    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	  return result
	}
	
	// Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollTop(cm, top) {
	  if (top == null) { return }
	  resolveScrollToPos(cm);
	  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	}
	
	// Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm) {
	  resolveScrollToPos(cm);
	  var cur = cm.getCursor();
	  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
	}
	
	function scrollToCoords(cm, x, y) {
	  if (x != null || y != null) { resolveScrollToPos(cm); }
	  if (x != null) { cm.curOp.scrollLeft = x; }
	  if (y != null) { cm.curOp.scrollTop = y; }
	}
	
	function scrollToRange(cm, range$$1) {
	  resolveScrollToPos(cm);
	  cm.curOp.scrollToPos = range$$1;
	}
	
	// When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm) {
	  var range$$1 = cm.curOp.scrollToPos;
	  if (range$$1) {
	    cm.curOp.scrollToPos = null;
	    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
	    scrollToCoordsRange(cm, from, to, range$$1.margin);
	  }
	}
	
	function scrollToCoordsRange(cm, from, to, margin) {
	  var sPos = calculateScrollPos(cm, {
	    left: Math.min(from.left, to.left),
	    top: Math.min(from.top, to.top) - margin,
	    right: Math.max(from.right, to.right),
	    bottom: Math.max(from.bottom, to.bottom) + margin
	  });
	  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	}
	
	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function updateScrollTop(cm, val) {
	  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	  setScrollTop(cm, val, true);
	  if (gecko) { updateDisplaySimple(cm); }
	  startWorker(cm, 100);
	}
	
	function setScrollTop(cm, val, forceScroll) {
	  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
	  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
	  cm.doc.scrollTop = val;
	  cm.display.scrollbars.setScrollTop(val);
	  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	}
	
	// Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm, val, isScroller, forceScroll) {
	  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
	  cm.doc.scrollLeft = val;
	  alignHorizontally(cm);
	  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	  cm.display.scrollbars.setScrollLeft(val);
	}
	
	// SCROLLBARS
	
	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm) {
	  var d = cm.display, gutterW = d.gutters.offsetWidth;
	  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	  return {
	    clientHeight: d.scroller.clientHeight,
	    viewHeight: d.wrapper.clientHeight,
	    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	    viewWidth: d.wrapper.clientWidth,
	    barLeft: cm.options.fixedGutter ? gutterW : 0,
	    docHeight: docH,
	    scrollHeight: docH + scrollGap(cm) + d.barHeight,
	    nativeBarWidth: d.nativeBarWidth,
	    gutterWidth: gutterW
	  }
	}
	
	var NativeScrollbars = function(place, scroll, cm) {
	  this.cm = cm;
	  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	  place(vert); place(horiz);
	
	  on(vert, "scroll", function () {
	    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	  });
	  on(horiz, "scroll", function () {
	    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	  });
	
	  this.checkedZeroWidth = false;
	  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	};
	
	NativeScrollbars.prototype.update = function (measure) {
	  var needsH = measure.scrollWidth > measure.clientWidth + 1;
	  var needsV = measure.scrollHeight > measure.clientHeight + 1;
	  var sWidth = measure.nativeBarWidth;
	
	  if (needsV) {
	    this.vert.style.display = "block";
	    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	    // A bug in IE8 can cause this value to be negative, so guard it.
	    this.vert.firstChild.style.height =
	      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	  } else {
	    this.vert.style.display = "";
	    this.vert.firstChild.style.height = "0";
	  }
	
	  if (needsH) {
	    this.horiz.style.display = "block";
	    this.horiz.style.right = needsV ? sWidth + "px" : "0";
	    this.horiz.style.left = measure.barLeft + "px";
	    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	    this.horiz.firstChild.style.width =
	      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	  } else {
	    this.horiz.style.display = "";
	    this.horiz.firstChild.style.width = "0";
	  }
	
	  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	    if (sWidth == 0) { this.zeroWidthHack(); }
	    this.checkedZeroWidth = true;
	  }
	
	  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	};
	
	NativeScrollbars.prototype.setScrollLeft = function (pos) {
	  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
	};
	
	NativeScrollbars.prototype.setScrollTop = function (pos) {
	  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
	};
	
	NativeScrollbars.prototype.zeroWidthHack = function () {
	  var w = mac && !mac_geMountainLion ? "12px" : "18px";
	  this.horiz.style.height = this.vert.style.width = w;
	  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	  this.disableHoriz = new Delayed;
	  this.disableVert = new Delayed;
	};
	
	NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	  bar.style.pointerEvents = "auto";
	  function maybeDisable() {
	    // To find out whether the scrollbar is still visible, we
	    // check whether the element under the pixel in the bottom
	    // right corner of the scrollbar box is the scrollbar box
	    // itself (when the bar is still visible) or its filler child
	    // (when the bar is hidden). If it is still visible, we keep
	    // it enabled, if it's hidden, we disable pointer events.
	    var box = bar.getBoundingClientRect();
	    var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
	        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
	    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
	    else { delay.set(1000, maybeDisable); }
	  }
	  delay.set(1000, maybeDisable);
	};
	
	NativeScrollbars.prototype.clear = function () {
	  var parent = this.horiz.parentNode;
	  parent.removeChild(this.horiz);
	  parent.removeChild(this.vert);
	};
	
	var NullScrollbars = function () {};
	
	NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	NullScrollbars.prototype.setScrollLeft = function () {};
	NullScrollbars.prototype.setScrollTop = function () {};
	NullScrollbars.prototype.clear = function () {};
	
	function updateScrollbars(cm, measure) {
	  if (!measure) { measure = measureForScrollbars(cm); }
	  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	  updateScrollbarsInner(cm, measure);
	  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	      { updateHeightsInViewport(cm); }
	    updateScrollbarsInner(cm, measureForScrollbars(cm));
	    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	  }
	}
	
	// Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm, measure) {
	  var d = cm.display;
	  var sizes = d.scrollbars.update(measure);
	
	  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
	
	  if (sizes.right && sizes.bottom) {
	    d.scrollbarFiller.style.display = "block";
	    d.scrollbarFiller.style.height = sizes.bottom + "px";
	    d.scrollbarFiller.style.width = sizes.right + "px";
	  } else { d.scrollbarFiller.style.display = ""; }
	  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	    d.gutterFiller.style.display = "block";
	    d.gutterFiller.style.height = sizes.bottom + "px";
	    d.gutterFiller.style.width = measure.gutterWidth + "px";
	  } else { d.gutterFiller.style.display = ""; }
	}
	
	var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
	
	function initScrollbars(cm) {
	  if (cm.display.scrollbars) {
	    cm.display.scrollbars.clear();
	    if (cm.display.scrollbars.addClass)
	      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }
	
	  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	    // Prevent clicks in the scrollbars from killing focus
	    on(node, "mousedown", function () {
	      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	    });
	    node.setAttribute("cm-not-content", "true");
	  }, function (pos, axis) {
	    if (axis == "horizontal") { setScrollLeft(cm, pos); }
	    else { updateScrollTop(cm, pos); }
	  }, cm);
	  if (cm.display.scrollbars.addClass)
	    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	}
	
	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.
	
	var nextOpId = 0;
	// Start a new operation.
	function startOperation(cm) {
	  cm.curOp = {
	    cm: cm,
	    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	    startHeight: cm.doc.height, // Used to detect need to update scrollbar
	    forceUpdate: false,      // Used to force a redraw
	    updateInput: null,       // Whether to reset the input textarea
	    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	    changeObjs: null,        // Accumulated changes, for firing change events
	    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	    selectionChanged: false, // Whether the selection needs to be redrawn
	    updateMaxLine: false,    // Set when the widest line needs to be determined anew
	    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	    scrollToPos: null,       // Used to scroll to a specific position
	    focus: false,
	    id: ++nextOpId           // Unique ID
	  };
	  pushOperation(cm.curOp);
	}
	
	// Finish an operation, updating the display and signalling delayed events
	function endOperation(cm) {
	  var op = cm.curOp;
	  finishOperation(op, function (group) {
	    for (var i = 0; i < group.ops.length; i++)
	      { group.ops[i].cm.curOp = null; }
	    endOperations(group);
	  });
	}
	
	// The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group) {
	  var ops = group.ops;
	  for (var i = 0; i < ops.length; i++) // Read DOM
	    { endOperation_R1(ops[i]); }
	  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	    { endOperation_W1(ops[i$1]); }
	  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	    { endOperation_R2(ops[i$2]); }
	  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	    { endOperation_W2(ops[i$3]); }
	  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	    { endOperation_finish(ops[i$4]); }
	}
	
	function endOperation_R1(op) {
	  var cm = op.cm, display = cm.display;
	  maybeClipScrollbars(cm);
	  if (op.updateMaxLine) { findMaxLine(cm); }
	
	  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                       op.scrollToPos.to.line >= display.viewTo) ||
	    display.maxLineChanged && cm.options.lineWrapping;
	  op.update = op.mustUpdate &&
	    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	}
	
	function endOperation_W1(op) {
	  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	}
	
	function endOperation_R2(op) {
	  var cm = op.cm, display = cm.display;
	  if (op.updatedDisplay) { updateHeightsInViewport(cm); }
	
	  op.barMeasure = measureForScrollbars(cm);
	
	  // If the max line changed since it was last measured, measure it,
	  // and ensure the document's width matches it.
	  // updateDisplay_W2 will use these properties to do the actual resizing
	  if (display.maxLineChanged && !cm.options.lineWrapping) {
	    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	    cm.display.sizerWidth = op.adjustWidthTo;
	    op.barMeasure.scrollWidth =
	      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	  }
	
	  if (op.updatedDisplay || op.selectionChanged)
	    { op.preparedSelection = display.input.prepareSelection(); }
	}
	
	function endOperation_W2(op) {
	  var cm = op.cm;
	
	  if (op.adjustWidthTo != null) {
	    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	    if (op.maxScrollLeft < cm.doc.scrollLeft)
	      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	    cm.display.maxLineChanged = false;
	  }
	
	  var takeFocus = op.focus && op.focus == activeElt();
	  if (op.preparedSelection)
	    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	  if (op.updatedDisplay || op.startHeight != cm.doc.height)
	    { updateScrollbars(cm, op.barMeasure); }
	  if (op.updatedDisplay)
	    { setDocumentHeight(cm, op.barMeasure); }
	
	  if (op.selectionChanged) { restartBlink(cm); }
	
	  if (cm.state.focused && op.updateInput)
	    { cm.display.input.reset(op.typing); }
	  if (takeFocus) { ensureFocus(op.cm); }
	}
	
	function endOperation_finish(op) {
	  var cm = op.cm, display = cm.display, doc = cm.doc;
	
	  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }
	
	  // Abort mouse wheel delta measurement, when scrolling explicitly
	  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	    { display.wheelStartX = display.wheelStartY = null; }
	
	  // Propagate the scroll position to the actual DOM scroller
	  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }
	
	  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
	  // If we need to scroll a specific position into view, do so.
	  if (op.scrollToPos) {
	    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	    maybeScrollWindow(cm, rect);
	  }
	
	  // Fire events for markers that are hidden/unidden by editing or
	  // undoing
	  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	  if (hidden) { for (var i = 0; i < hidden.length; ++i)
	    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }
	
	  if (display.wrapper.offsetHeight)
	    { doc.scrollTop = cm.display.scroller.scrollTop; }
	
	  // Fire change events, and delayed event handlers
	  if (op.changeObjs)
	    { signal(cm, "changes", cm, op.changeObjs); }
	  if (op.update)
	    { op.update.finish(); }
	}
	
	// Run the given function in an operation
	function runInOp(cm, f) {
	  if (cm.curOp) { return f() }
	  startOperation(cm);
	  try { return f() }
	  finally { endOperation(cm); }
	}
	// Wraps a function in an operation. Returns the wrapped function.
	function operation(cm, f) {
	  return function() {
	    if (cm.curOp) { return f.apply(cm, arguments) }
	    startOperation(cm);
	    try { return f.apply(cm, arguments) }
	    finally { endOperation(cm); }
	  }
	}
	// Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f) {
	  return function() {
	    if (this.curOp) { return f.apply(this, arguments) }
	    startOperation(this);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(this); }
	  }
	}
	function docMethodOp(f) {
	  return function() {
	    var cm = this.cm;
	    if (!cm || cm.curOp) { return f.apply(this, arguments) }
	    startOperation(cm);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(cm); }
	  }
	}
	
	// Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm, from, to, lendiff) {
	  if (from == null) { from = cm.doc.first; }
	  if (to == null) { to = cm.doc.first + cm.doc.size; }
	  if (!lendiff) { lendiff = 0; }
	
	  var display = cm.display;
	  if (lendiff && to < display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers > from))
	    { display.updateLineNumbers = from; }
	
	  cm.curOp.viewChanged = true;
	
	  if (from >= display.viewTo) { // Change after
	    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	      { resetView(cm); }
	  } else if (to <= display.viewFrom) { // Change before
	    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	      resetView(cm);
	    } else {
	      display.viewFrom += lendiff;
	      display.viewTo += lendiff;
	    }
	  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	    resetView(cm);
	  } else if (from <= display.viewFrom) { // Top overlap
	    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cut) {
	      display.view = display.view.slice(cut.index);
	      display.viewFrom = cut.lineN;
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  } else if (to >= display.viewTo) { // Bottom overlap
	    var cut$1 = viewCuttingPoint(cm, from, from, -1);
	    if (cut$1) {
	      display.view = display.view.slice(0, cut$1.index);
	      display.viewTo = cut$1.lineN;
	    } else {
	      resetView(cm);
	    }
	  } else { // Gap in the middle
	    var cutTop = viewCuttingPoint(cm, from, from, -1);
	    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cutTop && cutBot) {
	      display.view = display.view.slice(0, cutTop.index)
	        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	        .concat(display.view.slice(cutBot.index));
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  }
	
	  var ext = display.externalMeasured;
	  if (ext) {
	    if (to < ext.lineN)
	      { ext.lineN += lendiff; }
	    else if (from < ext.lineN + ext.size)
	      { display.externalMeasured = null; }
	  }
	}
	
	// Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm, line, type) {
	  cm.curOp.viewChanged = true;
	  var display = cm.display, ext = cm.display.externalMeasured;
	  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	    { display.externalMeasured = null; }
	
	  if (line < display.viewFrom || line >= display.viewTo) { return }
	  var lineView = display.view[findViewIndex(cm, line)];
	  if (lineView.node == null) { return }
	  var arr = lineView.changes || (lineView.changes = []);
	  if (indexOf(arr, type) == -1) { arr.push(type); }
	}
	
	// Clear the view.
	function resetView(cm) {
	  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	  cm.display.view = [];
	  cm.display.viewOffset = 0;
	}
	
	function viewCuttingPoint(cm, oldN, newN, dir) {
	  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	    { return {index: index, lineN: newN} }
	  var n = cm.display.viewFrom;
	  for (var i = 0; i < index; i++)
	    { n += view[i].size; }
	  if (n != oldN) {
	    if (dir > 0) {
	      if (index == view.length - 1) { return null }
	      diff = (n + view[index].size) - oldN;
	      index++;
	    } else {
	      diff = n - oldN;
	    }
	    oldN += diff; newN += diff;
	  }
	  while (visualLineNo(cm.doc, newN) != newN) {
	    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	    index += dir;
	  }
	  return {index: index, lineN: newN}
	}
	
	// Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm, from, to) {
	  var display = cm.display, view = display.view;
	  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	    display.view = buildViewArray(cm, from, to);
	    display.viewFrom = from;
	  } else {
	    if (display.viewFrom > from)
	      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	    else if (display.viewFrom < from)
	      { display.view = display.view.slice(findViewIndex(cm, from)); }
	    display.viewFrom = from;
	    if (display.viewTo < to)
	      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	    else if (display.viewTo > to)
	      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	  }
	  display.viewTo = to;
	}
	
	// Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm) {
	  var view = cm.display.view, dirty = 0;
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	  }
	  return dirty
	}
	
	// HIGHLIGHT WORKER
	
	function startWorker(cm, time) {
	  if (cm.doc.highlightFrontier < cm.display.viewTo)
	    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	}
	
	function highlightWorker(cm) {
	  var doc = cm.doc;
	  if (doc.highlightFrontier >= cm.display.viewTo) { return }
	  var end = +new Date + cm.options.workTime;
	  var context = getContextBefore(cm, doc.highlightFrontier);
	  var changedLines = [];
	
	  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	    if (context.line >= cm.display.viewFrom) { // Visible
	      var oldStyles = line.styles;
	      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	      var highlighted = highlightLine(cm, line, context, true);
	      if (resetState) { context.state = resetState; }
	      line.styles = highlighted.styles;
	      var oldCls = line.styleClasses, newCls = highlighted.classes;
	      if (newCls) { line.styleClasses = newCls; }
	      else if (oldCls) { line.styleClasses = null; }
	      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	      if (ischange) { changedLines.push(context.line); }
	      line.stateAfter = context.save();
	      context.nextLine();
	    } else {
	      if (line.text.length <= cm.options.maxHighlightLength)
	        { processLine(cm, line.text, context); }
	      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	      context.nextLine();
	    }
	    if (+new Date > end) {
	      startWorker(cm, cm.options.workDelay);
	      return true
	    }
	  });
	  doc.highlightFrontier = context.line;
	  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
	  if (changedLines.length) { runInOp(cm, function () {
	    for (var i = 0; i < changedLines.length; i++)
	      { regLineChange(cm, changedLines[i], "text"); }
	  }); }
	}
	
	// DISPLAY DRAWING
	
	var DisplayUpdate = function(cm, viewport, force) {
	  var display = cm.display;
	
	  this.viewport = viewport;
	  // Store some values that we'll need later (but don't want to force a relayout for)
	  this.visible = visibleLines(display, cm.doc, viewport);
	  this.editorIsHidden = !display.wrapper.offsetWidth;
	  this.wrapperHeight = display.wrapper.clientHeight;
	  this.wrapperWidth = display.wrapper.clientWidth;
	  this.oldDisplayWidth = displayWidth(cm);
	  this.force = force;
	  this.dims = getDimensions(cm);
	  this.events = [];
	};
	
	DisplayUpdate.prototype.signal = function (emitter, type) {
	  if (hasHandler(emitter, type))
	    { this.events.push(arguments); }
	};
	DisplayUpdate.prototype.finish = function () {
	    var this$1 = this;
	
	  for (var i = 0; i < this.events.length; i++)
	    { signal.apply(null, this$1.events[i]); }
	};
	
	function maybeClipScrollbars(cm) {
	  var display = cm.display;
	  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	    display.heightForcer.style.height = scrollGap(cm) + "px";
	    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	    display.scrollbarsClipped = true;
	  }
	}
	
	function selectionSnapshot(cm) {
	  if (cm.hasFocus()) { return null }
	  var active = activeElt();
	  if (!active || !contains(cm.display.lineDiv, active)) { return null }
	  var result = {activeElt: active};
	  if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	      result.anchorNode = sel.anchorNode;
	      result.anchorOffset = sel.anchorOffset;
	      result.focusNode = sel.focusNode;
	      result.focusOffset = sel.focusOffset;
	    }
	  }
	  return result
	}
	
	function restoreSelection(snapshot) {
	  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
	  snapshot.activeElt.focus();
	  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	    var sel = window.getSelection(), range$$1 = document.createRange();
	    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	    range$$1.collapse(false);
	    sel.removeAllRanges();
	    sel.addRange(range$$1);
	    sel.extend(snapshot.focusNode, snapshot.focusOffset);
	  }
	}
	
	// Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm, update) {
	  var display = cm.display, doc = cm.doc;
	
	  if (update.editorIsHidden) {
	    resetView(cm);
	    return false
	  }
	
	  // Bail out if the visible area is already rendered and nothing changed.
	  if (!update.force &&
	      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	      display.renderedView == display.view && countDirtyView(cm) == 0)
	    { return false }
	
	  if (maybeUpdateLineNumberWidth(cm)) {
	    resetView(cm);
	    update.dims = getDimensions(cm);
	  }
	
	  // Compute a suitable new viewport (from & to)
	  var end = doc.first + doc.size;
	  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	  if (sawCollapsedSpans) {
	    from = visualLineNo(cm.doc, from);
	    to = visualLineEndNo(cm.doc, to);
	  }
	
	  var different = from != display.viewFrom || to != display.viewTo ||
	    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	  adjustView(cm, from, to);
	
	  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	  // Position the mover div to align with the current scroll position
	  cm.display.mover.style.top = display.viewOffset + "px";
	
	  var toUpdate = countDirtyView(cm);
	  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	    { return false }
	
	  // For big changes, we hide the enclosing element during the
	  // update, since that speeds up the operations on most browsers.
	  var selSnapshot = selectionSnapshot(cm);
	  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	  patchDisplay(cm, display.updateLineNumbers, update.dims);
	  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	  display.renderedView = display.view;
	  // There might have been a widget with a focused element that got
	  // hidden or updated, if so re-focus it.
	  restoreSelection(selSnapshot);
	
	  // Prevent selection and cursors from interfering with the scroll
	  // width and height.
	  removeChildren(display.cursorDiv);
	  removeChildren(display.selectionDiv);
	  display.gutters.style.height = display.sizer.style.minHeight = 0;
	
	  if (different) {
	    display.lastWrapHeight = update.wrapperHeight;
	    display.lastWrapWidth = update.wrapperWidth;
	    startWorker(cm, 400);
	  }
	
	  display.updateLineNumbers = null;
	
	  return true
	}
	
	function postUpdateDisplay(cm, update) {
	  var viewport = update.viewport;
	
	  for (var first = true;; first = false) {
	    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	      // Clip forced viewport to actual scrollable area.
	      if (viewport && viewport.top != null)
	        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	      // Updated line heights might result in the drawn area not
	      // actually covering the viewport. Keep looping until it does.
	      update.visible = visibleLines(cm.display, cm.doc, viewport);
	      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	        { break }
	    }
	    if (!updateDisplayIfNeeded(cm, update)) { break }
	    updateHeightsInViewport(cm);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.force = false;
	  }
	
	  update.signal(cm, "update", cm);
	  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	  }
	}
	
	function updateDisplaySimple(cm, viewport) {
	  var update = new DisplayUpdate(cm, viewport);
	  if (updateDisplayIfNeeded(cm, update)) {
	    updateHeightsInViewport(cm);
	    postUpdateDisplay(cm, update);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.finish();
	  }
	}
	
	// Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm, updateNumbersFrom, dims) {
	  var display = cm.display, lineNumbers = cm.options.lineNumbers;
	  var container = display.lineDiv, cur = container.firstChild;
	
	  function rm(node) {
	    var next = node.nextSibling;
	    // Works around a throw-scroll bug in OS X Webkit
	    if (webkit && mac && cm.display.currentWheelTarget == node)
	      { node.style.display = "none"; }
	    else
	      { node.parentNode.removeChild(node); }
	    return next
	  }
	
	  var view = display.view, lineN = display.viewFrom;
	  // Loop over the elements in the view, syncing cur (the DOM nodes
	  // in display.lineDiv) with the view as we go.
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (lineView.hidden) {
	    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	      var node = buildLineElement(cm, lineView, lineN, dims);
	      container.insertBefore(node, cur);
	    } else { // Already drawn
	      while (cur != lineView.node) { cur = rm(cur); }
	      var updateNumber = lineNumbers && updateNumbersFrom != null &&
	        updateNumbersFrom <= lineN && lineView.lineNumber;
	      if (lineView.changes) {
	        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	        updateLineForChanges(cm, lineView, lineN, dims);
	      }
	      if (updateNumber) {
	        removeChildren(lineView.lineNumber);
	        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	      }
	      cur = lineView.node.nextSibling;
	    }
	    lineN += lineView.size;
	  }
	  while (cur) { cur = rm(cur); }
	}
	
	function updateGutterSpace(cm) {
	  var width = cm.display.gutters.offsetWidth;
	  cm.display.sizer.style.marginLeft = width + "px";
	}
	
	function setDocumentHeight(cm, measure) {
	  cm.display.sizer.style.minHeight = measure.docHeight + "px";
	  cm.display.heightForcer.style.top = measure.docHeight + "px";
	  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	}
	
	// Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm) {
	  var gutters = cm.display.gutters, specs = cm.options.gutters;
	  removeChildren(gutters);
	  var i = 0;
	  for (; i < specs.length; ++i) {
	    var gutterClass = specs[i];
	    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	    if (gutterClass == "CodeMirror-linenumbers") {
	      cm.display.lineGutter = gElt;
	      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	    }
	  }
	  gutters.style.display = i ? "" : "none";
	  updateGutterSpace(cm);
	}
	
	// Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options) {
	  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	  if (found == -1 && options.lineNumbers) {
	    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	  } else if (found > -1 && !options.lineNumbers) {
	    options.gutters = options.gutters.slice(0);
	    options.gutters.splice(found, 1);
	  }
	}
	
	// Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.
	
	var wheelSamples = 0;
	var wheelPixelsPerUnit = null;
	// Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if (ie) { wheelPixelsPerUnit = -.53; }
	else if (gecko) { wheelPixelsPerUnit = 15; }
	else if (chrome) { wheelPixelsPerUnit = -.7; }
	else if (safari) { wheelPixelsPerUnit = -1/3; }
	
	function wheelEventDelta(e) {
	  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	  else if (dy == null) { dy = e.wheelDelta; }
	  return {x: dx, y: dy}
	}
	function wheelEventPixels(e) {
	  var delta = wheelEventDelta(e);
	  delta.x *= wheelPixelsPerUnit;
	  delta.y *= wheelPixelsPerUnit;
	  return delta
	}
	
	function onScrollWheel(cm, e) {
	  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
	
	  var display = cm.display, scroll = display.scroller;
	  // Quit if there's nothing to scroll here
	  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	  if (!(dx && canScrollX || dy && canScrollY)) { return }
	
	  // Webkit browsers on OS X abort momentum scrolls when the target
	  // of the scroll event is removed from the scrollable element.
	  // This hack (see related code in patchDisplay) makes sure the
	  // element is kept around.
	  if (dy && mac && webkit) {
	    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	      for (var i = 0; i < view.length; i++) {
	        if (view[i].node == cur) {
	          cm.display.currentWheelTarget = cur;
	          break outer
	        }
	      }
	    }
	  }
	
	  // On some browsers, horizontal scrolling will cause redraws to
	  // happen before the gutter has been realigned, causing it to
	  // wriggle around in a most unseemly way. When we have an
	  // estimated pixels/delta value, we just handle horizontal
	  // scrolling entirely here. It'll be slightly off from native, but
	  // better than glitching out.
	  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	    if (dy && canScrollY)
	      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
	    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
	    // Only prevent default scrolling if vertical scrolling is
	    // actually possible. Otherwise, it causes vertical scroll
	    // jitter on OSX trackpads when deltaX is small and deltaY
	    // is large (issue #3579)
	    if (!dy || (dy && canScrollY))
	      { e_preventDefault(e); }
	    display.wheelStartX = null; // Abort measurement, if in progress
	    return
	  }
	
	  // 'Project' the visible viewport to cover the area that is being
	  // scrolled into view (if we know enough to estimate it).
	  if (dy && wheelPixelsPerUnit != null) {
	    var pixels = dy * wheelPixelsPerUnit;
	    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	    updateDisplaySimple(cm, {top: top, bottom: bot});
	  }
	
	  if (wheelSamples < 20) {
	    if (display.wheelStartX == null) {
	      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	      display.wheelDX = dx; display.wheelDY = dy;
	      setTimeout(function () {
	        if (display.wheelStartX == null) { return }
	        var movedX = scroll.scrollLeft - display.wheelStartX;
	        var movedY = scroll.scrollTop - display.wheelStartY;
	        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	          (movedX && display.wheelDX && movedX / display.wheelDX);
	        display.wheelStartX = display.wheelStartY = null;
	        if (!sample) { return }
	        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	        ++wheelSamples;
	      }, 200);
	    } else {
	      display.wheelDX += dx; display.wheelDY += dy;
	    }
	  }
	}
	
	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	var Selection = function(ranges, primIndex) {
	  this.ranges = ranges;
	  this.primIndex = primIndex;
	};
	
	Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
	
	Selection.prototype.equals = function (other) {
	    var this$1 = this;
	
	  if (other == this) { return true }
	  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var here = this$1.ranges[i], there = other.ranges[i];
	    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	  }
	  return true
	};
	
	Selection.prototype.deepCopy = function () {
	    var this$1 = this;
	
	  var out = [];
	  for (var i = 0; i < this.ranges.length; i++)
	    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
	  return new Selection(out, this.primIndex)
	};
	
	Selection.prototype.somethingSelected = function () {
	    var this$1 = this;
	
	  for (var i = 0; i < this.ranges.length; i++)
	    { if (!this$1.ranges[i].empty()) { return true } }
	  return false
	};
	
	Selection.prototype.contains = function (pos, end) {
	    var this$1 = this;
	
	  if (!end) { end = pos; }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var range = this$1.ranges[i];
	    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	      { return i }
	  }
	  return -1
	};
	
	var Range = function(anchor, head) {
	  this.anchor = anchor; this.head = head;
	};
	
	Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };
	
	// Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges, primIndex) {
	  var prim = ranges[primIndex];
	  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	  primIndex = indexOf(ranges, prim);
	  for (var i = 1; i < ranges.length; i++) {
	    var cur = ranges[i], prev = ranges[i - 1];
	    if (cmp(prev.to(), cur.from()) >= 0) {
	      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	      if (i <= primIndex) { --primIndex; }
	      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	    }
	  }
	  return new Selection(ranges, primIndex)
	}
	
	function simpleSelection(anchor, head) {
	  return new Selection([new Range(anchor, head || anchor)], 0)
	}
	
	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	function changeEnd(change) {
	  if (!change.text) { return change.to }
	  return Pos(change.from.line + change.text.length - 1,
	             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	}
	
	// Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos, change) {
	  if (cmp(pos, change.from) < 0) { return pos }
	  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
	
	  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	  return Pos(line, ch)
	}
	
	function computeSelAfterChange(doc, change) {
	  var out = [];
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    var range = doc.sel.ranges[i];
	    out.push(new Range(adjustForChange(range.anchor, change),
	                       adjustForChange(range.head, change)));
	  }
	  return normalizeSelection(out, doc.sel.primIndex)
	}
	
	function offsetPos(pos, old, nw) {
	  if (pos.line == old.line)
	    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	  else
	    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	}
	
	// Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc, changes, hint) {
	  var out = [];
	  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    var from = offsetPos(change.from, oldPrev, newPrev);
	    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	    oldPrev = change.to;
	    newPrev = to;
	    if (hint == "around") {
	      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	      out[i] = new Range(inv ? to : from, inv ? from : to);
	    } else {
	      out[i] = new Range(from, from);
	    }
	  }
	  return new Selection(out, doc.sel.primIndex)
	}
	
	// Used to get the editor into a consistent state again when options change.
	
	function loadMode(cm) {
	  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	  resetModeState(cm);
	}
	
	function resetModeState(cm) {
	  cm.doc.iter(function (line) {
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	  });
	  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	  startWorker(cm, 100);
	  cm.state.modeGen++;
	  if (cm.curOp) { regChange(cm); }
	}
	
	// DOCUMENT DATA STRUCTURE
	
	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc, change) {
	  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	}
	
	// Perform a change on the document data structure.
	function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
	  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	  function update(line, text, spans) {
	    updateLine(line, text, spans, estimateHeight$$1);
	    signalLater(line, "change", line, change);
	  }
	  function linesFor(start, end) {
	    var result = [];
	    for (var i = start; i < end; ++i)
	      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
	    return result
	  }
	
	  var from = change.from, to = change.to, text = change.text;
	  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
	
	  // Adjust the line structure
	  if (change.full) {
	    doc.insert(0, linesFor(0, text.length));
	    doc.remove(text.length, doc.size - text.length);
	  } else if (isWholeLineUpdate(doc, change)) {
	    // This is a whole-line replace. Treated specially to make
	    // sure line objects move the way they are supposed to.
	    var added = linesFor(0, text.length - 1);
	    update(lastLine, lastLine.text, lastSpans);
	    if (nlines) { doc.remove(from.line, nlines); }
	    if (added.length) { doc.insert(from.line, added); }
	  } else if (firstLine == lastLine) {
	    if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	    } else {
	      var added$1 = linesFor(1, text.length - 1);
	      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      doc.insert(from.line + 1, added$1);
	    }
	  } else if (text.length == 1) {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	    doc.remove(from.line + 1, nlines);
	  } else {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	    var added$2 = linesFor(1, text.length - 1);
	    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	    doc.insert(from.line + 1, added$2);
	  }
	
	  signalLater(doc, "change", doc, change);
	}
	
	// Call f for all linked documents.
	function linkedDocs(doc, f, sharedHistOnly) {
	  function propagate(doc, skip, sharedHist) {
	    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	      var rel = doc.linked[i];
	      if (rel.doc == skip) { continue }
	      var shared = sharedHist && rel.sharedHist;
	      if (sharedHistOnly && !shared) { continue }
	      f(rel.doc, shared);
	      propagate(rel.doc, doc, shared);
	    } }
	  }
	  propagate(doc, null, true);
	}
	
	// Attach a document to an editor.
	function attachDoc(cm, doc) {
	  if (doc.cm) { throw new Error("This document is already in use.") }
	  cm.doc = doc;
	  doc.cm = cm;
	  estimateLineHeights(cm);
	  loadMode(cm);
	  setDirectionClass(cm);
	  if (!cm.options.lineWrapping) { findMaxLine(cm); }
	  cm.options.mode = doc.modeOption;
	  regChange(cm);
	}
	
	function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	}
	
	function directionChanged(cm) {
	  runInOp(cm, function () {
	    setDirectionClass(cm);
	    regChange(cm);
	  });
	}
	
	function History(startGen) {
	  // Arrays of change events and selections. Doing something adds an
	  // event to done and clears undo. Undoing moves events from done
	  // to undone, redoing moves them in the other direction.
	  this.done = []; this.undone = [];
	  this.undoDepth = Infinity;
	  // Used to track when changes can be merged into a single undo
	  // event
	  this.lastModTime = this.lastSelTime = 0;
	  this.lastOp = this.lastSelOp = null;
	  this.lastOrigin = this.lastSelOrigin = null;
	  // Used by the isClean() method
	  this.generation = this.maxGeneration = startGen || 1;
	}
	
	// Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc, change) {
	  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	  return histChange
	}
	
	// Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array) {
	  while (array.length) {
	    var last = lst(array);
	    if (last.ranges) { array.pop(); }
	    else { break }
	  }
	}
	
	// Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist, force) {
	  if (force) {
	    clearSelectionEvents(hist.done);
	    return lst(hist.done)
	  } else if (hist.done.length && !lst(hist.done).ranges) {
	    return lst(hist.done)
	  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	    hist.done.pop();
	    return lst(hist.done)
	  }
	}
	
	// Register a change in the history. Merges changes that are within
	// a single operation, or are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc, change, selAfter, opId) {
	  var hist = doc.history;
	  hist.undone.length = 0;
	  var time = +new Date, cur;
	  var last;
	
	  if ((hist.lastOp == opId ||
	       hist.lastOrigin == change.origin && change.origin &&
	       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	        change.origin.charAt(0) == "*")) &&
	      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	    // Merge this change into the last event
	    last = lst(cur.changes);
	    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	      // Optimized case for simple insertion -- don't want to add
	      // new changesets for every character typed
	      last.to = changeEnd(change);
	    } else {
	      // Add new sub-event
	      cur.changes.push(historyChangeFromChange(doc, change));
	    }
	  } else {
	    // Can not be merged, start a new event.
	    var before = lst(hist.done);
	    if (!before || !before.ranges)
	      { pushSelectionToHistory(doc.sel, hist.done); }
	    cur = {changes: [historyChangeFromChange(doc, change)],
	           generation: hist.generation};
	    hist.done.push(cur);
	    while (hist.done.length > hist.undoDepth) {
	      hist.done.shift();
	      if (!hist.done[0].ranges) { hist.done.shift(); }
	    }
	  }
	  hist.done.push(selAfter);
	  hist.generation = ++hist.maxGeneration;
	  hist.lastModTime = hist.lastSelTime = time;
	  hist.lastOp = hist.lastSelOp = opId;
	  hist.lastOrigin = hist.lastSelOrigin = change.origin;
	
	  if (!last) { signal(doc, "historyAdded"); }
	}
	
	function selectionEventCanBeMerged(doc, origin, prev, sel) {
	  var ch = origin.charAt(0);
	  return ch == "*" ||
	    ch == "+" &&
	    prev.ranges.length == sel.ranges.length &&
	    prev.somethingSelected() == sel.somethingSelected() &&
	    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	}
	
	// Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc, sel, opId, options) {
	  var hist = doc.history, origin = options && options.origin;
	
	  // A new event is started when the previous origin does not match
	  // the current, or the origins don't allow matching. Origins
	  // starting with * are always merged, those starting with + are
	  // merged when similar and close together in time.
	  if (opId == hist.lastSelOp ||
	      (origin && hist.lastSelOrigin == origin &&
	       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	    { hist.done[hist.done.length - 1] = sel; }
	  else
	    { pushSelectionToHistory(sel, hist.done); }
	
	  hist.lastSelTime = +new Date;
	  hist.lastSelOrigin = origin;
	  hist.lastSelOp = opId;
	  if (options && options.clearRedo !== false)
	    { clearSelectionEvents(hist.undone); }
	}
	
	function pushSelectionToHistory(sel, dest) {
	  var top = lst(dest);
	  if (!(top && top.ranges && top.equals(sel)))
	    { dest.push(sel); }
	}
	
	// Used to store marked span information in the history.
	function attachLocalSpans(doc, change, from, to) {
	  var existing = change["spans_" + doc.id], n = 0;
	  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	    if (line.markedSpans)
	      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	    ++n;
	  });
	}
	
	// When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans) {
	  if (!spans) { return null }
	  var out;
	  for (var i = 0; i < spans.length; ++i) {
	    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	    else if (out) { out.push(spans[i]); }
	  }
	  return !out ? spans : out.length ? out : null
	}
	
	// Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc, change) {
	  var found = change["spans_" + doc.id];
	  if (!found) { return null }
	  var nw = [];
	  for (var i = 0; i < change.text.length; ++i)
	    { nw.push(removeClearedSpans(found[i])); }
	  return nw
	}
	
	// Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc, change) {
	  var old = getOldSpans(doc, change);
	  var stretched = stretchSpansOverChange(doc, change);
	  if (!old) { return stretched }
	  if (!stretched) { return old }
	
	  for (var i = 0; i < old.length; ++i) {
	    var oldCur = old[i], stretchCur = stretched[i];
	    if (oldCur && stretchCur) {
	      spans: for (var j = 0; j < stretchCur.length; ++j) {
	        var span = stretchCur[j];
	        for (var k = 0; k < oldCur.length; ++k)
	          { if (oldCur[k].marker == span.marker) { continue spans } }
	        oldCur.push(span);
	      }
	    } else if (stretchCur) {
	      old[i] = stretchCur;
	    }
	  }
	  return old
	}
	
	// Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events, newGroup, instantiateSel) {
	  var copy = [];
	  for (var i = 0; i < events.length; ++i) {
	    var event = events[i];
	    if (event.ranges) {
	      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	      continue
	    }
	    var changes = event.changes, newChanges = [];
	    copy.push({changes: newChanges});
	    for (var j = 0; j < changes.length; ++j) {
	      var change = changes[j], m = (void 0);
	      newChanges.push({from: change.from, to: change.to, text: change.text});
	      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	        if (indexOf(newGroup, Number(m[1])) > -1) {
	          lst(newChanges)[prop] = change[prop];
	          delete change[prop];
	        }
	      } } }
	    }
	  }
	  return copy
	}
	
	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.
	
	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(range, head, other, extend) {
	  if (extend) {
	    var anchor = range.anchor;
	    if (other) {
	      var posBefore = cmp(head, anchor) < 0;
	      if (posBefore != (cmp(other, anchor) < 0)) {
	        anchor = head;
	        head = other;
	      } else if (posBefore != (cmp(head, other) < 0)) {
	        head = other;
	      }
	    }
	    return new Range(anchor, head)
	  } else {
	    return new Range(other || head, head)
	  }
	}
	
	// Extend the primary selection range, discard the rest.
	function extendSelection(doc, head, other, options, extend) {
	  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
	  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	}
	
	// Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc, heads, options) {
	  var out = [];
	  var extend = doc.cm && (doc.cm.display.shift || doc.extend);
	  for (var i = 0; i < doc.sel.ranges.length; i++)
	    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
	  var newSel = normalizeSelection(out, doc.sel.primIndex);
	  setSelection(doc, newSel, options);
	}
	
	// Updates a single range in the selection.
	function replaceOneSelection(doc, i, range, options) {
	  var ranges = doc.sel.ranges.slice(0);
	  ranges[i] = range;
	  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	}
	
	// Reset the selection to a single range.
	function setSimpleSelection(doc, anchor, head, options) {
	  setSelection(doc, simpleSelection(anchor, head), options);
	}
	
	// Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc, sel, options) {
	  var obj = {
	    ranges: sel.ranges,
	    update: function(ranges) {
	      var this$1 = this;
	
	      this.ranges = [];
	      for (var i = 0; i < ranges.length; i++)
	        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                   clipPos(doc, ranges[i].head)); }
	    },
	    origin: options && options.origin
	  };
	  signal(doc, "beforeSelectionChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
	  else { return sel }
	}
	
	function setSelectionReplaceHistory(doc, sel, options) {
	  var done = doc.history.done, last = lst(done);
	  if (last && last.ranges) {
	    done[done.length - 1] = sel;
	    setSelectionNoUndo(doc, sel, options);
	  } else {
	    setSelection(doc, sel, options);
	  }
	}
	
	// Set a new selection.
	function setSelection(doc, sel, options) {
	  setSelectionNoUndo(doc, sel, options);
	  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	}
	
	function setSelectionNoUndo(doc, sel, options) {
	  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	    { sel = filterSelectionChange(doc, sel, options); }
	
	  var bias = options && options.bias ||
	    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
	
	  if (!(options && options.scroll === false) && doc.cm)
	    { ensureCursorVisible(doc.cm); }
	}
	
	function setSelectionInner(doc, sel) {
	  if (sel.equals(doc.sel)) { return }
	
	  doc.sel = sel;
	
	  if (doc.cm) {
	    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	    signalCursorActivity(doc.cm);
	  }
	  signalLater(doc, "cursorActivity", doc);
	}
	
	// Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc) {
	  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	}
	
	// Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc, sel, bias, mayClear) {
	  var out;
	  for (var i = 0; i < sel.ranges.length; i++) {
	    var range = sel.ranges[i];
	    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	    if (out || newAnchor != range.anchor || newHead != range.head) {
	      if (!out) { out = sel.ranges.slice(0, i); }
	      out[i] = new Range(newAnchor, newHead);
	    }
	  }
	  return out ? normalizeSelection(out, sel.primIndex) : sel
	}
	
	function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	  var line = getLine(doc, pos.line);
	  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	    var sp = line.markedSpans[i], m = sp.marker;
	    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	      if (mayClear) {
	        signal(m, "beforeCursorEnter");
	        if (m.explicitlyCleared) {
	          if (!line.markedSpans) { break }
	          else {--i; continue}
	        }
	      }
	      if (!m.atomic) { continue }
	
	      if (oldPos) {
	        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	      }
	
	      var far = m.find(dir < 0 ? -1 : 1);
	      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	    }
	  } }
	  return pos
	}
	
	// Ensure a given position is not inside an atomic range.
	function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	  var dir = bias || 1;
	  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	  if (!found) {
	    doc.cantEdit = true;
	    return Pos(doc.first, 0)
	  }
	  return found
	}
	
	function movePos(doc, pos, dir, line) {
	  if (dir < 0 && pos.ch == 0) {
	    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	    else { return null }
	  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	    else { return null }
	  } else {
	    return new Pos(pos.line, pos.ch + dir)
	  }
	}
	
	function selectAll(cm) {
	  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	}
	
	// UPDATING
	
	// Allow "beforeChange" event handlers to influence a change
	function filterChange(doc, change, update) {
	  var obj = {
	    canceled: false,
	    from: change.from,
	    to: change.to,
	    text: change.text,
	    origin: change.origin,
	    cancel: function () { return obj.canceled = true; }
	  };
	  if (update) { obj.update = function (from, to, text, origin) {
	    if (from) { obj.from = clipPos(doc, from); }
	    if (to) { obj.to = clipPos(doc, to); }
	    if (text) { obj.text = text; }
	    if (origin !== undefined) { obj.origin = origin; }
	  }; }
	  signal(doc, "beforeChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }
	
	  if (obj.canceled) { return null }
	  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	}
	
	// Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc, change, ignoreReadOnly) {
	  if (doc.cm) {
	    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	    if (doc.cm.state.suppressEdits) { return }
	  }
	
	  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	    change = filterChange(doc, change, true);
	    if (!change) { return }
	  }
	
	  // Possibly split or suppress the update based on the presence
	  // of read-only spans in its range.
	  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	  if (split) {
	    for (var i = split.length - 1; i >= 0; --i)
	      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
	  } else {
	    makeChangeInner(doc, change);
	  }
	}
	
	function makeChangeInner(doc, change) {
	  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	  var selAfter = computeSelAfterChange(doc, change);
	  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
	
	  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	  var rebased = [];
	
	  linkedDocs(doc, function (doc, sharedHist) {
	    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	      rebaseHist(doc.history, change);
	      rebased.push(doc.history);
	    }
	    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	  });
	}
	
	// Revert a change stored in a document's history.
	function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }
	
	  var hist = doc.history, event, selAfter = doc.sel;
	  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
	
	  // Verify that there is a useable event (so that ctrl-z won't
	  // needlessly clear selection events)
	  var i = 0;
	  for (; i < source.length; i++) {
	    event = source[i];
	    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	      { break }
	  }
	  if (i == source.length) { return }
	  hist.lastOrigin = hist.lastSelOrigin = null;
	
	  for (;;) {
	    event = source.pop();
	    if (event.ranges) {
	      pushSelectionToHistory(event, dest);
	      if (allowSelectionOnly && !event.equals(doc.sel)) {
	        setSelection(doc, event, {clearRedo: false});
	        return
	      }
	      selAfter = event;
	    }
	    else { break }
	  }
	
	  // Build up a reverse change object to add to the opposite history
	  // stack (redo when undoing, and vice versa).
	  var antiChanges = [];
	  pushSelectionToHistory(selAfter, dest);
	  dest.push({changes: antiChanges, generation: hist.generation});
	  hist.generation = event.generation || ++hist.maxGeneration;
	
	  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
	
	  var loop = function ( i ) {
	    var change = event.changes[i];
	    change.origin = type;
	    if (filter && !filterChange(doc, change, false)) {
	      source.length = 0;
	      return {}
	    }
	
	    antiChanges.push(historyChangeFromChange(doc, change));
	
	    var after = i ? computeSelAfterChange(doc, change) : lst(source);
	    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	    var rebased = [];
	
	    // Propagate to the linked documents
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	    });
	  };
	
	  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	    var returned = loop( i$1 );
	
	    if ( returned ) return returned.v;
	  }
	}
	
	// Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc, distance) {
	  if (distance == 0) { return }
	  doc.first += distance;
	  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	    Pos(range.anchor.line + distance, range.anchor.ch),
	    Pos(range.head.line + distance, range.head.ch)
	  ); }), doc.sel.primIndex);
	  if (doc.cm) {
	    regChange(doc.cm, doc.first, doc.first - distance, distance);
	    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	      { regLineChange(doc.cm, l, "gutter"); }
	  }
	}
	
	// More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc, change, selAfter, spans) {
	  if (doc.cm && !doc.cm.curOp)
	    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
	
	  if (change.to.line < doc.first) {
	    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	    return
	  }
	  if (change.from.line > doc.lastLine()) { return }
	
	  // Clip the change to the size of this doc
	  if (change.from.line < doc.first) {
	    var shift = change.text.length - 1 - (doc.first - change.from.line);
	    shiftDoc(doc, shift);
	    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	              text: [lst(change.text)], origin: change.origin};
	  }
	  var last = doc.lastLine();
	  if (change.to.line > last) {
	    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	              text: [change.text[0]], origin: change.origin};
	  }
	
	  change.removed = getBetween(doc, change.from, change.to);
	
	  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	  else { updateDoc(doc, change, spans); }
	  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	}
	
	// Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm, change, spans) {
	  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
	
	  var recomputeMaxLength = false, checkWidthStart = from.line;
	  if (!cm.options.lineWrapping) {
	    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	    doc.iter(checkWidthStart, to.line + 1, function (line) {
	      if (line == display.maxLine) {
	        recomputeMaxLength = true;
	        return true
	      }
	    });
	  }
	
	  if (doc.sel.contains(change.from, change.to) > -1)
	    { signalCursorActivity(cm); }
	
	  updateDoc(doc, change, spans, estimateHeight(cm));
	
	  if (!cm.options.lineWrapping) {
	    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	      var len = lineLength(line);
	      if (len > display.maxLineLength) {
	        display.maxLine = line;
	        display.maxLineLength = len;
	        display.maxLineChanged = true;
	        recomputeMaxLength = false;
	      }
	    });
	    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	  }
	
	  retreatFrontier(doc, from.line);
	  startWorker(cm, 400);
	
	  var lendiff = change.text.length - (to.line - from.line) - 1;
	  // Remember that these lines changed, for updating the display
	  if (change.full)
	    { regChange(cm); }
	  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	    { regLineChange(cm, from.line, "text"); }
	  else
	    { regChange(cm, from.line, to.line + 1, lendiff); }
	
	  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	  if (changeHandler || changesHandler) {
	    var obj = {
	      from: from, to: to,
	      text: change.text,
	      removed: change.removed,
	      origin: change.origin
	    };
	    if (changeHandler) { signalLater(cm, "change", cm, obj); }
	    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	  }
	  cm.display.selForContextMenu = null;
	}
	
	function replaceRange(doc, code, from, to, origin) {
	  if (!to) { to = from; }
	  if (cmp(to, from) < 0) { var assign;
	    (assign = [to, from], from = assign[0], to = assign[1], assign); }
	  if (typeof code == "string") { code = doc.splitLines(code); }
	  makeChange(doc, {from: from, to: to, text: code, origin: origin});
	}
	
	// Rebasing/resetting history to deal with externally-sourced changes
	
	function rebaseHistSelSingle(pos, from, to, diff) {
	  if (to < pos.line) {
	    pos.line += diff;
	  } else if (from < pos.line) {
	    pos.line = from;
	    pos.ch = 0;
	  }
	}
	
	// Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array, from, to, diff) {
	  for (var i = 0; i < array.length; ++i) {
	    var sub = array[i], ok = true;
	    if (sub.ranges) {
	      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	      for (var j = 0; j < sub.ranges.length; j++) {
	        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	      }
	      continue
	    }
	    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	      var cur = sub.changes[j$1];
	      if (to < cur.from.line) {
	        cur.from = Pos(cur.from.line + diff, cur.from.ch);
	        cur.to = Pos(cur.to.line + diff, cur.to.ch);
	      } else if (from <= cur.to.line) {
	        ok = false;
	        break
	      }
	    }
	    if (!ok) {
	      array.splice(0, i + 1);
	      i = 0;
	    }
	  }
	}
	
	function rebaseHist(hist, change) {
	  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	  rebaseHistArray(hist.done, from, to, diff);
	  rebaseHistArray(hist.undone, from, to, diff);
	}
	
	// Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc, handle, changeType, op) {
	  var no = handle, line = handle;
	  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	  else { no = lineNo(handle); }
	  if (no == null) { return null }
	  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	  return line
	}
	
	// The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
	
	function LeafChunk(lines) {
	  var this$1 = this;
	
	  this.lines = lines;
	  this.parent = null;
	  var height = 0;
	  for (var i = 0; i < lines.length; ++i) {
	    lines[i].parent = this$1;
	    height += lines[i].height;
	  }
	  this.height = height;
	}
	
	LeafChunk.prototype = {
	  chunkSize: function chunkSize() { return this.lines.length },
	
	  // Remove the n lines at offset 'at'.
	  removeInner: function removeInner(at, n) {
	    var this$1 = this;
	
	    for (var i = at, e = at + n; i < e; ++i) {
	      var line = this$1.lines[i];
	      this$1.height -= line.height;
	      cleanUpLine(line);
	      signalLater(line, "delete");
	    }
	    this.lines.splice(at, n);
	  },
	
	  // Helper used to collapse a small branch into a single leaf.
	  collapse: function collapse(lines) {
	    lines.push.apply(lines, this.lines);
	  },
	
	  // Insert the given array of lines at offset 'at', count them as
	  // having the given height.
	  insertInner: function insertInner(at, lines, height) {
	    var this$1 = this;
	
	    this.height += height;
	    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
	  },
	
	  // Used to iterate over a part of the tree.
	  iterN: function iterN(at, n, op) {
	    var this$1 = this;
	
	    for (var e = at + n; at < e; ++at)
	      { if (op(this$1.lines[at])) { return true } }
	  }
	};
	
	function BranchChunk(children) {
	  var this$1 = this;
	
	  this.children = children;
	  var size = 0, height = 0;
	  for (var i = 0; i < children.length; ++i) {
	    var ch = children[i];
	    size += ch.chunkSize(); height += ch.height;
	    ch.parent = this$1;
	  }
	  this.size = size;
	  this.height = height;
	  this.parent = null;
	}
	
	BranchChunk.prototype = {
	  chunkSize: function chunkSize() { return this.size },
	
	  removeInner: function removeInner(at, n) {
	    var this$1 = this;
	
	    this.size -= n;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var rm = Math.min(n, sz - at), oldHeight = child.height;
	        child.removeInner(at, rm);
	        this$1.height -= oldHeight - child.height;
	        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
	        if ((n -= rm) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	    // If the result is smaller than 25 lines, ensure that it is a
	    // single leaf node.
	    if (this.size - n < 25 &&
	        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	      var lines = [];
	      this.collapse(lines);
	      this.children = [new LeafChunk(lines)];
	      this.children[0].parent = this;
	    }
	  },
	
	  collapse: function collapse(lines) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
	  },
	
	  insertInner: function insertInner(at, lines, height) {
	    var this$1 = this;
	
	    this.size += lines.length;
	    this.height += height;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at <= sz) {
	        child.insertInner(at, lines, height);
	        if (child.lines && child.lines.length > 50) {
	          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	          var remaining = child.lines.length % 25 + 25;
	          for (var pos = remaining; pos < child.lines.length;) {
	            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	            child.height -= leaf.height;
	            this$1.children.splice(++i, 0, leaf);
	            leaf.parent = this$1;
	          }
	          child.lines = child.lines.slice(0, remaining);
	          this$1.maybeSpill();
	        }
	        break
	      }
	      at -= sz;
	    }
	  },
	
	  // When a node has grown, check whether it should be split.
	  maybeSpill: function maybeSpill() {
	    if (this.children.length <= 10) { return }
	    var me = this;
	    do {
	      var spilled = me.children.splice(me.children.length - 5, 5);
	      var sibling = new BranchChunk(spilled);
	      if (!me.parent) { // Become the parent node
	        var copy = new BranchChunk(me.children);
	        copy.parent = me;
	        me.children = [copy, sibling];
	        me = copy;
	     } else {
	        me.size -= sibling.size;
	        me.height -= sibling.height;
	        var myIndex = indexOf(me.parent.children, me);
	        me.parent.children.splice(myIndex + 1, 0, sibling);
	      }
	      sibling.parent = me.parent;
	    } while (me.children.length > 10)
	    me.parent.maybeSpill();
	  },
	
	  iterN: function iterN(at, n, op) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var used = Math.min(n, sz - at);
	        if (child.iterN(at, used, op)) { return true }
	        if ((n -= used) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	  }
	};
	
	// Line widgets are block elements displayed above or below a line.
	
	var LineWidget = function(doc, node, options) {
	  var this$1 = this;
	
	  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	    { this$1[opt] = options[opt]; } } }
	  this.doc = doc;
	  this.node = node;
	};
	
	LineWidget.prototype.clear = function () {
	    var this$1 = this;
	
	  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	  if (no == null || !ws) { return }
	  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
	  if (!ws.length) { line.widgets = null; }
	  var height = widgetHeight(this);
	  updateLineHeight(line, Math.max(0, line.height - height));
	  if (cm) {
	    runInOp(cm, function () {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	    signalLater(cm, "lineWidgetCleared", cm, this, no);
	  }
	};
	
	LineWidget.prototype.changed = function () {
	    var this$1 = this;
	
	  var oldH = this.height, cm = this.doc.cm, line = this.line;
	  this.height = null;
	  var diff = widgetHeight(this) - oldH;
	  if (!diff) { return }
	  updateLineHeight(line, line.height + diff);
	  if (cm) {
	    runInOp(cm, function () {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	    });
	  }
	};
	eventMixin(LineWidget);
	
	function adjustScrollWhenAboveVisible(cm, line, diff) {
	  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	    { addToScrollTop(cm, diff); }
	}
	
	function addLineWidget(doc, handle, node, options) {
	  var widget = new LineWidget(doc, node, options);
	  var cm = doc.cm;
	  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	  changeLine(doc, handle, "widget", function (line) {
	    var widgets = line.widgets || (line.widgets = []);
	    if (widget.insertAt == null) { widgets.push(widget); }
	    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	    widget.line = line;
	    if (cm && !lineIsHidden(doc, line)) {
	      var aboveVisible = heightAtLine(line) < doc.scrollTop;
	      updateLineHeight(line, line.height + widgetHeight(widget));
	      if (aboveVisible) { addToScrollTop(cm, widget.height); }
	      cm.curOp.forceUpdate = true;
	    }
	    return true
	  });
	  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
	  return widget
	}
	
	// TEXTMARKERS
	
	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.
	
	// Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId = 0;
	
	var TextMarker = function(doc, type) {
	  this.lines = [];
	  this.type = type;
	  this.doc = doc;
	  this.id = ++nextMarkerId;
	};
	
	// Clear the marker.
	TextMarker.prototype.clear = function () {
	    var this$1 = this;
	
	  if (this.explicitlyCleared) { return }
	  var cm = this.doc.cm, withOp = cm && !cm.curOp;
	  if (withOp) { startOperation(cm); }
	  if (hasHandler(this, "clear")) {
	    var found = this.find();
	    if (found) { signalLater(this, "clear", found.from, found.to); }
	  }
	  var min = null, max = null;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	    else if (cm) {
	      if (span.to != null) { max = lineNo(line); }
	      if (span.from != null) { min = lineNo(line); }
	    }
	    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
	      { updateLineHeight(line, textHeight(cm.display)); }
	  }
	  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
	    if (len > cm.display.maxLineLength) {
	      cm.display.maxLine = visual;
	      cm.display.maxLineLength = len;
	      cm.display.maxLineChanged = true;
	    }
	  } }
	
	  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	  this.lines.length = 0;
	  this.explicitlyCleared = true;
	  if (this.atomic && this.doc.cantEdit) {
	    this.doc.cantEdit = false;
	    if (cm) { reCheckSelection(cm.doc); }
	  }
	  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	  if (withOp) { endOperation(cm); }
	  if (this.parent) { this.parent.clear(); }
	};
	
	// Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find = function (side, lineObj) {
	    var this$1 = this;
	
	  if (side == null && this.type == "bookmark") { side = 1; }
	  var from, to;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (span.from != null) {
	      from = Pos(lineObj ? line : lineNo(line), span.from);
	      if (side == -1) { return from }
	    }
	    if (span.to != null) {
	      to = Pos(lineObj ? line : lineNo(line), span.to);
	      if (side == 1) { return to }
	    }
	  }
	  return from && {from: from, to: to}
	};
	
	// Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed = function () {
	    var this$1 = this;
	
	  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	  if (!pos || !cm) { return }
	  runInOp(cm, function () {
	    var line = pos.line, lineN = lineNo(pos.line);
	    var view = findViewForLine(cm, lineN);
	    if (view) {
	      clearLineMeasurementCacheFor(view);
	      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	    }
	    cm.curOp.updateMaxLine = true;
	    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	      var oldHeight = widget.height;
	      widget.height = null;
	      var dHeight = widgetHeight(widget) - oldHeight;
	      if (dHeight)
	        { updateLineHeight(line, line.height + dHeight); }
	    }
	    signalLater(cm, "markerChanged", cm, this$1);
	  });
	};
	
	TextMarker.prototype.attachLine = function (line) {
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;
	    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	  }
	  this.lines.push(line);
	};
	
	TextMarker.prototype.detachLine = function (line) {
	  this.lines.splice(indexOf(this.lines, line), 1);
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	  }
	};
	eventMixin(TextMarker);
	
	// Create a marker, wire it up to the right lines, and
	function markText(doc, from, to, options, type) {
	  // Shared markers (across linked documents) are handled separately
	  // (markTextShared will call out to this again, once per
	  // document).
	  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	  // Ensure we are in an operation.
	  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
	
	  var marker = new TextMarker(doc, type), diff = cmp(from, to);
	  if (options) { copyObj(options, marker, false); }
	  // Don't connect empty markers unless clearWhenEmpty is false
	  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	    { return marker }
	  if (marker.replacedWith) {
	    // Showing up as a widget implies collapsed (widget replaces text)
	    marker.collapsed = true;
	    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	  }
	  if (marker.collapsed) {
	    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	    seeCollapsedSpans();
	  }
	
	  if (marker.addToHistory)
	    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }
	
	  var curLine = from.line, cm = doc.cm, updateMaxLine;
	  doc.iter(curLine, to.line + 1, function (line) {
	    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	      { updateMaxLine = true; }
	    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	    addMarkedSpan(line, new MarkedSpan(marker,
	                                       curLine == from.line ? from.ch : null,
	                                       curLine == to.line ? to.ch : null));
	    ++curLine;
	  });
	  // lineIsHidden depends on the presence of the spans, so needs a second pass
	  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	  }); }
	
	  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }
	
	  if (marker.readOnly) {
	    seeReadOnlySpans();
	    if (doc.history.done.length || doc.history.undone.length)
	      { doc.clearHistory(); }
	  }
	  if (marker.collapsed) {
	    marker.id = ++nextMarkerId;
	    marker.atomic = true;
	  }
	  if (cm) {
	    // Sync editor state
	    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	    if (marker.collapsed)
	      { regChange(cm, from.line, to.line + 1); }
	    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	    if (marker.atomic) { reCheckSelection(cm.doc); }
	    signalLater(cm, "markerAdded", cm, marker);
	  }
	  return marker
	}
	
	// SHARED TEXTMARKERS
	
	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	var SharedTextMarker = function(markers, primary) {
	  var this$1 = this;
	
	  this.markers = markers;
	  this.primary = primary;
	  for (var i = 0; i < markers.length; ++i)
	    { markers[i].parent = this$1; }
	};
	
	SharedTextMarker.prototype.clear = function () {
	    var this$1 = this;
	
	  if (this.explicitlyCleared) { return }
	  this.explicitlyCleared = true;
	  for (var i = 0; i < this.markers.length; ++i)
	    { this$1.markers[i].clear(); }
	  signalLater(this, "clear");
	};
	
	SharedTextMarker.prototype.find = function (side, lineObj) {
	  return this.primary.find(side, lineObj)
	};
	eventMixin(SharedTextMarker);
	
	function markTextShared(doc, from, to, options, type) {
	  options = copyObj(options);
	  options.shared = false;
	  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	  var widget = options.widgetNode;
	  linkedDocs(doc, function (doc) {
	    if (widget) { options.widgetNode = widget.cloneNode(true); }
	    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	    for (var i = 0; i < doc.linked.length; ++i)
	      { if (doc.linked[i].isParent) { return } }
	    primary = lst(markers);
	  });
	  return new SharedTextMarker(markers, primary)
	}
	
	function findSharedMarkers(doc) {
	  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	}
	
	function copySharedMarkers(doc, markers) {
	  for (var i = 0; i < markers.length; i++) {
	    var marker = markers[i], pos = marker.find();
	    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	    if (cmp(mFrom, mTo)) {
	      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	      marker.markers.push(subMark);
	      subMark.parent = marker;
	    }
	  }
	}
	
	function detachSharedMarkers(markers) {
	  var loop = function ( i ) {
	    var marker = markers[i], linked = [marker.primary.doc];
	    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	    for (var j = 0; j < marker.markers.length; j++) {
	      var subMarker = marker.markers[j];
	      if (indexOf(linked, subMarker.doc) == -1) {
	        subMarker.parent = null;
	        marker.markers.splice(j--, 1);
	      }
	    }
	  };
	
	  for (var i = 0; i < markers.length; i++) loop( i );
	}
	
	var nextDocId = 0;
	var Doc = function(text, mode, firstLine, lineSep, direction) {
	  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	  if (firstLine == null) { firstLine = 0; }
	
	  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	  this.first = firstLine;
	  this.scrollTop = this.scrollLeft = 0;
	  this.cantEdit = false;
	  this.cleanGeneration = 1;
	  this.modeFrontier = this.highlightFrontier = firstLine;
	  var start = Pos(firstLine, 0);
	  this.sel = simpleSelection(start);
	  this.history = new History(null);
	  this.id = ++nextDocId;
	  this.modeOption = mode;
	  this.lineSep = lineSep;
	  this.direction = (direction == "rtl") ? "rtl" : "ltr";
	  this.extend = false;
	
	  if (typeof text == "string") { text = this.splitLines(text); }
	  updateDoc(this, {from: start, to: start, text: text});
	  setSelection(this, simpleSelection(start), sel_dontScroll);
	};
	
	Doc.prototype = createObj(BranchChunk.prototype, {
	  constructor: Doc,
	  // Iterate over the document. Supports two forms -- with only one
	  // argument, it calls that for each line in the document. With
	  // three, it iterates over the range given by the first two (with
	  // the second being non-inclusive).
	  iter: function(from, to, op) {
	    if (op) { this.iterN(from - this.first, to - from, op); }
	    else { this.iterN(this.first, this.first + this.size, from); }
	  },
	
	  // Non-public interface for adding and removing lines.
	  insert: function(at, lines) {
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	    this.insertInner(at - this.first, lines, height);
	  },
	  remove: function(at, n) { this.removeInner(at - this.first, n); },
	
	  // From here, the methods are part of the public interface. Most
	  // are also available from CodeMirror (editor) instances.
	
	  getValue: function(lineSep) {
	    var lines = getLines(this, this.first, this.first + this.size);
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	  setValue: docMethodOp(function(code) {
	    var top = Pos(this.first, 0), last = this.first + this.size - 1;
	    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                      text: this.splitLines(code), origin: "setValue", full: true}, true);
	    if (this.cm) { scrollToCoords(this.cm, 0, 0); }
	    setSelection(this, simpleSelection(top), sel_dontScroll);
	  }),
	  replaceRange: function(code, from, to, origin) {
	    from = clipPos(this, from);
	    to = to ? clipPos(this, to) : from;
	    replaceRange(this, code, from, to, origin);
	  },
	  getRange: function(from, to, lineSep) {
	    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	
	  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
	
	  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	  getLineNumber: function(line) {return lineNo(line)},
	
	  getLineHandleVisualStart: function(line) {
	    if (typeof line == "number") { line = getLine(this, line); }
	    return visualLine(line)
	  },
	
	  lineCount: function() {return this.size},
	  firstLine: function() {return this.first},
	  lastLine: function() {return this.first + this.size - 1},
	
	  clipPos: function(pos) {return clipPos(this, pos)},
	
	  getCursor: function(start) {
	    var range$$1 = this.sel.primary(), pos;
	    if (start == null || start == "head") { pos = range$$1.head; }
	    else if (start == "anchor") { pos = range$$1.anchor; }
	    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
	    else { pos = range$$1.from(); }
	    return pos
	  },
	  listSelections: function() { return this.sel.ranges },
	  somethingSelected: function() {return this.sel.somethingSelected()},
	
	  setCursor: docMethodOp(function(line, ch, options) {
	    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	  }),
	  setSelection: docMethodOp(function(anchor, head, options) {
	    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	  }),
	  extendSelection: docMethodOp(function(head, other, options) {
	    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	  }),
	  extendSelections: docMethodOp(function(heads, options) {
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  extendSelectionsBy: docMethodOp(function(f, options) {
	    var heads = map(this.sel.ranges, f);
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  setSelections: docMethodOp(function(ranges, primary, options) {
	    var this$1 = this;
	
	    if (!ranges.length) { return }
	    var out = [];
	    for (var i = 0; i < ranges.length; i++)
	      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
	                         clipPos(this$1, ranges[i].head)); }
	    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	    setSelection(this, normalizeSelection(out, primary), options);
	  }),
	  addSelection: docMethodOp(function(anchor, head, options) {
	    var ranges = this.sel.ranges.slice(0);
	    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	  }),
	
	  getSelection: function(lineSep) {
	    var this$1 = this;
	
	    var ranges = this.sel.ranges, lines;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      lines = lines ? lines.concat(sel) : sel;
	    }
	    if (lineSep === false) { return lines }
	    else { return lines.join(lineSep || this.lineSeparator()) }
	  },
	  getSelections: function(lineSep) {
	    var this$1 = this;
	
	    var parts = [], ranges = this.sel.ranges;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
	      parts[i] = sel;
	    }
	    return parts
	  },
	  replaceSelection: function(code, collapse, origin) {
	    var dup = [];
	    for (var i = 0; i < this.sel.ranges.length; i++)
	      { dup[i] = code; }
	    this.replaceSelections(dup, collapse, origin || "+input");
	  },
	  replaceSelections: docMethodOp(function(code, collapse, origin) {
	    var this$1 = this;
	
	    var changes = [], sel = this.sel;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range$$1 = sel.ranges[i];
	      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
	    }
	    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	      { makeChange(this$1, changes[i$1]); }
	    if (newSel) { setSelectionReplaceHistory(this, newSel); }
	    else if (this.cm) { ensureCursorVisible(this.cm); }
	  }),
	  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),
	
	  setExtending: function(val) {this.extend = val;},
	  getExtending: function() {return this.extend},
	
	  historySize: function() {
	    var hist = this.history, done = 0, undone = 0;
	    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	    return {undo: done, redo: undone}
	  },
	  clearHistory: function() {this.history = new History(this.history.maxGeneration);},
	
	  markClean: function() {
	    this.cleanGeneration = this.changeGeneration(true);
	  },
	  changeGeneration: function(forceSplit) {
	    if (forceSplit)
	      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	    return this.history.generation
	  },
	  isClean: function (gen) {
	    return this.history.generation == (gen || this.cleanGeneration)
	  },
	
	  getHistory: function() {
	    return {done: copyHistoryArray(this.history.done),
	            undone: copyHistoryArray(this.history.undone)}
	  },
	  setHistory: function(histData) {
	    var hist = this.history = new History(this.history.maxGeneration);
	    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	  },
	
	  setGutterMarker: docMethodOp(function(line, gutterID, value) {
	    return changeLine(this, line, "gutter", function (line) {
	      var markers = line.gutterMarkers || (line.gutterMarkers = {});
	      markers[gutterID] = value;
	      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	      return true
	    })
	  }),
	
	  clearGutter: docMethodOp(function(gutterID) {
	    var this$1 = this;
	
	    this.iter(function (line) {
	      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	        changeLine(this$1, line, "gutter", function () {
	          line.gutterMarkers[gutterID] = null;
	          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	          return true
	        });
	      }
	    });
	  }),
	
	  lineInfo: function(line) {
	    var n;
	    if (typeof line == "number") {
	      if (!isLine(this, line)) { return null }
	      n = line;
	      line = getLine(this, line);
	      if (!line) { return null }
	    } else {
	      n = lineNo(line);
	      if (n == null) { return null }
	    }
	    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	            widgets: line.widgets}
	  },
	
	  addLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      if (!line[prop]) { line[prop] = cls; }
	      else if (classTest(cls).test(line[prop])) { return false }
	      else { line[prop] += " " + cls; }
	      return true
	    })
	  }),
	  removeLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      var cur = line[prop];
	      if (!cur) { return false }
	      else if (cls == null) { line[prop] = null; }
	      else {
	        var found = cur.match(classTest(cls));
	        if (!found) { return false }
	        var end = found.index + found[0].length;
	        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	      }
	      return true
	    })
	  }),
	
	  addLineWidget: docMethodOp(function(handle, node, options) {
	    return addLineWidget(this, handle, node, options)
	  }),
	  removeLineWidget: function(widget) { widget.clear(); },
	
	  markText: function(from, to, options) {
	    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	  },
	  setBookmark: function(pos, options) {
	    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                    insertLeft: options && options.insertLeft,
	                    clearWhenEmpty: false, shared: options && options.shared,
	                    handleMouseEvents: options && options.handleMouseEvents};
	    pos = clipPos(this, pos);
	    return markText(this, pos, pos, realOpts, "bookmark")
	  },
	  findMarksAt: function(pos) {
	    pos = clipPos(this, pos);
	    var markers = [], spans = getLine(this, pos.line).markedSpans;
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if ((span.from == null || span.from <= pos.ch) &&
	          (span.to == null || span.to >= pos.ch))
	        { markers.push(span.marker.parent || span.marker); }
	    } }
	    return markers
	  },
	  findMarks: function(from, to, filter) {
	    from = clipPos(this, from); to = clipPos(this, to);
	    var found = [], lineNo$$1 = from.line;
	    this.iter(from.line, to.line + 1, function (line) {
	      var spans = line.markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; i++) {
	        var span = spans[i];
	        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
	              span.from == null && lineNo$$1 != from.line ||
	              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
	            (!filter || filter(span.marker)))
	          { found.push(span.marker.parent || span.marker); }
	      } }
	      ++lineNo$$1;
	    });
	    return found
	  },
	  getAllMarks: function() {
	    var markers = [];
	    this.iter(function (line) {
	      var sps = line.markedSpans;
	      if (sps) { for (var i = 0; i < sps.length; ++i)
	        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	    });
	    return markers
	  },
	
	  posFromIndex: function(off) {
	    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
	    this.iter(function (line) {
	      var sz = line.text.length + sepSize;
	      if (sz > off) { ch = off; return true }
	      off -= sz;
	      ++lineNo$$1;
	    });
	    return clipPos(this, Pos(lineNo$$1, ch))
	  },
	  indexFromPos: function (coords) {
	    coords = clipPos(this, coords);
	    var index = coords.ch;
	    if (coords.line < this.first || coords.ch < 0) { return 0 }
	    var sepSize = this.lineSeparator().length;
	    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	      index += line.text.length + sepSize;
	    });
	    return index
	  },
	
	  copy: function(copyHistory) {
	    var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                      this.modeOption, this.first, this.lineSep, this.direction);
	    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	    doc.sel = this.sel;
	    doc.extend = false;
	    if (copyHistory) {
	      doc.history.undoDepth = this.history.undoDepth;
	      doc.setHistory(this.getHistory());
	    }
	    return doc
	  },
	
	  linkedDoc: function(options) {
	    if (!options) { options = {}; }
	    var from = this.first, to = this.first + this.size;
	    if (options.from != null && options.from > from) { from = options.from; }
	    if (options.to != null && options.to < to) { to = options.to; }
	    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	    if (options.sharedHist) { copy.history = this.history
	    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	    copySharedMarkers(copy, findSharedMarkers(this));
	    return copy
	  },
	  unlinkDoc: function(other) {
	    var this$1 = this;
	
	    if (other instanceof CodeMirror$1) { other = other.doc; }
	    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	      var link = this$1.linked[i];
	      if (link.doc != other) { continue }
	      this$1.linked.splice(i, 1);
	      other.unlinkDoc(this$1);
	      detachSharedMarkers(findSharedMarkers(this$1));
	      break
	    } }
	    // If the histories were shared, split them again
	    if (other.history == this.history) {
	      var splitIds = [other.id];
	      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	      other.history = new History(null);
	      other.history.done = copyHistoryArray(this.history.done, splitIds);
	      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	    }
	  },
	  iterLinkedDocs: function(f) {linkedDocs(this, f);},
	
	  getMode: function() {return this.mode},
	  getEditor: function() {return this.cm},
	
	  splitLines: function(str) {
	    if (this.lineSep) { return str.split(this.lineSep) }
	    return splitLinesAuto(str)
	  },
	  lineSeparator: function() { return this.lineSep || "\n" },
	
	  setDirection: docMethodOp(function (dir) {
	    if (dir != "rtl") { dir = "ltr"; }
	    if (dir == this.direction) { return }
	    this.direction = dir;
	    this.iter(function (line) { return line.order = null; });
	    if (this.cm) { directionChanged(this.cm); }
	  })
	});
	
	// Public alias.
	Doc.prototype.eachLine = Doc.prototype.iter;
	
	// Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop = 0;
	
	function onDrop(e) {
	  var cm = this;
	  clearDragCursor(cm);
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	    { return }
	  e_preventDefault(e);
	  if (ie) { lastDrop = +new Date; }
	  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	  if (!pos || cm.isReadOnly()) { return }
	  // Might be a file drop, in which case we simply extract the text
	  // and insert it.
	  if (files && files.length && window.FileReader && window.File) {
	    var n = files.length, text = Array(n), read = 0;
	    var loadFile = function (file, i) {
	      if (cm.options.allowDropFileTypes &&
	          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	        { return }
	
	      var reader = new FileReader;
	      reader.onload = operation(cm, function () {
	        var content = reader.result;
	        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
	        text[i] = content;
	        if (++read == n) {
	          pos = clipPos(cm.doc, pos);
	          var change = {from: pos, to: pos,
	                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                        origin: "paste"};
	          makeChange(cm.doc, change);
	          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	        }
	      });
	      reader.readAsText(file);
	    };
	    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
	  } else { // Normal drop
	    // Don't do a replace if the drop happened inside of the selected text.
	    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	      cm.state.draggingText(e);
	      // Ensure the editor is re-focused
	      setTimeout(function () { return cm.display.input.focus(); }, 20);
	      return
	    }
	    try {
	      var text$1 = e.dataTransfer.getData("Text");
	      if (text$1) {
	        var selected;
	        if (cm.state.draggingText && !cm.state.draggingText.copy)
	          { selected = cm.listSelections(); }
	        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	        cm.replaceSelection(text$1, "around", "paste");
	        cm.display.input.focus();
	      }
	    }
	    catch(e){}
	  }
	}
	
	function onDragStart(cm, e) {
	  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
	
	  e.dataTransfer.setData("Text", cm.getSelection());
	  e.dataTransfer.effectAllowed = "copyMove";
	
	  // Use dummy image instead of default browsers image.
	  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	  if (e.dataTransfer.setDragImage && !safari) {
	    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (presto) {
	      img.width = img.height = 1;
	      cm.display.wrapper.appendChild(img);
	      // Force a relayout, or Opera won't use our image for some obscure reason
	      img._top = img.offsetTop;
	    }
	    e.dataTransfer.setDragImage(img, 0, 0);
	    if (presto) { img.parentNode.removeChild(img); }
	  }
	}
	
	function onDragOver(cm, e) {
	  var pos = posFromMouse(cm, e);
	  if (!pos) { return }
	  var frag = document.createDocumentFragment();
	  drawSelectionCursor(cm, pos, frag);
	  if (!cm.display.dragCursor) {
	    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	  }
	  removeChildrenAndAdd(cm.display.dragCursor, frag);
	}
	
	function clearDragCursor(cm) {
	  if (cm.display.dragCursor) {
	    cm.display.lineSpace.removeChild(cm.display.dragCursor);
	    cm.display.dragCursor = null;
	  }
	}
	
	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.
	
	function forEachCodeMirror(f) {
	  if (!document.getElementsByClassName) { return }
	  var byClass = document.getElementsByClassName("CodeMirror");
	  for (var i = 0; i < byClass.length; i++) {
	    var cm = byClass[i].CodeMirror;
	    if (cm) { f(cm); }
	  }
	}
	
	var globalsRegistered = false;
	function ensureGlobalHandlers() {
	  if (globalsRegistered) { return }
	  registerGlobalHandlers();
	  globalsRegistered = true;
	}
	function registerGlobalHandlers() {
	  // When the window resizes, we need to refresh active editors.
	  var resizeTimer;
	  on(window, "resize", function () {
	    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	      resizeTimer = null;
	      forEachCodeMirror(onResize);
	    }, 100); }
	  });
	  // When the window loses focus, we want to show the editor as blurred
	  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	}
	// Called when the window resizes
	function onResize(cm) {
	  var d = cm.display;
	  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	    { return }
	  // Might be a text scaling operation, clear size caches.
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	  d.scrollbarsClipped = false;
	  cm.setSize();
	}
	
	var keyNames = {
	  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	};
	
	// Number keys
	for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	// Alphabetic keys
	for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	// Function keys
	for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }
	
	var keyMap = {};
	
	keyMap.basic = {
	  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	  "Esc": "singleSelection"
	};
	// Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault = {
	  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	  fallthrough: "basic"
	};
	// Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy = {
	  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	  "Ctrl-O": "openLine"
	};
	keyMap.macDefault = {
	  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	  fallthrough: ["basic", "emacsy"]
	};
	keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
	
	// KEYMAP DISPATCH
	
	function normalizeKeyName(name) {
	  var parts = name.split(/-(?!$)/);
	  name = parts[parts.length - 1];
	  var alt, ctrl, shift, cmd;
	  for (var i = 0; i < parts.length - 1; i++) {
	    var mod = parts[i];
	    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	    else { throw new Error("Unrecognized modifier name: " + mod) }
	  }
	  if (alt) { name = "Alt-" + name; }
	  if (ctrl) { name = "Ctrl-" + name; }
	  if (cmd) { name = "Cmd-" + name; }
	  if (shift) { name = "Shift-" + name; }
	  return name
	}
	
	// This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	function normalizeKeyMap(keymap) {
	  var copy = {};
	  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	    var value = keymap[keyname];
	    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	    if (value == "...") { delete keymap[keyname]; continue }
	
	    var keys = map(keyname.split(" "), normalizeKeyName);
	    for (var i = 0; i < keys.length; i++) {
	      var val = (void 0), name = (void 0);
	      if (i == keys.length - 1) {
	        name = keys.join(" ");
	        val = value;
	      } else {
	        name = keys.slice(0, i + 1).join(" ");
	        val = "...";
	      }
	      var prev = copy[name];
	      if (!prev) { copy[name] = val; }
	      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	    }
	    delete keymap[keyname];
	  } }
	  for (var prop in copy) { keymap[prop] = copy[prop]; }
	  return keymap
	}
	
	function lookupKey(key, map$$1, handle, context) {
	  map$$1 = getKeyMap(map$$1);
	  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
	  if (found === false) { return "nothing" }
	  if (found === "...") { return "multi" }
	  if (found != null && handle(found)) { return "handled" }
	
	  if (map$$1.fallthrough) {
	    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
	      { return lookupKey(key, map$$1.fallthrough, handle, context) }
	    for (var i = 0; i < map$$1.fallthrough.length; i++) {
	      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
	      if (result) { return result }
	    }
	  }
	}
	
	// Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	function isModifierKey(value) {
	  var name = typeof value == "string" ? value : keyNames[value.keyCode];
	  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	}
	
	function addModifierNames(name, event, noShift) {
	  var base = name;
	  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	  return name
	}
	
	// Look up the name of a key as indicated by an event object.
	function keyName(event, noShift) {
	  if (presto && event.keyCode == 34 && event["char"]) { return false }
	  var name = keyNames[event.keyCode];
	  if (name == null || event.altGraphKey) { return false }
	  return addModifierNames(name, event, noShift)
	}
	
	function getKeyMap(val) {
	  return typeof val == "string" ? keyMap[val] : val
	}
	
	// Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm, compute) {
	  var ranges = cm.doc.sel.ranges, kill = [];
	  // Build up a set of ranges to kill first, merging overlapping
	  // ranges.
	  for (var i = 0; i < ranges.length; i++) {
	    var toKill = compute(ranges[i]);
	    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	      var replaced = kill.pop();
	      if (cmp(replaced.from, toKill.from) < 0) {
	        toKill.from = replaced.from;
	        break
	      }
	    }
	    kill.push(toKill);
	  }
	  // Next, remove those actual ranges.
	  runInOp(cm, function () {
	    for (var i = kill.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	    ensureCursorVisible(cm);
	  });
	}
	
	function moveCharLogically(line, ch, dir) {
	  var target = skipExtendingChars(line.text, ch + dir, dir);
	  return target < 0 || target > line.text.length ? null : target
	}
	
	function moveLogically(line, start, dir) {
	  var ch = moveCharLogically(line, start.ch, dir);
	  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	}
	
	function endOfLine(visually, cm, lineObj, lineNo, dir) {
	  if (visually) {
	    var order = getOrder(lineObj, cm.doc.direction);
	    if (order) {
	      var part = dir < 0 ? lst(order) : order[0];
	      var moveInStorageOrder = (dir < 0) == (part.level == 1);
	      var sticky = moveInStorageOrder ? "after" : "before";
	      var ch;
	      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	      // it could be that the last bidi part is not on the last visual line,
	      // since visual lines contain content order-consecutive chunks.
	      // Thus, in rtl, we are looking for the first (content-order) character
	      // in the rtl chunk that is on the last line (that is, the same line
	      // as the last (content-order) character).
	      if (part.level > 0 || cm.doc.direction == "rtl") {
	        var prep = prepareMeasureForLine(cm, lineObj);
	        ch = dir < 0 ? lineObj.text.length - 1 : 0;
	        var targetTop = measureCharPrepared(cm, prep, ch).top;
	        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
	      } else { ch = dir < 0 ? part.to : part.from; }
	      return new Pos(lineNo, ch, sticky)
	    }
	  }
	  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	}
	
	function moveVisually(cm, line, start, dir) {
	  var bidi = getOrder(line, cm.doc.direction);
	  if (!bidi) { return moveLogically(line, start, dir) }
	  if (start.ch >= line.text.length) {
	    start.ch = line.text.length;
	    start.sticky = "before";
	  } else if (start.ch <= 0) {
	    start.ch = 0;
	    start.sticky = "after";
	  }
	  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	    // nothing interesting happens.
	    return moveLogically(line, start, dir)
	  }
	
	  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	  var prep;
	  var getWrappedLineExtent = function (ch) {
	    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	    prep = prep || prepareMeasureForLine(cm, line);
	    return wrappedLineExtentChar(cm, line, prep, ch)
	  };
	  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
	
	  if (cm.doc.direction == "rtl" || part.level == 1) {
	    var moveInStorageOrder = (part.level == 1) == (dir < 0);
	    var ch = mv(start, moveInStorageOrder ? 1 : -1);
	    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	      var sticky = moveInStorageOrder ? "before" : "after";
	      return new Pos(start.line, ch, sticky)
	    }
	  }
	
	  // Case 3: Could not move within this bidi part in this visual line, so leave
	  // the current bidi part
	
	  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	      ? new Pos(start.line, mv(ch, 1), "before")
	      : new Pos(start.line, ch, "after"); };
	
	    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	      var part = bidi[partPos];
	      var moveInStorageOrder = (dir > 0) == (part.level != 1);
	      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	    }
	  };
	
	  // Case 3a: Look for other bidi parts on the same visual line
	  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	  if (res) { return res }
	
	  // Case 3b: Look for other bidi parts on the next visual line
	  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	    if (res) { return res }
	  }
	
	  // Case 4: Nowhere to move
	  return null
	}
	
	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands = {
	  selectAll: selectAll,
	  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	    if (range.empty()) {
	      var len = getLine(cm.doc, range.head.line).text.length;
	      if (range.head.ch == len && range.head.line < cm.lastLine())
	        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	      else
	        { return {from: range.head, to: Pos(range.head.line, len)} }
	    } else {
	      return {from: range.from(), to: range.to()}
	    }
	  }); },
	  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0),
	    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	  }); }); },
	  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0), to: range.from()
	  }); }); },
	  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	    return {from: leftPos, to: range.from()}
	  }); },
	  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	    return {from: range.from(), to: rightPos }
	  }); },
	  undo: function (cm) { return cm.undo(); },
	  redo: function (cm) { return cm.redo(); },
	  undoSelection: function (cm) { return cm.undoSelection(); },
	  redoSelection: function (cm) { return cm.redoSelection(); },
	  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	    {origin: "+move", bias: -1}
	  ); },
	  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	  }, sel_move); },
	  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: 0, top: top}, "div")
	  }, sel_move); },
	  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    var pos = cm.coordsChar({left: 0, top: top}, "div");
	    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	    return pos
	  }, sel_move); },
	  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	  goLineDown: function (cm) { return cm.moveV(1, "line"); },
	  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	  goPageDown: function (cm) { return cm.moveV(1, "page"); },
	  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	  goCharRight: function (cm) { return cm.moveH(1, "char"); },
	  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	  goWordRight: function (cm) { return cm.moveH(1, "word"); },
	  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	  indentAuto: function (cm) { return cm.indentSelection("smart"); },
	  indentMore: function (cm) { return cm.indentSelection("add"); },
	  indentLess: function (cm) { return cm.indentSelection("subtract"); },
	  insertTab: function (cm) { return cm.replaceSelection("\t"); },
	  insertSoftTab: function (cm) {
	    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].from();
	      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	      spaces.push(spaceStr(tabSize - col % tabSize));
	    }
	    cm.replaceSelections(spaces);
	  },
	  defaultTab: function (cm) {
	    if (cm.somethingSelected()) { cm.indentSelection("add"); }
	    else { cm.execCommand("insertTab"); }
	  },
	  // Swap the two chars left and right of each selection's head.
	  // Move cursor behind the two swapped characters afterwards.
	  //
	  // Doesn't consider line feeds a character.
	  // Doesn't scan more than one line above to find a character.
	  // Doesn't do anything on an empty line.
	  // Doesn't do anything with non-empty selections.
	  transposeChars: function (cm) { return runInOp(cm, function () {
	    var ranges = cm.listSelections(), newSel = [];
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) { continue }
	      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	      if (line) {
	        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	        if (cur.ch > 0) {
	          cur = new Pos(cur.line, cur.ch + 1);
	          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
	        } else if (cur.line > cm.doc.first) {
	          var prev = getLine(cm.doc, cur.line - 1).text;
	          if (prev) {
	            cur = new Pos(cur.line, 1);
	            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                            prev.charAt(prev.length - 1),
	                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	          }
	        }
	      }
	      newSel.push(new Range(cur, cur));
	    }
	    cm.setSelections(newSel);
	  }); },
	  newlineAndIndent: function (cm) { return runInOp(cm, function () {
	    var sels = cm.listSelections();
	    for (var i = sels.length - 1; i >= 0; i--)
	      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	    sels = cm.listSelections();
	    for (var i$1 = 0; i$1 < sels.length; i$1++)
	      { cm.indentLine(sels[i$1].from().line, null, true); }
	    ensureCursorVisible(cm);
	  }); },
	  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	};
	
	
	function lineStart(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLine(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, visual, lineN, 1)
	}
	function lineEnd(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLineEnd(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, line, lineN, -1)
	}
	function lineStartSmart(cm, pos) {
	  var start = lineStart(cm, pos.line);
	  var line = getLine(cm.doc, start.line);
	  var order = getOrder(line, cm.doc.direction);
	  if (!order || order[0].level == 0) {
	    var firstNonWS = Math.max(0, line.text.search(/\S/));
	    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	  }
	  return start
	}
	
	// Run a handler that was bound to a key.
	function doHandleBinding(cm, bound, dropShift) {
	  if (typeof bound == "string") {
	    bound = commands[bound];
	    if (!bound) { return false }
	  }
	  // Ensure previous input has been read, so that the handler sees a
	  // consistent view of the document
	  cm.display.input.ensurePolled();
	  var prevShift = cm.display.shift, done = false;
	  try {
	    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	    if (dropShift) { cm.display.shift = false; }
	    done = bound(cm) != Pass;
	  } finally {
	    cm.display.shift = prevShift;
	    cm.state.suppressEdits = false;
	  }
	  return done
	}
	
	function lookupKeyForEditor(cm, name, handle) {
	  for (var i = 0; i < cm.state.keyMaps.length; i++) {
	    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	    if (result) { return result }
	  }
	  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	    || lookupKey(name, cm.options.keyMap, handle, cm)
	}
	
	// Note that, despite the name, this function is also used to check
	// for bound mouse clicks.
	
	var stopSeq = new Delayed;
	function dispatchKey(cm, name, e, handle) {
	  var seq = cm.state.keySeq;
	  if (seq) {
	    if (isModifierKey(name)) { return "handled" }
	    stopSeq.set(50, function () {
	      if (cm.state.keySeq == seq) {
	        cm.state.keySeq = null;
	        cm.display.input.reset();
	      }
	    });
	    name = seq + " " + name;
	  }
	  var result = lookupKeyForEditor(cm, name, handle);
	
	  if (result == "multi")
	    { cm.state.keySeq = name; }
	  if (result == "handled")
	    { signalLater(cm, "keyHandled", cm, name, e); }
	
	  if (result == "handled" || result == "multi") {
	    e_preventDefault(e);
	    restartBlink(cm);
	  }
	
	  if (seq && !result && /\'$/.test(name)) {
	    e_preventDefault(e);
	    return true
	  }
	  return !!result
	}
	
	// Handle a key from the keydown event.
	function handleKeyBinding(cm, e) {
	  var name = keyName(e, true);
	  if (!name) { return false }
	
	  if (e.shiftKey && !cm.state.keySeq) {
	    // First try to resolve full name (including 'Shift-'). Failing
	    // that, see if there is a cursor-motion command (starting with
	    // 'go') bound to the keyname without 'Shift-'.
	    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	        || dispatchKey(cm, name, e, function (b) {
	             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	               { return doHandleBinding(cm, b) }
	           })
	  } else {
	    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	  }
	}
	
	// Handle a key from the keypress event
	function handleCharBinding(cm, e, ch) {
	  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	}
	
	var lastStoppedKey = null;
	function onKeyDown(e) {
	  var cm = this;
	  cm.curOp.focus = activeElt();
	  if (signalDOMEvent(cm, e)) { return }
	  // IE does strange things with escape.
	  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	  var code = e.keyCode;
	  cm.display.shift = code == 16 || e.shiftKey;
	  var handled = handleKeyBinding(cm, e);
	  if (presto) {
	    lastStoppedKey = handled ? code : null;
	    // Opera has no cut event... we try to at least catch the key combo
	    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	      { cm.replaceSelection("", null, "cut"); }
	  }
	
	  // Turn mouse into crosshair when Alt is held on Mac.
	  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	    { showCrossHair(cm); }
	}
	
	function showCrossHair(cm) {
	  var lineDiv = cm.display.lineDiv;
	  addClass(lineDiv, "CodeMirror-crosshair");
	
	  function up(e) {
	    if (e.keyCode == 18 || !e.altKey) {
	      rmClass(lineDiv, "CodeMirror-crosshair");
	      off(document, "keyup", up);
	      off(document, "mouseover", up);
	    }
	  }
	  on(document, "keyup", up);
	  on(document, "mouseover", up);
	}
	
	function onKeyUp(e) {
	  if (e.keyCode == 16) { this.doc.sel.shift = false; }
	  signalDOMEvent(this, e);
	}
	
	function onKeyPress(e) {
	  var cm = this;
	  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	  var keyCode = e.keyCode, charCode = e.charCode;
	  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	  // Some browsers fire keypress events for backspace
	  if (ch == "\x08") { return }
	  if (handleCharBinding(cm, e, ch)) { return }
	  cm.display.input.onKeyPress(e);
	}
	
	var DOUBLECLICK_DELAY = 400;
	
	var PastClick = function(time, pos, button) {
	  this.time = time;
	  this.pos = pos;
	  this.button = button;
	};
	
	PastClick.prototype.compare = function (time, pos, button) {
	  return this.time + DOUBLECLICK_DELAY > time &&
	    cmp(pos, this.pos) == 0 && button == this.button
	};
	
	var lastClick;
	var lastDoubleClick;
	function clickRepeat(pos, button) {
	  var now = +new Date;
	  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	    lastClick = lastDoubleClick = null;
	    return "triple"
	  } else if (lastClick && lastClick.compare(now, pos, button)) {
	    lastDoubleClick = new PastClick(now, pos, button);
	    lastClick = null;
	    return "double"
	  } else {
	    lastClick = new PastClick(now, pos, button);
	    lastDoubleClick = null;
	    return "single"
	  }
	}
	
	// A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e) {
	  var cm = this, display = cm.display;
	  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	  display.input.ensurePolled();
	  display.shift = e.shiftKey;
	
	  if (eventInWidget(display, e)) {
	    if (!webkit) {
	      // Briefly turn off draggability, to allow widgets to do
	      // normal dragging things.
	      display.scroller.draggable = false;
	      setTimeout(function () { return display.scroller.draggable = true; }, 100);
	    }
	    return
	  }
	  if (clickInGutter(cm, e)) { return }
	  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
	  window.focus();
	
	  // #3261: make sure, that we're not starting a second selection
	  if (button == 1 && cm.state.selectingText)
	    { cm.state.selectingText(e); }
	
	  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }
	
	  if (button == 1) {
	    if (pos) { leftButtonDown(cm, pos, repeat, e); }
	    else if (e_target(e) == display.scroller) { e_preventDefault(e); }
	  } else if (button == 2) {
	    if (pos) { extendSelection(cm.doc, pos); }
	    setTimeout(function () { return display.input.focus(); }, 20);
	  } else if (button == 3) {
	    if (captureRightClick) { onContextMenu(cm, e); }
	    else { delayBlurEvent(cm); }
	  }
	}
	
	function handleMappedButton(cm, button, pos, repeat, event) {
	  var name = "Click";
	  if (repeat == "double") { name = "Double" + name; }
	  else if (repeat == "triple") { name = "Triple" + name; }
	  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
	
	  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
	    if (typeof bound == "string") { bound = commands[bound]; }
	    if (!bound) { return false }
	    var done = false;
	    try {
	      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	      done = bound(cm, pos) != Pass;
	    } finally {
	      cm.state.suppressEdits = false;
	    }
	    return done
	  })
	}
	
	function configureMouse(cm, repeat, event) {
	  var option = cm.getOption("configureMouse");
	  var value = option ? option(cm, repeat, event) : {};
	  if (value.unit == null) {
	    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	  }
	  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
	  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
	  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
	  return value
	}
	
	function leftButtonDown(cm, pos, repeat, event) {
	  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	  else { cm.curOp.focus = activeElt(); }
	
	  var behavior = configureMouse(cm, repeat, event);
	
	  var sel = cm.doc.sel, contained;
	  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
	      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
	      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
	    { leftButtonStartDrag(cm, event, pos, behavior); }
	  else
	    { leftButtonSelect(cm, event, pos, behavior); }
	}
	
	// Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm, event, pos, behavior) {
	  var display = cm.display, moved = false;
	  var dragEnd = operation(cm, function (e) {
	    if (webkit) { display.scroller.draggable = false; }
	    cm.state.draggingText = false;
	    off(document, "mouseup", dragEnd);
	    off(document, "mousemove", mouseMove);
	    off(display.scroller, "dragstart", dragStart);
	    off(display.scroller, "drop", dragEnd);
	    if (!moved) {
	      e_preventDefault(e);
	      if (!behavior.addNew)
	        { extendSelection(cm.doc, pos, null, null, behavior.extend); }
	      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	      if (webkit || ie && ie_version == 9)
	        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }
	      else
	        { display.input.focus(); }
	    }
	  });
	  var mouseMove = function(e2) {
	    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	  };
	  var dragStart = function () { return moved = true; };
	  // Let the drag handler handle this.
	  if (webkit) { display.scroller.draggable = true; }
	  cm.state.draggingText = dragEnd;
	  dragEnd.copy = !behavior.moveOnDrag;
	  // IE's approach to draggable
	  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	  on(document, "mouseup", dragEnd);
	  on(document, "mousemove", mouseMove);
	  on(display.scroller, "dragstart", dragStart);
	  on(display.scroller, "drop", dragEnd);
	
	  delayBlurEvent(cm);
	  setTimeout(function () { return display.input.focus(); }, 20);
	}
	
	function rangeForUnit(cm, pos, unit) {
	  if (unit == "char") { return new Range(pos, pos) }
	  if (unit == "word") { return cm.findWordAt(pos) }
	  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	  var result = unit(cm, pos);
	  return new Range(result.from, result.to)
	}
	
	// Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm, event, start, behavior) {
	  var display = cm.display, doc = cm.doc;
	  e_preventDefault(event);
	
	  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	  if (behavior.addNew && !behavior.extend) {
	    ourIndex = doc.sel.contains(start);
	    if (ourIndex > -1)
	      { ourRange = ranges[ourIndex]; }
	    else
	      { ourRange = new Range(start, start); }
	  } else {
	    ourRange = doc.sel.primary();
	    ourIndex = doc.sel.primIndex;
	  }
	
	  if (behavior.unit == "rectangle") {
	    if (!behavior.addNew) { ourRange = new Range(start, start); }
	    start = posFromMouse(cm, event, true, true);
	    ourIndex = -1;
	  } else {
	    var range$$1 = rangeForUnit(cm, start, behavior.unit);
	    if (behavior.extend)
	      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
	    else
	      { ourRange = range$$1; }
	  }
	
	  if (!behavior.addNew) {
	    ourIndex = 0;
	    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	    startSel = doc.sel;
	  } else if (ourIndex == -1) {
	    ourIndex = ranges.length;
	    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                 {scroll: false, origin: "*mouse"});
	  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                 {scroll: false, origin: "*mouse"});
	    startSel = doc.sel;
	  } else {
	    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	  }
	
	  var lastPos = start;
	  function extendTo(pos) {
	    if (cmp(lastPos, pos) == 0) { return }
	    lastPos = pos;
	
	    if (behavior.unit == "rectangle") {
	      var ranges = [], tabSize = cm.options.tabSize;
	      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	           line <= end; line++) {
	        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	        if (left == right)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	        else if (text.length > leftPos)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	      }
	      if (!ranges.length) { ranges.push(new Range(start, start)); }
	      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                   {origin: "*mouse", scroll: false});
	      cm.scrollIntoView(pos);
	    } else {
	      var oldRange = ourRange;
	      var range$$1 = rangeForUnit(cm, pos, behavior.unit);
	      var anchor = oldRange.anchor, head;
	      if (cmp(range$$1.anchor, anchor) > 0) {
	        head = range$$1.head;
	        anchor = minPos(oldRange.from(), range$$1.anchor);
	      } else {
	        head = range$$1.anchor;
	        anchor = maxPos(oldRange.to(), range$$1.head);
	      }
	      var ranges$1 = startSel.ranges.slice(0);
	      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
	    }
	  }
	
	  var editorSize = display.wrapper.getBoundingClientRect();
	  // Used to ensure timeout re-tries don't fire when another extend
	  // happened in the meantime (clearTimeout isn't reliable -- at
	  // least on Chrome, the timeouts still happen even when cleared,
	  // if the clear happens after their scheduled firing time).
	  var counter = 0;
	
	  function extend(e) {
	    var curCount = ++counter;
	    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
	    if (!cur) { return }
	    if (cmp(cur, lastPos) != 0) {
	      cm.curOp.focus = activeElt();
	      extendTo(cur);
	      var visible = visibleLines(display, doc);
	      if (cur.line >= visible.to || cur.line < visible.from)
	        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	    } else {
	      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	      if (outside) { setTimeout(operation(cm, function () {
	        if (counter != curCount) { return }
	        display.scroller.scrollTop += outside;
	        extend(e);
	      }), 50); }
	    }
	  }
	
	  function done(e) {
	    cm.state.selectingText = false;
	    counter = Infinity;
	    e_preventDefault(e);
	    display.input.focus();
	    off(document, "mousemove", move);
	    off(document, "mouseup", up);
	    doc.history.lastSelOrigin = null;
	  }
	
	  var move = operation(cm, function (e) {
	    if (!e_button(e)) { done(e); }
	    else { extend(e); }
	  });
	  var up = operation(cm, done);
	  cm.state.selectingText = up;
	  on(document, "mousemove", move);
	  on(document, "mouseup", up);
	}
	
	// Used when mouse-selecting to adjust the anchor to the proper side
	// of a bidi jump depending on the visual position of the head.
	function bidiSimplify(cm, range$$1) {
	  var anchor = range$$1.anchor;
	  var head = range$$1.head;
	  var anchorLine = getLine(cm.doc, anchor.line);
	  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
	  var order = getOrder(anchorLine);
	  if (!order) { return range$$1 }
	  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
	  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
	  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
	  if (boundary == 0 || boundary == order.length) { return range$$1 }
	
	  // Compute the relative visual position of the head compared to the
	  // anchor (<0 is to the left, >0 to the right)
	  var leftSide;
	  if (head.line != anchor.line) {
	    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	  } else {
	    var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
	    if (headIndex == boundary - 1 || headIndex == boundary)
	      { leftSide = dir < 0; }
	    else
	      { leftSide = dir > 0; }
	  }
	
	  var usePart = order[boundary + (leftSide ? -1 : 0)];
	  var from = leftSide == (usePart.level == 1);
	  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
	  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
	}
	
	
	// Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm, e, type, prevent) {
	  var mX, mY;
	  if (e.touches) {
	    mX = e.touches[0].clientX;
	    mY = e.touches[0].clientY;
	  } else {
	    try { mX = e.clientX; mY = e.clientY; }
	    catch(e) { return false }
	  }
	  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	  if (prevent) { e_preventDefault(e); }
	
	  var display = cm.display;
	  var lineBox = display.lineDiv.getBoundingClientRect();
	
	  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	  mY -= lineBox.top - display.viewOffset;
	
	  for (var i = 0; i < cm.options.gutters.length; ++i) {
	    var g = display.gutters.childNodes[i];
	    if (g && g.getBoundingClientRect().right >= mX) {
	      var line = lineAtHeight(cm.doc, mY);
	      var gutter = cm.options.gutters[i];
	      signal(cm, type, cm, line, gutter, e);
	      return e_defaultPrevented(e)
	    }
	  }
	}
	
	function clickInGutter(cm, e) {
	  return gutterEvent(cm, e, "gutterClick", true)
	}
	
	// CONTEXT MENU HANDLING
	
	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm, e) {
	  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	  if (signalDOMEvent(cm, e, "contextmenu")) { return }
	  cm.display.input.onContextMenu(e);
	}
	
	function contextMenuInGutter(cm, e) {
	  if (!hasHandler(cm, "gutterContextMenu")) { return false }
	  return gutterEvent(cm, e, "gutterContextMenu", false)
	}
	
	function themeChanged(cm) {
	  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	  clearCaches(cm);
	}
	
	var Init = {toString: function(){return "CodeMirror.Init"}};
	
	var defaults = {};
	var optionHandlers = {};
	
	function defineOptions(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;
	
	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) { optionHandlers[name] =
	      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	  }
	
	  CodeMirror.defineOption = option;
	
	  // Passed to option handlers when there is no old value.
	  CodeMirror.Init = Init;
	
	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	  option("mode", null, function (cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);
	
	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function (cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("lineSeparator", null, function (cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) { return }
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function (line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) { break }
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	  });
	  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != Init) { cm.refresh(); }
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	  }, true);
	  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);
	
	  option("theme", "default", function (cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function (cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != Init && getKeyMap(old);
	    if (prev && prev.detach) { prev.detach(cm, next); }
	    if (next.attach) { next.attach(cm, prev || null); }
	  });
	  option("extraKeys", null);
	  option("configureMouse", null);
	
	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function (cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	  option("scrollbarStyle", "native", function (cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);
	
	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);
	  option("pasteLinesPerSelection", true);
	
	  option("readOnly", false, function (cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	    }
	    cm.display.input.readOnlyChanged(val);
	  });
	  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);
	
	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function (cm, val) {
	    if (!val) { cm.display.input.resetPosition(); }
	  });
	
	  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	  option("autofocus", null);
	  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	}
	
	function guttersChanged(cm) {
	  updateGutters(cm);
	  regChange(cm);
	  alignHorizontally(cm);
	}
	
	function dragDropChanged(cm, value, old) {
	  var wasOn = old && old != Init;
	  if (!value != !wasOn) {
	    var funcs = cm.display.dragFunctions;
	    var toggle = value ? on : off;
	    toggle(cm.display.scroller, "dragstart", funcs.start);
	    toggle(cm.display.scroller, "dragenter", funcs.enter);
	    toggle(cm.display.scroller, "dragover", funcs.over);
	    toggle(cm.display.scroller, "dragleave", funcs.leave);
	    toggle(cm.display.scroller, "drop", funcs.drop);
	  }
	}
	
	function wrappingChanged(cm) {
	  if (cm.options.lineWrapping) {
	    addClass(cm.display.wrapper, "CodeMirror-wrap");
	    cm.display.sizer.style.minWidth = "";
	    cm.display.sizerWidth = null;
	  } else {
	    rmClass(cm.display.wrapper, "CodeMirror-wrap");
	    findMaxLine(cm);
	  }
	  estimateLineHeights(cm);
	  regChange(cm);
	  clearCaches(cm);
	  setTimeout(function () { return updateScrollbars(cm); }, 100);
	}
	
	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.
	
	function CodeMirror$1(place, options) {
	  var this$1 = this;
	
	  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }
	
	  this.options = options = options ? copyObj(options) : {};
	  // Determine effective options based on given values and defaults.
	  copyObj(defaults, options, false);
	  setGuttersForLineNumbers(options);
	
	  var doc = options.value;
	  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	  this.doc = doc;
	
	  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
	  var display = this.display = new Display(place, doc, input);
	  display.wrapper.CodeMirror = this;
	  updateGutters(this);
	  themeChanged(this);
	  if (options.lineWrapping)
	    { this.display.wrapper.className += " CodeMirror-wrap"; }
	  initScrollbars(this);
	
	  this.state = {
	    keyMaps: [],  // stores maps added by addKeyMap
	    overlays: [], // highlighting overlays, as added by addOverlay
	    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	    overwrite: false,
	    delayingBlurEvent: false,
	    focused: false,
	    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	    selectingText: false,
	    draggingText: false,
	    highlight: new Delayed(), // stores highlight worker timeout
	    keySeq: null,  // Unfinished key sequence
	    specialChars: null
	  };
	
	  if (options.autofocus && !mobile) { display.input.focus(); }
	
	  // Override magic textarea content restore that IE sometimes does
	  // on our hidden textarea on reload
	  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }
	
	  registerEventHandlers(this);
	  ensureGlobalHandlers();
	
	  startOperation(this);
	  this.curOp.forceUpdate = true;
	  attachDoc(this, doc);
	
	  if ((options.autofocus && !mobile) || this.hasFocus())
	    { setTimeout(bind(onFocus, this), 20); }
	  else
	    { onBlur(this); }
	
	  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	    { optionHandlers[opt](this$1, options[opt], Init); } }
	  maybeUpdateLineNumberWidth(this);
	  if (options.finishInit) { options.finishInit(this); }
	  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
	  endOperation(this);
	  // Suppress optimizelegibility in Webkit, since it breaks text
	  // measuring on line wrapping boundaries.
	  if (webkit && options.lineWrapping &&
	      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	    { display.lineDiv.style.textRendering = "auto"; }
	}
	
	// The default configuration options.
	CodeMirror$1.defaults = defaults;
	// Functions to run when options are changed.
	CodeMirror$1.optionHandlers = optionHandlers;
	
	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm) {
	  var d = cm.display;
	  on(d.scroller, "mousedown", operation(cm, onMouseDown));
	  // Older IE's will not fire a second mousedown for a double click
	  if (ie && ie_version < 11)
	    { on(d.scroller, "dblclick", operation(cm, function (e) {
	      if (signalDOMEvent(cm, e)) { return }
	      var pos = posFromMouse(cm, e);
	      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	      e_preventDefault(e);
	      var word = cm.findWordAt(pos);
	      extendSelection(cm.doc, word.anchor, word.head);
	    })); }
	  else
	    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	  // Some browsers fire contextmenu *after* opening the menu, at
	  // which point we can't mess with it anymore. Context menu is
	  // handled in onMouseDown for these browsers.
	  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }
	
	  // Used to suppress mouse event handling when a touch happens
	  var touchFinished, prevTouch = {end: 0};
	  function finishTouch() {
	    if (d.activeTouch) {
	      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	      prevTouch = d.activeTouch;
	      prevTouch.end = +new Date;
	    }
	  }
	  function isMouseLikeTouchEvent(e) {
	    if (e.touches.length != 1) { return false }
	    var touch = e.touches[0];
	    return touch.radiusX <= 1 && touch.radiusY <= 1
	  }
	  function farAway(touch, other) {
	    if (other.left == null) { return true }
	    var dx = other.left - touch.left, dy = other.top - touch.top;
	    return dx * dx + dy * dy > 20 * 20
	  }
	  on(d.scroller, "touchstart", function (e) {
	    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	      d.input.ensurePolled();
	      clearTimeout(touchFinished);
	      var now = +new Date;
	      d.activeTouch = {start: now, moved: false,
	                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
	      if (e.touches.length == 1) {
	        d.activeTouch.left = e.touches[0].pageX;
	        d.activeTouch.top = e.touches[0].pageY;
	      }
	    }
	  });
	  on(d.scroller, "touchmove", function () {
	    if (d.activeTouch) { d.activeTouch.moved = true; }
	  });
	  on(d.scroller, "touchend", function (e) {
	    var touch = d.activeTouch;
	    if (touch && !eventInWidget(d, e) && touch.left != null &&
	        !touch.moved && new Date - touch.start < 300) {
	      var pos = cm.coordsChar(d.activeTouch, "page"), range;
	      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	        { range = new Range(pos, pos); }
	      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	        { range = cm.findWordAt(pos); }
	      else // Triple tap
	        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	      cm.setSelection(range.anchor, range.head);
	      cm.focus();
	      e_preventDefault(e);
	    }
	    finishTouch();
	  });
	  on(d.scroller, "touchcancel", finishTouch);
	
	  // Sync scrolling between fake scrollbars and real scrollable
	  // area, ensure viewport is updated when scrolling.
	  on(d.scroller, "scroll", function () {
	    if (d.scroller.clientHeight) {
	      updateScrollTop(cm, d.scroller.scrollTop);
	      setScrollLeft(cm, d.scroller.scrollLeft, true);
	      signal(cm, "scroll", cm);
	    }
	  });
	
	  // Listen to wheel events in order to try and update the viewport on time.
	  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });
	
	  // Prevent wrapper from ever scrolling
	  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });
	
	  d.dragFunctions = {
	    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	    start: function (e) { return onDragStart(cm, e); },
	    drop: operation(cm, onDrop),
	    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	  };
	
	  var inp = d.input.getField();
	  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	  on(inp, "keydown", operation(cm, onKeyDown));
	  on(inp, "keypress", operation(cm, onKeyPress));
	  on(inp, "focus", function (e) { return onFocus(cm, e); });
	  on(inp, "blur", function (e) { return onBlur(cm, e); });
	}
	
	var initHooks = [];
	CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };
	
	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm, n, how, aggressive) {
	  var doc = cm.doc, state;
	  if (how == null) { how = "add"; }
	  if (how == "smart") {
	    // Fall back to "prev" when the mode doesn't have an indentation
	    // method.
	    if (!doc.mode.indent) { how = "prev"; }
	    else { state = getContextBefore(cm, n).state; }
	  }
	
	  var tabSize = cm.options.tabSize;
	  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	  if (line.stateAfter) { line.stateAfter = null; }
	  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	  if (!aggressive && !/\S/.test(line.text)) {
	    indentation = 0;
	    how = "not";
	  } else if (how == "smart") {
	    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	    if (indentation == Pass || indentation > 150) {
	      if (!aggressive) { return }
	      how = "prev";
	    }
	  }
	  if (how == "prev") {
	    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	    else { indentation = 0; }
	  } else if (how == "add") {
	    indentation = curSpace + cm.options.indentUnit;
	  } else if (how == "subtract") {
	    indentation = curSpace - cm.options.indentUnit;
	  } else if (typeof how == "number") {
	    indentation = curSpace + how;
	  }
	  indentation = Math.max(0, indentation);
	
	  var indentString = "", pos = 0;
	  if (cm.options.indentWithTabs)
	    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	  if (pos < indentation) { indentString += spaceStr(indentation - pos); }
	
	  if (indentString != curSpaceString) {
	    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	    line.stateAfter = null;
	    return true
	  } else {
	    // Ensure that, if the cursor was in the whitespace at the start
	    // of the line, it is moved to the end of that space.
	    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	      var range = doc.sel.ranges[i$1];
	      if (range.head.line == n && range.head.ch < curSpaceString.length) {
	        var pos$1 = Pos(n, curSpaceString.length);
	        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	        break
	      }
	    }
	  }
	}
	
	// This will be set to a {lineWise: bool, text: [string]} object, so
	// that, when pasting, we know what kind of selections the copied
	// text was made out of.
	var lastCopied = null;
	
	function setLastCopied(newLastCopied) {
	  lastCopied = newLastCopied;
	}
	
	function applyTextInput(cm, inserted, deleted, sel, origin) {
	  var doc = cm.doc;
	  cm.display.shift = false;
	  if (!sel) { sel = doc.sel; }
	
	  var paste = cm.state.pasteIncoming || origin == "paste";
	  var textLines = splitLinesAuto(inserted), multiPaste = null;
	  // When pasing N lines into N selections, insert one line per selection
	  if (paste && sel.ranges.length > 1) {
	    if (lastCopied && lastCopied.text.join("\n") == inserted) {
	      if (sel.ranges.length % lastCopied.text.length == 0) {
	        multiPaste = [];
	        for (var i = 0; i < lastCopied.text.length; i++)
	          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	      }
	    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	      multiPaste = map(textLines, function (l) { return [l]; });
	    }
	  }
	
	  var updateInput;
	  // Normal behavior is to insert the new text into every selection
	  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	    var range$$1 = sel.ranges[i$1];
	    var from = range$$1.from(), to = range$$1.to();
	    if (range$$1.empty()) {
	      if (deleted && deleted > 0) // Handle deletion
	        { from = Pos(from.line, from.ch - deleted); }
	      else if (cm.state.overwrite && !paste) // Handle overwrite
	        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	        { from = to = Pos(from.line, 0); }
	    }
	    updateInput = cm.curOp.updateInput;
	    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	    makeChange(cm.doc, changeEvent);
	    signalLater(cm, "inputRead", cm, changeEvent);
	  }
	  if (inserted && !paste)
	    { triggerElectric(cm, inserted); }
	
	  ensureCursorVisible(cm);
	  cm.curOp.updateInput = updateInput;
	  cm.curOp.typing = true;
	  cm.state.pasteIncoming = cm.state.cutIncoming = false;
	}
	
	function handlePaste(e, cm) {
	  var pasted = e.clipboardData && e.clipboardData.getData("Text");
	  if (pasted) {
	    e.preventDefault();
	    if (!cm.isReadOnly() && !cm.options.disableInput)
	      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	    return true
	  }
	}
	
	function triggerElectric(cm, inserted) {
	  // When an 'electric' character is inserted, immediately trigger a reindent
	  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	  var sel = cm.doc.sel;
	
	  for (var i = sel.ranges.length - 1; i >= 0; i--) {
	    var range$$1 = sel.ranges[i];
	    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
	    var mode = cm.getModeAt(range$$1.head);
	    var indented = false;
	    if (mode.electricChars) {
	      for (var j = 0; j < mode.electricChars.length; j++)
	        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	          indented = indentLine(cm, range$$1.head.line, "smart");
	          break
	        } }
	    } else if (mode.electricInput) {
	      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
	        { indented = indentLine(cm, range$$1.head.line, "smart"); }
	    }
	    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
	  }
	}
	
	function copyableRanges(cm) {
	  var text = [], ranges = [];
	  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	    var line = cm.doc.sel.ranges[i].head.line;
	    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	    ranges.push(lineRange);
	    text.push(cm.getRange(lineRange.anchor, lineRange.head));
	  }
	  return {text: text, ranges: ranges}
	}
	
	function disableBrowserMagic(field, spellcheck) {
	  field.setAttribute("autocorrect", "off");
	  field.setAttribute("autocapitalize", "off");
	  field.setAttribute("spellcheck", !!spellcheck);
	}
	
	function hiddenTextarea() {
	  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	  // The textarea is kept positioned near the cursor to prevent the
	  // fact that it'll be scrolled into view on input from scrolling
	  // our fake cursor out of view. On webkit, when wrap=off, paste is
	  // very slow. So make the area wide instead.
	  if (webkit) { te.style.width = "1000px"; }
	  else { te.setAttribute("wrap", "off"); }
	  // If border: 0; -- iOS fails to open keyboard (issue #1287)
	  if (ios) { te.style.border = "1px solid black"; }
	  disableBrowserMagic(te);
	  return div
	}
	
	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.
	
	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.
	
	var addEditorMethods = function(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;
	
	  var helpers = CodeMirror.helpers = {};
	
	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},
	
	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") { return }
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        { operation(this, optionHandlers[option])(this, value, old); }
	      signal(this, "optionChange", this, option);
	    },
	
	    getOption: function(option) {return this.options[option]},
	    getDoc: function() {return this.doc},
	
	    addKeyMap: function(map$$1, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
	    },
	    removeKeyMap: function(map$$1) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
	          maps.splice(i, 1);
	          return true
	        } }
	    },
	
	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function (overlay) { return overlay.priority; });
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var this$1 = this;
	
	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this$1.state.modeGen++;
	          regChange(this$1);
	          return
	        }
	      }
	    }),
	
	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	        else { dir = dir ? "add" : "subtract"; }
	      }
	      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	    }),
	    indentSelection: methodOp(function(how) {
	      var this$1 = this;
	
	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range$$1 = ranges[i];
	        if (!range$$1.empty()) {
	          var from = range$$1.from(), to = range$$1.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            { indentLine(this$1, j, how); }
	          var newRanges = this$1.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	        } else if (range$$1.head.line > end) {
	          indentLine(this$1, range$$1.head.line, how, true);
	          end = range$$1.head.line;
	          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
	        }
	      }
	    }),
	
	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise)
	    },
	
	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true)
	    },
	
	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) { type = styles[2]; }
	      else { for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	        else { type = styles[mid * 2 + 2]; break }
	      } }
	      var cut = type ? type.indexOf("overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	    },
	
	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) { return mode }
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	    },
	
	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0]
	    },
	
	    getHelpers: function(pos, type) {
	      var this$1 = this;
	
	      var found = [];
	      if (!helpers.hasOwnProperty(type)) { return found }
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) { found.push(help[mode[type]]); }
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) { found.push(val); }
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	        var cur = help._global[i$1];
	        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
	          { found.push(cur.val); }
	      }
	      return found
	    },
	
	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getContextBefore(this, line + 1, precise).state
	    },
	
	    cursorCoords: function(start, mode) {
	      var pos, range$$1 = this.doc.sel.primary();
	      if (start == null) { pos = range$$1.head; }
	      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	      else { pos = start ? range$$1.from() : range$$1.to(); }
	      return cursorCoords(this, pos, mode || "page")
	    },
	
	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page")
	    },
	
	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top)
	    },
	
	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset)
	    },
	    heightAtLine: function(line, mode, includeWidgets) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) { line = this.doc.first; }
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0)
	    },
	
	    defaultTextHeight: function() { return textHeight(this.display) },
	    defaultCharWidth: function() { return charWidth(this.display) },
	
	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
	
	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          { top = pos.top - node.offsetHeight; }
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          { top = pos.bottom; }
	        if (left + node.offsetWidth > hspace)
	          { left = hspace - node.offsetWidth; }
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") { left = 0; }
	        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	    },
	
	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,
	    triggerOnMouseDown: methodOp(onMouseDown),
	
	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        { return commands[cmd].call(null, this) }
	    },
	
	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),
	
	    findPosH: function(from, amount, unit, visually) {
	      var this$1 = this;
	
	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        cur = findPosH(this$1.doc, cur, dir, unit, visually);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },
	
	    moveH: methodOp(function(dir, unit) {
	      var this$1 = this;
	
	      this.extendSelectionsBy(function (range$$1) {
	        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
	          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
	        else
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	      }, sel_move);
	    }),
	
	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        { doc.replaceSelection("", null, "+delete"); }
	      else
	        { deleteNearSelection(this, function (range$$1) {
	          var other = findPosH(doc, range$$1.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
	        }); }
	    }),
	
	    findPosV: function(from, amount, unit, goalColumn) {
	      var this$1 = this;
	
	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        var coords = cursorCoords(this$1, cur, "div");
	        if (x == null) { x = coords.left; }
	        else { coords.left = x; }
	        cur = findPosV(this$1, coords, dir, unit);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },
	
	    moveV: methodOp(function(dir, unit) {
	      var this$1 = this;
	
	      var doc = this.doc, goals = [];
	      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function (range$$1) {
	        if (collapse)
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	        var headPos = cursorCoords(this$1, range$$1.head, "div");
	        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
	        goals.push(headPos.left);
	        var pos = findPosV(this$1, headPos, dir, unit);
	        if (unit == "page" && range$$1 == doc.sel.primary())
	          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
	        return pos
	      }, sel_move);
	      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	        { doc.sel.ranges[i].goalColumn = goals[i]; } }
	    }),
	
	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function (ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	        while (start > 0 && check(line.charAt(start - 1))) { --start; }
	        while (end < line.length && check(line.charAt(end))) { ++end; }
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end))
	    },
	
	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) { return }
	      if (this.state.overwrite = !this.state.overwrite)
	        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	      else
	        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	
	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt() },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
	
	    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	    },
	
	    scrollIntoView: methodOp(function(range$$1, margin) {
	      if (range$$1 == null) {
	        range$$1 = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) { margin = this.options.cursorScrollMargin; }
	      } else if (typeof range$$1 == "number") {
	        range$$1 = {from: Pos(range$$1, 0), to: null};
	      } else if (range$$1.from == null) {
	        range$$1 = {from: range$$1, to: null};
	      }
	      if (!range$$1.to) { range$$1.to = range$$1.from; }
	      range$$1.margin = margin || 0;
	
	      if (range$$1.from.line != null) {
	        scrollToRange(this, range$$1);
	      } else {
	        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
	      }
	    }),
	
	    setSize: methodOp(function(width, height) {
	      var this$1 = this;
	
	      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	      if (width != null) { this.display.wrapper.style.width = interpret(width); }
	      if (height != null) { this.display.wrapper.style.height = interpret(height); }
	      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	      var lineNo$$1 = this.display.viewFrom;
	      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
	        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
	        ++lineNo$$1;
	      });
	      this.curOp.forceUpdate = true;
	      signal(this, "refresh", this);
	    }),
	
	    operation: function(f){return runInOp(this, f)},
	    startOperation: function(){return startOperation(this)},
	    endOperation: function(){return endOperation(this)},
	
	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        { estimateLineHeights(this); }
	      signal(this, "refresh", this);
	    }),
	
	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old
	    }),
	
	    getInputField: function(){return this.display.input.getField()},
	    getWrapperElement: function(){return this.display.wrapper},
	    getScrollerElement: function(){return this.display.scroller},
	    getGutterElement: function(){return this.display.gutters}
	  };
	  eventMixin(CodeMirror);
	
	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };
	};
	
	// Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc, pos, dir, unit, visually) {
	  var oldPos = pos;
	  var origDir = dir;
	  var lineObj = getLine(doc, pos.line);
	  function findNextLine() {
	    var l = pos.line + dir;
	    if (l < doc.first || l >= doc.first + doc.size) { return false }
	    pos = new Pos(l, pos.ch, pos.sticky);
	    return lineObj = getLine(doc, l)
	  }
	  function moveOnce(boundToLine) {
	    var next;
	    if (visually) {
	      next = moveVisually(doc.cm, lineObj, pos, dir);
	    } else {
	      next = moveLogically(lineObj, pos, dir);
	    }
	    if (next == null) {
	      if (!boundToLine && findNextLine())
	        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
	      else
	        { return false }
	    } else {
	      pos = next;
	    }
	    return true
	  }
	
	  if (unit == "char") {
	    moveOnce();
	  } else if (unit == "column") {
	    moveOnce(true);
	  } else if (unit == "word" || unit == "group") {
	    var sawType = null, group = unit == "group";
	    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	    for (var first = true;; first = false) {
	      if (dir < 0 && !moveOnce(!first)) { break }
	      var cur = lineObj.text.charAt(pos.ch) || "\n";
	      var type = isWordChar(cur, helper) ? "w"
	        : group && cur == "\n" ? "n"
	        : !group || /\s/.test(cur) ? null
	        : "p";
	      if (group && !first && !type) { type = "s"; }
	      if (sawType && sawType != type) {
	        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	        break
	      }
	
	      if (type) { sawType = type; }
	      if (dir > 0 && !moveOnce(!first)) { break }
	    }
	  }
	  var result = skipAtomic(doc, pos, oldPos, origDir, true);
	  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	  return result
	}
	
	// For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm, pos, dir, unit) {
	  var doc = cm.doc, x = pos.left, y;
	  if (unit == "page") {
	    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
	
	  } else if (unit == "line") {
	    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	  }
	  var target;
	  for (;;) {
	    target = coordsChar(cm, x, y);
	    if (!target.outside) { break }
	    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	    y += dir * 5;
	  }
	  return target
	}
	
	// CONTENTEDITABLE INPUT STYLE
	
	var ContentEditableInput = function(cm) {
	  this.cm = cm;
	  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	  this.polling = new Delayed();
	  this.composing = null;
	  this.gracePeriod = false;
	  this.readDOMTimeout = null;
	};
	
	ContentEditableInput.prototype.init = function (display) {
	    var this$1 = this;
	
	  var input = this, cm = input.cm;
	  var div = input.div = display.lineDiv;
	  disableBrowserMagic(div, cm.options.spellcheck);
	
	  on(div, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	  });
	
	  on(div, "compositionstart", function (e) {
	    this$1.composing = {data: e.data, done: false};
	  });
	  on(div, "compositionupdate", function (e) {
	    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	  });
	  on(div, "compositionend", function (e) {
	    if (this$1.composing) {
	      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	      this$1.composing.done = true;
	    }
	  });
	
	  on(div, "touchstart", function () { return input.forceCompositionEnd(); });
	
	  on(div, "input", function () {
	    if (!this$1.composing) { this$1.readFromDOMSoon(); }
	  });
	
	  function onCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.operation(function () {
	          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	          cm.replaceSelection("", null, "cut");
	        });
	      }
	    }
	    if (e.clipboardData) {
	      e.clipboardData.clearData();
	      var content = lastCopied.text.join("\n");
	      // iOS exposes the clipboard API, but seems to discard content inserted into it
	      e.clipboardData.setData("Text", content);
	      if (e.clipboardData.getData("Text") == content) {
	        e.preventDefault();
	        return
	      }
	    }
	    // Old-fashioned briefly-focus-a-textarea hack
	    var kludge = hiddenTextarea(), te = kludge.firstChild;
	    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	    te.value = lastCopied.text.join("\n");
	    var hadFocus = document.activeElement;
	    selectInput(te);
	    setTimeout(function () {
	      cm.display.lineSpace.removeChild(kludge);
	      hadFocus.focus();
	      if (hadFocus == div) { input.showPrimarySelection(); }
	    }, 50);
	  }
	  on(div, "copy", onCopyCut);
	  on(div, "cut", onCopyCut);
	};
	
	ContentEditableInput.prototype.prepareSelection = function () {
	  var result = prepareSelection(this.cm, false);
	  result.focus = this.cm.state.focused;
	  return result
	};
	
	ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	  if (!info || !this.cm.display.view.length) { return }
	  if (info.focus || takeFocus) { this.showPrimarySelection(); }
	  this.showMultipleSelections(info);
	};
	
	ContentEditableInput.prototype.showPrimarySelection = function () {
	  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
	  var from = prim.from(), to = prim.to();
	
	  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	    sel.removeAllRanges();
	    return
	  }
	
	  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	      cmp(minPos(curAnchor, curFocus), from) == 0 &&
	      cmp(maxPos(curAnchor, curFocus), to) == 0)
	    { return }
	
	  var view = cm.display.view;
	  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
	      {node: view[0].measure.map[2], offset: 0};
	  var end = to.line < cm.display.viewTo && posToDOM(cm, to);
	  if (!end) {
	    var measure = view[view.length - 1].measure;
	    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
	  }
	
	  if (!start || !end) {
	    sel.removeAllRanges();
	    return
	  }
	
	  var old = sel.rangeCount && sel.getRangeAt(0), rng;
	  try { rng = range(start.node, start.offset, end.offset, end.node); }
	  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	  if (rng) {
	    if (!gecko && cm.state.focused) {
	      sel.collapse(start.node, start.offset);
	      if (!rng.collapsed) {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	    } else {
	      sel.removeAllRanges();
	      sel.addRange(rng);
	    }
	    if (old && sel.anchorNode == null) { sel.addRange(old); }
	    else if (gecko) { this.startGracePeriod(); }
	  }
	  this.rememberSelection();
	};
	
	ContentEditableInput.prototype.startGracePeriod = function () {
	    var this$1 = this;
	
	  clearTimeout(this.gracePeriod);
	  this.gracePeriod = setTimeout(function () {
	    this$1.gracePeriod = false;
	    if (this$1.selectionChanged())
	      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	  }, 20);
	};
	
	ContentEditableInput.prototype.showMultipleSelections = function (info) {
	  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	};
	
	ContentEditableInput.prototype.rememberSelection = function () {
	  var sel = window.getSelection();
	  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	};
	
	ContentEditableInput.prototype.selectionInEditor = function () {
	  var sel = window.getSelection();
	  if (!sel.rangeCount) { return false }
	  var node = sel.getRangeAt(0).commonAncestorContainer;
	  return contains(this.div, node)
	};
	
	ContentEditableInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor") {
	    if (!this.selectionInEditor())
	      { this.showSelection(this.prepareSelection(), true); }
	    this.div.focus();
	  }
	};
	ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	ContentEditableInput.prototype.getField = function () { return this.div };
	
	ContentEditableInput.prototype.supportsTouch = function () { return true };
	
	ContentEditableInput.prototype.receivedFocus = function () {
	  var input = this;
	  if (this.selectionInEditor())
	    { this.pollSelection(); }
	  else
	    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }
	
	  function poll() {
	    if (input.cm.state.focused) {
	      input.pollSelection();
	      input.polling.set(input.cm.options.pollInterval, poll);
	    }
	  }
	  this.polling.set(this.cm.options.pollInterval, poll);
	};
	
	ContentEditableInput.prototype.selectionChanged = function () {
	  var sel = window.getSelection();
	  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	};
	
	ContentEditableInput.prototype.pollSelection = function () {
	  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	  var sel = window.getSelection(), cm = this.cm;
	  // On Android Chrome (version 56, at least), backspacing into an
	  // uneditable block element will put the cursor in that element,
	  // and then, because it's not editable, hide the virtual keyboard.
	  // Because Android doesn't allow us to actually detect backspace
	  // presses in a sane way, this code checks for when that happens
	  // and simulates a backspace press in this case.
	  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
	    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	    this.blur();
	    this.focus();
	    return
	  }
	  if (this.composing) { return }
	  this.rememberSelection();
	  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (anchor && head) { runInOp(cm, function () {
	    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	  }); }
	};
	
	ContentEditableInput.prototype.pollContent = function () {
	  if (this.readDOMTimeout != null) {
	    clearTimeout(this.readDOMTimeout);
	    this.readDOMTimeout = null;
	  }
	
	  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	  var from = sel.from(), to = sel.to();
	  if (from.ch == 0 && from.line > cm.firstLine())
	    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	    { to = Pos(to.line + 1, 0); }
	  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
	
	  var fromIndex, fromLine, fromNode;
	  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	    fromLine = lineNo(display.view[0].line);
	    fromNode = display.view[0].node;
	  } else {
	    fromLine = lineNo(display.view[fromIndex].line);
	    fromNode = display.view[fromIndex - 1].node.nextSibling;
	  }
	  var toIndex = findViewIndex(cm, to.line);
	  var toLine, toNode;
	  if (toIndex == display.view.length - 1) {
	    toLine = display.viewTo - 1;
	    toNode = display.lineDiv.lastChild;
	  } else {
	    toLine = lineNo(display.view[toIndex + 1].line) - 1;
	    toNode = display.view[toIndex + 1].node.previousSibling;
	  }
	
	  if (!fromNode) { return false }
	  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	  while (newText.length > 1 && oldText.length > 1) {
	    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	    else { break }
	  }
	
	  var cutFront = 0, cutEnd = 0;
	  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	    { ++cutFront; }
	  var newBot = lst(newText), oldBot = lst(oldText);
	  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
	  while (cutEnd < maxCutEnd &&
	         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	    { ++cutEnd; }
	  // Try to move start of change to start of selection if ambiguous
	  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	    while (cutFront && cutFront > from.ch &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	      cutFront--;
	      cutEnd++;
	    }
	  }
	
	  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
	
	  var chFrom = Pos(fromLine, cutFront);
	  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	    return true
	  }
	};
	
	ContentEditableInput.prototype.ensurePolled = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.reset = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.forceCompositionEnd = function () {
	  if (!this.composing) { return }
	  clearTimeout(this.readDOMTimeout);
	  this.composing = null;
	  this.updateFromDOM();
	  this.div.blur();
	  this.div.focus();
	};
	ContentEditableInput.prototype.readFromDOMSoon = function () {
	    var this$1 = this;
	
	  if (this.readDOMTimeout != null) { return }
	  this.readDOMTimeout = setTimeout(function () {
	    this$1.readDOMTimeout = null;
	    if (this$1.composing) {
	      if (this$1.composing.done) { this$1.composing = null; }
	      else { return }
	    }
	    this$1.updateFromDOM();
	  }, 80);
	};
	
	ContentEditableInput.prototype.updateFromDOM = function () {
	    var this$1 = this;
	
	  if (this.cm.isReadOnly() || !this.pollContent())
	    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	};
	
	ContentEditableInput.prototype.setUneditable = function (node) {
	  node.contentEditable = "false";
	};
	
	ContentEditableInput.prototype.onKeyPress = function (e) {
	  if (e.charCode == 0) { return }
	  e.preventDefault();
	  if (!this.cm.isReadOnly())
	    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	};
	
	ContentEditableInput.prototype.readOnlyChanged = function (val) {
	  this.div.contentEditable = String(val != "nocursor");
	};
	
	ContentEditableInput.prototype.onContextMenu = function () {};
	ContentEditableInput.prototype.resetPosition = function () {};
	
	ContentEditableInput.prototype.needsContentAttribute = true;
	
	function posToDOM(cm, pos) {
	  var view = findViewForLine(cm, pos.line);
	  if (!view || view.hidden) { return null }
	  var line = getLine(cm.doc, pos.line);
	  var info = mapFromLineView(view, line, pos.line);
	
	  var order = getOrder(line, cm.doc.direction), side = "left";
	  if (order) {
	    var partPos = getBidiPartAt(order, pos.ch);
	    side = partPos % 2 ? "right" : "left";
	  }
	  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	  result.offset = result.collapse == "right" ? result.end : result.start;
	  return result
	}
	
	function isInGutter(node) {
	  for (var scan = node; scan; scan = scan.parentNode)
	    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	  return false
	}
	
	function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
	
	function domTextBetween(cm, from, to, fromLine, toLine) {
	  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	  function close() {
	    if (closing) {
	      text += lineSep;
	      closing = false;
	    }
	  }
	  function addText(str) {
	    if (str) {
	      close();
	      text += str;
	    }
	  }
	  function walk(node) {
	    if (node.nodeType == 1) {
	      var cmText = node.getAttribute("cm-text");
	      if (cmText != null) {
	        addText(cmText || node.textContent.replace(/\u200b/g, ""));
	        return
	      }
	      var markerID = node.getAttribute("cm-marker"), range$$1;
	      if (markerID) {
	        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	        if (found.length && (range$$1 = found[0].find(0)))
	          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
	        return
	      }
	      if (node.getAttribute("contenteditable") == "false") { return }
	      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
	      if (isBlock) { close(); }
	      for (var i = 0; i < node.childNodes.length; i++)
	        { walk(node.childNodes[i]); }
	      if (isBlock) { closing = true; }
	    } else if (node.nodeType == 3) {
	      addText(node.nodeValue);
	    }
	  }
	  for (;;) {
	    walk(from);
	    if (from == to) { break }
	    from = from.nextSibling;
	  }
	  return text
	}
	
	function domToPos(cm, node, offset) {
	  var lineNode;
	  if (node == cm.display.lineDiv) {
	    lineNode = cm.display.lineDiv.childNodes[offset];
	    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	    node = null; offset = 0;
	  } else {
	    for (lineNode = node;; lineNode = lineNode.parentNode) {
	      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	    }
	  }
	  for (var i = 0; i < cm.display.view.length; i++) {
	    var lineView = cm.display.view[i];
	    if (lineView.node == lineNode)
	      { return locateNodeInLineView(lineView, node, offset) }
	  }
	}
	
	function locateNodeInLineView(lineView, node, offset) {
	  var wrapper = lineView.text.firstChild, bad = false;
	  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	  if (node == wrapper) {
	    bad = true;
	    node = wrapper.childNodes[offset];
	    offset = 0;
	    if (!node) {
	      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	      return badPos(Pos(lineNo(line), line.text.length), bad)
	    }
	  }
	
	  var textNode = node.nodeType == 3 ? node : null, topNode = node;
	  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	    textNode = node.firstChild;
	    if (offset) { offset = textNode.nodeValue.length; }
	  }
	  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	  var measure = lineView.measure, maps = measure.maps;
	
	  function find(textNode, topNode, offset) {
	    for (var i = -1; i < (maps ? maps.length : 0); i++) {
	      var map$$1 = i < 0 ? measure.map : maps[i];
	      for (var j = 0; j < map$$1.length; j += 3) {
	        var curNode = map$$1[j + 2];
	        if (curNode == textNode || curNode == topNode) {
	          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	          var ch = map$$1[j] + offset;
	          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
	          return Pos(line, ch)
	        }
	      }
	    }
	  }
	  var found = find(textNode, topNode, offset);
	  if (found) { return badPos(found, bad) }
	
	  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	    found = find(after, after.firstChild, 0);
	    if (found)
	      { return badPos(Pos(found.line, found.ch - dist), bad) }
	    else
	      { dist += after.textContent.length; }
	  }
	  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	    found = find(before, before.firstChild, -1);
	    if (found)
	      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	    else
	      { dist$1 += before.textContent.length; }
	  }
	}
	
	// TEXTAREA INPUT STYLE
	
	var TextareaInput = function(cm) {
	  this.cm = cm;
	  // See input.poll and input.reset
	  this.prevInput = "";
	
	  // Flag that indicates whether we expect input to appear real soon
	  // now (after some event like 'keypress' or 'input') and are
	  // polling intensively.
	  this.pollingFast = false;
	  // Self-resetting timeout for the poller
	  this.polling = new Delayed();
	  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	  this.hasSelection = false;
	  this.composing = null;
	};
	
	TextareaInput.prototype.init = function (display) {
	    var this$1 = this;
	
	  var input = this, cm = this.cm;
	
	  // Wraps and hides input textarea
	  var div = this.wrapper = hiddenTextarea();
	  // The semihidden textarea that is focused when the editor is
	  // focused, and receives input.
	  var te = this.textarea = div.firstChild;
	  display.wrapper.insertBefore(div, display.wrapper.firstChild);
	
	  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	  if (ios) { te.style.width = "0px"; }
	
	  on(te, "input", function () {
	    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	    input.poll();
	  });
	
	  on(te, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	
	    cm.state.pasteIncoming = true;
	    input.fastPoll();
	  });
	
	  function prepareCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.setSelections(ranges.ranges, null, sel_dontScroll);
	      } else {
	        input.prevInput = "";
	        te.value = ranges.text.join("\n");
	        selectInput(te);
	      }
	    }
	    if (e.type == "cut") { cm.state.cutIncoming = true; }
	  }
	  on(te, "cut", prepareCopyCut);
	  on(te, "copy", prepareCopyCut);
	
	  on(display.scroller, "paste", function (e) {
	    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	    cm.state.pasteIncoming = true;
	    input.focus();
	  });
	
	  // Prevent normal selection in the editor (we handle our own)
	  on(display.lineSpace, "selectstart", function (e) {
	    if (!eventInWidget(display, e)) { e_preventDefault(e); }
	  });
	
	  on(te, "compositionstart", function () {
	    var start = cm.getCursor("from");
	    if (input.composing) { input.composing.range.clear(); }
	    input.composing = {
	      start: start,
	      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	    };
	  });
	  on(te, "compositionend", function () {
	    if (input.composing) {
	      input.poll();
	      input.composing.range.clear();
	      input.composing = null;
	    }
	  });
	};
	
	TextareaInput.prototype.prepareSelection = function () {
	  // Redraw the selection and/or cursor
	  var cm = this.cm, display = cm.display, doc = cm.doc;
	  var result = prepareSelection(cm);
	
	  // Move the hidden textarea near the cursor to prevent scrolling artifacts
	  if (cm.options.moveInputWithCursor) {
	    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                        headPos.top + lineOff.top - wrapOff.top));
	    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                         headPos.left + lineOff.left - wrapOff.left));
	  }
	
	  return result
	};
	
	TextareaInput.prototype.showSelection = function (drawn) {
	  var cm = this.cm, display = cm.display;
	  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	  if (drawn.teTop != null) {
	    this.wrapper.style.top = drawn.teTop + "px";
	    this.wrapper.style.left = drawn.teLeft + "px";
	  }
	};
	
	// Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	TextareaInput.prototype.reset = function (typing) {
	  if (this.contextMenuPending || this.composing) { return }
	  var cm = this.cm;
	  if (cm.somethingSelected()) {
	    this.prevInput = "";
	    var content = cm.getSelection();
	    this.textarea.value = content;
	    if (cm.state.focused) { selectInput(this.textarea); }
	    if (ie && ie_version >= 9) { this.hasSelection = content; }
	  } else if (!typing) {
	    this.prevInput = this.textarea.value = "";
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	  }
	};
	
	TextareaInput.prototype.getField = function () { return this.textarea };
	
	TextareaInput.prototype.supportsTouch = function () { return false };
	
	TextareaInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	    try { this.textarea.focus(); }
	    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	  }
	};
	
	TextareaInput.prototype.blur = function () { this.textarea.blur(); };
	
	TextareaInput.prototype.resetPosition = function () {
	  this.wrapper.style.top = this.wrapper.style.left = 0;
	};
	
	TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };
	
	// Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	TextareaInput.prototype.slowPoll = function () {
	    var this$1 = this;
	
	  if (this.pollingFast) { return }
	  this.polling.set(this.cm.options.pollInterval, function () {
	    this$1.poll();
	    if (this$1.cm.state.focused) { this$1.slowPoll(); }
	  });
	};
	
	// When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	TextareaInput.prototype.fastPoll = function () {
	  var missed = false, input = this;
	  input.pollingFast = true;
	  function p() {
	    var changed = input.poll();
	    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	    else {input.pollingFast = false; input.slowPoll();}
	  }
	  input.polling.set(20, p);
	};
	
	// Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	TextareaInput.prototype.poll = function () {
	    var this$1 = this;
	
	  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	  // Since this is called a *lot*, try to bail out as cheaply as
	  // possible when it is clear that nothing happened. hasSelection
	  // will be the case when there is a lot of text in the textarea,
	  // in which case reading its value would be expensive.
	  if (this.contextMenuPending || !cm.state.focused ||
	      (hasSelection(input) && !prevInput && !this.composing) ||
	      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	    { return false }
	
	  var text = input.value;
	  // If nothing changed, bail.
	  if (text == prevInput && !cm.somethingSelected()) { return false }
	  // Work around nonsensical selection resetting in IE9/10, and
	  // inexplicable appearance of private area unicode characters on
	  // some key combos in Mac (#2689).
	  if (ie && ie_version >= 9 && this.hasSelection === text ||
	      mac && /[\uf700-\uf7ff]/.test(text)) {
	    cm.display.input.reset();
	    return false
	  }
	
	  if (cm.doc.sel == cm.display.selForContextMenu) {
	    var first = text.charCodeAt(0);
	    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	  }
	  // Find the part of the input that is actually new
	  var same = 0, l = Math.min(prevInput.length, text.length);
	  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }
	
	  runInOp(cm, function () {
	    applyTextInput(cm, text.slice(same), prevInput.length - same,
	                   null, this$1.composing ? "*compose" : null);
	
	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	    else { this$1.prevInput = text; }
	
	    if (this$1.composing) {
	      this$1.composing.range.clear();
	      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                         {className: "CodeMirror-composing"});
	    }
	  });
	  return true
	};
	
	TextareaInput.prototype.ensurePolled = function () {
	  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	};
	
	TextareaInput.prototype.onKeyPress = function () {
	  if (ie && ie_version >= 9) { this.hasSelection = null; }
	  this.fastPoll();
	};
	
	TextareaInput.prototype.onContextMenu = function (e) {
	  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	  if (!pos || presto) { return } // Opera is difficult.
	
	  // Reset the current text selection only if the click is done outside of the selection
	  // and 'resetSelectionOnContextMenu' option is true.
	  var reset = cm.options.resetSelectionOnContextMenu;
	  if (reset && cm.doc.sel.contains(pos) == -1)
	    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }
	
	  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	  input.wrapper.style.cssText = "position: absolute";
	  var wrapperBox = input.wrapper.getBoundingClientRect();
	  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	  var oldScrollY;
	  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	  display.input.focus();
	  if (webkit) { window.scrollTo(null, oldScrollY); }
	  display.input.reset();
	  // Adds "Select all" to context menu in FF
	  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	  input.contextMenuPending = true;
	  display.selForContextMenu = cm.doc.sel;
	  clearTimeout(display.detectingSelectAll);
	
	  // Select-all will be greyed out if there's nothing to select, so
	  // this adds a zero-width space so that we can later check whether
	  // it got selected.
	  function prepareSelectAllHack() {
	    if (te.selectionStart != null) {
	      var selected = cm.somethingSelected();
	      var extval = "\u200b" + (selected ? te.value : "");
	      te.value = "\u21da"; // Used to catch context-menu undo
	      te.value = extval;
	      input.prevInput = selected ? "" : "\u200b";
	      te.selectionStart = 1; te.selectionEnd = extval.length;
	      // Re-set this, in case some other handler touched the
	      // selection in the meantime.
	      display.selForContextMenu = cm.doc.sel;
	    }
	  }
	  function rehide() {
	    input.contextMenuPending = false;
	    input.wrapper.style.cssText = oldWrapperCSS;
	    te.style.cssText = oldCSS;
	    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }
	
	    // Try to detect the user choosing select-all
	    if (te.selectionStart != null) {
	      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	      var i = 0, poll = function () {
	        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	            te.selectionEnd > 0 && input.prevInput == "\u200b") {
	          operation(cm, selectAll)(cm);
	        } else if (i++ < 10) {
	          display.detectingSelectAll = setTimeout(poll, 500);
	        } else {
	          display.selForContextMenu = null;
	          display.input.reset();
	        }
	      };
	      display.detectingSelectAll = setTimeout(poll, 200);
	    }
	  }
	
	  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	  if (captureRightClick) {
	    e_stop(e);
	    var mouseup = function () {
	      off(window, "mouseup", mouseup);
	      setTimeout(rehide, 20);
	    };
	    on(window, "mouseup", mouseup);
	  } else {
	    setTimeout(rehide, 50);
	  }
	};
	
	TextareaInput.prototype.readOnlyChanged = function (val) {
	  if (!val) { this.reset(); }
	  this.textarea.disabled = val == "nocursor";
	};
	
	TextareaInput.prototype.setUneditable = function () {};
	
	TextareaInput.prototype.needsContentAttribute = false;
	
	function fromTextArea(textarea, options) {
	  options = options ? copyObj(options) : {};
	  options.value = textarea.value;
	  if (!options.tabindex && textarea.tabIndex)
	    { options.tabindex = textarea.tabIndex; }
	  if (!options.placeholder && textarea.placeholder)
	    { options.placeholder = textarea.placeholder; }
	  // Set autofocus to true if this textarea is focused, or if it has
	  // autofocus and no other element is focused.
	  if (options.autofocus == null) {
	    var hasFocus = activeElt();
	    options.autofocus = hasFocus == textarea ||
	      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	  }
	
	  function save() {textarea.value = cm.getValue();}
	
	  var realSubmit;
	  if (textarea.form) {
	    on(textarea.form, "submit", save);
	    // Deplorable hack to make the submit method do the right thing.
	    if (!options.leaveSubmitMethodAlone) {
	      var form = textarea.form;
	      realSubmit = form.submit;
	      try {
	        var wrappedSubmit = form.submit = function () {
	          save();
	          form.submit = realSubmit;
	          form.submit();
	          form.submit = wrappedSubmit;
	        };
	      } catch(e) {}
	    }
	  }
	
	  options.finishInit = function (cm) {
	    cm.save = save;
	    cm.getTextArea = function () { return textarea; };
	    cm.toTextArea = function () {
	      cm.toTextArea = isNaN; // Prevent this from being ran twice
	      save();
	      textarea.parentNode.removeChild(cm.getWrapperElement());
	      textarea.style.display = "";
	      if (textarea.form) {
	        off(textarea.form, "submit", save);
	        if (typeof textarea.form.submit == "function")
	          { textarea.form.submit = realSubmit; }
	      }
	    };
	  };
	
	  textarea.style.display = "none";
	  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	    options);
	  return cm
	}
	
	function addLegacyProps(CodeMirror) {
	  CodeMirror.off = off;
	  CodeMirror.on = on;
	  CodeMirror.wheelEventPixels = wheelEventPixels;
	  CodeMirror.Doc = Doc;
	  CodeMirror.splitLines = splitLinesAuto;
	  CodeMirror.countColumn = countColumn;
	  CodeMirror.findColumn = findColumn;
	  CodeMirror.isWordChar = isWordCharBasic;
	  CodeMirror.Pass = Pass;
	  CodeMirror.signal = signal;
	  CodeMirror.Line = Line;
	  CodeMirror.changeEnd = changeEnd;
	  CodeMirror.scrollbarModel = scrollbarModel;
	  CodeMirror.Pos = Pos;
	  CodeMirror.cmpPos = cmp;
	  CodeMirror.modes = modes;
	  CodeMirror.mimeModes = mimeModes;
	  CodeMirror.resolveMode = resolveMode;
	  CodeMirror.getMode = getMode;
	  CodeMirror.modeExtensions = modeExtensions;
	  CodeMirror.extendMode = extendMode;
	  CodeMirror.copyState = copyState;
	  CodeMirror.startState = startState;
	  CodeMirror.innerMode = innerMode;
	  CodeMirror.commands = commands;
	  CodeMirror.keyMap = keyMap;
	  CodeMirror.keyName = keyName;
	  CodeMirror.isModifierKey = isModifierKey;
	  CodeMirror.lookupKey = lookupKey;
	  CodeMirror.normalizeKeyMap = normalizeKeyMap;
	  CodeMirror.StringStream = StringStream;
	  CodeMirror.SharedTextMarker = SharedTextMarker;
	  CodeMirror.TextMarker = TextMarker;
	  CodeMirror.LineWidget = LineWidget;
	  CodeMirror.e_preventDefault = e_preventDefault;
	  CodeMirror.e_stopPropagation = e_stopPropagation;
	  CodeMirror.e_stop = e_stop;
	  CodeMirror.addClass = addClass;
	  CodeMirror.contains = contains;
	  CodeMirror.rmClass = rmClass;
	  CodeMirror.keyNames = keyNames;
	}
	
	// EDITOR CONSTRUCTOR
	
	defineOptions(CodeMirror$1);
	
	addEditorMethods(CodeMirror$1);
	
	// Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	  { CodeMirror$1.prototype[prop] = (function(method) {
	    return function() {return method.apply(this.doc, arguments)}
	  })(Doc.prototype[prop]); } }
	
	eventMixin(Doc);
	
	// INPUT HANDLING
	
	CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};
	
	// MODE DEFINITION AND QUERYING
	
	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror$1.defineMode = function(name/*, mode, …*/) {
	  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
	  defineMode.apply(this, arguments);
	};
	
	CodeMirror$1.defineMIME = defineMIME;
	
	// Minimal default mode.
	CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	CodeMirror$1.defineMIME("text/plain", "null");
	
	// EXTENSIONS
	
	CodeMirror$1.defineExtension = function (name, func) {
	  CodeMirror$1.prototype[name] = func;
	};
	CodeMirror$1.defineDocExtension = function (name, func) {
	  Doc.prototype[name] = func;
	};
	
	CodeMirror$1.fromTextArea = fromTextArea;
	
	addLegacyProps(CodeMirror$1);
	
	CodeMirror$1.version = "5.31.0";
	
	return CodeMirror$1;
	
	})));


/***/ }),
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isType = isType;
	exports.assertType = assertType;
	exports.isInputType = isInputType;
	exports.assertInputType = assertInputType;
	exports.isOutputType = isOutputType;
	exports.assertOutputType = assertOutputType;
	exports.isLeafType = isLeafType;
	exports.assertLeafType = assertLeafType;
	exports.isCompositeType = isCompositeType;
	exports.assertCompositeType = assertCompositeType;
	exports.isAbstractType = isAbstractType;
	exports.assertAbstractType = assertAbstractType;
	exports.getNullableType = getNullableType;
	exports.isNamedType = isNamedType;
	exports.assertNamedType = assertNamedType;
	exports.getNamedType = getNamedType;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _assertValidName = __webpack_require__(167);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	// Predicates & Assertions
	
	/**
	 * These are all of the possible kinds of types.
	 */
	function isType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;
	}
	
	function assertType(type) {
	  !isType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL type.') : void 0;
	  return type;
	}
	
	/**
	 * These types may be used as input types for arguments and directives.
	 */
	function isInputType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLNonNull && isInputType(type.ofType) || type instanceof GraphQLList && isInputType(type.ofType);
	}
	
	function assertInputType(type) {
	  !isInputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL input type.') : void 0;
	  return type;
	}
	
	/**
	 * These types may be used as output types as the result of fields.
	 */
	function isOutputType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLNonNull && isOutputType(type.ofType) || type instanceof GraphQLList && isOutputType(type.ofType);
	}
	
	function assertOutputType(type) {
	  !isOutputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL output type.') : void 0;
	  return type;
	}
	
	/**
	 * These types may describe types which may be leaf values.
	 */
	function isLeafType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType;
	}
	
	function assertLeafType(type) {
	  !isLeafType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL leaf type.') : void 0;
	  return type;
	}
	
	/**
	 * These types may describe the parent context of a selection set.
	 */
	function isCompositeType(type) {
	  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;
	}
	
	function assertCompositeType(type) {
	  !isCompositeType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL composite type.') : void 0;
	  return type;
	}
	
	/**
	 * These types may describe the parent context of a selection set.
	 */
	function isAbstractType(type) {
	  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;
	}
	
	function assertAbstractType(type) {
	  !isAbstractType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL abstract type.') : void 0;
	  return type;
	}
	
	/**
	 * These types can all accept null as a value.
	 */
	function getNullableType(type) {
	  return type instanceof GraphQLNonNull ? type.ofType : type;
	}
	
	/**
	 * These named types do not include modifiers like List or NonNull.
	 */
	function isNamedType(type) {
	  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType;
	}
	
	function assertNamedType(type) {
	  !isNamedType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL named type.') : void 0;
	  return type;
	}
	
	/* eslint-disable no-redeclare */
	function getNamedType(type) {
	  /* eslint-enable no-redeclare */
	  if (type) {
	    var unmodifiedType = type;
	    while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {
	      unmodifiedType = unmodifiedType.ofType;
	    }
	    return unmodifiedType;
	  }
	}
	
	/**
	 * Used while defining GraphQL types to allow for circular references in
	 * otherwise immutable type definitions.
	 */
	
	
	function resolveThunk(thunk) {
	  return typeof thunk === 'function' ? thunk() : thunk;
	}
	
	/**
	 * Scalar Type Definition
	 *
	 * The leaf values of any request and input values to arguments are
	 * Scalars (or Enums) and are defined with a name and a series of functions
	 * used to parse input from ast or variables and to ensure validity.
	 *
	 * Example:
	 *
	 *     const OddType = new GraphQLScalarType({
	 *       name: 'Odd',
	 *       serialize(value) {
	 *         return value % 2 === 1 ? value : null;
	 *       }
	 *     });
	 *
	 */
	
	var GraphQLScalarType = exports.GraphQLScalarType = function () {
	  function GraphQLScalarType(config) {
	    _classCallCheck(this, GraphQLScalarType);
	
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    this.astNode = config.astNode;
	    !(typeof config.serialize === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide "serialize" function. If this custom Scalar ' + 'is also used as an input type, ensure "parseValue" and "parseLiteral" ' + 'functions are also provided.') : void 0;
	    if (config.parseValue || config.parseLiteral) {
	      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide both "parseValue" and "parseLiteral" ' + 'functions.') : void 0;
	    }
	    this._scalarConfig = config;
	  }
	
	  // Serializes an internal value to include in a response.
	
	
	  GraphQLScalarType.prototype.serialize = function serialize(value) {
	    var serializer = this._scalarConfig.serialize;
	    return serializer(value);
	  };
	
	  // Determines if an internal value is valid for this type.
	  // Equivalent to checking for if the parsedValue is nullish.
	
	
	  GraphQLScalarType.prototype.isValidValue = function isValidValue(value) {
	    return !(0, _isNullish2.default)(this.parseValue(value));
	  };
	
	  // Parses an externally provided value to use as an input.
	
	
	  GraphQLScalarType.prototype.parseValue = function parseValue(value) {
	    var parser = this._scalarConfig.parseValue;
	    return parser && !(0, _isNullish2.default)(value) ? parser(value) : undefined;
	  };
	
	  // Determines if an internal value is valid for this type.
	  // Equivalent to checking for if the parsedLiteral is nullish.
	
	
	  GraphQLScalarType.prototype.isValidLiteral = function isValidLiteral(valueNode) {
	    return !(0, _isNullish2.default)(this.parseLiteral(valueNode));
	  };
	
	  // Parses an externally provided literal value to use as an input.
	
	
	  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueNode) {
	    var parser = this._scalarConfig.parseLiteral;
	    return parser ? parser(valueNode) : undefined;
	  };
	
	  GraphQLScalarType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLScalarType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;
	
	/**
	 * Object Type Definition
	 *
	 * Almost all of the GraphQL types you define will be object types. Object types
	 * have a name, but most importantly describe their fields.
	 *
	 * Example:
	 *
	 *     const AddressType = new GraphQLObjectType({
	 *       name: 'Address',
	 *       fields: {
	 *         street: { type: GraphQLString },
	 *         number: { type: GraphQLInt },
	 *         formatted: {
	 *           type: GraphQLString,
	 *           resolve(obj) {
	 *             return obj.number + ' ' + obj.street
	 *           }
	 *         }
	 *       }
	 *     });
	 *
	 * When two types need to refer to each other, or a type needs to refer to
	 * itself in a field, you can use a function expression (aka a closure or a
	 * thunk) to supply the fields lazily.
	 *
	 * Example:
	 *
	 *     const PersonType = new GraphQLObjectType({
	 *       name: 'Person',
	 *       fields: () => ({
	 *         name: { type: GraphQLString },
	 *         bestFriend: { type: PersonType },
	 *       })
	 *     });
	 *
	 */
	var GraphQLObjectType = exports.GraphQLObjectType = function () {
	  function GraphQLObjectType(config) {
	    _classCallCheck(this, GraphQLObjectType);
	
	    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);
	    this.name = config.name;
	    this.description = config.description;
	    this.astNode = config.astNode;
	    this.extensionASTNodes = config.extensionASTNodes || [];
	    if (config.isTypeOf) {
	      !(typeof config.isTypeOf === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide "isTypeOf" as a function.') : void 0;
	    }
	    this.isTypeOf = config.isTypeOf;
	    this._typeConfig = config;
	  }
	
	  GraphQLObjectType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
	  };
	
	  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {
	    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));
	  };
	
	  GraphQLObjectType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLObjectType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;
	
	function defineInterfaces(type, interfacesThunk) {
	  var interfaces = resolveThunk(interfacesThunk);
	  if (!interfaces) {
	    return [];
	  }
	  !Array.isArray(interfaces) ? (0, _invariant2.default)(0, type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.') : void 0;
	
	  var implementedTypeNames = Object.create(null);
	  interfaces.forEach(function (iface) {
	    !(iface instanceof GraphQLInterfaceType) ? (0, _invariant2.default)(0, type.name + ' may only implement Interface types, it cannot ' + ('implement: ' + String(iface) + '.')) : void 0;
	    !!implementedTypeNames[iface.name] ? (0, _invariant2.default)(0, type.name + ' may declare it implements ' + iface.name + ' only once.') : void 0;
	    implementedTypeNames[iface.name] = true;
	    if (typeof iface.resolveType !== 'function') {
	      !(typeof type.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Interface Type ' + iface.name + ' does not provide a "resolveType" ' + ('function and implementing Type ' + type.name + ' does not provide a ') + '"isTypeOf" function. There is no way to resolve this implementing ' + 'type during execution.') : void 0;
	    }
	  });
	  return interfaces;
	}
	
	function defineFieldMap(type, fieldsThunk) {
	  var fieldMap = resolveThunk(fieldsThunk);
	  !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;
	
	  var fieldNames = Object.keys(fieldMap);
	  !(fieldNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;
	
	  var resultFieldMap = Object.create(null);
	  fieldNames.forEach(function (fieldName) {
	    (0, _assertValidName.assertValidName)(fieldName);
	    var fieldConfig = fieldMap[fieldName];
	    !isPlainObj(fieldConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field config must be an object') : void 0;
	    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' should provide "deprecationReason" instead ' + 'of "isDeprecated".') : void 0;
	    var field = _extends({}, fieldConfig, {
	      isDeprecated: Boolean(fieldConfig.deprecationReason),
	      name: fieldName
	    });
	    !isOutputType(field.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + String(field.type) + '.')) : void 0;
	    !isValidResolver(field.resolve) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field resolver must be a function if ' + ('provided, but got: ' + String(field.resolve) + '.')) : void 0;
	    var argsConfig = fieldConfig.args;
	    if (!argsConfig) {
	      field.args = [];
	    } else {
	      !isPlainObj(argsConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.') : void 0;
	      field.args = Object.keys(argsConfig).map(function (argName) {
	        (0, _assertValidName.assertValidName)(argName);
	        var arg = argsConfig[argName];
	        !isInputType(arg.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.')) : void 0;
	        return {
	          name: argName,
	          description: arg.description === undefined ? null : arg.description,
	          type: arg.type,
	          defaultValue: arg.defaultValue,
	          astNode: arg.astNode
	        };
	      });
	    }
	    resultFieldMap[fieldName] = field;
	  });
	  return resultFieldMap;
	}
	
	function isPlainObj(obj) {
	  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);
	}
	
	// If a resolver is defined, it must be a function.
	function isValidResolver(resolver) {
	  return resolver == null || typeof resolver === 'function';
	}
	
	/**
	 * Interface Type Definition
	 *
	 * When a field can return one of a heterogeneous set of types, a Interface type
	 * is used to describe what types are possible, what fields are in common across
	 * all types, as well as a function to determine which type is actually used
	 * when the field is resolved.
	 *
	 * Example:
	 *
	 *     const EntityType = new GraphQLInterfaceType({
	 *       name: 'Entity',
	 *       fields: {
	 *         name: { type: GraphQLString }
	 *       }
	 *     });
	 *
	 */
	var GraphQLInterfaceType = exports.GraphQLInterfaceType = function () {
	  function GraphQLInterfaceType(config) {
	    _classCallCheck(this, GraphQLInterfaceType);
	
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    this.astNode = config.astNode;
	    if (config.resolveType) {
	      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide "resolveType" as a function.') : void 0;
	    }
	    this.resolveType = config.resolveType;
	    this._typeConfig = config;
	  }
	
	  GraphQLInterfaceType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
	  };
	
	  GraphQLInterfaceType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLInterfaceType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;
	
	/**
	 * Union Type Definition
	 *
	 * When a field can return one of a heterogeneous set of types, a Union type
	 * is used to describe what types are possible as well as providing a function
	 * to determine which type is actually used when the field is resolved.
	 *
	 * Example:
	 *
	 *     const PetType = new GraphQLUnionType({
	 *       name: 'Pet',
	 *       types: [ DogType, CatType ],
	 *       resolveType(value) {
	 *         if (value instanceof Dog) {
	 *           return DogType;
	 *         }
	 *         if (value instanceof Cat) {
	 *           return CatType;
	 *         }
	 *       }
	 *     });
	 *
	 */
	var GraphQLUnionType = exports.GraphQLUnionType = function () {
	  function GraphQLUnionType(config) {
	    _classCallCheck(this, GraphQLUnionType);
	
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    this.astNode = config.astNode;
	    if (config.resolveType) {
	      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide "resolveType" as a function.') : void 0;
	    }
	    this.resolveType = config.resolveType;
	    this._typeConfig = config;
	  }
	
	  GraphQLUnionType.prototype.getTypes = function getTypes() {
	    return this._types || (this._types = defineTypes(this, this._typeConfig.types));
	  };
	
	  GraphQLUnionType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLUnionType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;
	
	function defineTypes(unionType, typesThunk) {
	  var types = resolveThunk(typesThunk);
	
	  !(Array.isArray(types) && types.length > 0) ? (0, _invariant2.default)(0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.')) : void 0;
	  var includedTypeNames = Object.create(null);
	  types.forEach(function (objType) {
	    !(objType instanceof GraphQLObjectType) ? (0, _invariant2.default)(0, unionType.name + ' may only contain Object types, it cannot contain: ' + (String(objType) + '.')) : void 0;
	    !!includedTypeNames[objType.name] ? (0, _invariant2.default)(0, unionType.name + ' can include ' + objType.name + ' type only once.') : void 0;
	    includedTypeNames[objType.name] = true;
	    if (typeof unionType.resolveType !== 'function') {
	      !(typeof objType.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Union type "' + unionType.name + '" does not provide a "resolveType" ' + ('function and possible type "' + objType.name + '" does not provide an ') + '"isTypeOf" function. There is no way to resolve this possible type ' + 'during execution.') : void 0;
	    }
	  });
	
	  return types;
	}
	
	/**
	 * Enum Type Definition
	 *
	 * Some leaf values of requests and input values are Enums. GraphQL serializes
	 * Enum values as strings, however internally Enums can be represented by any
	 * kind of type, often integers.
	 *
	 * Example:
	 *
	 *     const RGBType = new GraphQLEnumType({
	 *       name: 'RGB',
	 *       values: {
	 *         RED: { value: 0 },
	 *         GREEN: { value: 1 },
	 *         BLUE: { value: 2 }
	 *       }
	 *     });
	 *
	 * Note: If a value is not provided in a definition, the name of the enum value
	 * will be used as its internal value.
	 */
	var GraphQLEnumType /* <T> */ = exports.GraphQLEnumType = function () {
	  function GraphQLEnumType(config /* <T> */) {
	    _classCallCheck(this, GraphQLEnumType);
	
	    this.name = config.name;
	    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);
	    this.description = config.description;
	    this.astNode = config.astNode;
	    this._values = defineEnumValues(this, config.values);
	    this._enumConfig = config;
	  }
	
	  GraphQLEnumType.prototype.getValues = function getValues() {
	    return this._values;
	  };
	
	  GraphQLEnumType.prototype.getValue = function getValue(name) {
	    return this._getNameLookup()[name];
	  };
	
	  GraphQLEnumType.prototype.serialize = function serialize(value /* T */) {
	    var enumValue = this._getValueLookup().get(value);
	    return enumValue ? enumValue.name : null;
	  };
	
	  GraphQLEnumType.prototype.isValidValue = function isValidValue(value) {
	    return typeof value === 'string' && this._getNameLookup()[value] !== undefined;
	  };
	
	  GraphQLEnumType.prototype.parseValue = function parseValue(value) /* T */{
	    if (typeof value === 'string') {
	      var enumValue = this._getNameLookup()[value];
	      if (enumValue) {
	        return enumValue.value;
	      }
	    }
	  };
	
	  GraphQLEnumType.prototype.isValidLiteral = function isValidLiteral(valueNode) {
	    return valueNode.kind === Kind.ENUM && this._getNameLookup()[valueNode.value] !== undefined;
	  };
	
	  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueNode) /* T */{
	    if (valueNode.kind === Kind.ENUM) {
	      var enumValue = this._getNameLookup()[valueNode.value];
	      if (enumValue) {
	        return enumValue.value;
	      }
	    }
	  };
	
	  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {
	    if (!this._valueLookup) {
	      var lookup = new Map();
	      this.getValues().forEach(function (value) {
	        lookup.set(value.value, value);
	      });
	      this._valueLookup = lookup;
	    }
	    return this._valueLookup;
	  };
	
	  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {
	    if (!this._nameLookup) {
	      var lookup = Object.create(null);
	      this.getValues().forEach(function (value) {
	        lookup[value.name] = value;
	      });
	      this._nameLookup = lookup;
	    }
	    return this._nameLookup;
	  };
	
	  GraphQLEnumType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLEnumType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;
	
	function defineEnumValues(type, valueMap /* <T> */
	) {
	  !isPlainObj(valueMap) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;
	  var valueNames = Object.keys(valueMap);
	  !(valueNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;
	  return valueNames.map(function (valueName) {
	    (0, _assertValidName.assertValidName)(valueName);
	    !(['true', 'false', 'null'].indexOf(valueName) === -1) ? (0, _invariant2.default)(0, 'Name "' + valueName + '" can not be used as an Enum value.') : void 0;
	
	    var value = valueMap[valueName];
	    !isPlainObj(value) ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' must refer to an object with a "value" key ' + ('representing an internal value but got: ' + String(value) + '.')) : void 0;
	    !!value.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' should provide "deprecationReason" instead ' + 'of "isDeprecated".') : void 0;
	    return {
	      name: valueName,
	      description: value.description,
	      isDeprecated: Boolean(value.deprecationReason),
	      deprecationReason: value.deprecationReason,
	      astNode: value.astNode,
	      value: value.hasOwnProperty('value') ? value.value : valueName
	    };
	  });
	} /* <T> */
	
	
	/**
	 * Input Object Type Definition
	 *
	 * An input object defines a structured collection of fields which may be
	 * supplied to a field argument.
	 *
	 * Using `NonNull` will ensure that a value must be provided by the query
	 *
	 * Example:
	 *
	 *     const GeoPoint = new GraphQLInputObjectType({
	 *       name: 'GeoPoint',
	 *       fields: {
	 *         lat: { type: new GraphQLNonNull(GraphQLFloat) },
	 *         lon: { type: new GraphQLNonNull(GraphQLFloat) },
	 *         alt: { type: GraphQLFloat, defaultValue: 0 },
	 *       }
	 *     });
	 *
	 */
	var GraphQLInputObjectType = exports.GraphQLInputObjectType = function () {
	  function GraphQLInputObjectType(config) {
	    _classCallCheck(this, GraphQLInputObjectType);
	
	    (0, _assertValidName.assertValidName)(config.name);
	    this.name = config.name;
	    this.description = config.description;
	    this.astNode = config.astNode;
	    this._typeConfig = config;
	  }
	
	  GraphQLInputObjectType.prototype.getFields = function getFields() {
	    return this._fields || (this._fields = this._defineFieldMap());
	  };
	
	  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {
	    var _this = this;
	
	    var fieldMap = resolveThunk(this._typeConfig.fields);
	    !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;
	    var fieldNames = Object.keys(fieldMap);
	    !(fieldNames.length > 0) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;
	    var resultFieldMap = Object.create(null);
	    fieldNames.forEach(function (fieldName) {
	      (0, _assertValidName.assertValidName)(fieldName);
	      var field = _extends({}, fieldMap[fieldName], {
	        name: fieldName
	      });
	      !isInputType(field.type) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + String(field.type) + '.')) : void 0;
	      !(field.resolve == null) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type has a resolve property, but ' + 'Input Types cannot define resolvers.') : void 0;
	      resultFieldMap[fieldName] = field;
	    });
	    return resultFieldMap;
	  };
	
	  GraphQLInputObjectType.prototype.toString = function toString() {
	    return this.name;
	  };
	
	  return GraphQLInputObjectType;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;
	
	/**
	 * List Modifier
	 *
	 * A list is a kind of type marker, a wrapping type which points to another
	 * type. Lists are often created within the context of defining the fields of
	 * an object type.
	 *
	 * Example:
	 *
	 *     const PersonType = new GraphQLObjectType({
	 *       name: 'Person',
	 *       fields: () => ({
	 *         parents: { type: new GraphQLList(Person) },
	 *         children: { type: new GraphQLList(Person) },
	 *       })
	 *     })
	 *
	 */
	var GraphQLList = exports.GraphQLList = function () {
	  function GraphQLList(type) {
	    _classCallCheck(this, GraphQLList);
	
	    !isType(type) ? (0, _invariant2.default)(0, 'Can only create List of a GraphQLType but got: ' + String(type) + '.') : void 0;
	    this.ofType = type;
	  }
	
	  GraphQLList.prototype.toString = function toString() {
	    return '[' + String(this.ofType) + ']';
	  };
	
	  return GraphQLList;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLList.prototype.toJSON = GraphQLList.prototype.inspect = GraphQLList.prototype.toString;
	
	/**
	 * Non-Null Modifier
	 *
	 * A non-null is a kind of type marker, a wrapping type which points to another
	 * type. Non-null types enforce that their values are never null and can ensure
	 * an error is raised if this ever occurs during a request. It is useful for
	 * fields which you can make a strong guarantee on non-nullability, for example
	 * usually the id field of a database row will never be null.
	 *
	 * Example:
	 *
	 *     const RowType = new GraphQLObjectType({
	 *       name: 'Row',
	 *       fields: () => ({
	 *         id: { type: new GraphQLNonNull(GraphQLString) },
	 *       })
	 *     })
	 *
	 * Note: the enforcement of non-nullability occurs within the executor.
	 */
	
	var GraphQLNonNull = exports.GraphQLNonNull = function () {
	  function GraphQLNonNull(type) {
	    _classCallCheck(this, GraphQLNonNull);
	
	    !(isType(type) && !(type instanceof GraphQLNonNull)) ? (0, _invariant2.default)(0, 'Can only create NonNull of a Nullable GraphQLType but got: ' + (String(type) + '.')) : void 0;
	    this.ofType = type;
	  }
	
	  GraphQLNonNull.prototype.toString = function toString() {
	    return this.ofType.toString() + '!';
	  };
	
	  return GraphQLNonNull;
	}();
	
	// Also provide toJSON and inspect aliases for toString.
	
	
	GraphQLNonNull.prototype.toJSON = GraphQLNonNull.prototype.inspect = GraphQLNonNull.prototype.toString;

/***/ }),
/* 8 */,
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ScalingCellSizeAndPositionManager = __webpack_require__(196);
	
	var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellPosition', {
	  value: {
	    columnIndex: __webpack_require__(1).number.isRequired,
	    rowIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRendererParams', {
	  value: {
	    columnIndex: __webpack_require__(1).number.isRequired,
	    isScrolling: __webpack_require__(1).bool.isRequired,
	    isVisible: __webpack_require__(1).bool.isRequired,
	    key: __webpack_require__(1).string.isRequired,
	    parent: __webpack_require__(1).object.isRequired,
	    rowIndex: __webpack_require__(1).number.isRequired,
	    style: __webpack_require__(1).object.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRenderer', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams', {
	  value: {
	    cellCache: __webpack_require__(1).object.isRequired,
	    cellRenderer: __webpack_require__(1).func.isRequired,
	    columnSizeAndPositionManager: typeof _ScalingCellSizeAndPositionManager2.default === 'function' ? __webpack_require__(1).instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : __webpack_require__(1).any.isRequired,
	    columnStartIndex: __webpack_require__(1).number.isRequired,
	    columnStopIndex: __webpack_require__(1).number.isRequired,
	    deferredMeasurementCache: __webpack_require__(1).object,
	    horizontalOffsetAdjustment: __webpack_require__(1).number.isRequired,
	    isScrolling: __webpack_require__(1).bool.isRequired,
	    parent: __webpack_require__(1).object.isRequired,
	    rowSizeAndPositionManager: typeof _ScalingCellSizeAndPositionManager2.default === 'function' ? __webpack_require__(1).instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : __webpack_require__(1).any.isRequired,
	    rowStartIndex: __webpack_require__(1).number.isRequired,
	    rowStopIndex: __webpack_require__(1).number.isRequired,
	    scrollLeft: __webpack_require__(1).number.isRequired,
	    scrollTop: __webpack_require__(1).number.isRequired,
	    styleCache: __webpack_require__(1).object.isRequired,
	    verticalOffsetAdjustment: __webpack_require__(1).number.isRequired,
	    visibleColumnIndices: __webpack_require__(1).object.isRequired,
	    visibleRowIndices: __webpack_require__(1).object.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRangeRenderer', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellSizeGetter', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellSize', {
	  value: __webpack_require__(1).oneOfType([__webpack_require__(1).func, __webpack_require__(1).number]),
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_NoContentRenderer', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Scroll', {
	  value: {
	    clientHeight: __webpack_require__(1).number.isRequired,
	    clientWidth: __webpack_require__(1).number.isRequired,
	    scrollHeight: __webpack_require__(1).number.isRequired,
	    scrollLeft: __webpack_require__(1).number.isRequired,
	    scrollTop: __webpack_require__(1).number.isRequired,
	    scrollWidth: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange', {
	  value: {
	    horizontal: __webpack_require__(1).bool.isRequired,
	    vertical: __webpack_require__(1).bool.isRequired,
	    size: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RenderedSection', {
	  value: {
	    columnOverscanStartIndex: __webpack_require__(1).number.isRequired,
	    columnOverscanStopIndex: __webpack_require__(1).number.isRequired,
	    columnStartIndex: __webpack_require__(1).number.isRequired,
	    columnStopIndex: __webpack_require__(1).number.isRequired,
	    rowOverscanStartIndex: __webpack_require__(1).number.isRequired,
	    rowOverscanStopIndex: __webpack_require__(1).number.isRequired,
	    rowStartIndex: __webpack_require__(1).number.isRequired,
	    rowStopIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams', {
	  value: {
	    direction: __webpack_require__(1).oneOf(['horizontal', 'vertical']).isRequired,
	    scrollDirection: __webpack_require__(1).oneOf([-1, 1]).isRequired,
	    cellCount: __webpack_require__(1).number.isRequired,
	    overscanCellsCount: __webpack_require__(1).number.isRequired,
	    startIndex: __webpack_require__(1).number.isRequired,
	    stopIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndices', {
	  value: {
	    overscanStartIndex: __webpack_require__(1).number.isRequired,
	    overscanStopIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Alignment', {
	  value: __webpack_require__(1).oneOf(['auto', 'end', 'start', 'center']),
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_VisibleCellRange', {
	  value: {
	    start: __webpack_require__(1).number,
	    stop: __webpack_require__(1).number
	  },
	  configurable: true
	});

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1044)


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _graphql = __webpack_require__(612);
	
	Object.defineProperty(exports, 'graphql', {
	  enumerable: true,
	  get: function get() {
	    return _graphql.graphql;
	  }
	});
	
	var _type = __webpack_require__(617);
	
	Object.defineProperty(exports, 'GraphQLSchema', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLSchema;
	  }
	});
	Object.defineProperty(exports, 'GraphQLScalarType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLScalarType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInterfaceType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInterfaceType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLUnionType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLUnionType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLEnumType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLEnumType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInputObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInputObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLList', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLList;
	  }
	});
	Object.defineProperty(exports, 'GraphQLNonNull', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLNonNull;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLDirective;
	  }
	});
	Object.defineProperty(exports, 'TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeKind;
	  }
	});
	Object.defineProperty(exports, 'DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _type.DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInt', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLInt;
	  }
	});
	Object.defineProperty(exports, 'GraphQLFloat', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLFloat;
	  }
	});
	Object.defineProperty(exports, 'GraphQLString', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLString;
	  }
	});
	Object.defineProperty(exports, 'GraphQLBoolean', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLBoolean;
	  }
	});
	Object.defineProperty(exports, 'GraphQLID', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLID;
	  }
	});
	Object.defineProperty(exports, 'specifiedDirectives', {
	  enumerable: true,
	  get: function get() {
	    return _type.specifiedDirectives;
	  }
	});
	Object.defineProperty(exports, 'GraphQLIncludeDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLIncludeDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLSkipDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLSkipDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDeprecatedDirective', {
	  enumerable: true,
	  get: function get() {
	    return _type.GraphQLDeprecatedDirective;
	  }
	});
	Object.defineProperty(exports, 'DEFAULT_DEPRECATION_REASON', {
	  enumerable: true,
	  get: function get() {
	    return _type.DEFAULT_DEPRECATION_REASON;
	  }
	});
	Object.defineProperty(exports, 'SchemaMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.SchemaMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeNameMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _type.TypeNameMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, '__Schema', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Schema;
	  }
	});
	Object.defineProperty(exports, '__Directive', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Directive;
	  }
	});
	Object.defineProperty(exports, '__DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _type.__DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, '__Type', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Type;
	  }
	});
	Object.defineProperty(exports, '__Field', {
	  enumerable: true,
	  get: function get() {
	    return _type.__Field;
	  }
	});
	Object.defineProperty(exports, '__InputValue', {
	  enumerable: true,
	  get: function get() {
	    return _type.__InputValue;
	  }
	});
	Object.defineProperty(exports, '__EnumValue', {
	  enumerable: true,
	  get: function get() {
	    return _type.__EnumValue;
	  }
	});
	Object.defineProperty(exports, '__TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _type.__TypeKind;
	  }
	});
	Object.defineProperty(exports, 'isType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isType;
	  }
	});
	Object.defineProperty(exports, 'isInputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isInputType;
	  }
	});
	Object.defineProperty(exports, 'isOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isOutputType;
	  }
	});
	Object.defineProperty(exports, 'isLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isLeafType;
	  }
	});
	Object.defineProperty(exports, 'isCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isCompositeType;
	  }
	});
	Object.defineProperty(exports, 'isAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isAbstractType;
	  }
	});
	Object.defineProperty(exports, 'isNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _type.isNamedType;
	  }
	});
	Object.defineProperty(exports, 'assertType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertType;
	  }
	});
	Object.defineProperty(exports, 'assertInputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertInputType;
	  }
	});
	Object.defineProperty(exports, 'assertOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertOutputType;
	  }
	});
	Object.defineProperty(exports, 'assertLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertLeafType;
	  }
	});
	Object.defineProperty(exports, 'assertCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertCompositeType;
	  }
	});
	Object.defineProperty(exports, 'assertAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertAbstractType;
	  }
	});
	Object.defineProperty(exports, 'assertNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _type.assertNamedType;
	  }
	});
	Object.defineProperty(exports, 'getNullableType', {
	  enumerable: true,
	  get: function get() {
	    return _type.getNullableType;
	  }
	});
	Object.defineProperty(exports, 'getNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _type.getNamedType;
	  }
	});
	
	var _language = __webpack_require__(613);
	
	Object.defineProperty(exports, 'Source', {
	  enumerable: true,
	  get: function get() {
	    return _language.Source;
	  }
	});
	Object.defineProperty(exports, 'getLocation', {
	  enumerable: true,
	  get: function get() {
	    return _language.getLocation;
	  }
	});
	Object.defineProperty(exports, 'parse', {
	  enumerable: true,
	  get: function get() {
	    return _language.parse;
	  }
	});
	Object.defineProperty(exports, 'parseValue', {
	  enumerable: true,
	  get: function get() {
	    return _language.parseValue;
	  }
	});
	Object.defineProperty(exports, 'parseType', {
	  enumerable: true,
	  get: function get() {
	    return _language.parseType;
	  }
	});
	Object.defineProperty(exports, 'print', {
	  enumerable: true,
	  get: function get() {
	    return _language.print;
	  }
	});
	Object.defineProperty(exports, 'visit', {
	  enumerable: true,
	  get: function get() {
	    return _language.visit;
	  }
	});
	Object.defineProperty(exports, 'visitInParallel', {
	  enumerable: true,
	  get: function get() {
	    return _language.visitInParallel;
	  }
	});
	Object.defineProperty(exports, 'visitWithTypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _language.visitWithTypeInfo;
	  }
	});
	Object.defineProperty(exports, 'getVisitFn', {
	  enumerable: true,
	  get: function get() {
	    return _language.getVisitFn;
	  }
	});
	Object.defineProperty(exports, 'Kind', {
	  enumerable: true,
	  get: function get() {
	    return _language.Kind;
	  }
	});
	Object.defineProperty(exports, 'TokenKind', {
	  enumerable: true,
	  get: function get() {
	    return _language.TokenKind;
	  }
	});
	Object.defineProperty(exports, 'BREAK', {
	  enumerable: true,
	  get: function get() {
	    return _language.BREAK;
	  }
	});
	
	var _execution = __webpack_require__(611);
	
	Object.defineProperty(exports, 'execute', {
	  enumerable: true,
	  get: function get() {
	    return _execution.execute;
	  }
	});
	Object.defineProperty(exports, 'defaultFieldResolver', {
	  enumerable: true,
	  get: function get() {
	    return _execution.defaultFieldResolver;
	  }
	});
	Object.defineProperty(exports, 'responsePathAsArray', {
	  enumerable: true,
	  get: function get() {
	    return _execution.responsePathAsArray;
	  }
	});
	Object.defineProperty(exports, 'getDirectiveValues', {
	  enumerable: true,
	  get: function get() {
	    return _execution.getDirectiveValues;
	  }
	});
	
	var _subscription = __webpack_require__(614);
	
	Object.defineProperty(exports, 'subscribe', {
	  enumerable: true,
	  get: function get() {
	    return _subscription.subscribe;
	  }
	});
	Object.defineProperty(exports, 'createSourceEventStream', {
	  enumerable: true,
	  get: function get() {
	    return _subscription.createSourceEventStream;
	  }
	});
	
	var _validation = __webpack_require__(627);
	
	Object.defineProperty(exports, 'validate', {
	  enumerable: true,
	  get: function get() {
	    return _validation.validate;
	  }
	});
	Object.defineProperty(exports, 'ValidationContext', {
	  enumerable: true,
	  get: function get() {
	    return _validation.ValidationContext;
	  }
	});
	Object.defineProperty(exports, 'specifiedRules', {
	  enumerable: true,
	  get: function get() {
	    return _validation.specifiedRules;
	  }
	});
	Object.defineProperty(exports, 'ArgumentsOfCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.ArgumentsOfCorrectTypeRule;
	  }
	});
	Object.defineProperty(exports, 'DefaultValuesOfCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.DefaultValuesOfCorrectTypeRule;
	  }
	});
	Object.defineProperty(exports, 'FieldsOnCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.FieldsOnCorrectTypeRule;
	  }
	});
	Object.defineProperty(exports, 'FragmentsOnCompositeTypesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.FragmentsOnCompositeTypesRule;
	  }
	});
	Object.defineProperty(exports, 'KnownArgumentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.KnownArgumentNamesRule;
	  }
	});
	Object.defineProperty(exports, 'KnownDirectivesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.KnownDirectivesRule;
	  }
	});
	Object.defineProperty(exports, 'KnownFragmentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.KnownFragmentNamesRule;
	  }
	});
	Object.defineProperty(exports, 'KnownTypeNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.KnownTypeNamesRule;
	  }
	});
	Object.defineProperty(exports, 'LoneAnonymousOperationRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.LoneAnonymousOperationRule;
	  }
	});
	Object.defineProperty(exports, 'NoFragmentCyclesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.NoFragmentCyclesRule;
	  }
	});
	Object.defineProperty(exports, 'NoUndefinedVariablesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.NoUndefinedVariablesRule;
	  }
	});
	Object.defineProperty(exports, 'NoUnusedFragmentsRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.NoUnusedFragmentsRule;
	  }
	});
	Object.defineProperty(exports, 'NoUnusedVariablesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.NoUnusedVariablesRule;
	  }
	});
	Object.defineProperty(exports, 'OverlappingFieldsCanBeMergedRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.OverlappingFieldsCanBeMergedRule;
	  }
	});
	Object.defineProperty(exports, 'PossibleFragmentSpreadsRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.PossibleFragmentSpreadsRule;
	  }
	});
	Object.defineProperty(exports, 'ProvidedNonNullArgumentsRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.ProvidedNonNullArgumentsRule;
	  }
	});
	Object.defineProperty(exports, 'ScalarLeafsRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.ScalarLeafsRule;
	  }
	});
	Object.defineProperty(exports, 'SingleFieldSubscriptionsRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.SingleFieldSubscriptionsRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueArgumentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueArgumentNamesRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueDirectivesPerLocationRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueDirectivesPerLocationRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueFragmentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueFragmentNamesRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueInputFieldNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueInputFieldNamesRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueOperationNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueOperationNamesRule;
	  }
	});
	Object.defineProperty(exports, 'UniqueVariableNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.UniqueVariableNamesRule;
	  }
	});
	Object.defineProperty(exports, 'VariablesAreInputTypesRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.VariablesAreInputTypesRule;
	  }
	});
	Object.defineProperty(exports, 'VariablesInAllowedPositionRule', {
	  enumerable: true,
	  get: function get() {
	    return _validation.VariablesInAllowedPositionRule;
	  }
	});
	
	var _error = __webpack_require__(4);
	
	Object.defineProperty(exports, 'GraphQLError', {
	  enumerable: true,
	  get: function get() {
	    return _error.GraphQLError;
	  }
	});
	Object.defineProperty(exports, 'formatError', {
	  enumerable: true,
	  get: function get() {
	    return _error.formatError;
	  }
	});
	
	var _utilities = __webpack_require__(623);
	
	Object.defineProperty(exports, 'introspectionQuery', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.introspectionQuery;
	  }
	});
	Object.defineProperty(exports, 'getOperationAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.getOperationAST;
	  }
	});
	Object.defineProperty(exports, 'buildClientSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildClientSchema;
	  }
	});
	Object.defineProperty(exports, 'buildASTSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildASTSchema;
	  }
	});
	Object.defineProperty(exports, 'buildSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.buildSchema;
	  }
	});
	Object.defineProperty(exports, 'extendSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.extendSchema;
	  }
	});
	Object.defineProperty(exports, 'printSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.printSchema;
	  }
	});
	Object.defineProperty(exports, 'printIntrospectionSchema', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.printIntrospectionSchema;
	  }
	});
	Object.defineProperty(exports, 'printType', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.printType;
	  }
	});
	Object.defineProperty(exports, 'typeFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.typeFromAST;
	  }
	});
	Object.defineProperty(exports, 'valueFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.valueFromAST;
	  }
	});
	Object.defineProperty(exports, 'astFromValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.astFromValue;
	  }
	});
	Object.defineProperty(exports, 'TypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.TypeInfo;
	  }
	});
	Object.defineProperty(exports, 'isValidJSValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isValidJSValue;
	  }
	});
	Object.defineProperty(exports, 'isValidLiteralValue', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isValidLiteralValue;
	  }
	});
	Object.defineProperty(exports, 'concatAST', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.concatAST;
	  }
	});
	Object.defineProperty(exports, 'separateOperations', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.separateOperations;
	  }
	});
	Object.defineProperty(exports, 'isEqualType', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isEqualType;
	  }
	});
	Object.defineProperty(exports, 'isTypeSubTypeOf', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.isTypeSubTypeOf;
	  }
	});
	Object.defineProperty(exports, 'doTypesOverlap', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.doTypesOverlap;
	  }
	});
	Object.defineProperty(exports, 'assertValidName', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.assertValidName;
	  }
	});
	Object.defineProperty(exports, 'findBreakingChanges', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.findBreakingChanges;
	  }
	});
	Object.defineProperty(exports, 'findDangerousChanges', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.findDangerousChanges;
	  }
	});
	Object.defineProperty(exports, 'BreakingChangeType', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.BreakingChangeType;
	  }
	});
	Object.defineProperty(exports, 'DangerousChangeType', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.DangerousChangeType;
	  }
	});
	Object.defineProperty(exports, 'findDeprecatedUsages', {
	  enumerable: true,
	  get: function get() {
	    return _utilities.findDeprecatedUsages;
	  }
	});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	// Name
	
	var NAME = exports.NAME = 'Name';
	
	// Document
	
	var DOCUMENT = exports.DOCUMENT = 'Document';
	var OPERATION_DEFINITION = exports.OPERATION_DEFINITION = 'OperationDefinition';
	var VARIABLE_DEFINITION = exports.VARIABLE_DEFINITION = 'VariableDefinition';
	var VARIABLE = exports.VARIABLE = 'Variable';
	var SELECTION_SET = exports.SELECTION_SET = 'SelectionSet';
	var FIELD = exports.FIELD = 'Field';
	var ARGUMENT = exports.ARGUMENT = 'Argument';
	
	// Fragments
	
	var FRAGMENT_SPREAD = exports.FRAGMENT_SPREAD = 'FragmentSpread';
	var INLINE_FRAGMENT = exports.INLINE_FRAGMENT = 'InlineFragment';
	var FRAGMENT_DEFINITION = exports.FRAGMENT_DEFINITION = 'FragmentDefinition';
	
	// Values
	
	var INT = exports.INT = 'IntValue';
	var FLOAT = exports.FLOAT = 'FloatValue';
	var STRING = exports.STRING = 'StringValue';
	var BOOLEAN = exports.BOOLEAN = 'BooleanValue';
	var NULL = exports.NULL = 'NullValue';
	var ENUM = exports.ENUM = 'EnumValue';
	var LIST = exports.LIST = 'ListValue';
	var OBJECT = exports.OBJECT = 'ObjectValue';
	var OBJECT_FIELD = exports.OBJECT_FIELD = 'ObjectField';
	
	// Directives
	
	var DIRECTIVE = exports.DIRECTIVE = 'Directive';
	
	// Types
	
	var NAMED_TYPE = exports.NAMED_TYPE = 'NamedType';
	var LIST_TYPE = exports.LIST_TYPE = 'ListType';
	var NON_NULL_TYPE = exports.NON_NULL_TYPE = 'NonNullType';
	
	// Type System Definitions
	
	var SCHEMA_DEFINITION = exports.SCHEMA_DEFINITION = 'SchemaDefinition';
	var OPERATION_TYPE_DEFINITION = exports.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';
	
	// Type Definitions
	
	var SCALAR_TYPE_DEFINITION = exports.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';
	var OBJECT_TYPE_DEFINITION = exports.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';
	var FIELD_DEFINITION = exports.FIELD_DEFINITION = 'FieldDefinition';
	var INPUT_VALUE_DEFINITION = exports.INPUT_VALUE_DEFINITION = 'InputValueDefinition';
	var INTERFACE_TYPE_DEFINITION = exports.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';
	var UNION_TYPE_DEFINITION = exports.UNION_TYPE_DEFINITION = 'UnionTypeDefinition';
	var ENUM_TYPE_DEFINITION = exports.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';
	var ENUM_VALUE_DEFINITION = exports.ENUM_VALUE_DEFINITION = 'EnumValueDefinition';
	var INPUT_OBJECT_TYPE_DEFINITION = exports.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';
	
	// Type Extensions
	
	var TYPE_EXTENSION_DEFINITION = exports.TYPE_EXTENSION_DEFINITION = 'TypeExtensionDefinition';
	
	// Directive Definitions
	
	var DIRECTIVE_DEFINITION = exports.DIRECTIVE_DEFINITION = 'DirectiveDefinition';

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = invariant;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function invariant(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var YAMLException = __webpack_require__(75);
	
	var TYPE_CONSTRUCTOR_OPTIONS = [
	  'kind',
	  'resolve',
	  'construct',
	  'instanceOf',
	  'predicate',
	  'represent',
	  'defaultStyle',
	  'styleAliases'
	];
	
	var YAML_NODE_KINDS = [
	  'scalar',
	  'sequence',
	  'mapping'
	];
	
	function compileStyleAliases(map) {
	  var result = {};
	
	  if (map !== null) {
	    Object.keys(map).forEach(function (style) {
	      map[style].forEach(function (alias) {
	        result[String(alias)] = style;
	      });
	    });
	  }
	
	  return result;
	}
	
	function Type(tag, options) {
	  options = options || {};
	
	  Object.keys(options).forEach(function (name) {
	    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
	      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	    }
	  });
	
	  // TODO: Add tag format check.
	  this.tag          = tag;
	  this.kind         = options['kind']         || null;
	  this.resolve      = options['resolve']      || function () { return true; };
	  this.construct    = options['construct']    || function (data) { return data; };
	  this.instanceOf   = options['instanceOf']   || null;
	  this.predicate    = options['predicate']    || null;
	  this.represent    = options['represent']    || null;
	  this.defaultStyle = options['defaultStyle'] || null;
	  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
	
	  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
	    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	  }
	}
	
	module.exports = Type;


/***/ }),
/* 19 */,
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Grid = __webpack_require__(820);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Grid).default;
	  }
	});
	Object.defineProperty(exports, 'Grid', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Grid).default;
	  }
	});
	
	var _accessibilityOverscanIndicesGetter = __webpack_require__(821);
	
	Object.defineProperty(exports, 'accessibilityOverscanIndicesGetter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_accessibilityOverscanIndicesGetter).default;
	  }
	});
	
	var _defaultCellRangeRenderer = __webpack_require__(336);
	
	Object.defineProperty(exports, 'defaultCellRangeRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_defaultCellRangeRenderer).default;
	  }
	});
	
	var _defaultOverscanIndicesGetter = __webpack_require__(337);
	
	Object.defineProperty(exports, 'defaultOverscanIndicesGetter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_defaultOverscanIndicesGetter).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 23 */,
/* 24 */,
/* 25 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = whitespace;
	
	var fromCode = String.fromCharCode;
	var re = /\s/;
	
	/* Check if the given character code, or the character
	 * code at the first character, is a whitespace character. */
	function whitespace(character) {
	  return re.test(
	    typeof character === 'number' ? fromCode(character) : character.charAt(0)
	  );
	}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(2));
		else if(typeof define === 'function' && define.amd)
			define(["React"], factory);
		else if(typeof exports === 'object')
			exports["graphcool-styles"] = factory(require("react"));
		else
			root["graphcool-styles"] = factory(root["React"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// identity function for calling harmory imports with the correct context
	/******/ 	__webpack_require__.i = function(value) { return value; };
	
	/******/ 	// define getter function for harmory exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		Object.defineProperty(exports, name, {
	/******/ 			configurable: false,
	/******/ 			enumerable: true,
	/******/ 			get: getter
	/******/ 		});
	/******/ 	};
	
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 9);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var React = __webpack_require__(8);
	var objectAssign = __webpack_require__(6);
	__webpack_require__(5);
	var Icon = (function (_super) {
	    __extends(Icon, _super);
	    function Icon(props) {
	        var _this = _super.call(this, props) || this;
	        var src = _this.props.src;
	        var match = src.match(/data:image\/svg[^,]*?(;base64)?,(.*)/);
	        if (match && match[1] && match[2]) {
	            src = atob(match[2]);
	        }
	        if (src.match(/\.svg$/)) {
	            src = null;
	            _this.fetch();
	        }
	        _this.state = {
	            src: src,
	        };
	        return _this;
	    }
	    Icon.prototype.componentWillReceiveProps = function (nextProps) {
	        if (nextProps.src && nextProps.src.match(/\.svg$/)) {
	            this.fetch(nextProps);
	        }
	        else {
	            this.setState({ src: nextProps.src });
	        }
	    };
	    Icon.prototype.fetch = function (props) {
	        var _this = this;
	        if (props === void 0) { props = this.props; }
	        fetch(props.src)
	            .then(function (res) { return res.text(); })
	            .then(function (src) {
	            _this.setState({ src: src });
	        });
	    };
	    Icon.prototype.render = function () {
	        var src = this.state.src;
	        if (!src) {
	            return null;
	        }
	        var width = this.props.width || 16;
	        var height = this.props.height || 16;
	        var color = this.props.color || '#000';
	        var stroke = this.props.stroke || false;
	        var strokeWidth = this.props.strokeWidth || 1;
	        var rotate = this.props.rotate || 0;
	        var fillCode = !stroke ? "fill=\"" + color + "\"" : 'fill="none"';
	        var strokeCode = stroke ? "stroke=\"" + color + "\" stroke-width=\"" + strokeWidth + "px\"" : 'stroke="none"';
	        var styleCode = "style=\"width: " + width + "px; height: " + height + "px;\"";
	        var html = src.replace(/<svg/, "<svg " + strokeCode + " " + fillCode + " " + styleCode);
	        var restProps = objectAssign({}, this.props);
	        delete restProps.width;
	        delete restProps.height;
	        delete restProps.stroke;
	        delete restProps.strokeWidth;
	        delete restProps.color;
	        delete restProps.src;
	        delete restProps.className;
	        return (React.createElement("i", __assign({}, restProps, { className: this.props.className, style: {
	                transform: "rotate(" + rotate + "deg)",
	                WebkitTransform: "rotate(" + rotate + "deg)",
	                display: 'flex',
	            }, dangerouslySetInnerHTML: { __html: html } })));
	    };
	    return Icon;
	}(React.PureComponent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Icon;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
	"use strict";
	"use strict";
	exports.black = '#000';
	exports.white = '#fff';
	exports.green = 'rgba(39,174,96,1)';
	exports.blue = 'rgba(42,126,210,1)';
	exports.darkBlue = 'rgba(23,42,58,1)';
	exports.darkerBlue = 'rgba(15,32,46,1)';
	exports.darkestBlue = 'rgb(11,20,28)';
	exports.orange = 'rgba(207,92,54,1)';
	exports.red = 'rgba(242,92,84,1)';
	exports.accent = '#00b861';
	exports.lightGreen = 'rgba(42,189,60,1)';
	exports.lightBlue = 'rgba(74,183,255,1)';
	exports.pink = 'rgb(224,0,130)';
	exports.pink10 = 'rgba(224,0,130,0.1)';
	exports.pink20 = 'rgba(224,0,130,0.2)';
	exports.pink30 = 'rgba(224,0,130,0.3)';
	exports.pink40 = 'rgba(224,0,130,0.4)';
	exports.pink50 = 'rgba(224,0,130,0.5)';
	exports.pink60 = 'rgba(224,0,130,0.6)';
	exports.pink70 = 'rgba(224,0,130,0.7)';
	exports.pink80 = 'rgba(224,0,130,0.8)';
	exports.pink90 = 'rgba(224,0,130,0.9)';
	exports.lightYellow = 'rgba(252,246,169,1)';
	exports.lightYellow20 = 'rgba(252,246,169,0.2)';
	exports.lightBrown = 'rgba(209,167,0,1)';
	exports.toggleGreen = 'rgba(126, 211, 33, 1)';
	exports.green0 = 'rgba(39,174,96,0)';
	exports.green50 = 'rgba(39,174,96,.5)';
	exports.lighterGreen = 'rgb(210, 242, 214)';
	exports.lightGreen05 = 'rgba(42,189,60,.05)';
	exports.lightGreen10 = 'rgba(42,189,60,.1)';
	exports.lightGreen20 = 'rgba(42,189,60,.2)';
	exports.lightGreen30 = 'rgba(42,189,60,.3)';
	exports.lightGreen50 = 'rgba(42,189,60,.5)';
	exports.blue0 = 'rgba(42,126,210,0)';
	exports.blue10 = 'rgba(42,126,210,.1)';
	exports.blue20 = 'rgba(42,126,210,.2)';
	exports.blue50 = 'rgba(42,126,210,.5)';
	exports.blue80 = 'rgba(42,126,210,.8)';
	exports.darkBlue0 = 'rgba(23,42,58,0)';
	exports.darkBlue02 = 'rgba(23,42,58,.02)';
	exports.darkBlue04 = 'rgba(23,42,58,.04)';
	exports.darkBlue05 = 'rgba(23,42,58,.05)';
	exports.darkBlue06 = 'rgba(23,42,58,.06)';
	exports.darkBlue07 = 'rgba(23,42,58,.07)';
	exports.darkBlue10 = 'rgba(23,42,58,.10)';
	exports.darkBlue20 = 'rgba(23,42,58,.20)';
	exports.darkBlue30 = 'rgba(23,42,58,.30)';
	exports.darkBlue40 = 'rgba(23,42,58,.40)';
	exports.darkBlue50 = 'rgba(23,42,58,.5)';
	exports.darkBlue60 = 'rgba(23,42,58,.6)';
	exports.darkBlue70 = 'rgba(23,42,58,.7)';
	exports.darkBlue80 = 'rgba(23,42,58,.8)';
	exports.darkBlue90 = 'rgba(23,42,58,.9)';
	exports.darkerBlue0 = 'rgba(15,32,46,0)';
	exports.darkerBlue50 = 'rgba(15,32,46,.5)';
	exports.orange0 = 'rgba(207,92,54,0)';
	exports.orange50 = 'rgba(207,92,54,.5)';
	exports.red0 = 'rgba(242,92,84,0)';
	exports.red10 = 'rgba(242,92,84,.1)';
	exports.red20 = 'rgba(242,92,84,.2)';
	exports.red30 = 'rgba(242,92,84,.3)';
	exports.red40 = 'rgba(242,92,84,.4)';
	exports.red50 = 'rgba(242,92,84,.5)';
	exports.darkBlueGray = 'rgba(9,20,28,1)';
	exports.gray02 = 'rgba(0,0,0,0.02)';
	exports.gray04 = 'rgba(0,0,0,0.04)';
	exports.gray07 = 'rgba(0,0,0,0.07)';
	exports.gray10 = 'rgba(0,0,0,0.1)';
	exports.gray20 = 'rgba(0,0,0,0.2)';
	exports.gray30 = 'rgba(0,0,0,0.3)';
	exports.gray40 = 'rgba(0,0,0,0.4)';
	exports.gray50 = 'rgba(0,0,0,0.5)';
	exports.gray60 = 'rgba(0,0,0,0.6)';
	exports.gray70 = 'rgba(0,0,0,0.7)';
	exports.gray80 = 'rgba(0,0,0,0.8)';
	exports.gray90 = 'rgba(0,0,0,0.9)';
	exports.white04 = 'rgba(255,255,255,0.04)';
	exports.white07 = 'rgba(255,255,255,0.07)';
	exports.white10 = 'rgba(255,255,255,0.1)';
	exports.white20 = 'rgba(255,255,255,0.2)';
	exports.white30 = 'rgba(255,255,255,0.3)';
	exports.white40 = 'rgba(255,255,255,0.4)';
	exports.white50 = 'rgba(255,255,255,0.5)';
	exports.white60 = 'rgba(255,255,255,0.6)';
	exports.white70 = 'rgba(255,255,255,0.7)';
	exports.white80 = 'rgba(255,255,255,0.8)';
	exports.white90 = 'rgba(255,255,255,0.9)';
	exports.purple = 'rgba(164,3,111,1)';
	exports.purple20 = 'rgba(164,3,111,.2)';
	exports.lightOrange = 'rgba(241,143,1,1)';
	exports.lightOrange10 = 'rgba(241,143,1,.1)';
	exports.lightOrange20 = 'rgba(241,143,1,.2)';
	exports.lightOrange30 = 'rgba(241,143,1,.3)';
	exports.lightGray = 'rgba(195,191,196)';
	exports.pblue = 'rgba(74,144,226,1)';
	exports.pblue20 = 'rgba(74,144,226,0.2)';
	exports.pred = 'rgba(208,2,27,1)';
	exports.pred20 = 'rgba(208,2,27,0.2)';
	exports.pbrown = 'rgba(174,145,0,1)';
	exports.pyellow40 = 'rgba(248,231,28,0.4)';
	exports.pgreen = 'rgba(39,174,96,1)';
	exports.plightgreen50 = 'rgba(184,233,134,0.5)';
	exports.size04 = '4px';
	exports.size06 = '6px';
	exports.size10 = '10px';
	exports.size16 = '16px';
	exports.size25 = '25px';
	exports.size38 = '38px';
	exports.size60 = '60px';
	exports.size96 = '96px';
	exports.size12 = '12px';
	exports.size14 = '14px';
	exports.copyLineheight = '1.5';
	exports.titleLineheight = '1.3';
	exports.duration = '.1s';
	exports.size32 = '32px';
	exports.size30 = '30px';
	exports.size20 = '20px';
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	// removed by extract-text-webpack-plugin
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	// removed by extract-text-webpack-plugin
	module.exports = {"cover":"_10FW4QcCx4hka4m0qKKeK5","contain":"_1LuPjFJhHsh_9VzEsByA9x","bbox":"_1r_MN90NHKKHQpyvVfC54j","cbox":"cuuFrKRDWD35Pnb5EbBeC","bgCenter":"_3YeaAMWQHF1tuwhAm1seW2","bgTop":"_3YLbBlahtqRnwMLOwiCAyK","bgRight":"_28sjOE__HNAreQ6wWD6A0u","bgBottom":"_1FXbTMQ0eVDqjhd5C6MLtO","bgLeft":"y9VsMdsk53iF1rYcBmBXY","outline0":"_2Ejg1pjGXZAAKDo_-okvzh","ba":"_1kdAhj1hbgBk_qQd2PG51r","bt":"_1a-o6MR9N_5wNXbBxMXU4T","br":"_3ASZ_8V44fhhZ0WhqC2bTL","bb":"_3q-lFMNQ7rOI9otwjX994K","bl":"_3ZPIFTryWchKG0qIxUo4K7","bn":"_3mG4xjhvBYRe54t10v3ffx","bWhite":"_1DFjBqMTVlhZmYpGYxWSeV","bWhite90":"wNxU4Msdf7AxqMd66TX5-","bWhite80":"_28zdkubue7Wzv_mqPiBK0k","bWhite70":"_1LybuyoQQws7Rf2XDJA5vY","bWhite60":"_3BvPxROpgUlpmN3S-cDDNd","bWhite50":"_2I9auJAV7Tot7RR5WHWn1x","bWhite40":"PH8Nd2rkhvRhc9oy59KIq","bWhite30":"_1JjOor62ETpUWDJ_HjRkIZ","bWhite20":"_2JeJ2fIBzC6M2xmDsYRJnE","bWhite10":"_2rS7DTem_uGNzWIZRTIeku","bWhite05":"_1D2lAuS38XdOAfqs7GQXKa","bBlack":"_3JMbbNtAzJX7UJ4tsCpUkt","bBlack90":"_2x_HWjzYpmrF695In0TYJd","bBlack80":"_2dw6_f5aZ_RrUzSPZAzGAH","bBlack70":"_1wP0Vs0S5rjTrkfssZtrYr","bBlack60":"_3EokjGlLZlS9kZRNydbvLN","bBlack50":"_1bCU6egGJOxAM35wDoHE40","bBlack40":"BeK9KhwqDP-ArkQoOIQcE","bBlack30":"_1-4DteDNUKS8qkg2ntdU1E","bBlack20":"_1AMPsL8puPDey4kJe3HQkw","bBlack10":"_1Zy3gYduWwo-7QWxoAvA4x","bBlack05":"_2FIeoXv1IcPTw_hfbcr-KL","bGreen":"_1hxEIvBQQmvclIOo8GXcev","bGreen50":"_3H5xfG2DoAyU8QoCJVhnEt","bBlue":"dKsmkXqeMmLQNHD0zBzp4","bDarkBlue":"_2-1OjUvIanwzGhUrBxSp-U","bDarkBlue90":"_1IJyHdt-X8ZLN5b7_lqymW","bDarkBlue80":"_2cHXWprz9LiukPGnTbWb9M","bDarkBlue70":"_1CNjc8bmxZOfTc0bO6z43J","bDarkBlue60":"_24KkcSQwjH6OilmwdPTlNP","bDarkBlue50":"_2I9IYYFiX7pKqwNpbWwYM-","bDarkBlue40":"_27DnNuLsvX2Xz1aFTm4A_R","bDarkBlue30":"cWrPkV_1XpW6EOpSyQQVN","bDarkBlue20":"_25jXXtOZQiNO5bpWJ_pAEh","bDarkBlue10":"_135sACcML-9iC6ZCZmqgNx","bDarkBlue06":"_3pEyLMmR5ysIV0v8_iTulA","bDarkBlue05":"_2BVKOjxz0mLfKBjDtQMT9k","bDarkerBlue":"_3XZjiemKD7JyShfJFmaBaU","bRed":"_1gEHLYB0kmT3eAzO2zJNME","bRed10":"_2GAtAs6kNpG1wCUXkmzrlv","bRed20":"_2SzczH-3GZWGcJMt_wdGzX","bRed30":"_1YR-Ow91ILIacqOgx83cum","bLightOrange":"_2MF-DU_9bF0D_xOfctrTMp","bLightOrange10":"_39PS2adXciPOnphqnYkkc8","bLightOrange20":"_30_FzqB1GpkN_M3dTwhwE5","bLightOrange30":"_3t-fW640WSz78o9SXlHdx6","br0":"zKHLpV-Lbn8HQFbwOVYuL","br1":"_3VfU_TXAvGQwLPrXT7FWkH","br2":"_27Qzs-o0QwC0Aq3H2-qs_7","overlay":"vISW1aTdstPXK90JlKDbk","uppercaseButton":"_2Px2VcxEZte7Cdw3imZ_O6","br100":"_1FtHSMBJ6K-KJ2yq6HMoa3","brPill":"_1xW-awe-94xoLkM3EvaNOq","brBottom":"_2JmjCanTJAXGALD5y4wJic","brTop":"_3tcuZjDOSBIxuUEFJFtB0q","brRight":"_3Ud4hTA_mb2AEOTLcKJ15w","brLeft":"_30FfN3JecOglXB08Sx6tLh","bDotted":"_3OE5SuGRebKAf6DExo3Kmx","bDashed":"_27vJz3rWfl7N06M-zDeuiu","bSolid":"_1TDzvTWajZi1IcO6NM7nAn","bNone":"_31shiPUCV_iB4S5aXY_IXz","bw0":"_3WdvQYmaCpCvtUV8wyKLDj","bw1":"_3JTR6VC5_0d2caXkPRu12j","bw2":"_2scIzgAJ6gFn9JGGbi2v9s","bt0":"_2_mn-Q043iL3J23rKkoPPO","bb0":"_1GSC5aIY5Ic83oHiUKaPZH","bl0":"VKiNA_kwScqRnW0OGenkE","buttonShadow":"_35wBjEjU02ZagLblAg72x","overlayShadow":"_3M1p4nTGLlXx3Fygd2qEoY","pre":"_1Z8BjDxlEdjf0Qx4C2C2yY","top0":"_1JMSrpyWcsrF0YTuLngw8","top4":"BWHz4FQxWJTyu4jOH9FmY","top6":"U4QtS8PQTbj9XfwGQBDgr","top10":"_13znEvZMzG-txhoha5MVLk","top16":"zs1L52G3bNNp8l2IhEdfs","top25":"_8aIUDytXkHXBl2cwaiijg","top38":"LOzS2NuMbhBxFUIPgBspY","top60":"_1Pv6tA88lgbneHzHTkSTP6","top96":"_1MJwmOBCBVyBWfYuG2LX2o","top50":"_2CVMYteoFRhMy-bmhWSZ90","top100":"aDK1HodgK9EKieeoycBhW","right0":"wrts3hfzxzV_UIEmpZyuN","right4":"_3NGOJcU9ZdkGBnpQ6Ec5ez","right6":"jeBUVNYOkrPNwoxddDHJF","right10":"_2cmkpUIDxFa8rNUozB5uwx","right16":"_2OWWYsf78zwpkW-TTZPXEf","right25":"DGal8xBiAPXyI5OxyipMs","right38":"_1SDiWNIG8HiSK-SXauRxmW","right60":"_1kMc5NxEH1-DBOjwv5TD4K","right96":"_2V-aARNXJdKNZzAQdNVwQf","right50":"_3koFoMXCEHR9snEGdOAQYK","right100":"_2m6j75LO8SUDTBhqBqD8OW","bottom0":"VsXyP77qSgAjiIBGPHXxb","bottom4":"_2e3RmtPd5cw3utrg0SXEeH","bottom6":"_19zBYXg1vyvcKi--v6BsVc","bottom10":"_1ETV6toHwBnzcRttty39K2","bottom16":"L0JkbyD4xchtSxL4OS_wq","bottom25":"_3qgj8ymVeuZwB5sxzj7Rum","bottom38":"_3PUr-0DoB5DFJ6FV8WkmfR","bottom60":"_1Ek7pAG8ABKTtdz-8I3jcz","bottom96":"_1Fushh54fHr5j3qJDv-Xlm","bottom50":"_2eDT8z6CJ0DEA-3izSQbSu","bottom100":"_3j5gQ7-4KKcWAFZPoijSjF","left0":"_2doYfrjcP0xGrYFa_CvITH","left4":"_1gh9Zi6rexLxgo2jcJvtBd","left6":"_3_CJY_qoCuWY1VE8n9qid3","left10":"_1d11OYszcXat8IiKJyY8_E","left16":"qtiQV0ytQvC4815ss8QD1","left25":"_38iOjKGWH453C6Z3c-_l6e","left38":"viWOtbc97nweE_sJLBRaR","left60":"_2eJT4Y1QrzF0D66xT06AOh","left96":"_2omNC3p9k9dyosOn2tpQuC","left50":"_3I853d9j2Rl799G50vtqxW","left100":"_25i4hOJ82FgJ0v54Ew5VDW","absoluteFill":"_15YGwY3qYoi360D2Ih5zKo","tlCenter":"_2vAAhhjpQLJL21_MCEG_kV","tlHCenter":"_3ZFILtFhGSsdHtc0geZ8-z","tlVCenter":"QdA9UWwdQMbwjMKxLIPY4","dn":"_17j995rfWsmQIFGDJQ6XdS","di":"EaROI91t1vPRMOIRfTiEk","db":"_25p8vinkYbRFafxLtWtjU8","dib":"pTuotAhPR3-f0-LVOqBlx","dit":"_3yjp4v6UisybPRTPAcFl_E","dt":"_25-DUscSuAz8KpFy44cOf-","dtc":"_2_iDea9XRJL4Go1PZKSUP6","dtRow":"_2hX0udmOextLQZPbQSXzCC","dtRowGroup":"_3yR0vOFlHTPhqdWbNYJMRv","dtColumn":"_3QODXfcn_JSDVrk2wIt0DY","dtColumnGroup":"X0Tqg8wSjibKtegQr-rLW","dtFixed":"_3blXNR94uBOcBjLfm5y1QT","flex":"_3GuTSrHKwjo6PCyBxYcCcH","inlineFlex":"KwBvZoOjlxgnPOvm9KQzj","flex1":"_3rbVNh-XyLw5nfqfVDnJx_","flexAuto":"_27fVgoi0x7Ye5YsXvxnnID","flexFixed":"_1A5NwlFKNpx74hgHN3jnL7","flexSlide":"_1hOVN7CIQLQdgRwtuxSu4p","flexNone":"_23aJRTTsjVbymXj3EIO_NS","flexColumn":"YHeFsjXY5Bc7hHDVK_drA","flexRow":"_1dvw4W3Pi8mH6OELHUrpj2","flexWrap":"_3md39j-0qcoL921KWobGT2","itemsStart":"ehvqV-ccyehRrgy85DJr7","itemsEnd":"E_ZwMZo3FgBYywy4dUbGb","itemsCenter":"_3ydaqxSyN2UbWoMv-UPSZM","itemsBaseline":"_3AYnfQEFbB2wWZIT6bKSTb","itemsStretch":"_10oQTMBE1xjOCeuEdSg6pp","selfStart":"_8uTvBRUvyxrknbLjsrNnh","selfEnd":"_31hDWl_QUP1CCXTT6as4d6","selfCenter":"_2ctKOLoNC5vEnj66k984SZ","selfBaseline":"_2s7nf9JLmnh-TgGMlss1yI","selfStretch":"_3Z-UQq_4cQnyJixX14wE7k","justifyStart":"_2b1wuzOYM_Qqxd4Bk-up2K","justifyEnd":"M05wVZrYpSfNbf4X3f_AQ","justifyCenter":"ZFjflJkQFo7_PealgUwo2","justifyBetween":"_3Jnm8XUq9GBgVmd4tcjMJP","justifyAround":"_1dK4AMXg3LRH5yNA384Xio","contentStart":"KI_DJ4-f2HrNHlfmL-iJd","contentEnd":"_3AaPhUvxjAo-_FgMLb_6A-","contentCenter":"_2YOt4zSUZL6dPovM0jALrK","contentBetween":"_13Asmx5fg4ZJOu5vvja49G","contentAround":"_2t6PEs1PZBB4jaxS_z03Al","contentStretch":"_2Wc-JcrRXzN0PVNOW_uyVy","order0":"Y42gC5SSDvAobJTQDv4XR","order1":"_3w2h02nn_ywPMrkr4wR9iv","order2":"_2CGlAwKY8i6h-jEBbKSGSU","order3":"_1cRE2wAKtVlIazunFyDOLz","order4":"_2O7kU-2r2YXXJVEb5cjCYZ","order5":"puwwCU_Xka2fcap_IHizl","order6":"_3jGhMspAENAXT0Me-_YZrC","order7":"_1ofEMZRlL2h9j9PaIDVdEh","order8":"_3CAbOvcqJ7TGXQFf3yP0KR","orderLast":"_23pdtJhQLCoCFImkt-R4jH","sansSerif":"_2N9l-k94VywJzM5RlH655","code":"_24dmIHzYCMNRbWVT5TsREj","i":"_1N2u6z1vTBt3LLRcmYa__P","fsNormal":"_2AA-GJIDsP4Iy62dIx59wp","normal":"gogg7bXBqKjzN6FS6JzG-","b":"_1nWu1dmDBwenl9S06y31u3","fw3":"_3xcNz6tSpi-OCTkR3f68pg","fw4":"_2gwpv-keeAS7XidqsHeplu","fw5":"_3v4HErAltpbSn15dBRFDSK","fw6":"_3qeKFHcrvc1gagJ4SdQMCN","uppercaseLabel":"_3xzqYqZb7Rqt6q6z5aM2RI","fw7":"_2mpBymPixd6__-dGMPQ3k6","inputReset":"IQ-Tx8cW3tr9yGDmcRMKW","buttonReset":"rPkH_NAQ7_a1KT9Ve_xsb","h100":"OylKyb9EtT_7WunfrjSao","minH100":"Mx6ayEva5foz0chjrk4SH","vh100":"_2UXkfnaAszhDFkWlXT5rq3","minVh100":"_1gWvEQwpFpSQfiPQKNaJ8-","hAuto":"_1EGbcgSqMuqi0Kw_b1NqzP","hInherit":"_2iAJs6-0mvSlUaXTw5UB2S","mono":"_3sGwyiRyN-hoDVe0Jy1p_8","tracked":"Ic7Sg0exE6bblMV9Ab_0e","lhSolid":"_2W5LXL6YRlTKjYODYnGT6k","lhTitle":"_1p6gKnYvQMNfbIr4TNaiKv","lhCopy":"_3SrpRseGYxRM_cLzX4g90o","link":"_3jckzILLbynTzZMq0uJ_Z_","list":"_287zrnHjtdLjlnK5_Ohsn","mw100":"_2VZBdt53SFy4ToRYmn8QKv","mwNone":"_1sOKa7AXZnvuGpjk55bodj","w10":"Ta_ugO36ARSqJNQey9l18","w20":"_3i5fn6KtJcGDzsTNyOYYHd","w25":"_2jHUsMSkuHzhHd9U1bUKKX","w30":"WTn5lD4CNnAkw6EMEonZi","w40":"K5TCrZCgc9d0CNafLLLm9","w50":"_1xuGsp_FQxBVLO3bPu99GC","w60":"Ia2Au5_R3tJCIxxjAz6dC","w70":"_2lPoDwprfCuML3rQTa1J4y","w75":"_3Nit-T0_Ti1u-igY_iQsUu","w80":"_1vsG0Kd5kGi3aSFDaiix89","w90":"_3rmbBG6WLRdo76O9PjmpbY","w100":"DCxtikbu074qee0UxmgBt","wThird":"egsRFyovoMblOKRZdVd2J","wTwoThirds":"_3UscRmyqaGcl0IQLRvGGJz","wAuto":"_2LDYjQDBJxzWLP6XbXO_wN","hS04":"_2-4CPqwCMJLu-CtNJGrQOE","hS06":"_2Dk7wIWtO7MEUz-4Z3auqD","hS10":"_28vh-KvCFQABPMjenvxFMF","hS12":"_2r-49NIu4NSHS1MYm3EE_X","hS16":"_1c4VMf5feOrnpuEhMWfk7d","hS20":"_2muzpfMdIloyw1AwkP_bqG","hS25":"aJmWctWALQK7yo6H9bNju","hS38":"_2In7Eeril1DlE9jzbNXYp8","hS60":"_2MGeu79E8UdvLi8RQK6FAI","hS96":"uhXCr4YbF83lFmKk4FVDr","wS04":"t_UQMFmO8A5ANEqg8cByH","wS06":"Ll4aMh1kGQ2MLyaqf8aQs","wS10":"_1FMS5bxCeTMWqLDOOhTbF0","wS12":"fLnBWAs_3QCCxKQqolpSQ","wS16":"_6YqlmCoMwSRRp1KpNstgs","wS20":"_2Re784g9DnyJwSu2DrDH7o","wS25":"oLJ136x8Dmr9GTRGbXUjT","wS38":"_36yVs7pMpYZ_SYpu4Igclx","wS60":"_1OForozThDw5EZzfLk0RFx","wS96":"_2R8EnF4xiu5g5EM0xICCIK","overflowVisible":"_26F2Q4DzFNQwIKg3066fpm","overflowHidden":"_195lXLpg18c4zSuVCW0vDN","overflowScroll":"JZwdPEkwR0dHEvlNHogtg","overflowAuto":"_1LIqbZdID-W4ntlHyv_PTL","overflowXVisible":"_1Mn-wlUX9lOr8mijgD4IbM","overflowXHidden":"_2lXofOg-rWdlmxF6drjdlJ","overflowXScroll":"_32mT8XYVnXn7Nh8UX7IHhd","overflowXAuto":"_3Ovu-NEXTWPnxbXfQ5EFmM","overflowYVisible":"_1vAHuwctYKTKljBfN4_Lht","overflowYHidden":"TGdZP2lp9uDChfVWlCTp9","overflowYScroll":"_35zi7_Metv44As_0M2O3RY","overflowYAuto":"iYozZREcEOKb8IV1P43uL","nosb":"_2JjtCckqjucWePpnADbRDR","static":"_3p3DS_VU4jYCdKHvpU1DN5","relative":"_2MPmtfV72o10JZ9ZtlFNC","absolute":"_3AiuHjB7WkaPBh-VbuGEBO","fixed":"RSM_D_U_lsqdd9YyTXmfn","o100":"_2zTFbHvMT8inFjPTugKzOM","o90":"_1OycbEZkbuKVAI54KAh1rx","o80":"_1tPVxp8_94hPbwxyVW6-XN","o70":"_3ptu5RbIkJmseVACTooAwA","o60":"_3Mc97sXRWY2FxZjhmakUsn","o50":"_30h8RdgKnf8SviW0aDlol5","o40":"_2EjpFjF_5zO-8ZsJYVhO3z","o30":"_2qV-LtbNj4f7l9gsoJ0rzt","o20":"_3n6dzou8kwGzEwg3LUTpLg","o10":"_37LmpZ6Y64ABkI9OWHx0GT","o05":"_2fFyryUEsClKmkSaH3YGMP","o025":"_1f2TEHOIgxGVib4ZC-9FRa","o0":"_3hgvzZQ-7T_rPGWqh3ybtJ","black90":"_1cC1H4_Vpx35tV9kF1HQuy","black80":"IdIDBwPvp8Y5Xfx3w2iFx","black70":"_1fGbE3lUWz5Nnv5_CV1CSf","black60":"BbwUmC5EQGgVzTVSffWra","black50":"_3mo0LV4yY0WFRcTp4592T","black40":"_3UTJORqKFNcvsvKfax5N7D","black30":"_3T4eEsqQ5Yi7mFvTFNHkFa","black20":"_2z7CAPUunvizkgW9ra0V7l","black10":"_3vVSOkTEWMUSR8g9Yo7KvJ","lightOrange":"_1RqT4-1sHu28zLTqegnWmU","lightOrange20":"_1srcIva_GDs-ud0sZlRufy","white90":"_9wvkkGW2gz6KceqMGPdD","white80":"vVYH9vB4Pc7I05DTUDQSh","white70":"_24hO5Lk23jVl4AsGYLyByn","white60":"_3vrEDl_yv6I_427bxSCSQ9","white50":"_1tmPhG4vuMMToJ3LiYLfYD","white40":"_3qDncVwGrNHYj6gjSNYusy","white30":"_2Lyea5wAZCju8yPkZgfNXV","white20":"_2rajtQH24rII3oHgpCXCAu","white10":"MkAe9a1ek5Z0k-QSZWlX2","white":"_2RAbAmlD34SzkA4T_IL1Cz","black":"_3KuhvM99A3svAL-DLJRmFU","blue":"_1QcnP4H2rX7dfY6oldZygq","blue20":"_3DgeDVe-mKYWkdv1liNruw","blue50":"_3jEelmilt6iMl6o5zlUgsR","purple":"shJV-hLY33NEK6bCbwflD","lightBlue":"_15FMuV2ijarE0S4MIBnHeq","darkBlue":"_3k_eiwG_vmNf9VIRLDtAL6","darkBlue90":"_2_wfYlhyXZItHiKwa4uiGB","darkBlue80":"_3IJBnFlRDLQrvL9ezYj4b3","darkBlue70":"_1fleMeZ-x8zKiocrC9LRgQ","darkBlue60":"_1g8iGfDT28_m7UOacTy2uD","darkBlue50":"_2PzUkrZ7r2uIfq-IShlvVd","darkBlue40":"YRmEmv0KT3RxWe1ckTzCM","darkBlue30":"_37MmawOGiojiUTo9GehCB5","darkBlue20":"_1z6ScVl6BTOk2dRgwhj6aJ","darkBlue10":"_2o_WhyUaiQJ2Q1Jm1gNWJ2","pink":"_1E5V9K7RKqLqXsJpLR89IK","pink90":"zdaaJVl0KlmmBTgI_ADwE","pink80":"_1hkX1LShnugZTJ-05c5ufa","pink70":"_324uVhha7lXfmnSbWP8M_F","pink60":"_17obkhVjelEFP_1jvNCDDS","pink50":"_1LxdLs78khHt9uALDVEtxh","pink40":"_3fuMAuswxwyDUgpwgnBCga","pink30":"_1hkclN1Pm6oRtiS0c1ccq_","pink20":"_28tPMGbqWWxVLiwtFsepGH","pink10":"-EIyd-gdF7GGpIW7iauR9","darkerBlue":"_3XCxks2tocccGJCwft9FyI","darkerBlue50":"_19sBTQeR30Q1dbbhOxjOPr","orange":"_2EXaTsruJEyXCmQRi3oKEV","red":"_3Oy5w5DIgniXBLrTPYxtVg","green":"_1nWVMizzjfLgBKTaZJDlOW","green30":"_3vCFrFEvtBLK_mMd2uKuNQ","green50":"_2EPoE_GOK3MVrd-_KJPs4Z","lightgreen05":"_32YxtMdQspz0CvIjLC6slt","lightgreen10":"jf6PLcfzAf5DocaP5lHnY","lightgreen20":"_1NEvXlXeRFru5PDuIJ14cf","lightgreen30":"_18UTrg2DgZ94N_bm7wTysa","lightgreen50":"_1d8r-5X2GMc3ksb65Xv6Z_","bgTransparent":"_2_8k6-_OX4CgJ1PXbkj8JU","bgNone":"_2OmdhsT7rSBzjKH_ZZicYW","bgBlack90":"_1iIr8aZgdLh_VrdG9udiuj","bgBlack80":"_2A-ps7Q3vgnmG0u23LHbqP","bgBlack70":"_1qx_eYuXMSPs1BoDZDzjsO","bgBlack60":"_3lgIGnAohPSMelCYGZ2L-E","bgBlack50":"_2DvgSo20cvFKmS3K1DW7Ty","bgBlack40":"_3gcNm1AKvbTeA8iAnnO-vW","bgBlack30":"_3OxIQjtKpHFO9-7Xt1ro4b","bgBlack20":"_11v6cG3UEMqSC5TCTWJEho","bgBlack10":"_1XqsFqsWtIAMACv7AjPSQV","bgBlack07":"_2c1JGswLy0HZSX-DYiq1TL","bgBlack04":"_3htb7-LNONfROwm4aLqe_p","bgBlack02":"_1h0KdHPNntttN21yoVTUM3","bgWhite90":"_1_-VAw4MOE8hZWO2jciQ7A","bgWhite80":"zqrS-G5U4_gNg24uJoht8","bgWhite70":"_81gHVI9gbqtnlhfD34d7x","bgWhite60":"_2bYotXBCDRWN-GLFNOV5yn","bgWhite50":"_1LQ0-PwDSMN27qff3VkRLE","bgWhite40":"_2g0QcWClos0u8Lw9LCPGGD","bgWhite30":"_17NygAoRWXOKQwithS1GS","bgWhite20":"_23oMnTS5UhJfGSgFmhapxd","bgWhite10":"_38ptatkjQmJD5lf_ovEPdB","bgWhite07":"_3kX7fu4YSXDx_6YXuFSTsL","bgWhite04":"_25AI2jNylMeRE_oMFbSnXD","bgBlack":"pYxyhzdblPmnW63lW-zNv","bgWhite":"jXjgZVejWnkDu_mIskk7b","bgBlue":"_2xuOMoVxb3M7CJKyKjL82Z","bgBlue20":"_1yfSNUdpmqwDNNYJk_iDx","bgBlue10":"_7U9H1WOR2_7_qNK0q0I74","bgBlue50":"_1RSNfyMRAYViWzHxSgpt3y","bgDarkBlue":"_1ryqHUyg5xol3TJdMo6oAb","bgDarkBlue90":"_1OKl7QcR5MLrF6QVzlkeiZ","bgDarkBlue80":"HSf6HCTevbRAFaEP4_jIy","bgDarkBlue70":"_1nn8elgKMUlNbXkG0N1Jre","bgDarkBlue60":"_27ATHJ2gsudymGd-hv3QU0","bgDarkBlue50":"_3Mu3_n47hMIUbzXDidnspp","bgDarkBlue40":"_2GFqU91BulJgs7EqQB27vL","bgDarkBlue30":"_23UzPzt0c6JPVld5lnXQzm","bgDarkBlue20":"_1RCJmVnw91f9iMzKiO2Orv","bgDarkBlue10":"e2Knw789cxkmRF1Vvzobf","bgDarkBlue07":"_2yBt4B5YD8bD3f32-dFlML","bgDarkBlue04":"tSbPFPmyOGhjbiqVx3i_x","bgPink":"_1b6YniJPVm_nDgx0YO738_","bgPink90":"aMj-PWo1u1XNsaIhP5lDK","bgPink80":"_1od7uffhyqr77PfRZWgpIF","bgPink70":"O71HUSkmQ2c2xIF4UHi4I","bgPink60":"_3efVmgBvoAt_IM19mZ-OZC","bgPink50":"_3kwfsCnhTuKwrYLB7fuc5t","bgPink40":"gtFti2MtW2Ke68rf8oDJd","bgPink30":"_1x1-C_E1aey85cgZgQzlkV","bgPink20":"_16dhXDdk51ar_Vkknbkqxa","bgPink10":"_2G9M7_I7Ml1uKhUHbuFIYu","bgDarkerBlue":"JCU2gRVLDnH974D1KyPYg","bgDarkestBlue":"_2oRFVjKJLlaJLPRuPaB0t2","bgOrange":"_2mFrWqdpqCtGS5EwmFiMEz","bgRed":"_1fSImSwwq49X9WdEvt3jDY","bgRed10":"_2M8a6d52x6lf1srv_Tg1S_","bgrRed":"_2RqXND-XVHHCLDARzRfayO","bgLightOrange":"_1_H0sjHwuVadcmEAzoU0eB","bgLightOrange10":"_3QRdHS8qmvg_B-enxWcIal","bgLightOrange20":"_3J4DvkagP7p_BHWnq6dwth","bgLightOrange30":"_1K7YSYc0NrZGYeGhoEOErn","bgDarkBlueGray":"nC8Q3CpJ4tgG4FogJHcy_","bgGreen":"_33YBYNfdicj12JzO5V3M__","bgGreen10":"Goe5EQx5Ovf2JEhAcOPK4","bgGreen20":"_6lO9ivDcXQO0Fu8W7ULHl","bgGreen30":"_31V54FQcm3Ji7APEAu3GBv","bgGreen40":"_1vsQgtcmCQxfVImYOiHevD","bgGreen50":"_3wCo-HdE9_hLuFaSPALz6D","bgGreen60":"wnUcMlOcrUof2IWDHNNLq","bgGreen70":"Qp8uEvaIK3oAYyhq4H_qs","bgGreen80":"_1Pbon5GcPd3oc9JFPTpcht","bgGreen90":"U5YCVF8OYkqAd2uSY6wAP","bgLightergreen":"_30GbpK6ptCoouxDTuMKMxT","bgLightgreen05":"CUGfi9CAqI1_RiOUZVj8Y","bgLightgreen10":"-PgYKnmWt9Bmadrtphobp","bgLightgreen20":"XE9Gd8kAgdxLudnjAI1HW","bgLightgreen30":"DwZE52tUdkoiAGFoYYHu2","bgLightgreen50":"_2CiV2Mca9EfHCPsngGkC9c","brown":"_2RfjhAC8ROCsZSG_TY2Voi","bgPblue20":"_3lRjGhp2jr50-VKtP2LjnA","bgPred20":"_2q4xzL3cAp2qhf284wv8gg","bgPyellow40":"_3pA9wvWx_5-Svl4Q3vkNWH","bgPlightgreen50":"_3SR54v4Pw6fK9asY7LWNjh","bgLightGray":"_1FZViqH2Wg_4yjSN0mEV2h","bgPurple":"_1XhVTap00yOKZOGTVUIBU","bgPurple20":"_3RsN6SO2Y4b4glK8lEL4Oi","pa0":"_2KZfQJCx1Oy38jGqsT4Y3N","pa4":"_160fTBlQ4g19DmCHbzpU3S","pa6":"_1AcvKYLZN_12kFAb9SfGIH","pa10":"_1lykGxX323FWUdTrnL5gUE","pa12":"VcRICSLUYhivGHBubhoSz","pa16":"_1xJEpXETb_gBsgwtijtrpp","pa20":"_1InhotFK2UYVLEhpJZCZHE","pa25":"_1jHpNGE0pSknzcw6Dknm4b","pa38":"X8QGQuylbgbUfghZL8hli","pa60":"_3GMw5L6NHvySMQN1DtHDWR","pa96":"_12t4k36183K-00JTpOspTl","ph0":"rg6kRR6lzXP2P6U3t2SfE","ph4":"_3b9zbmUQgouoNzkjnOep8E","ph6":"_1ghU_tqdBD233Mv2kBvqg_","ph10":"_355Xh3fWTg8J69fNjrAsUz","ph12":"_7dupTi4DuxMO8dASlADQG","ph16":"eodgZyhKBhrxfPozUQOBg","ph20":"_1MgsPU58mWJMPhnCT4wDKs","ph25":"eJfVXnHy_PScngY9-U-77","ph38":"_1AIc6bIEULBNHqf8XKSpgZ","ph60":"_1k41OtONoQ-o799KrXuR5Y","ph96":"_3AOBqJX4bEHBEszGpfeGe7","pv0":"_1iHEJvnkjPusyrtvTT8C7e","pv4":"_2aZQ49KBaXL6_oQiN98B4j","pv6":"_3FO6jhB76-ABA7ALGQy6z2","pv8":"ADpMYPlNSHWadKnI2hVJk","pv10":"_1xiRngciIazZO0weMu4jmp","pv12":"_2n32P1b9gyYWK9qdEO7_CI","pv16":"HPpbzpN51W-eB8avunzB6","pv20":"_6ygES_vmwJESLUjS_uAtw","pv25":"_2YY8GCkQYyHvlAqARVTxMH","pv38":"_27Z40BqvBihLkLj3Lb-88M","pv60":"_3Wks68yhXtYyG0-X_SXFiJ","pv96":"_1dh4NijCa943zgpt5hf8eA","pl0":"_14qLJw-4-N5wQpCAy1U0qF","pl4":"_1uQRbV3IlDXo_umie5z0b-","pl6":"_95va4-tHwIlUgXxZNvLew","pl10":"_3q9ouFL8-2aOeu09rIMLPe","pl12":"L4A7UK7mYq5Y1HowUv5Y4","pl16":"_1rvKxjz5Z7su4t1gLt91cU","pl25":"_25Usf6OgQars-HhiwH6p-l","pl38":"_XqHhjpA6VV9Tj8j9oywI","pl60":"_2TUa2Mv87v778MtYIGDBD7","pl96":"_2OThI_iDUXxKxF2QAxigmi","pr0":"nJLoW1tI-_3zWndW1gOV-","pr4":"_--WGP7zYyTXioy73z1dCg","pr6":"_3mgWknTer1yWklkYiGWjh5","pr10":"_6ioXSzid5U46myOWACV6U","pr12":"_3CrTrDKVlLKvUnr0-Toosp","pr16":"_2VzxDHXWsHByZ39IvbtP8m","pr20":"POmqgGP7ylMs0hRXLtRSe","pr25":"_3Xt1l7v76hIoTve8PBkDIF","pr38":"_1lnJMlA75hJXw-jQjEfG0Z","pr60":"eXQ99XyPrPxRD0Fq36xnX","pr96":"_37gK5eWqpYZR5ZJ573B1Un","pt0":"_9g7bUKJOWsbYSEt2dlLyd","pt4":"_3YQb9Oc-j3e_aJxsakGTrA","pt6":"_31-KXui9v6V31W-uZH7xV4","pt10":"_3ARWB_ZV2fpRnFPlYWCCQJ","pt12":"_2vq6kdsymJ6ye-DaLWUV2O","pt16":"_22wEqO5V-BXXuEl6PmRd7V","pt20":"_135tO8hQEgb8S6-BHPJd_8","pt25":"_3QvvSWc_20mXZiKHEZUc7j","pt38":"_23ThnGFgoT7g4-02lNtclH","pt60":"_2Ee369uKrPw1yVsXzwSbyM","pt96":"_2lRgKHOgcw5mWmFxhwxI3n","pb0":"N__g8FDrdykNbox71EhTa","pb4":"_39vN1j2p5Baq_JXVRQvKoe","pb6":"_3s3H_dkrl4hIvStpX9F9KM","pb10":"_2sz0sMFMFPvCEOz1-VJq5Y","pb12":"_3lSd5hu5XLekSZS3ZhGS_1","pb16":"_12DAHmrDHqQ0Im-k_ETwqw","pb20":"_13JU4cXUJUrvN-aBuD1zAI","pb25":"_3sZiNUSlWx4b9oPBA7tHcW","pb38":"_1CnMa2Cp48Toy03pIy9gPw","pb60":"_32Kux4qKW_8c7lcsHbx3qT","pb96":"_3SVVQ_uV-DN9usguh3D2Of","ma0":"_7VmKzs0FhXzCyvHd3-QeS","ma4":"WAnc8DhAW_--P87J0vs-j","ma6":"_71U-FZ0OVRr4G2zgDX24O","ma10":"_3KgKmJXEc6gNt1_AYpwf7h","ma12":"_3iAmpsYXLEC3CzlmerlbtO","ma16":"_1Z1958DegXFvWjsO6LE1SA","ma20":"S7BqMiJfKwSf69DkpX5tn","ma25":"_31sI2n0ChHUZcOHhC13y5W","ma38":"_3wsLmXr1AgY4SERSJeSukJ","ma60":"Y17vMljujVZOKuGvNY6XF","ma96":"D0Eow3uhie_aAkfZBybdZ","maAuto":"_1mYge8FU1Fh1ls3ZN5_E6e","mh0":"_12nR5sAapNbgvzf1u53ma5","mh4":"O14pQb32SQXc1j96SPHB3","mh6":"_1lgC6fOaMm6waQdHxF_bsC","mh10":"_2wtpKXArT76HLNIWYe-5vq","mh12":"_27muAXTa-wVPyZA6w8uwDc","mh16":"_3GH6ob27JQ9RJu0s-K1DF3","mh20":"_19GHm3n4VoV9j5q0fyg7jx","mh25":"_1Jkw0bRUU6XanlqA-b2xht","mh38":"_3GJnFIrccFegkEUJhfDEZQ","mh60":"R-WelXMzyC9bKlRZTfdd-","mh96":"_2BAkJ-3_dW36pglpqgWKlg","mhAuto":"_3rrCrTpyUSbOnKmiqOgfH7","mv0":"YXcPCVNmP3kvvbzVpeCBC","mv4":"_3zNKc2FFoBz6l1girFFKL_","mv6":"_1ZZN2q5ejbTH2m6CKwfa3W","mv10":"_3e6uyEIA57JZE2mNoMH2at","mv12":"_1DsJjMSOUeOdaydkktHww_","mv16":"_1AJurG9zYXP0Vy1apYtEOK","mv20":"_3-Fyb4f2rAjBHDgUWzYpJc","mv25":"_2d2yK4mC4RBOHMref3nGPe","mv38":"_22o23SlOvaat1aHZCCtHes","mv60":"PbjZPvifQf0dX_Xw2Uhcz","mv96":"_3dxes1JMSzP7urlxGn0iKA","mvAuto":"_1H-lNEozTha4B1ezQiWkVz","mla":"_1l1Ukd3LB1GBAEHr3HHLxz","ml0":"_3UOf69eJEFA4bmgW0wuE5-","ml4":"_2r3PQjwufvHzcBVHK5Uv0u","ml6":"HZiGwEyROIzLYG2bCRd7u","ml10":"_2cJax2du0xR51Djr3vJazW","ml12":"_16JQez-7BdJ6EqxFmobyT","ml16":"_2lStyLB4sanpsAIulEM77X","ml20":"_1hCpxzNFKOR7vbY-QsJpKy","ml25":"_3Q4tR99B4yc76O3qj5aXQ1","ml38":"_3j4c4awh7JeWr-FjwgmNxn","ml60":"_3Phv7uVCUrN4aj8j1_v0IB","ml96":"R-1CkynyrOldUfVfsM3CS","mlAuto":"_2VyGMpClTUwH8u-up_LOMW","mra":"_2E4w1Z5DgDSbq4qhiL2B6j","mr0":"_20doAWxOwyNXf-rbIT6pUb","mr4":"_1GSC8Swyes_9uZ_Iw0Sv91","mr6":"_3mMi3YoF5_ieM6PbrSVhia","mr10":"_1ExomcTiXRhI2LBQLtmyt9","mr12":"_1ObnQqkVxoTa3PQONL2Gn","mr16":"_3Ca_IsiXTXZ6MrpYrfBjDc","mr20":"_3FRBJs0_FJmZ0rKOVwvaAL","mr25":"_2mtdW5smdD8n9HKUwnOal9","mr38":"_3GcWBw3XSjlucaSAxuEj6H","mr60":"_3HQeghaYFc9HLFcNOyIWn7","mr96":"o8aI72dqdAFBedOhpy3dP","mrAuto":"_3CKlTpxZgBFK_8VJvHJoJV","mt0":"_1-YeVRe7bdPLY3l2j6R2J3","mt4":"_18AxGSUvuPwlsH6ZzhI0Gj","mt6":"_3i6WR0RjHRSJYA_3bIpmBL","mt10":"GWuIrh52uKgYAZuNs3nNl","mt12":"_2qWM8HwBtOgRSvM-R4C9Sl","mt16":"_1gPVz5Eodnj9s6mP0dLF2x","mt20":"CY2oB6GXdHK3U7gw7NQEz","mt25":"_1KOJb7VROwdD7EWnGH6QA4","mt38":"QaSO8O1mCCtDVmFRRHX01","mt60":"_62CwOFd0yLIMqNPPWeR92","mt96":"_2IDnu9G426xulZoeBQnX-N","mtAuto":"_13relwbukBRl3OV5LqFDec","mb0":"_3KUhzXaENgo0OCO6FcM9A","mb4":"_3MAA_Ou3XwOdWEppEGIQ2y","mb6":"uUoB9fQYQKyHFAGGY16d-","mb10":"_1vf6x8FS4EV_L5fB-o3gbz","mb12":"_340djYt9WGHRi_UWIr_p9a","mb16":"_20fgfDStauKxLk4W9OentS","mb20":"_1Rbp_VfhLlmZIttTmc3KoB","mb25":"_6LvySfBVvQxZ1_wMarRRh","mb38":"_2vfeNTvBi3o9N35aDACw91","mb60":"hevD7SrN2aLTc9SRdpFeS","mb96":"qUVbEqs6MbY-IMeFe1shz","mbAuto":"_14BLbbS9URQhMnKUT7XqvE","f12":"iB1ZWL5j1eebbLlbcyk74","f14":"_1Pmgu6zLdFnW_74uAElK-J","f10":"_1Nr3H3soG1OP-fHX7xrG4y","f16":"_14ZM9JMdcBdFPrCxPDFwfV","f20":"_4FSi4SNPVf2IIrzcQMA1y","f25":"_26mOMITWugXXrMZsA6v99Y","f32":"KCpdCRxNrPknA8sf_qnwE","f38":"_1f-eZYmUEem6rQKUH1j2k9","f60":"_32ucsH7zJL3S3PBg6QGlrg","f96":"_1-GL_hfp99ZancD2UvHHed","fInherit":"_3_UTpYe-psvWug_8xfCIM5","hf32":"_2zhphYn4gPEfx0hbqpNCTZ","hf30":"_3xmTZQGc-Z9sjVE-lCE0F5","hf20":"_2zVlpRORV7g5vwpTMxezYR","strike":"BRjhTl5yCcX55j8KAfJvm","underline":"l5sMEcypSs-rKW8EJfsA_","noUnderline":"_2THEsNrmDDuGaVfNPMSarg","tl":"_3JlVhLfsVaQjFfzR4wOe9n","tr":"_1QdsG6OKLiBTPyi9ycQn3P","tc":"_1jC0RpjdtCvk4Is2IpaMh4","toe":"s8EkHPoDKt-sP320Z_kQA","ttc":"esCoD43zOovplrskfzsIa","ttl":"_9kabcoRPfLOJHXzaGObvJ","ttu":"_2ITS4bK2-ZTGdrOaT4N-io","ttn":"m4bG4tQuRIjDikm_fGhDA","center":"_20spl01gdmozXB9-nX025","clip":"ToVcG9-VrF-A6mi_66hCt","wsNormal":"Xz3ZJvON_2TDoxKGygOyt","nowrap":"_3VZZw63ewT5CxG4NVE83Wx","vBase":"_236aVAjCQ2qJdYZt8FGHFd","vMid":"_1CVaXnkHiqBgIU6pA_dzOK","vTop":"_1ZA5CHMldnXZJKue18oJDl","vBtm":"RC_yARy2cIyGKeHyICwaW","dim":"_1A1j0GNaPlZdaCMd36HlhE","noEvents":"sRfRA42nFRJbmvfbfJoov","pointer":"_3cNa21YDMaaqifnbPN8el9","cursorDefault":"_1hrmg-n8ITDUTFj--WxY8U","z0":"_5m-YHSoE5XdwbOPu_bpSs","z1":"sbXGwEFx0CJRMjW-vUVRR","z2":"_3ngljXlEGD6QK6qZnoCYgO","z3":"_31CAQeRL_mJpKdzHmpSjQ5","z4":"_2D_p-FIhTQL1SVW7ipb3CQ","z5":"qOa8jLrksAlQdrSQPN11j","z999":"_21Hz-Zro7PQ2S6V7REbk5G","z9999":"_33NXQTV3AtgCkVNDypDFRi","zMax":"_3rb7j06Kw8TrFw1dklM8zV","zInherit":"_3daj5cFjnJMCxc__MRowzc","zInitial":"D6naKn339rCH8RL3izHag","zUnset":"_2QpM2rV9luOmaWzQ_tE3lG","debug":"_3IUyoJh6ZDGNgwVGXZuxHn","debugWhite":"_28d_GhanlFQnjeGd1JLSjb","debugBlack":"_3JosabSPe0bQPrsiBv_OBo"};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
	// removed by extract-text-webpack-plugin
	module.exports = {"cover":"cover","contain":"contain","bbox":"bbox","cbox":"cbox","bgCenter":"bgCenter","bgTop":"bgTop","bgRight":"bgRight","bgBottom":"bgBottom","bgLeft":"bgLeft","outline0":"outline0","ba":"ba","bt":"bt","br":"br","bb":"bb","bl":"bl","bn":"bn","bWhite":"bWhite","bWhite90":"bWhite90","bWhite80":"bWhite80","bWhite70":"bWhite70","bWhite60":"bWhite60","bWhite50":"bWhite50","bWhite40":"bWhite40","bWhite30":"bWhite30","bWhite20":"bWhite20","bWhite10":"bWhite10","bWhite05":"bWhite05","bBlack":"bBlack","bBlack90":"bBlack90","bBlack80":"bBlack80","bBlack70":"bBlack70","bBlack60":"bBlack60","bBlack50":"bBlack50","bBlack40":"bBlack40","bBlack30":"bBlack30","bBlack20":"bBlack20","bBlack10":"bBlack10","bBlack05":"bBlack05","bGreen":"bGreen","bGreen50":"bGreen50","bBlue":"bBlue","bDarkBlue":"bDarkBlue","bDarkBlue90":"bDarkBlue90","bDarkBlue80":"bDarkBlue80","bDarkBlue70":"bDarkBlue70","bDarkBlue60":"bDarkBlue60","bDarkBlue50":"bDarkBlue50","bDarkBlue40":"bDarkBlue40","bDarkBlue30":"bDarkBlue30","bDarkBlue20":"bDarkBlue20","bDarkBlue10":"bDarkBlue10","bDarkBlue06":"bDarkBlue06","bDarkBlue05":"bDarkBlue05","bDarkerBlue":"bDarkerBlue","bRed":"bRed","bRed10":"bRed10","bRed20":"bRed20","bRed30":"bRed30","bLightOrange":"bLightOrange","bLightOrange10":"bLightOrange10","bLightOrange20":"bLightOrange20","bLightOrange30":"bLightOrange30","br0":"br0","br1":"br1","br2":"br2","br100":"br100","brPill":"brPill","brBottom":"brBottom","brTop":"brTop","brRight":"brRight","brLeft":"brLeft","bDotted":"bDotted","bDashed":"bDashed","bSolid":"bSolid","bNone":"bNone","bw0":"bw0","bw1":"bw1","bw2":"bw2","bt0":"bt0","bb0":"bb0","bl0":"bl0","buttonShadow":"buttonShadow","overlayShadow":"overlayShadow","pre":"pre","top0":"top0","top4":"top4","top6":"top6","top10":"top10","top16":"top16","top25":"top25","top38":"top38","top60":"top60","top96":"top96","top50":"top50","top100":"top100","right0":"right0","right4":"right4","right6":"right6","right10":"right10","right16":"right16","right25":"right25","right38":"right38","right60":"right60","right96":"right96","right50":"right50","right100":"right100","bottom0":"bottom0","bottom4":"bottom4","bottom6":"bottom6","bottom10":"bottom10","bottom16":"bottom16","bottom25":"bottom25","bottom38":"bottom38","bottom60":"bottom60","bottom96":"bottom96","bottom50":"bottom50","bottom100":"bottom100","left0":"left0","left4":"left4","left6":"left6","left10":"left10","left16":"left16","left25":"left25","left38":"left38","left60":"left60","left96":"left96","left50":"left50","left100":"left100","absoluteFill":"absoluteFill","tlCenter":"tlCenter","tlHCenter":"tlHCenter","tlVCenter":"tlVCenter","dn":"dn","di":"di","db":"db","dib":"dib","dit":"dit","dt":"dt","dtc":"dtc","dtRow":"dtRow","dtRowGroup":"dtRowGroup","dtColumn":"dtColumn","dtColumnGroup":"dtColumnGroup","dtFixed":"dtFixed","flex":"flex","inlineFlex":"inlineFlex","flex1":"flex1","flexAuto":"flexAuto","flexFixed":"flexFixed","flexSlide":"flexSlide","flexNone":"flexNone","flexColumn":"flexColumn","flexRow":"flexRow","flexWrap":"flexWrap","itemsStart":"itemsStart","itemsEnd":"itemsEnd","itemsCenter":"itemsCenter","itemsBaseline":"itemsBaseline","itemsStretch":"itemsStretch","selfStart":"selfStart","selfEnd":"selfEnd","selfCenter":"selfCenter","selfBaseline":"selfBaseline","selfStretch":"selfStretch","justifyStart":"justifyStart","justifyEnd":"justifyEnd","justifyCenter":"justifyCenter","justifyBetween":"justifyBetween","justifyAround":"justifyAround","contentStart":"contentStart","contentEnd":"contentEnd","contentCenter":"contentCenter","contentBetween":"contentBetween","contentAround":"contentAround","contentStretch":"contentStretch","order0":"order0","order1":"order1","order2":"order2","order3":"order3","order4":"order4","order5":"order5","order6":"order6","order7":"order7","order8":"order8","orderLast":"orderLast","sansSerif":"sansSerif","code":"code","i":"i","fsNormal":"fsNormal","normal":"normal","b":"b","fw3":"fw3","fw4":"fw4","fw5":"fw5","fw6":"fw6","fw7":"fw7","inputReset":"inputReset","buttonReset":"buttonReset","h100":"h100","minH100":"minH100","vh100":"vh100","minVh100":"minVh100","hAuto":"hAuto","hInherit":"hInherit","mono":"mono","tracked":"tracked","lhSolid":"lhSolid","lhTitle":"lhTitle","lhCopy":"lhCopy","link":"link","list":"list","mw100":"mw100","mwNone":"mwNone","w10":"w10","w20":"w20","w25":"w25","w30":"w30","w40":"w40","w50":"w50","w60":"w60","w70":"w70","w75":"w75","w80":"w80","w90":"w90","w100":"w100","wThird":"wThird","wTwoThirds":"wTwoThirds","wAuto":"wAuto","hS04":"hS04","hS06":"hS06","hS10":"hS10","hS12":"hS12","hS16":"hS16","hS20":"hS20","hS25":"hS25","hS38":"hS38","hS60":"hS60","hS96":"hS96","wS04":"wS04","wS06":"wS06","wS10":"wS10","wS12":"wS12","wS16":"wS16","wS20":"wS20","wS25":"wS25","wS38":"wS38","wS60":"wS60","wS96":"wS96","overflowVisible":"overflowVisible","overflowHidden":"overflowHidden","overflowScroll":"overflowScroll","overflowAuto":"overflowAuto","overflowXVisible":"overflowXVisible","overflowXHidden":"overflowXHidden","overflowXScroll":"overflowXScroll","overflowXAuto":"overflowXAuto","overflowYVisible":"overflowYVisible","overflowYHidden":"overflowYHidden","overflowYScroll":"overflowYScroll","overflowYAuto":"overflowYAuto","nosb":"nosb","static":"static","relative":"relative","absolute":"absolute","fixed":"fixed","o100":"o100","o90":"o90","o80":"o80","o70":"o70","o60":"o60","o50":"o50","o40":"o40","o30":"o30","o20":"o20","o10":"o10","o05":"o05","o025":"o025","o0":"o0","black90":"black90","black80":"black80","black70":"black70","black60":"black60","black50":"black50","black40":"black40","black30":"black30","black20":"black20","black10":"black10","lightOrange":"lightOrange","lightOrange20":"lightOrange20","white90":"white90","white80":"white80","white70":"white70","white60":"white60","white50":"white50","white40":"white40","white30":"white30","white20":"white20","white10":"white10","white":"white","black":"black","blue":"blue","blue20":"blue20","blue50":"blue50","purple":"purple","lightBlue":"lightBlue","darkBlue":"darkBlue","darkBlue90":"darkBlue90","darkBlue80":"darkBlue80","darkBlue70":"darkBlue70","darkBlue60":"darkBlue60","darkBlue50":"darkBlue50","darkBlue40":"darkBlue40","darkBlue30":"darkBlue30","darkBlue20":"darkBlue20","darkBlue10":"darkBlue10","pink":"pink","pink90":"pink90","pink80":"pink80","pink70":"pink70","pink60":"pink60","pink50":"pink50","pink40":"pink40","pink30":"pink30","pink20":"pink20","pink10":"pink10","darkerBlue":"darkerBlue","darkerBlue50":"darkerBlue50","orange":"orange","red":"red","green":"green","green30":"green30","green50":"green50","lightgreen05":"lightgreen05","lightgreen10":"lightgreen10","lightgreen20":"lightgreen20","lightgreen30":"lightgreen30","lightgreen50":"lightgreen50","bgTransparent":"bgTransparent","bgNone":"bgNone","bgBlack90":"bgBlack90","bgBlack80":"bgBlack80","bgBlack70":"bgBlack70","bgBlack60":"bgBlack60","bgBlack50":"bgBlack50","bgBlack40":"bgBlack40","bgBlack30":"bgBlack30","bgBlack20":"bgBlack20","bgBlack10":"bgBlack10","bgBlack07":"bgBlack07","bgBlack04":"bgBlack04","bgBlack02":"bgBlack02","bgWhite90":"bgWhite90","bgWhite80":"bgWhite80","bgWhite70":"bgWhite70","bgWhite60":"bgWhite60","bgWhite50":"bgWhite50","bgWhite40":"bgWhite40","bgWhite30":"bgWhite30","bgWhite20":"bgWhite20","bgWhite10":"bgWhite10","bgWhite07":"bgWhite07","bgWhite04":"bgWhite04","bgBlack":"bgBlack","bgWhite":"bgWhite","bgBlue":"bgBlue","bgBlue20":"bgBlue20","bgBlue10":"bgBlue10","bgBlue50":"bgBlue50","bgDarkBlue":"bgDarkBlue","bgDarkBlue90":"bgDarkBlue90","bgDarkBlue80":"bgDarkBlue80","bgDarkBlue70":"bgDarkBlue70","bgDarkBlue60":"bgDarkBlue60","bgDarkBlue50":"bgDarkBlue50","bgDarkBlue40":"bgDarkBlue40","bgDarkBlue30":"bgDarkBlue30","bgDarkBlue20":"bgDarkBlue20","bgDarkBlue10":"bgDarkBlue10","bgDarkBlue07":"bgDarkBlue07","bgDarkBlue04":"bgDarkBlue04","bgPink":"bgPink","bgPink90":"bgPink90","bgPink80":"bgPink80","bgPink70":"bgPink70","bgPink60":"bgPink60","bgPink50":"bgPink50","bgPink40":"bgPink40","bgPink30":"bgPink30","bgPink20":"bgPink20","bgPink10":"bgPink10","bgDarkerBlue":"bgDarkerBlue","bgDarkestBlue":"bgDarkestBlue","bgOrange":"bgOrange","bgRed":"bgRed","bgRed10":"bgRed10","bgrRed":"bgrRed","bgLightOrange":"bgLightOrange","bgLightOrange10":"bgLightOrange10","bgLightOrange20":"bgLightOrange20","bgLightOrange30":"bgLightOrange30","bgDarkBlueGray":"bgDarkBlueGray","bgGreen":"bgGreen","bgGreen10":"bgGreen10","bgGreen20":"bgGreen20","bgGreen30":"bgGreen30","bgGreen40":"bgGreen40","bgGreen50":"bgGreen50","bgGreen60":"bgGreen60","bgGreen70":"bgGreen70","bgGreen80":"bgGreen80","bgGreen90":"bgGreen90","bgLightergreen":"bgLightergreen","bgLightgreen05":"bgLightgreen05","bgLightgreen10":"bgLightgreen10","bgLightgreen20":"bgLightgreen20","bgLightgreen30":"bgLightgreen30","bgLightgreen50":"bgLightgreen50","brown":"brown","bgPblue20":"bgPblue20","bgPred20":"bgPred20","bgPyellow40":"bgPyellow40","bgPlightgreen50":"bgPlightgreen50","bgLightGray":"bgLightGray","bgPurple":"bgPurple","bgPurple20":"bgPurple20","pa0":"pa0","pa4":"pa4","pa6":"pa6","pa10":"pa10","pa12":"pa12","pa16":"pa16","pa20":"pa20","pa25":"pa25","pa38":"pa38","pa60":"pa60","pa96":"pa96","ph0":"ph0","ph4":"ph4","ph6":"ph6","ph10":"ph10","ph12":"ph12","ph16":"ph16","ph20":"ph20","ph25":"ph25","ph38":"ph38","ph60":"ph60","ph96":"ph96","pv0":"pv0","pv4":"pv4","pv6":"pv6","pv8":"pv8","pv10":"pv10","pv12":"pv12","pv16":"pv16","pv20":"pv20","pv25":"pv25","pv38":"pv38","pv60":"pv60","pv96":"pv96","pl0":"pl0","pl4":"pl4","pl6":"pl6","pl10":"pl10","pl12":"pl12","pl16":"pl16","pl25":"pl25","pl38":"pl38","pl60":"pl60","pl96":"pl96","pr0":"pr0","pr4":"pr4","pr6":"pr6","pr10":"pr10","pr12":"pr12","pr16":"pr16","pr20":"pr20","pr25":"pr25","pr38":"pr38","pr60":"pr60","pr96":"pr96","pt0":"pt0","pt4":"pt4","pt6":"pt6","pt10":"pt10","pt12":"pt12","pt16":"pt16","pt20":"pt20","pt25":"pt25","pt38":"pt38","pt60":"pt60","pt96":"pt96","pb0":"pb0","pb4":"pb4","pb6":"pb6","pb10":"pb10","pb12":"pb12","pb16":"pb16","pb20":"pb20","pb25":"pb25","pb38":"pb38","pb60":"pb60","pb96":"pb96","ma0":"ma0","ma4":"ma4","ma6":"ma6","ma10":"ma10","ma12":"ma12","ma16":"ma16","ma20":"ma20","ma25":"ma25","ma38":"ma38","ma60":"ma60","ma96":"ma96","maAuto":"maAuto","mh0":"mh0","mh4":"mh4","mh6":"mh6","mh10":"mh10","mh12":"mh12","mh16":"mh16","mh20":"mh20","mh25":"mh25","mh38":"mh38","mh60":"mh60","mh96":"mh96","mhAuto":"mhAuto","mv0":"mv0","mv4":"mv4","mv6":"mv6","mv10":"mv10","mv12":"mv12","mv16":"mv16","mv20":"mv20","mv25":"mv25","mv38":"mv38","mv60":"mv60","mv96":"mv96","mvAuto":"mvAuto","mla":"mla","ml0":"ml0","ml4":"ml4","ml6":"ml6","ml10":"ml10","ml12":"ml12","ml16":"ml16","ml20":"ml20","ml25":"ml25","ml38":"ml38","ml60":"ml60","ml96":"ml96","mlAuto":"mlAuto","mra":"mra","mr0":"mr0","mr4":"mr4","mr6":"mr6","mr10":"mr10","mr12":"mr12","mr16":"mr16","mr20":"mr20","mr25":"mr25","mr38":"mr38","mr60":"mr60","mr96":"mr96","mrAuto":"mrAuto","mt0":"mt0","mt4":"mt4","mt6":"mt6","mt10":"mt10","mt12":"mt12","mt16":"mt16","mt20":"mt20","mt25":"mt25","mt38":"mt38","mt60":"mt60","mt96":"mt96","mtAuto":"mtAuto","mb0":"mb0","mb4":"mb4","mb6":"mb6","mb10":"mb10","mb12":"mb12","mb16":"mb16","mb20":"mb20","mb25":"mb25","mb38":"mb38","mb60":"mb60","mb96":"mb96","mbAuto":"mbAuto","f12":"f12","f14":"f14","f10":"f10","f16":"f16","f20":"f20","f25":"f25","f32":"f32","f38":"f38","f60":"f60","f96":"f96","fInherit":"fInherit","hf32":"hf32","hf30":"hf30","hf20":"hf20","strike":"strike","underline":"underline","noUnderline":"noUnderline","tl":"tl","tr":"tr","tc":"tc","toe":"toe","ttc":"ttc","ttl":"ttl","ttu":"ttu","ttn":"ttn","center":"center","clip":"clip","wsNormal":"wsNormal","nowrap":"nowrap","vBase":"vBase","vMid":"vMid","vTop":"vTop","vBtm":"vBtm","dim":"dim","noEvents":"noEvents","pointer":"pointer","cursorDefault":"cursorDefault","z0":"z0","z1":"z1","z2":"z2","z3":"z3","z4":"z4","z5":"z5","z999":"z999","z9999":"z9999","zMax":"zMax","zInherit":"zInherit","zInitial":"zInitial","zUnset":"zUnset","debug":"debug","debugWhite":"debugWhite","debugBlack":"debugBlack"};
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
	// the whatwg-fetch polyfill installs the fetch() function
	// on the global object (window or self)
	//
	// Return that as the export for use in Webpack, Browserify etc.
	__webpack_require__(7);
	module.exports = self.fetch.bind(self);
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	"use strict";
	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (typeof input === 'string') {
	      this.url = input
	    } else {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split('\r\n').forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	"use strict";
	var Icon_1 = __webpack_require__(0);
	exports.Icon = Icon_1.default;
	var variables = __webpack_require__(1);
	exports.variables = variables;
	exports.$v = variables;
	var groups = __webpack_require__(3);
	exports.groups = groups;
	exports.$g = groups;
	var particles = __webpack_require__(4);
	exports.particles = particles;
	exports.$p = particles;
	var base = __webpack_require__(2);
	exports.base = base;
	
	
	/***/ }
	/******/ ]);
	});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.print = print;
	
	var _visitor = __webpack_require__(80);
	
	/**
	 * Converts an AST into a string, using one set of reasonable
	 * formatting rules.
	 */
	function print(ast) {
	  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   */
	
	var printDocASTReducer = {
	  Name: function Name(node) {
	    return node.value;
	  },
	  Variable: function Variable(node) {
	    return '$' + node.name;
	  },
	
	  // Document
	
	  Document: function Document(node) {
	    return join(node.definitions, '\n\n') + '\n';
	  },
	
	  OperationDefinition: function OperationDefinition(node) {
	    var op = node.operation;
	    var name = node.name;
	    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
	    var directives = join(node.directives, ' ');
	    var selectionSet = node.selectionSet;
	    // Anonymous queries with no directives or variable definitions can use
	    // the query short form.
	    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
	  },
	
	
	  VariableDefinition: function VariableDefinition(_ref) {
	    var variable = _ref.variable,
	        type = _ref.type,
	        defaultValue = _ref.defaultValue;
	    return variable + ': ' + type + wrap(' = ', defaultValue);
	  },
	
	  SelectionSet: function SelectionSet(_ref2) {
	    var selections = _ref2.selections;
	    return block(selections);
	  },
	
	  Field: function Field(_ref3) {
	    var alias = _ref3.alias,
	        name = _ref3.name,
	        args = _ref3.arguments,
	        directives = _ref3.directives,
	        selectionSet = _ref3.selectionSet;
	    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
	  },
	
	  Argument: function Argument(_ref4) {
	    var name = _ref4.name,
	        value = _ref4.value;
	    return name + ': ' + value;
	  },
	
	  // Fragments
	
	  FragmentSpread: function FragmentSpread(_ref5) {
	    var name = _ref5.name,
	        directives = _ref5.directives;
	    return '...' + name + wrap(' ', join(directives, ' '));
	  },
	
	  InlineFragment: function InlineFragment(_ref6) {
	    var typeCondition = _ref6.typeCondition,
	        directives = _ref6.directives,
	        selectionSet = _ref6.selectionSet;
	    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
	  },
	
	  FragmentDefinition: function FragmentDefinition(_ref7) {
	    var name = _ref7.name,
	        typeCondition = _ref7.typeCondition,
	        directives = _ref7.directives,
	        selectionSet = _ref7.selectionSet;
	    return 'fragment ' + name + ' on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ') + selectionSet;
	  },
	
	  // Value
	
	  IntValue: function IntValue(_ref8) {
	    var value = _ref8.value;
	    return value;
	  },
	  FloatValue: function FloatValue(_ref9) {
	    var value = _ref9.value;
	    return value;
	  },
	  StringValue: function StringValue(_ref10) {
	    var value = _ref10.value;
	    return JSON.stringify(value);
	  },
	  BooleanValue: function BooleanValue(_ref11) {
	    var value = _ref11.value;
	    return JSON.stringify(value);
	  },
	  NullValue: function NullValue() {
	    return 'null';
	  },
	  EnumValue: function EnumValue(_ref12) {
	    var value = _ref12.value;
	    return value;
	  },
	  ListValue: function ListValue(_ref13) {
	    var values = _ref13.values;
	    return '[' + join(values, ', ') + ']';
	  },
	  ObjectValue: function ObjectValue(_ref14) {
	    var fields = _ref14.fields;
	    return '{' + join(fields, ', ') + '}';
	  },
	  ObjectField: function ObjectField(_ref15) {
	    var name = _ref15.name,
	        value = _ref15.value;
	    return name + ': ' + value;
	  },
	
	  // Directive
	
	  Directive: function Directive(_ref16) {
	    var name = _ref16.name,
	        args = _ref16.arguments;
	    return '@' + name + wrap('(', join(args, ', '), ')');
	  },
	
	  // Type
	
	  NamedType: function NamedType(_ref17) {
	    var name = _ref17.name;
	    return name;
	  },
	  ListType: function ListType(_ref18) {
	    var type = _ref18.type;
	    return '[' + type + ']';
	  },
	  NonNullType: function NonNullType(_ref19) {
	    var type = _ref19.type;
	    return type + '!';
	  },
	
	  // Type System Definitions
	
	  SchemaDefinition: function SchemaDefinition(_ref20) {
	    var directives = _ref20.directives,
	        operationTypes = _ref20.operationTypes;
	    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
	  },
	
	  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
	    var operation = _ref21.operation,
	        type = _ref21.type;
	    return operation + ': ' + type;
	  },
	
	  ScalarTypeDefinition: function ScalarTypeDefinition(_ref22) {
	    var name = _ref22.name,
	        directives = _ref22.directives;
	    return join(['scalar', name, join(directives, ' ')], ' ');
	  },
	
	  ObjectTypeDefinition: function ObjectTypeDefinition(_ref23) {
	    var name = _ref23.name,
	        interfaces = _ref23.interfaces,
	        directives = _ref23.directives,
	        fields = _ref23.fields;
	    return join(['type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ');
	  },
	
	  FieldDefinition: function FieldDefinition(_ref24) {
	    var name = _ref24.name,
	        args = _ref24.arguments,
	        type = _ref24.type,
	        directives = _ref24.directives;
	    return name + wrap('(', join(args, ', '), ')') + ': ' + type + wrap(' ', join(directives, ' '));
	  },
	
	  InputValueDefinition: function InputValueDefinition(_ref25) {
	    var name = _ref25.name,
	        type = _ref25.type,
	        defaultValue = _ref25.defaultValue,
	        directives = _ref25.directives;
	    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
	  },
	
	  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref26) {
	    var name = _ref26.name,
	        directives = _ref26.directives,
	        fields = _ref26.fields;
	    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
	  },
	
	  UnionTypeDefinition: function UnionTypeDefinition(_ref27) {
	    var name = _ref27.name,
	        directives = _ref27.directives,
	        types = _ref27.types;
	    return join(['union', name, join(directives, ' '), '= ' + join(types, ' | ')], ' ');
	  },
	
	  EnumTypeDefinition: function EnumTypeDefinition(_ref28) {
	    var name = _ref28.name,
	        directives = _ref28.directives,
	        values = _ref28.values;
	    return join(['enum', name, join(directives, ' '), block(values)], ' ');
	  },
	
	  EnumValueDefinition: function EnumValueDefinition(_ref29) {
	    var name = _ref29.name,
	        directives = _ref29.directives;
	    return join([name, join(directives, ' ')], ' ');
	  },
	
	  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref30) {
	    var name = _ref30.name,
	        directives = _ref30.directives,
	        fields = _ref30.fields;
	    return join(['input', name, join(directives, ' '), block(fields)], ' ');
	  },
	
	  TypeExtensionDefinition: function TypeExtensionDefinition(_ref31) {
	    var definition = _ref31.definition;
	    return 'extend ' + definition;
	  },
	
	  DirectiveDefinition: function DirectiveDefinition(_ref32) {
	    var name = _ref32.name,
	        args = _ref32.arguments,
	        locations = _ref32.locations;
	    return 'directive @' + name + wrap('(', join(args, ', '), ')') + ' on ' + join(locations, ' | ');
	  }
	};
	
	/**
	 * Given maybeArray, print an empty string if it is null or empty, otherwise
	 * print all items together separated by separator if provided
	 */
	function join(maybeArray, separator) {
	  return maybeArray ? maybeArray.filter(function (x) {
	    return x;
	  }).join(separator || '') : '';
	}
	
	/**
	 * Given array, print each item on its own line, wrapped in an
	 * indented "{ }" block.
	 */
	function block(array) {
	  return array && array.length !== 0 ? indent('{\n' + join(array, '\n')) + '\n}' : '{}';
	}
	
	/**
	 * If maybeString is not null or empty, then wrap with start and end, otherwise
	 * print an empty string.
	 */
	function wrap(start, maybeString, end) {
	  return maybeString ? start + maybeString + (end || '') : '';
	}
	
	function indent(maybeString) {
	  return maybeString && maybeString.replace(/\n/g, '\n  ');
	}

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.specifiedDirectives = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.DirectiveLocation = undefined;
	
	var _definition = __webpack_require__(7);
	
	var _scalars = __webpack_require__(42);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _assertValidName = __webpack_require__(167);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	var DirectiveLocation = exports.DirectiveLocation = {
	  // Operations
	  QUERY: 'QUERY',
	  MUTATION: 'MUTATION',
	  SUBSCRIPTION: 'SUBSCRIPTION',
	  FIELD: 'FIELD',
	  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
	  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
	  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
	  // Schema Definitions
	  SCHEMA: 'SCHEMA',
	  SCALAR: 'SCALAR',
	  OBJECT: 'OBJECT',
	  FIELD_DEFINITION: 'FIELD_DEFINITION',
	  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
	  INTERFACE: 'INTERFACE',
	  UNION: 'UNION',
	  ENUM: 'ENUM',
	  ENUM_VALUE: 'ENUM_VALUE',
	  INPUT_OBJECT: 'INPUT_OBJECT',
	  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
	};
	
	// eslint-disable-line
	
	/**
	 * Directives are used by the GraphQL runtime as a way of modifying execution
	 * behavior. Type system creators will usually not create these directly.
	 */
	var GraphQLDirective = exports.GraphQLDirective = function GraphQLDirective(config) {
	  _classCallCheck(this, GraphQLDirective);
	
	  !config.name ? (0, _invariant2.default)(0, 'Directive must be named.') : void 0;
	  (0, _assertValidName.assertValidName)(config.name);
	  !Array.isArray(config.locations) ? (0, _invariant2.default)(0, 'Must provide locations for directive.') : void 0;
	  this.name = config.name;
	  this.description = config.description;
	  this.locations = config.locations;
	  this.astNode = config.astNode;
	
	  var args = config.args;
	  if (!args) {
	    this.args = [];
	  } else {
	    !!Array.isArray(args) ? (0, _invariant2.default)(0, '@' + config.name + ' args must be an object with argument names as keys.') : void 0;
	    this.args = Object.keys(args).map(function (argName) {
	      (0, _assertValidName.assertValidName)(argName);
	      var arg = args[argName];
	      !(0, _definition.isInputType)(arg.type) ? (0, _invariant2.default)(0, '@' + config.name + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.')) : void 0;
	      return {
	        name: argName,
	        description: arg.description === undefined ? null : arg.description,
	        type: arg.type,
	        defaultValue: arg.defaultValue,
	        astNode: arg.astNode
	      };
	    });
	  }
	};
	
	/**
	 * Used to conditionally include fields or fragments.
	 */
	var GraphQLIncludeDirective = exports.GraphQLIncludeDirective = new GraphQLDirective({
	  name: 'include',
	  description: 'Directs the executor to include this field or fragment only when ' + 'the `if` argument is true.',
	  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
	  args: {
	    if: {
	      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	      description: 'Included when true.'
	    }
	  }
	});
	
	/**
	 * Used to conditionally skip (exclude) fields or fragments.
	 */
	var GraphQLSkipDirective = exports.GraphQLSkipDirective = new GraphQLDirective({
	  name: 'skip',
	  description: 'Directs the executor to skip this field or fragment when the `if` ' + 'argument is true.',
	  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
	  args: {
	    if: {
	      type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	      description: 'Skipped when true.'
	    }
	  }
	});
	
	/**
	 * Constant string used for default reason for a deprecation.
	 */
	var DEFAULT_DEPRECATION_REASON = exports.DEFAULT_DEPRECATION_REASON = 'No longer supported';
	
	/**
	 * Used to declare element of a GraphQL schema as deprecated.
	 */
	var GraphQLDeprecatedDirective = exports.GraphQLDeprecatedDirective = new GraphQLDirective({
	  name: 'deprecated',
	  description: 'Marks an element of a GraphQL schema as no longer supported.',
	  locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],
	  args: {
	    reason: {
	      type: _scalars.GraphQLString,
	      description: 'Explains why this element was deprecated, usually also including a ' + 'suggestion for how to access supported similar data. Formatted ' + 'in [Markdown](https://daringfireball.net/projects/markdown/).',
	      defaultValue: DEFAULT_DEPRECATION_REASON
	    }
	  }
	});
	
	/**
	 * The full list of specified directives.
	 */
	var specifiedDirectives = exports.specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective];

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLSchema = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _definition = __webpack_require__(7);
	
	var _directives = __webpack_require__(33);
	
	var _introspection = __webpack_require__(41);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _typeComparators = __webpack_require__(110);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	/**
	 * Schema Definition
	 *
	 * A Schema is created by supplying the root types of each type of operation,
	 * query and mutation (optional). A schema definition is then supplied to the
	 * validator and executor.
	 *
	 * Example:
	 *
	 *     const MyAppSchema = new GraphQLSchema({
	 *       query: MyAppQueryRootType,
	 *       mutation: MyAppMutationRootType,
	 *     })
	 *
	 * Note: If an array of `directives` are provided to GraphQLSchema, that will be
	 * the exact list of directives represented and allowed. If `directives` is not
	 * provided then a default set of the specified directives (e.g. @include and
	 * @skip) will be used. If you wish to provide *additional* directives to these
	 * specified directives, you must explicitly declare them. Example:
	 *
	 *     const MyAppSchema = new GraphQLSchema({
	 *       ...
	 *       directives: specifiedDirectives.concat([ myCustomDirective ]),
	 *     })
	 *
	 */
	var GraphQLSchema = exports.GraphQLSchema = function () {
	  function GraphQLSchema(config) {
	    var _this = this;
	
	    _classCallCheck(this, GraphQLSchema);
	
	    !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? (0, _invariant2.default)(0, 'Must provide configuration object.') : void 0;
	
	    !(config.query instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema query must be Object Type but got: ' + String(config.query) + '.') : void 0;
	    this._queryType = config.query;
	
	    !(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema mutation must be Object Type if provided but got: ' + String(config.mutation) + '.') : void 0;
	    this._mutationType = config.mutation;
	
	    !(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema subscription must be Object Type if provided but got: ' + String(config.subscription) + '.') : void 0;
	    this._subscriptionType = config.subscription;
	
	    !(!config.types || Array.isArray(config.types)) ? (0, _invariant2.default)(0, 'Schema types must be Array if provided but got: ' + String(config.types) + '.') : void 0;
	
	    !(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {
	      return directive instanceof _directives.GraphQLDirective;
	    })) ? (0, _invariant2.default)(0, 'Schema directives must be Array<GraphQLDirective> if provided but got: ' + String(config.directives) + '.') : void 0;
	    // Provide specified directives (e.g. @include and @skip) by default.
	    this._directives = config.directives || _directives.specifiedDirectives;
	    this.astNode = config.astNode || null;
	
	    // Build type map now to detect any errors within this schema.
	    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema];
	
	    var types = config.types;
	    if (types) {
	      initialTypes = initialTypes.concat(types);
	    }
	
	    this._typeMap = initialTypes.reduce(typeMapReducer, Object.create(null));
	
	    // Keep track of all implementations by interface name.
	    this._implementations = Object.create(null);
	    Object.keys(this._typeMap).forEach(function (typeName) {
	      var type = _this._typeMap[typeName];
	      if (type instanceof _definition.GraphQLObjectType) {
	        type.getInterfaces().forEach(function (iface) {
	          var impls = _this._implementations[iface.name];
	          if (impls) {
	            impls.push(type);
	          } else {
	            _this._implementations[iface.name] = [type];
	          }
	        });
	      }
	    });
	
	    // Enforce correct interface implementations.
	    Object.keys(this._typeMap).forEach(function (typeName) {
	      var type = _this._typeMap[typeName];
	      if (type instanceof _definition.GraphQLObjectType) {
	        type.getInterfaces().forEach(function (iface) {
	          return assertObjectImplementsInterface(_this, type, iface);
	        });
	      }
	    });
	  }
	
	  GraphQLSchema.prototype.getQueryType = function getQueryType() {
	    return this._queryType;
	  };
	
	  GraphQLSchema.prototype.getMutationType = function getMutationType() {
	    return this._mutationType;
	  };
	
	  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {
	    return this._subscriptionType;
	  };
	
	  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {
	    return this._typeMap;
	  };
	
	  GraphQLSchema.prototype.getType = function getType(name) {
	    return this.getTypeMap()[name];
	  };
	
	  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {
	    if (abstractType instanceof _definition.GraphQLUnionType) {
	      return abstractType.getTypes();
	    }
	    !(abstractType instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0) : void 0;
	    return this._implementations[abstractType.name];
	  };
	
	  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {
	    var possibleTypeMap = this._possibleTypeMap;
	    if (!possibleTypeMap) {
	      this._possibleTypeMap = possibleTypeMap = Object.create(null);
	    }
	
	    if (!possibleTypeMap[abstractType.name]) {
	      var possibleTypes = this.getPossibleTypes(abstractType);
	      !Array.isArray(possibleTypes) ? (0, _invariant2.default)(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;
	      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {
	        return map[type.name] = true, map;
	      }, Object.create(null));
	    }
	
	    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);
	  };
	
	  GraphQLSchema.prototype.getDirectives = function getDirectives() {
	    return this._directives;
	  };
	
	  GraphQLSchema.prototype.getDirective = function getDirective(name) {
	    return (0, _find2.default)(this.getDirectives(), function (directive) {
	      return directive.name === name;
	    });
	  };
	
	  return GraphQLSchema;
	}();
	
	function typeMapReducer(map, type) {
	  if (!type) {
	    return map;
	  }
	  if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {
	    return typeMapReducer(map, type.ofType);
	  }
	  if (map[type.name]) {
	    !(map[type.name] === type) ? (0, _invariant2.default)(0, 'Schema must contain unique named types but contains multiple ' + ('types named "' + type.name + '".')) : void 0;
	    return map;
	  }
	  map[type.name] = type;
	
	  var reducedMap = map;
	
	  if (type instanceof _definition.GraphQLUnionType) {
	    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);
	  }
	
	  if (type instanceof _definition.GraphQLObjectType) {
	    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);
	  }
	
	  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	    var fieldMap = type.getFields();
	    Object.keys(fieldMap).forEach(function (fieldName) {
	      var field = fieldMap[fieldName];
	
	      if (field.args) {
	        var fieldArgTypes = field.args.map(function (arg) {
	          return arg.type;
	        });
	        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
	      }
	      reducedMap = typeMapReducer(reducedMap, field.type);
	    });
	  }
	
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    var _fieldMap = type.getFields();
	    Object.keys(_fieldMap).forEach(function (fieldName) {
	      var field = _fieldMap[fieldName];
	      reducedMap = typeMapReducer(reducedMap, field.type);
	    });
	  }
	
	  return reducedMap;
	}
	
	function assertObjectImplementsInterface(schema, object, iface) {
	  var objectFieldMap = object.getFields();
	  var ifaceFieldMap = iface.getFields();
	
	  // Assert each interface field is implemented.
	  Object.keys(ifaceFieldMap).forEach(function (fieldName) {
	    var objectField = objectFieldMap[fieldName];
	    var ifaceField = ifaceFieldMap[fieldName];
	
	    // Assert interface field exists on object.
	    !objectField ? (0, _invariant2.default)(0, '"' + iface.name + '" expects field "' + fieldName + '" but "' + object.name + '" ' + 'does not provide it.') : void 0;
	
	    // Assert interface field type is satisfied by object field type, by being
	    // a valid subtype. (covariant)
	    !(0, _typeComparators.isTypeSubTypeOf)(schema, objectField.type, ifaceField.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects type "' + String(ifaceField.type) + '" ' + 'but ' + (object.name + '.' + fieldName + ' provides type "' + String(objectField.type) + '".')) : void 0;
	
	    // Assert each interface field arg is implemented.
	    ifaceField.args.forEach(function (ifaceArg) {
	      var argName = ifaceArg.name;
	      var objectArg = (0, _find2.default)(objectField.args, function (arg) {
	        return arg.name === argName;
	      });
	
	      // Assert interface field arg exists on object field.
	      !objectArg ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects argument "' + argName + '" but ' + (object.name + '.' + fieldName + ' does not provide it.')) : void 0;
	
	      // Assert interface field arg type matches object field arg type.
	      // (invariant)
	      !(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + '(' + argName + ':) expects type ' + ('"' + String(ifaceArg.type) + '" but ') + (object.name + '.' + fieldName + '(' + argName + ':) provides type ') + ('"' + String(objectArg.type) + '".')) : void 0;
	    });
	
	    // Assert additional arguments must not be required.
	    objectField.args.forEach(function (objectArg) {
	      var argName = objectArg.name;
	      var ifaceArg = (0, _find2.default)(ifaceField.args, function (arg) {
	        return arg.name === argName;
	      });
	      if (!ifaceArg) {
	        !!(objectArg.type instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, object.name + '.' + fieldName + '(' + argName + ':) is of required type ' + ('"' + String(objectArg.type) + '" but is not also provided by the ') + ('interface ' + iface.name + '.' + fieldName + '.')) : void 0;
	      }
	    });
	  });
	}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.typeFromAST = undefined;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Given a Schema and an AST node describing a type, return a GraphQLType
	 * definition which applies to that type. For example, if provided the parsed
	 * AST node for `[User]`, a GraphQLList instance will be returned, containing
	 * the type called "User" found in the schema. If a type called "User" is not
	 * found in the schema, then undefined will be returned.
	 */
	/* eslint-disable no-redeclare */
	function typeFromASTImpl(schema, typeNode) {
	  /* eslint-enable no-redeclare */
	  var innerType = void 0;
	  if (typeNode.kind === Kind.LIST_TYPE) {
	    innerType = typeFromAST(schema, typeNode.type);
	    return innerType && new _definition.GraphQLList(innerType);
	  }
	  if (typeNode.kind === Kind.NON_NULL_TYPE) {
	    innerType = typeFromAST(schema, typeNode.type);
	    return innerType && new _definition.GraphQLNonNull(innerType);
	  }
	  !(typeNode.kind === Kind.NAMED_TYPE) ? (0, _invariant2.default)(0, 'Must be a named type.') : void 0;
	  return schema.getType(typeNode.name.value);
	}
	// This will export typeFromAST with the correct type, but currently exposes
	// ~26 errors: https://gist.github.com/4a29403a99a8186fcb15064d69c5f3ae
	// export var typeFromAST: typeof typeFromASTType = typeFromASTImpl;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var typeFromAST = exports.typeFromAST = typeFromASTImpl;

/***/ }),
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = undefined;
	
	var _isInvalid = __webpack_require__(79);
	
	var _isInvalid2 = _interopRequireDefault(_isInvalid);
	
	var _astFromValue = __webpack_require__(168);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _scalars = __webpack_require__(42);
	
	var _directives = __webpack_require__(33);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var __Schema = exports.__Schema = new _definition.GraphQLObjectType({
	  name: '__Schema',
	  isIntrospection: true,
	  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',
	  fields: function fields() {
	    return {
	      types: {
	        description: 'A list of all types supported by this server.',
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
	        resolve: function resolve(schema) {
	          var typeMap = schema.getTypeMap();
	          return Object.keys(typeMap).map(function (key) {
	            return typeMap[key];
	          });
	        }
	      },
	      queryType: {
	        description: 'The type that query operations will be rooted at.',
	        type: new _definition.GraphQLNonNull(__Type),
	        resolve: function resolve(schema) {
	          return schema.getQueryType();
	        }
	      },
	      mutationType: {
	        description: 'If this server supports mutation, the type that ' + 'mutation operations will be rooted at.',
	        type: __Type,
	        resolve: function resolve(schema) {
	          return schema.getMutationType();
	        }
	      },
	      subscriptionType: {
	        description: 'If this server support subscription, the type that ' + 'subscription operations will be rooted at.',
	        type: __Type,
	        resolve: function resolve(schema) {
	          return schema.getSubscriptionType();
	        }
	      },
	      directives: {
	        description: 'A list of all directives supported by this server.',
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
	        resolve: function resolve(schema) {
	          return schema.getDirectives();
	        }
	      }
	    };
	  }
	});
	
	var __Directive = exports.__Directive = new _definition.GraphQLObjectType({
	  name: '__Directive',
	  isIntrospection: true,
	  description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + '\n\nIn some cases, you need to provide options to alter GraphQL\'s ' + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      locations: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation)))
	      },
	      args: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
	        resolve: function resolve(directive) {
	          return directive.args || [];
	        }
	      },
	      // NOTE: the following three fields are deprecated and are no longer part
	      // of the GraphQL specification.
	      onOperation: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.QUERY) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.MUTATION) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.SUBSCRIPTION) !== -1;
	        }
	      },
	      onFragment: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.FRAGMENT_SPREAD) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.INLINE_FRAGMENT) !== -1 || d.locations.indexOf(_directives.DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
	        }
	      },
	      onField: {
	        deprecationReason: 'Use `locations`.',
	        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
	        resolve: function resolve(d) {
	          return d.locations.indexOf(_directives.DirectiveLocation.FIELD) !== -1;
	        }
	      }
	    };
	  }
	});
	
	var __DirectiveLocation = exports.__DirectiveLocation = new _definition.GraphQLEnumType({
	  name: '__DirectiveLocation',
	  isIntrospection: true,
	  description: 'A Directive can be adjacent to many parts of the GraphQL language, a ' + '__DirectiveLocation describes one such possible adjacencies.',
	  values: {
	    QUERY: {
	      value: _directives.DirectiveLocation.QUERY,
	      description: 'Location adjacent to a query operation.'
	    },
	    MUTATION: {
	      value: _directives.DirectiveLocation.MUTATION,
	      description: 'Location adjacent to a mutation operation.'
	    },
	    SUBSCRIPTION: {
	      value: _directives.DirectiveLocation.SUBSCRIPTION,
	      description: 'Location adjacent to a subscription operation.'
	    },
	    FIELD: {
	      value: _directives.DirectiveLocation.FIELD,
	      description: 'Location adjacent to a field.'
	    },
	    FRAGMENT_DEFINITION: {
	      value: _directives.DirectiveLocation.FRAGMENT_DEFINITION,
	      description: 'Location adjacent to a fragment definition.'
	    },
	    FRAGMENT_SPREAD: {
	      value: _directives.DirectiveLocation.FRAGMENT_SPREAD,
	      description: 'Location adjacent to a fragment spread.'
	    },
	    INLINE_FRAGMENT: {
	      value: _directives.DirectiveLocation.INLINE_FRAGMENT,
	      description: 'Location adjacent to an inline fragment.'
	    },
	    SCHEMA: {
	      value: _directives.DirectiveLocation.SCHEMA,
	      description: 'Location adjacent to a schema definition.'
	    },
	    SCALAR: {
	      value: _directives.DirectiveLocation.SCALAR,
	      description: 'Location adjacent to a scalar definition.'
	    },
	    OBJECT: {
	      value: _directives.DirectiveLocation.OBJECT,
	      description: 'Location adjacent to an object type definition.'
	    },
	    FIELD_DEFINITION: {
	      value: _directives.DirectiveLocation.FIELD_DEFINITION,
	      description: 'Location adjacent to a field definition.'
	    },
	    ARGUMENT_DEFINITION: {
	      value: _directives.DirectiveLocation.ARGUMENT_DEFINITION,
	      description: 'Location adjacent to an argument definition.'
	    },
	    INTERFACE: {
	      value: _directives.DirectiveLocation.INTERFACE,
	      description: 'Location adjacent to an interface definition.'
	    },
	    UNION: {
	      value: _directives.DirectiveLocation.UNION,
	      description: 'Location adjacent to a union definition.'
	    },
	    ENUM: {
	      value: _directives.DirectiveLocation.ENUM,
	      description: 'Location adjacent to an enum definition.'
	    },
	    ENUM_VALUE: {
	      value: _directives.DirectiveLocation.ENUM_VALUE,
	      description: 'Location adjacent to an enum value definition.'
	    },
	    INPUT_OBJECT: {
	      value: _directives.DirectiveLocation.INPUT_OBJECT,
	      description: 'Location adjacent to an input object type definition.'
	    },
	    INPUT_FIELD_DEFINITION: {
	      value: _directives.DirectiveLocation.INPUT_FIELD_DEFINITION,
	      description: 'Location adjacent to an input object field definition.'
	    }
	  }
	});
	
	var __Type = exports.__Type = new _definition.GraphQLObjectType({
	  name: '__Type',
	  isIntrospection: true,
	  description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\n\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',
	  fields: function fields() {
	    return {
	      kind: {
	        type: new _definition.GraphQLNonNull(__TypeKind),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLScalarType) {
	            return TypeKind.SCALAR;
	          } else if (type instanceof _definition.GraphQLObjectType) {
	            return TypeKind.OBJECT;
	          } else if (type instanceof _definition.GraphQLInterfaceType) {
	            return TypeKind.INTERFACE;
	          } else if (type instanceof _definition.GraphQLUnionType) {
	            return TypeKind.UNION;
	          } else if (type instanceof _definition.GraphQLEnumType) {
	            return TypeKind.ENUM;
	          } else if (type instanceof _definition.GraphQLInputObjectType) {
	            return TypeKind.INPUT_OBJECT;
	          } else if (type instanceof _definition.GraphQLList) {
	            return TypeKind.LIST;
	          } else if (type instanceof _definition.GraphQLNonNull) {
	            return TypeKind.NON_NULL;
	          }
	          throw new Error('Unknown kind of type: ' + type);
	        }
	      },
	      name: { type: _scalars.GraphQLString },
	      description: { type: _scalars.GraphQLString },
	      fields: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
	        args: {
	          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }
	        },
	        resolve: function resolve(type, _ref) {
	          var includeDeprecated = _ref.includeDeprecated;
	
	          if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	            var fieldMap = type.getFields();
	            var fields = Object.keys(fieldMap).map(function (fieldName) {
	              return fieldMap[fieldName];
	            });
	            if (!includeDeprecated) {
	              fields = fields.filter(function (field) {
	                return !field.deprecationReason;
	              });
	            }
	            return fields;
	          }
	          return null;
	        }
	      },
	      interfaces: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLObjectType) {
	            return type.getInterfaces();
	          }
	        }
	      },
	      possibleTypes: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
	        resolve: function resolve(type, args, context, _ref2) {
	          var schema = _ref2.schema;
	
	          if ((0, _definition.isAbstractType)(type)) {
	            return schema.getPossibleTypes(type);
	          }
	        }
	      },
	      enumValues: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
	        args: {
	          includeDeprecated: { type: _scalars.GraphQLBoolean, defaultValue: false }
	        },
	        resolve: function resolve(type, _ref3) {
	          var includeDeprecated = _ref3.includeDeprecated;
	
	          if (type instanceof _definition.GraphQLEnumType) {
	            var values = type.getValues();
	            if (!includeDeprecated) {
	              values = values.filter(function (value) {
	                return !value.deprecationReason;
	              });
	            }
	            return values;
	          }
	        }
	      },
	      inputFields: {
	        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
	        resolve: function resolve(type) {
	          if (type instanceof _definition.GraphQLInputObjectType) {
	            var fieldMap = type.getFields();
	            return Object.keys(fieldMap).map(function (fieldName) {
	              return fieldMap[fieldName];
	            });
	          }
	        }
	      },
	      ofType: { type: __Type }
	    };
	  }
	});
	
	var __Field = exports.__Field = new _definition.GraphQLObjectType({
	  name: '__Field',
	  isIntrospection: true,
	  description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      args: {
	        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
	        resolve: function resolve(field) {
	          return field.args || [];
	        }
	      },
	      type: { type: new _definition.GraphQLNonNull(__Type) },
	      isDeprecated: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },
	      deprecationReason: {
	        type: _scalars.GraphQLString
	      }
	    };
	  }
	});
	
	var __InputValue = exports.__InputValue = new _definition.GraphQLObjectType({
	  name: '__InputValue',
	  isIntrospection: true,
	  description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      type: { type: new _definition.GraphQLNonNull(__Type) },
	      defaultValue: {
	        type: _scalars.GraphQLString,
	        description: 'A GraphQL-formatted string representing the default value for this ' + 'input value.',
	        resolve: function resolve(inputVal) {
	          return (0, _isInvalid2.default)(inputVal.defaultValue) ? null : (0, _printer.print)((0, _astFromValue.astFromValue)(inputVal.defaultValue, inputVal.type));
	        }
	      }
	    };
	  }
	});
	
	var __EnumValue = exports.__EnumValue = new _definition.GraphQLObjectType({
	  name: '__EnumValue',
	  isIntrospection: true,
	  description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',
	  fields: function fields() {
	    return {
	      name: { type: new _definition.GraphQLNonNull(_scalars.GraphQLString) },
	      description: { type: _scalars.GraphQLString },
	      isDeprecated: { type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean) },
	      deprecationReason: {
	        type: _scalars.GraphQLString
	      }
	    };
	  }
	});
	
	var TypeKind = exports.TypeKind = {
	  SCALAR: 'SCALAR',
	  OBJECT: 'OBJECT',
	  INTERFACE: 'INTERFACE',
	  UNION: 'UNION',
	  ENUM: 'ENUM',
	  INPUT_OBJECT: 'INPUT_OBJECT',
	  LIST: 'LIST',
	  NON_NULL: 'NON_NULL'
	};
	
	var __TypeKind = exports.__TypeKind = new _definition.GraphQLEnumType({
	  name: '__TypeKind',
	  isIntrospection: true,
	  description: 'An enum describing what kind of type a given `__Type` is.',
	  values: {
	    SCALAR: {
	      value: TypeKind.SCALAR,
	      description: 'Indicates this type is a scalar.'
	    },
	    OBJECT: {
	      value: TypeKind.OBJECT,
	      description: 'Indicates this type is an object. ' + '`fields` and `interfaces` are valid fields.'
	    },
	    INTERFACE: {
	      value: TypeKind.INTERFACE,
	      description: 'Indicates this type is an interface. ' + '`fields` and `possibleTypes` are valid fields.'
	    },
	    UNION: {
	      value: TypeKind.UNION,
	      description: 'Indicates this type is a union. ' + '`possibleTypes` is a valid field.'
	    },
	    ENUM: {
	      value: TypeKind.ENUM,
	      description: 'Indicates this type is an enum. ' + '`enumValues` is a valid field.'
	    },
	    INPUT_OBJECT: {
	      value: TypeKind.INPUT_OBJECT,
	      description: 'Indicates this type is an input object. ' + '`inputFields` is a valid field.'
	    },
	    LIST: {
	      value: TypeKind.LIST,
	      description: 'Indicates this type is a list. ' + '`ofType` is a valid field.'
	    },
	    NON_NULL: {
	      value: TypeKind.NON_NULL,
	      description: 'Indicates this type is a non-null. ' + '`ofType` is a valid field.'
	    }
	  }
	});
	
	/**
	 * Note that these are GraphQLField and not GraphQLFieldConfig,
	 * so the format for args is different.
	 */
	
	var SchemaMetaFieldDef = exports.SchemaMetaFieldDef = {
	  name: '__schema',
	  type: new _definition.GraphQLNonNull(__Schema),
	  description: 'Access the current type schema of this server.',
	  args: [],
	  resolve: function resolve(source, args, context, _ref4) {
	    var schema = _ref4.schema;
	    return schema;
	  }
	};
	
	var TypeMetaFieldDef = exports.TypeMetaFieldDef = {
	  name: '__type',
	  type: __Type,
	  description: 'Request the type information of a single type.',
	  args: [{ name: 'name', type: new _definition.GraphQLNonNull(_scalars.GraphQLString) }],
	  resolve: function resolve(source, _ref5, context, _ref6) {
	    var name = _ref5.name;
	    var schema = _ref6.schema;
	    return schema.getType(name);
	  }
	};
	
	var TypeNameMetaFieldDef = exports.TypeNameMetaFieldDef = {
	  name: '__typename',
	  type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
	  description: 'The name of the current Object type at runtime.',
	  args: [],
	  resolve: function resolve(source, args, context, _ref7) {
	    var parentType = _ref7.parentType;
	    return parentType.name;
	  }
	};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = undefined;
	
	var _definition = __webpack_require__(7);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	// As per the GraphQL Spec, Integers are only treated as valid when a valid
	// 32-bit signed integer, providing the broadest support across platforms.
	//
	// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because
	// they are internally represented as IEEE 754 doubles.
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var MAX_INT = 2147483647;
	var MIN_INT = -2147483648;
	
	function coerceInt(value) {
	  if (value === '') {
	    throw new TypeError('Int cannot represent non 32-bit signed integer value: (empty string)');
	  }
	  var num = Number(value);
	  if (num !== num || num > MAX_INT || num < MIN_INT) {
	    throw new TypeError('Int cannot represent non 32-bit signed integer value: ' + String(value));
	  }
	  var int = Math.floor(num);
	  if (int !== num) {
	    throw new TypeError('Int cannot represent non-integer value: ' + String(value));
	  }
	  return int;
	}
	
	var GraphQLInt = exports.GraphQLInt = new _definition.GraphQLScalarType({
	  name: 'Int',
	  description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^31) and 2^31 - 1. ',
	  serialize: coerceInt,
	  parseValue: coerceInt,
	  parseLiteral: function parseLiteral(ast) {
	    if (ast.kind === Kind.INT) {
	      var num = parseInt(ast.value, 10);
	      if (num <= MAX_INT && num >= MIN_INT) {
	        return num;
	      }
	    }
	    return null;
	  }
	});
	
	function coerceFloat(value) {
	  if (value === '') {
	    throw new TypeError('Float cannot represent non numeric value: (empty string)');
	  }
	  var num = Number(value);
	  if (num === num) {
	    return num;
	  }
	  throw new TypeError('Float cannot represent non numeric value: ' + String(value));
	}
	
	var GraphQLFloat = exports.GraphQLFloat = new _definition.GraphQLScalarType({
	  name: 'Float',
	  description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',
	  serialize: coerceFloat,
	  parseValue: coerceFloat,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.FLOAT || ast.kind === Kind.INT ? parseFloat(ast.value) : null;
	  }
	});
	
	function coerceString(value) {
	  if (Array.isArray(value)) {
	    throw new TypeError('String cannot represent an array value: [' + String(value) + ']');
	  }
	  return String(value);
	}
	
	var GraphQLString = exports.GraphQLString = new _definition.GraphQLScalarType({
	  name: 'String',
	  description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',
	  serialize: coerceString,
	  parseValue: coerceString,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.STRING ? ast.value : null;
	  }
	});
	
	var GraphQLBoolean = exports.GraphQLBoolean = new _definition.GraphQLScalarType({
	  name: 'Boolean',
	  description: 'The `Boolean` scalar type represents `true` or `false`.',
	  serialize: Boolean,
	  parseValue: Boolean,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.BOOLEAN ? ast.value : null;
	  }
	});
	
	var GraphQLID = exports.GraphQLID = new _definition.GraphQLScalarType({
	  name: 'ID',
	  description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `"4"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',
	  serialize: String,
	  parseValue: String,
	  parseLiteral: function parseLiteral(ast) {
	    return ast.kind === Kind.STRING || ast.kind === Kind.INT ? ast.value : null;
	  }
	});

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	
	exports = module.exports = trim;
	
	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}
	
	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};
	
	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ }),
/* 45 */,
/* 46 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNullish;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	/**
	 * Returns true if a value is null, undefined, or NaN.
	 */
	function isNullish(value) {
	  return value === null || value === undefined || value !== value;
	}

/***/ }),
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */
/***/ (function(module, exports) {

	'use strict';
	
	
	function isNothing(subject) {
	  return (typeof subject === 'undefined') || (subject === null);
	}
	
	
	function isObject(subject) {
	  return (typeof subject === 'object') && (subject !== null);
	}
	
	
	function toArray(sequence) {
	  if (Array.isArray(sequence)) return sequence;
	  else if (isNothing(sequence)) return [];
	
	  return [ sequence ];
	}
	
	
	function extend(target, source) {
	  var index, length, key, sourceKeys;
	
	  if (source) {
	    sourceKeys = Object.keys(source);
	
	    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	      key = sourceKeys[index];
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	
	function repeat(string, count) {
	  var result = '', cycle;
	
	  for (cycle = 0; cycle < count; cycle += 1) {
	    result += string;
	  }
	
	  return result;
	}
	
	
	function isNegativeZero(number) {
	  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
	}
	
	
	module.exports.isNothing      = isNothing;
	module.exports.isObject       = isObject;
	module.exports.toArray        = toArray;
	module.exports.repeat         = repeat;
	module.exports.isNegativeZero = isNegativeZero;
	module.exports.extend         = extend;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*eslint-disable max-len*/
	
	var common        = __webpack_require__(55);
	var YAMLException = __webpack_require__(75);
	var Type          = __webpack_require__(18);
	
	
	function compileList(schema, name, result) {
	  var exclude = [];
	
	  schema.include.forEach(function (includedSchema) {
	    result = compileList(includedSchema, name, result);
	  });
	
	  schema[name].forEach(function (currentType) {
	    result.forEach(function (previousType, previousIndex) {
	      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
	        exclude.push(previousIndex);
	      }
	    });
	
	    result.push(currentType);
	  });
	
	  return result.filter(function (type, index) {
	    return exclude.indexOf(index) === -1;
	  });
	}
	
	
	function compileMap(/* lists... */) {
	  var result = {
	        scalar: {},
	        sequence: {},
	        mapping: {},
	        fallback: {}
	      }, index, length;
	
	  function collectType(type) {
	    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
	  }
	
	  for (index = 0, length = arguments.length; index < length; index += 1) {
	    arguments[index].forEach(collectType);
	  }
	  return result;
	}
	
	
	function Schema(definition) {
	  this.include  = definition.include  || [];
	  this.implicit = definition.implicit || [];
	  this.explicit = definition.explicit || [];
	
	  this.implicit.forEach(function (type) {
	    if (type.loadKind && type.loadKind !== 'scalar') {
	      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	    }
	  });
	
	  this.compiledImplicit = compileList(this, 'implicit', []);
	  this.compiledExplicit = compileList(this, 'explicit', []);
	  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
	}
	
	
	Schema.DEFAULT = null;
	
	
	Schema.create = function createSchema() {
	  var schemas, types;
	
	  switch (arguments.length) {
	    case 1:
	      schemas = Schema.DEFAULT;
	      types = arguments[0];
	      break;
	
	    case 2:
	      schemas = arguments[0];
	      types = arguments[1];
	      break;
	
	    default:
	      throw new YAMLException('Wrong number of arguments for Schema.create function');
	  }
	
	  schemas = common.toArray(schemas);
	  types = common.toArray(types);
	
	  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
	    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	  }
	
	  if (!types.every(function (type) { return type instanceof Type; })) {
	    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	  }
	
	  return new Schema({
	    include: schemas,
	    explicit: types
	  });
	};
	
	
	module.exports = Schema;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLError = GraphQLError;
	
	var _location = __webpack_require__(165);
	
	/**
	 * A GraphQLError describes an Error found during the parse, validate, or
	 * execute phases of performing a GraphQL operation. In addition to a message
	 * and stack trace, it also includes information about the locations in a
	 * GraphQL document and/or execution result that correspond to the Error.
	 */
	function GraphQLError( // eslint-disable-line no-redeclare
	message, nodes, source, positions, path, originalError) {
	  // Compute locations in the source for the given nodes/positions.
	  var _source = source;
	  if (!_source && nodes && nodes.length > 0) {
	    var node = nodes[0];
	    _source = node && node.loc && node.loc.source;
	  }
	
	  var _positions = positions;
	  if (!_positions && nodes) {
	    _positions = nodes.filter(function (node) {
	      return Boolean(node.loc);
	    }).map(function (node) {
	      return node.loc.start;
	    });
	  }
	  if (_positions && _positions.length === 0) {
	    _positions = undefined;
	  }
	
	  var _locations = void 0;
	  var _source2 = _source; // seems here Flow need a const to resolve type.
	  if (_source2 && _positions) {
	    _locations = _positions.map(function (pos) {
	      return (0, _location.getLocation)(_source2, pos);
	    });
	  }
	
	  Object.defineProperties(this, {
	    message: {
	      value: message,
	      // By being enumerable, JSON.stringify will include `message` in the
	      // resulting output. This ensures that the simplest possible GraphQL
	      // service adheres to the spec.
	      enumerable: true,
	      writable: true
	    },
	    locations: {
	      // Coercing falsey values to undefined ensures they will not be included
	      // in JSON.stringify() when not provided.
	      value: _locations || undefined,
	      // By being enumerable, JSON.stringify will include `locations` in the
	      // resulting output. This ensures that the simplest possible GraphQL
	      // service adheres to the spec.
	      enumerable: true
	    },
	    path: {
	      // Coercing falsey values to undefined ensures they will not be included
	      // in JSON.stringify() when not provided.
	      value: path || undefined,
	      // By being enumerable, JSON.stringify will include `path` in the
	      // resulting output. This ensures that the simplest possible GraphQL
	      // service adheres to the spec.
	      enumerable: true
	    },
	    nodes: {
	      value: nodes || undefined
	    },
	    source: {
	      value: _source || undefined
	    },
	    positions: {
	      value: _positions || undefined
	    },
	    originalError: {
	      value: originalError
	    }
	  });
	
	  // Include (non-enumerable) stack trace.
	  if (originalError && originalError.stack) {
	    Object.defineProperty(this, 'stack', {
	      value: originalError.stack,
	      writable: true,
	      configurable: true
	    });
	  } else if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, GraphQLError);
	  } else {
	    Object.defineProperty(this, 'stack', {
	      value: Error().stack,
	      writable: true,
	      configurable: true
	    });
	  }
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	GraphQLError.prototype = Object.create(Error.prototype, {
	  constructor: { value: GraphQLError },
	  name: { value: 'GraphQLError' }
	});

/***/ }),
/* 58 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = find;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function find(list, predicate) {
	  for (var i = 0; i < list.length; i++) {
	    if (predicate(list[i])) {
	      return list[i];
	    }
	  }
	}

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = keyMap;
	
	
	/**
	 * Creates a keyed JS object from an array, given a function to produce the keys
	 * for each value in the array.
	 *
	 * This provides a convenient lookup for the array items if the key function
	 * produces unique results.
	 *
	 *     const phoneBook = [
	 *       { name: 'Jon', num: '555-1234' },
	 *       { name: 'Jenny', num: '867-5309' }
	 *     ]
	 *
	 *     // { Jon: { name: 'Jon', num: '555-1234' },
	 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
	 *     const entriesByName = keyMap(
	 *       phoneBook,
	 *       entry => entry.name
	 *     )
	 *
	 *     // { name: 'Jenny', num: '857-6309' }
	 *     const jennyEntry = entriesByName['Jenny']
	 *
	 */
	function keyMap(list, keyFn) {
	  return list.reduce(function (map, item) {
	    return map[keyFn(item)] = item, map;
	  }, Object.create(null));
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 60 */,
/* 61 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2016, Lee Byron
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @ignore
	 */
	
	/**
	 * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)
	 * is a *protocol* which describes a standard way to produce a sequence of
	 * values, typically the values of the Iterable represented by this Iterator.
	 *
	 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} Iterator
	 * @template T The type of each iterated value
	 * @property {function (): { value: T, done: boolean }} next
	 *   A method which produces either the next value in a sequence or a result
	 *   where the `done` property is `true` indicating the end of the Iterator.
	 */
	
	/**
	 * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	 * is a *protocol* which when implemented allows a JavaScript object to define
	 * their iteration behavior, such as what values are looped over in a `for..of`
	 * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)
	 * implement the Iterable protocol, including `Array` and `Map`.
	 *
	 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} Iterable
	 * @template T The type of each iterated value
	 * @property {function (): Iterator<T>} Symbol.iterator
	 *   A method which produces an Iterator for this Iterable.
	 */
	
	// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
	var SYMBOL_ITERATOR = typeof Symbol === 'function' && Symbol.iterator
	
	/**
	 * A property name to be used as the name of an Iterable's method responsible
	 * for producing an Iterator, referred to as `@@iterator`. Typically represents
	 * the value `Symbol.iterator` but falls back to the string `"@@iterator"` when
	 * `Symbol.iterator` is not defined.
	 *
	 * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,
	 * but do not use it for accessing existing Iterables, instead use
	 * `getIterator()` or `isIterable()`.
	 *
	 * @example
	 *
	 * var $$iterator = require('iterall').$$iterator
	 *
	 * function Counter (to) {
	 *   this.to = to
	 * }
	 *
	 * Counter.prototype[$$iterator] = function () {
	 *   return {
	 *     to: this.to,
	 *     num: 0,
	 *     next () {
	 *       if (this.num >= this.to) {
	 *         return { value: undefined, done: true }
	 *       }
	 *       return { value: this.num++, done: false }
	 *     }
	 *   }
	 * }
	 *
	 * var counter = new Counter(3)
	 * for (var number of counter) {
	 *   console.log(number) // 0 ... 1 ... 2
	 * }
	 *
	 * @type {Symbol|string}
	 */
	var $$iterator = SYMBOL_ITERATOR || '@@iterator'
	exports.$$iterator = $$iterator
	
	/**
	 * Returns true if the provided object implements the Iterator protocol via
	 * either implementing a `Symbol.iterator` or `"@@iterator"` method.
	 *
	 * @example
	 *
	 * var isIterable = require('iterall').isIterable
	 * isIterable([ 1, 2, 3 ]) // true
	 * isIterable('ABC') // true
	 * isIterable({ length: 1, 0: 'Alpha' }) // false
	 * isIterable({ key: 'value' }) // false
	 * isIterable(new Map()) // true
	 *
	 * @param obj
	 *   A value which might implement the Iterable protocol.
	 * @return {boolean} true if Iterable.
	 */
	function isIterable(obj) {
	  return !!getIteratorMethod(obj)
	}
	exports.isIterable = isIterable
	
	/**
	 * Returns true if the provided object implements the Array-like protocol via
	 * defining a positive-integer `length` property.
	 *
	 * @example
	 *
	 * var isArrayLike = require('iterall').isArrayLike
	 * isArrayLike([ 1, 2, 3 ]) // true
	 * isArrayLike('ABC') // true
	 * isArrayLike({ length: 1, 0: 'Alpha' }) // true
	 * isArrayLike({ key: 'value' }) // false
	 * isArrayLike(new Map()) // false
	 *
	 * @param obj
	 *   A value which might implement the Array-like protocol.
	 * @return {boolean} true if Array-like.
	 */
	function isArrayLike(obj) {
	  var length = obj != null && obj.length
	  return typeof length === 'number' && length >= 0 && length % 1 === 0
	}
	exports.isArrayLike = isArrayLike
	
	/**
	 * Returns true if the provided object is an Object (i.e. not a string literal)
	 * and is either Iterable or Array-like.
	 *
	 * This may be used in place of [Array.isArray()][isArray] to determine if an
	 * object should be iterated-over. It always excludes string literals and
	 * includes Arrays (regardless of if it is Iterable). It also includes other
	 * Array-like objects such as NodeList, TypedArray, and Buffer.
	 *
	 * @example
	 *
	 * var isCollection = require('iterall').isCollection
	 * isCollection([ 1, 2, 3 ]) // true
	 * isCollection('ABC') // false
	 * isCollection({ length: 1, 0: 'Alpha' }) // true
	 * isCollection({ key: 'value' }) // false
	 * isCollection(new Map()) // true
	 *
	 * @example
	 *
	 * var forEach = require('iterall').forEach
	 * if (isCollection(obj)) {
	 *   forEach(obj, function (value) {
	 *     console.log(value)
	 *   })
	 * }
	 *
	 * @param obj
	 *   An Object value which might implement the Iterable or Array-like protocols.
	 * @return {boolean} true if Iterable or Array-like Object.
	 */
	function isCollection(obj) {
	  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))
	}
	exports.isCollection = isCollection
	
	/**
	 * If the provided object implements the Iterator protocol, its Iterator object
	 * is returned. Otherwise returns undefined.
	 *
	 * @example
	 *
	 * var getIterator = require('iterall').getIterator
	 * var iterator = getIterator([ 1, 2, 3 ])
	 * iterator.next() // { value: 1, done: false }
	 * iterator.next() // { value: 2, done: false }
	 * iterator.next() // { value: 3, done: false }
	 * iterator.next() // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>} iterable
	 *   An Iterable object which is the source of an Iterator.
	 * @return {Iterator<T>} new Iterator instance.
	 */
	function getIterator(iterable) {
	  var method = getIteratorMethod(iterable)
	  if (method) {
	    return method.call(iterable)
	  }
	}
	exports.getIterator = getIterator
	
	/**
	 * If the provided object implements the Iterator protocol, the method
	 * responsible for producing its Iterator object is returned.
	 *
	 * This is used in rare cases for performance tuning. This method must be called
	 * with obj as the contextual this-argument.
	 *
	 * @example
	 *
	 * var getIteratorMethod = require('iterall').getIteratorMethod
	 * var myArray = [ 1, 2, 3 ]
	 * var method = getIteratorMethod(myArray)
	 * if (method) {
	 *   var iterator = method.call(myArray)
	 * }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>} iterable
	 *   An Iterable object which defines an `@@iterator` method.
	 * @return {function(): Iterator<T>} `@@iterator` method.
	 */
	function getIteratorMethod(iterable) {
	  if (iterable != null) {
	    var method =
	      (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) || iterable['@@iterator']
	    if (typeof method === 'function') {
	      return method
	    }
	  }
	}
	exports.getIteratorMethod = getIteratorMethod
	
	/**
	 * Similar to `getIterator()`, this method returns a new Iterator given an
	 * Iterable. However it will also create an Iterator for a non-Iterable
	 * Array-like collection, such as Array in a non-ES2015 environment.
	 *
	 * `createIterator` is complimentary to `forEach`, but allows a "pull"-based
	 * iteration as opposed to `forEach`'s "push"-based iteration.
	 *
	 * `createIterator` produces an Iterator for Array-likes with the same behavior
	 * as ArrayIteratorPrototype described in the ECMAScript specification, and
	 * does *not* skip over "holes".
	 *
	 * @example
	 *
	 * var createIterator = require('iterall').createIterator
	 *
	 * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }
	 * var iterator = createIterator(myArraylike)
	 * iterator.next() // { value: 'Alpha', done: false }
	 * iterator.next() // { value: 'Bravo', done: false }
	 * iterator.next() // { value: 'Charlie', done: false }
	 * iterator.next() // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>|{ length: number }} collection
	 *   An Iterable or Array-like object to produce an Iterator.
	 * @return {Iterator<T>} new Iterator instance.
	 */
	function createIterator(collection) {
	  if (collection != null) {
	    var iterator = getIterator(collection)
	    if (iterator) {
	      return iterator
	    }
	    if (isArrayLike(collection)) {
	      return new ArrayLikeIterator(collection)
	    }
	  }
	}
	exports.createIterator = createIterator
	
	// When the object provided to `createIterator` is not Iterable but is
	// Array-like, this simple Iterator is created.
	function ArrayLikeIterator(obj) {
	  this._o = obj
	  this._i = 0
	}
	
	// Note: all Iterators are themselves Iterable.
	ArrayLikeIterator.prototype[$$iterator] = function() {
	  return this
	}
	
	// A simple state-machine determines the IteratorResult returned, yielding
	// each value in the Array-like object in order of their indicies.
	ArrayLikeIterator.prototype.next = function() {
	  if (this._o === void 0 || this._i >= this._o.length) {
	    this._o = void 0
	    return { value: void 0, done: true }
	  }
	  return { value: this._o[this._i++], done: false }
	}
	
	/**
	 * Given an object which either implements the Iterable protocol or is
	 * Array-like, iterate over it, calling the `callback` at each iteration.
	 *
	 * Use `forEach` where you would expect to use a `for ... of` loop in ES6.
	 * However `forEach` adheres to the behavior of [Array#forEach][] described in
	 * the ECMAScript specification, skipping over "holes" in Array-likes. It will
	 * also delegate to a `forEach` method on `collection` if one is defined,
	 * ensuring native performance for `Arrays`.
	 *
	 * Similar to [Array#forEach][], the `callback` function accepts three
	 * arguments, and is provided with `thisArg` as the calling context.
	 *
	 * Note: providing an infinite Iterator to forEach will produce an error.
	 *
	 * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
	 *
	 * @example
	 *
	 * var forEach = require('iterall').forEach
	 *
	 * forEach(myIterable, function (value, index, iterable) {
	 *   console.log(value, index, iterable === myIterable)
	 * })
	 *
	 * @example
	 *
	 * // ES6:
	 * for (let value of myIterable) {
	 *   console.log(value)
	 * }
	 *
	 * // Any JavaScript environment:
	 * forEach(myIterable, function (value) {
	 *   console.log(value)
	 * })
	 *
	 * @template T the type of each iterated value
	 * @param {Iterable<T>|{ length: number }} collection
	 *   The Iterable or array to iterate over.
	 * @param {function(T, number, object)} callback
	 *   Function to execute for each iteration, taking up to three arguments
	 * @param [thisArg]
	 *   Optional. Value to use as `this` when executing `callback`.
	 */
	function forEach(collection, callback, thisArg) {
	  if (collection != null) {
	    if (typeof collection.forEach === 'function') {
	      return collection.forEach(callback, thisArg)
	    }
	    var i = 0
	    var iterator = getIterator(collection)
	    if (iterator) {
	      var step
	      while (!(step = iterator.next()).done) {
	        callback.call(thisArg, step.value, i++, collection)
	        // Infinite Iterators could cause forEach to run forever.
	        // After a very large number of iterations, produce an error.
	        /* istanbul ignore if */
	        if (i > 9999999) {
	          throw new TypeError('Near-infinite iteration.')
	        }
	      }
	    } else if (isArrayLike(collection)) {
	      for (; i < collection.length; i++) {
	        if (collection.hasOwnProperty(i)) {
	          callback.call(thisArg, collection[i], i, collection)
	        }
	      }
	    }
	  }
	}
	exports.forEach = forEach
	
	/////////////////////////////////////////////////////
	//                                                 //
	//                 ASYNC ITERATORS                 //
	//                                                 //
	/////////////////////////////////////////////////////
	
	/**
	 * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/)
	 * is a *protocol* which describes a standard way to produce and consume an
	 * asynchronous sequence of values, typically the values of the AsyncIterable
	 * represented by this AsyncIterator.
	 *
	 * AsyncIterator is similar to Observable or Stream.
	 *
	 * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} AsyncIterator
	 * @template T The type of each iterated value
	 * @property {function (): Promise<{ value: T, done: boolean }>} next
	 *   A method which produces a Promise which resolves to either the next value
	 *   in a sequence or a result where the `done` property is `true` indicating
	 *   the end of the sequence of values. It may also produce a Promise which
	 *   becomes rejected, indicating a failure.
	 */
	
	/**
	 * AsyncIterable is a *protocol* which when implemented allows a JavaScript
	 * object to define their asynchronous iteration behavior, such as what values
	 * are looped over in a `for-await-of` loop or `iterall`'s `forAwaitEach`
	 * function.
	 *
	 * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)
	 * it can be utilized by any version of JavaScript.
	 *
	 * @typedef {Object} AsyncIterable
	 * @template T The type of each iterated value
	 * @property {function (): AsyncIterator<T>} Symbol.asyncIterator
	 *   A method which produces an AsyncIterator for this AsyncIterable.
	 */
	
	// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator
	var SYMBOL_ASYNC_ITERATOR = typeof Symbol === 'function' && Symbol.asyncIterator
	
	/**
	 * A property name to be used as the name of an AsyncIterable's method
	 * responsible for producing an Iterator, referred to as `@@asyncIterator`.
	 * Typically represents the value `Symbol.asyncIterator` but falls back to the
	 * string `"@@asyncIterator"` when `Symbol.asyncIterator` is not defined.
	 *
	 * Use `$$asyncIterator` for defining new AsyncIterables instead of
	 * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,
	 * instead use `getAsyncIterator()` or `isAsyncIterable()`.
	 *
	 * @example
	 *
	 * var $$asyncIterator = require('iterall').$$asyncIterator
	 *
	 * function Chirper (to) {
	 *   this.to = to
	 * }
	 *
	 * Chirper.prototype[$$asyncIterator] = function () {
	 *   return {
	 *     to: this.to,
	 *     num: 0,
	 *     next () {
	 *       return new Promise(function (resolve) {
	 *         if (this.num >= this.to) {
	 *           resolve({ value: undefined, done: true })
	 *         } else {
	 *           setTimeout(function () {
	 *             resolve({ value: this.num++, done: false })
	 *           }, 1000)
	 *         }
	 *       }
	 *     }
	 *   }
	 * }
	 *
	 * var chirper = new Chirper(3)
	 * for await (var number of chirper) {
	 *   console.log(number) // 0 ...wait... 1 ...wait... 2
	 * }
	 *
	 * @type {Symbol|string}
	 */
	var $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator'
	exports.$$asyncIterator = $$asyncIterator
	
	/**
	 * Returns true if the provided object implements the AsyncIterator protocol via
	 * either implementing a `Symbol.asyncIterator` or `"@@asyncIterator"` method.
	 *
	 * @example
	 *
	 * var isAsyncIterable = require('iterall').isAsyncIterable
	 * isAsyncIterable(myStream) // true
	 * isAsyncIterable('ABC') // false
	 *
	 * @param obj
	 *   A value which might implement the AsyncIterable protocol.
	 * @return {boolean} true if AsyncIterable.
	 */
	function isAsyncIterable(obj) {
	  return !!getAsyncIteratorMethod(obj)
	}
	exports.isAsyncIterable = isAsyncIterable
	
	/**
	 * If the provided object implements the AsyncIterator protocol, its
	 * AsyncIterator object is returned. Otherwise returns undefined.
	 *
	 * @example
	 *
	 * var getAsyncIterator = require('iterall').getAsyncIterator
	 * var asyncIterator = getAsyncIterator(myStream)
	 * asyncIterator.next().then(console.log) // { value: 1, done: false }
	 * asyncIterator.next().then(console.log) // { value: 2, done: false }
	 * asyncIterator.next().then(console.log) // { value: 3, done: false }
	 * asyncIterator.next().then(console.log) // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {AsyncIterable<T>} asyncIterable
	 *   An AsyncIterable object which is the source of an AsyncIterator.
	 * @return {AsyncIterator<T>} new AsyncIterator instance.
	 */
	function getAsyncIterator(asyncIterable) {
	  var method = getAsyncIteratorMethod(asyncIterable)
	  if (method) {
	    return method.call(asyncIterable)
	  }
	}
	exports.getAsyncIterator = getAsyncIterator
	
	/**
	 * If the provided object implements the AsyncIterator protocol, the method
	 * responsible for producing its AsyncIterator object is returned.
	 *
	 * This is used in rare cases for performance tuning. This method must be called
	 * with obj as the contextual this-argument.
	 *
	 * @example
	 *
	 * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod
	 * var method = getAsyncIteratorMethod(myStream)
	 * if (method) {
	 *   var asyncIterator = method.call(myStream)
	 * }
	 *
	 * @template T the type of each iterated value
	 * @param {AsyncIterable<T>} asyncIterable
	 *   An AsyncIterable object which defines an `@@asyncIterator` method.
	 * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.
	 */
	function getAsyncIteratorMethod(asyncIterable) {
	  if (asyncIterable != null) {
	    var method =
	      (SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||
	      asyncIterable['@@asyncIterator']
	    if (typeof method === 'function') {
	      return method
	    }
	  }
	}
	exports.getAsyncIteratorMethod = getAsyncIteratorMethod
	
	/**
	 * Similar to `getAsyncIterator()`, this method returns a new AsyncIterator
	 * given an AsyncIterable. However it will also create an AsyncIterator for a
	 * non-async Iterable as well as non-Iterable Array-like collection, such as
	 * Array in a pre-ES2015 environment.
	 *
	 * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a
	 * buffering "pull"-based iteration as opposed to `forAwaitEach`'s
	 * "push"-based iteration.
	 *
	 * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as
	 * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).
	 *
	 * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.
	 * > While `Promise` has been available in modern browsers for a number of
	 * > years, legacy browsers (like IE 11) may require a polyfill.
	 *
	 * @example
	 *
	 * var createAsyncIterator = require('iterall').createAsyncIterator
	 *
	 * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }
	 * var iterator = createAsyncIterator(myArraylike)
	 * iterator.next().then(console.log) // { value: 'Alpha', done: false }
	 * iterator.next().then(console.log) // { value: 'Bravo', done: false }
	 * iterator.next().then(console.log) // { value: 'Charlie', done: false }
	 * iterator.next().then(console.log) // { value: undefined, done: true }
	 *
	 * @template T the type of each iterated value
	 * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source
	 *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.
	 * @return {AsyncIterator<T>} new AsyncIterator instance.
	 */
	function createAsyncIterator(source) {
	  if (source != null) {
	    var asyncIterator = getAsyncIterator(source)
	    if (asyncIterator) {
	      return asyncIterator
	    }
	    var iterator = createIterator(source)
	    if (iterator) {
	      return new AsyncFromSyncIterator(iterator)
	    }
	  }
	}
	exports.createAsyncIterator = createAsyncIterator
	
	// When the object provided to `createAsyncIterator` is not AsyncIterable but is
	// sync Iterable, this simple wrapper is created.
	function AsyncFromSyncIterator(iterator) {
	  this._i = iterator
	}
	
	// Note: all AsyncIterators are themselves AsyncIterable.
	AsyncFromSyncIterator.prototype[$$asyncIterator] = function() {
	  return this
	}
	
	// A simple state-machine determines the IteratorResult returned, yielding
	// each value in the Array-like object in order of their indicies.
	AsyncFromSyncIterator.prototype.next = function() {
	  var step = this._i.next()
	  return Promise.resolve(step.value).then(function(value) {
	    return { value: value, done: step.done }
	  })
	}
	
	/**
	 * Given an object which either implements the AsyncIterable protocol or is
	 * Array-like, iterate over it, calling the `callback` at each iteration.
	 *
	 * Use `forAwaitEach` where you would expect to use a `for-await-of` loop.
	 *
	 * Similar to [Array#forEach][], the `callback` function accepts three
	 * arguments, and is provided with `thisArg` as the calling context.
	 *
	 * > Note: Using `forAwaitEach` requires the existence of `Promise`.
	 * > While `Promise` has been available in modern browsers for a number of
	 * > years, legacy browsers (like IE 11) may require a polyfill.
	 *
	 * @example
	 *
	 * var forAwaitEach = require('iterall').forAwaitEach
	 *
	 * forAwaitEach(myIterable, function (value, index, iterable) {
	 *   console.log(value, index, iterable === myIterable)
	 * })
	 *
	 * @example
	 *
	 * // ES2017:
	 * for await (let value of myAsyncIterable) {
	 *   console.log(await doSomethingAsync(value))
	 * }
	 * console.log('done')
	 *
	 * // Any JavaScript environment:
	 * forAwaitEach(myAsyncIterable, function (value) {
	 *   return doSomethingAsync(value).then(console.log)
	 * }).then(function () {
	 *   console.log('done')
	 * })
	 *
	 * @template T the type of each iterated value
	 * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source
	 *   The AsyncIterable or array to iterate over.
	 * @param {function(T, number, object)} callback
	 *   Function to execute for each iteration, taking up to three arguments
	 * @param [thisArg]
	 *   Optional. Value to use as `this` when executing `callback`.
	 */
	function forAwaitEach(source, callback, thisArg) {
	  var asyncIterator = createAsyncIterator(source)
	  if (asyncIterator) {
	    var i = 0
	    return new Promise(function(resolve, reject) {
	      function next() {
	        return asyncIterator
	          .next()
	          .then(function(step) {
	            if (!step.done) {
	              Promise.resolve(callback.call(thisArg, step.value, i++, source))
	                .then(next)
	                .catch(reject)
	            } else {
	              resolve()
	            }
	          })
	          .catch(reject)
	      }
	      next()
	    })
	  }
	}
	exports.forAwaitEach = forAwaitEach


/***/ }),
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Index", {
	  value: {
	    index: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_PositionInfo", {
	  value: {
	    x: __webpack_require__(1).number.isRequired,
	    y: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_ScrollPosition", {
	  value: {
	    scrollLeft: __webpack_require__(1).number.isRequired,
	    scrollTop: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo", {
	  value: {
	    height: __webpack_require__(1).number.isRequired,
	    width: __webpack_require__(1).number.isRequired,
	    x: __webpack_require__(1).number.isRequired,
	    y: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_SizeInfo", {
	  value: {
	    height: __webpack_require__(1).number.isRequired,
	    width: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});

/***/ }),
/* 66 */,
/* 67 */,
/* 68 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = c;
	c.displayName = 'c';
	c.aliases = [];
	function c(Prism) {
	  Prism.languages.c = Prism.languages.extend('clike', {
	    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
	    operator: /-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/]/,
	    number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i
	  });
	  Prism.languages.insertBefore('c', 'string', {
	    macro: {
	      // allow for multiline macro definitions
	      // spaces after the # character compile fine with gcc
	      pattern: /(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
	      lookbehind: true,
	      alias: 'property',
	      inside: {
	        // highlight the path of the include statement as a string
	        string: {
	          pattern: /(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,
	          lookbehind: true
	        },
	        // highlight macro directives as keywords
	        directive: {
	          pattern: /(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,
	          lookbehind: true,
	          alias: 'keyword'
	        }
	      }
	    },
	    // highlight predefined macros as constants
	    constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/
	  });
	  delete Prism.languages.c['class-name'];
	  delete Prism.languages.c['boolean'];
	}


/***/ }),
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */
/***/ (function(module, exports) {

	// YAML error class. http://stackoverflow.com/questions/8458984
	//
	'use strict';
	
	function YAMLException(reason, mark) {
	  // Super constructor
	  Error.call(this);
	
	  this.name = 'YAMLException';
	  this.reason = reason;
	  this.mark = mark;
	  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
	
	  // Include stack trace in error object
	  if (Error.captureStackTrace) {
	    // Chrome and NodeJS
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    // FF, IE 10+ and Safari 6+. Fallback for others
	    this.stack = (new Error()).stack || '';
	  }
	}
	
	
	// Inherit from Error
	YAMLException.prototype = Object.create(Error.prototype);
	YAMLException.prototype.constructor = YAMLException;
	
	
	YAMLException.prototype.toString = function toString(compact) {
	  var result = this.name + ': ';
	
	  result += this.reason || '(unknown reason)';
	
	  if (!compact && this.mark) {
	    result += ' ' + this.mark.toString();
	  }
	
	  return result;
	};
	
	
	module.exports = YAMLException;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `safeLoad` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on standard YAML's Core schema and includes most of
	// extra types described at YAML tag repository. (http://yaml.org/type/)
	
	
	'use strict';
	
	
	var Schema = __webpack_require__(56);
	
	
	module.exports = new Schema({
	  include: [
	    __webpack_require__(249)
	  ],
	  implicit: [
	    __webpack_require__(536),
	    __webpack_require__(529)
	  ],
	  explicit: [
	    __webpack_require__(521),
	    __webpack_require__(531),
	    __webpack_require__(532),
	    __webpack_require__(534)
	  ]
	});


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _graphql = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var TypeLink = function (_React$Component) {
	  _inherits(TypeLink, _React$Component);
	
	  function TypeLink() {
	    _classCallCheck(this, TypeLink);
	
	    return _possibleConstructorReturn(this, (TypeLink.__proto__ || Object.getPrototypeOf(TypeLink)).apply(this, arguments));
	  }
	
	  _createClass(TypeLink, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps) {
	      return this.props.type !== nextProps.type;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return renderType(this.props.type, this.props.onClick);
	    }
	  }]);
	
	  return TypeLink;
	}(_react2.default.Component);
	
	TypeLink.propTypes = {
	  type: _propTypes2.default.object,
	  onClick: _propTypes2.default.func
	};
	exports.default = TypeLink;
	
	
	function renderType(type, _onClick) {
	  if (type instanceof _graphql.GraphQLNonNull) {
	    return _react2.default.createElement(
	      'span',
	      null,
	      renderType(type.ofType, _onClick),
	      '!'
	    );
	  }
	  if (type instanceof _graphql.GraphQLList) {
	    return _react2.default.createElement(
	      'span',
	      null,
	      '[',
	      renderType(type.ofType, _onClick),
	      ']'
	    );
	  }
	  return _react2.default.createElement(
	    'a',
	    { className: 'type-name', onClick: function onClick(event) {
	        return _onClick(type, event);
	      } },
	    type.name
	  );
	}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _CharacterStream = __webpack_require__(605);
	
	Object.defineProperty(exports, 'CharacterStream', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CharacterStream).default;
	  }
	});
	
	var _Rules = __webpack_require__(257);
	
	Object.defineProperty(exports, 'LexRules', {
	  enumerable: true,
	  get: function get() {
	    return _Rules.LexRules;
	  }
	});
	Object.defineProperty(exports, 'ParseRules', {
	  enumerable: true,
	  get: function get() {
	    return _Rules.ParseRules;
	  }
	});
	Object.defineProperty(exports, 'isIgnored', {
	  enumerable: true,
	  get: function get() {
	    return _Rules.isIgnored;
	  }
	});
	
	var _RuleHelpers = __webpack_require__(256);
	
	Object.defineProperty(exports, 'butNot', {
	  enumerable: true,
	  get: function get() {
	    return _RuleHelpers.butNot;
	  }
	});
	Object.defineProperty(exports, 'list', {
	  enumerable: true,
	  get: function get() {
	    return _RuleHelpers.list;
	  }
	});
	Object.defineProperty(exports, 'opt', {
	  enumerable: true,
	  get: function get() {
	    return _RuleHelpers.opt;
	  }
	});
	Object.defineProperty(exports, 'p', {
	  enumerable: true,
	  get: function get() {
	    return _RuleHelpers.p;
	  }
	});
	Object.defineProperty(exports, 't', {
	  enumerable: true,
	  get: function get() {
	    return _RuleHelpers.t;
	  }
	});
	
	var _onlineParser = __webpack_require__(606);
	
	Object.defineProperty(exports, 'onlineParser', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_onlineParser).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInvalid;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	/**
	 * Returns true if a value is undefined, or NaN.
	 */
	function isInvalid(value) {
	  return value === undefined || value !== value;
	}

/***/ }),
/* 80 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.visit = visit;
	exports.visitInParallel = visitInParallel;
	exports.visitWithTypeInfo = visitWithTypeInfo;
	exports.getVisitFn = getVisitFn;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	var QueryDocumentKeys = exports.QueryDocumentKeys = {
	  Name: [],
	
	  Document: ['definitions'],
	  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
	  VariableDefinition: ['variable', 'type', 'defaultValue'],
	  Variable: ['name'],
	  SelectionSet: ['selections'],
	  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
	  Argument: ['name', 'value'],
	
	  FragmentSpread: ['name', 'directives'],
	  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
	  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],
	
	  IntValue: [],
	  FloatValue: [],
	  StringValue: [],
	  BooleanValue: [],
	  NullValue: [],
	  EnumValue: [],
	  ListValue: ['values'],
	  ObjectValue: ['fields'],
	  ObjectField: ['name', 'value'],
	
	  Directive: ['name', 'arguments'],
	
	  NamedType: ['name'],
	  ListType: ['type'],
	  NonNullType: ['type'],
	
	  SchemaDefinition: ['directives', 'operationTypes'],
	  OperationTypeDefinition: ['type'],
	
	  ScalarTypeDefinition: ['name', 'directives'],
	  ObjectTypeDefinition: ['name', 'interfaces', 'directives', 'fields'],
	  FieldDefinition: ['name', 'arguments', 'type', 'directives'],
	  InputValueDefinition: ['name', 'type', 'defaultValue', 'directives'],
	  InterfaceTypeDefinition: ['name', 'directives', 'fields'],
	  UnionTypeDefinition: ['name', 'directives', 'types'],
	  EnumTypeDefinition: ['name', 'directives', 'values'],
	  EnumValueDefinition: ['name', 'directives'],
	  InputObjectTypeDefinition: ['name', 'directives', 'fields'],
	
	  TypeExtensionDefinition: ['definition'],
	
	  DirectiveDefinition: ['name', 'arguments', 'locations']
	};
	
	var BREAK = exports.BREAK = {};
	
	/**
	 * visit() will walk through an AST using a depth first traversal, calling
	 * the visitor's enter function at each node in the traversal, and calling the
	 * leave function after visiting that node and all of its child nodes.
	 *
	 * By returning different values from the enter and leave functions, the
	 * behavior of the visitor can be altered, including skipping over a sub-tree of
	 * the AST (by returning false), editing the AST by returning a value or null
	 * to remove the value, or to stop the whole traversal by returning BREAK.
	 *
	 * When using visit() to edit an AST, the original AST will not be modified, and
	 * a new version of the AST with the changes applied will be returned from the
	 * visit function.
	 *
	 *     const editedAST = visit(ast, {
	 *       enter(node, key, parent, path, ancestors) {
	 *         // @return
	 *         //   undefined: no action
	 *         //   false: skip visiting this node
	 *         //   visitor.BREAK: stop visiting altogether
	 *         //   null: delete this node
	 *         //   any value: replace this node with the returned value
	 *       },
	 *       leave(node, key, parent, path, ancestors) {
	 *         // @return
	 *         //   undefined: no action
	 *         //   false: no action
	 *         //   visitor.BREAK: stop visiting altogether
	 *         //   null: delete this node
	 *         //   any value: replace this node with the returned value
	 *       }
	 *     });
	 *
	 * Alternatively to providing enter() and leave() functions, a visitor can
	 * instead provide functions named the same as the kinds of AST nodes, or
	 * enter/leave visitors at a named key, leading to four permutations of
	 * visitor API:
	 *
	 * 1) Named visitors triggered when entering a node a specific kind.
	 *
	 *     visit(ast, {
	 *       Kind(node) {
	 *         // enter the "Kind" node
	 *       }
	 *     })
	 *
	 * 2) Named visitors that trigger upon entering and leaving a node of
	 *    a specific kind.
	 *
	 *     visit(ast, {
	 *       Kind: {
	 *         enter(node) {
	 *           // enter the "Kind" node
	 *         }
	 *         leave(node) {
	 *           // leave the "Kind" node
	 *         }
	 *       }
	 *     })
	 *
	 * 3) Generic visitors that trigger upon entering and leaving any node.
	 *
	 *     visit(ast, {
	 *       enter(node) {
	 *         // enter any node
	 *       },
	 *       leave(node) {
	 *         // leave any node
	 *       }
	 *     })
	 *
	 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
	 *
	 *     visit(ast, {
	 *       enter: {
	 *         Kind(node) {
	 *           // enter the "Kind" node
	 *         }
	 *       },
	 *       leave: {
	 *         Kind(node) {
	 *           // leave the "Kind" node
	 *         }
	 *       }
	 *     })
	 */
	function visit(root, visitor, keyMap) {
	  var visitorKeys = keyMap || QueryDocumentKeys;
	
	  var stack = void 0;
	  var inArray = Array.isArray(root);
	  var keys = [root];
	  var index = -1;
	  var edits = [];
	  var parent = void 0;
	  var path = [];
	  var ancestors = [];
	  var newRoot = root;
	
	  do {
	    index++;
	    var isLeaving = index === keys.length;
	    var key = void 0;
	    var node = void 0;
	    var isEdited = isLeaving && edits.length !== 0;
	    if (isLeaving) {
	      key = ancestors.length === 0 ? undefined : path.pop();
	      node = parent;
	      parent = ancestors.pop();
	      if (isEdited) {
	        if (inArray) {
	          node = node.slice();
	        } else {
	          var clone = {};
	          for (var k in node) {
	            if (node.hasOwnProperty(k)) {
	              clone[k] = node[k];
	            }
	          }
	          node = clone;
	        }
	        var editOffset = 0;
	        for (var ii = 0; ii < edits.length; ii++) {
	          var editKey = edits[ii][0];
	          var editValue = edits[ii][1];
	          if (inArray) {
	            editKey -= editOffset;
	          }
	          if (inArray && editValue === null) {
	            node.splice(editKey, 1);
	            editOffset++;
	          } else {
	            node[editKey] = editValue;
	          }
	        }
	      }
	      index = stack.index;
	      keys = stack.keys;
	      edits = stack.edits;
	      inArray = stack.inArray;
	      stack = stack.prev;
	    } else {
	      key = parent ? inArray ? index : keys[index] : undefined;
	      node = parent ? parent[key] : newRoot;
	      if (node === null || node === undefined) {
	        continue;
	      }
	      if (parent) {
	        path.push(key);
	      }
	    }
	
	    var result = void 0;
	    if (!Array.isArray(node)) {
	      if (!isNode(node)) {
	        throw new Error('Invalid AST Node: ' + JSON.stringify(node));
	      }
	      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
	      if (visitFn) {
	        result = visitFn.call(visitor, node, key, parent, path, ancestors);
	
	        if (result === BREAK) {
	          break;
	        }
	
	        if (result === false) {
	          if (!isLeaving) {
	            path.pop();
	            continue;
	          }
	        } else if (result !== undefined) {
	          edits.push([key, result]);
	          if (!isLeaving) {
	            if (isNode(result)) {
	              node = result;
	            } else {
	              path.pop();
	              continue;
	            }
	          }
	        }
	      }
	    }
	
	    if (result === undefined && isEdited) {
	      edits.push([key, node]);
	    }
	
	    if (!isLeaving) {
	      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };
	      inArray = Array.isArray(node);
	      keys = inArray ? node : visitorKeys[node.kind] || [];
	      index = -1;
	      edits = [];
	      if (parent) {
	        ancestors.push(parent);
	      }
	      parent = node;
	    }
	  } while (stack !== undefined);
	
	  if (edits.length !== 0) {
	    newRoot = edits[edits.length - 1][1];
	  }
	
	  return newRoot;
	}
	
	function isNode(maybeNode) {
	  return maybeNode && typeof maybeNode.kind === 'string';
	}
	
	/**
	 * Creates a new visitor instance which delegates to many visitors to run in
	 * parallel. Each visitor will be visited for each node before moving on.
	 *
	 * If a prior visitor edits a node, no following visitors will see that node.
	 */
	function visitInParallel(visitors) {
	  var skipping = new Array(visitors.length);
	
	  return {
	    enter: function enter(node) {
	      for (var i = 0; i < visitors.length; i++) {
	        if (!skipping[i]) {
	          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);
	          if (fn) {
	            var result = fn.apply(visitors[i], arguments);
	            if (result === false) {
	              skipping[i] = node;
	            } else if (result === BREAK) {
	              skipping[i] = BREAK;
	            } else if (result !== undefined) {
	              return result;
	            }
	          }
	        }
	      }
	    },
	    leave: function leave(node) {
	      for (var i = 0; i < visitors.length; i++) {
	        if (!skipping[i]) {
	          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);
	          if (fn) {
	            var result = fn.apply(visitors[i], arguments);
	            if (result === BREAK) {
	              skipping[i] = BREAK;
	            } else if (result !== undefined && result !== false) {
	              return result;
	            }
	          }
	        } else if (skipping[i] === node) {
	          skipping[i] = null;
	        }
	      }
	    }
	  };
	}
	
	/**
	 * Creates a new visitor instance which maintains a provided TypeInfo instance
	 * along with visiting visitor.
	 */
	function visitWithTypeInfo(typeInfo, visitor) {
	  return {
	    enter: function enter(node) {
	      typeInfo.enter(node);
	      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);
	      if (fn) {
	        var result = fn.apply(visitor, arguments);
	        if (result !== undefined) {
	          typeInfo.leave(node);
	          if (isNode(result)) {
	            typeInfo.enter(result);
	          }
	        }
	        return result;
	      }
	    },
	    leave: function leave(node) {
	      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);
	      var result = void 0;
	      if (fn) {
	        result = fn.apply(visitor, arguments);
	      }
	      typeInfo.leave(node);
	      return result;
	    }
	  };
	}
	
	/**
	 * Given a visitor instance, if it is leaving or not, and a node kind, return
	 * the function the visitor runtime should call.
	 */
	function getVisitFn(visitor, kind, isLeaving) {
	  var kindVisitor = visitor[kind];
	  if (kindVisitor) {
	    if (!isLeaving && typeof kindVisitor === 'function') {
	      // { Kind() {} }
	      return kindVisitor;
	    }
	    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
	    if (typeof kindSpecificVisitor === 'function') {
	      // { Kind: { enter() {}, leave() {} } }
	      return kindSpecificVisitor;
	    }
	  } else {
	    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
	    if (specificVisitor) {
	      if (typeof specificVisitor === 'function') {
	        // { enter() {}, leave() {} }
	        return specificVisitor;
	      }
	      var specificKindVisitor = specificVisitor[kind];
	      if (typeof specificKindVisitor === 'function') {
	        // { enter: { Kind() {} }, leave: { Kind() {} } }
	        return specificKindVisitor;
	      }
	    }
	  }
	}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.valueFromAST = valueFromAST;
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _isInvalid = __webpack_require__(79);
	
	var _isInvalid2 = _interopRequireDefault(_isInvalid);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Produces a JavaScript value given a GraphQL Value AST.
	 *
	 * A GraphQL type must be provided, which will be used to interpret different
	 * GraphQL Value literals.
	 *
	 * Returns `undefined` when the value could not be validly coerced according to
	 * the provided type.
	 *
	 * | GraphQL Value        | JSON Value    |
	 * | -------------------- | ------------- |
	 * | Input Object         | Object        |
	 * | List                 | Array         |
	 * | Boolean              | Boolean       |
	 * | String               | String        |
	 * | Int / Float          | Number        |
	 * | Enum Value           | Mixed         |
	 * | NullValue            | null          |
	 *
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function valueFromAST(valueNode, type, variables) {
	  if (!valueNode) {
	    // When there is no node, then there is also no value.
	    // Importantly, this is different from returning the value null.
	    return;
	  }
	
	  if (type instanceof _definition.GraphQLNonNull) {
	    if (valueNode.kind === Kind.NULL) {
	      return; // Invalid: intentionally return no value.
	    }
	    return valueFromAST(valueNode, type.ofType, variables);
	  }
	
	  if (valueNode.kind === Kind.NULL) {
	    // This is explicitly returning the value null.
	    return null;
	  }
	
	  if (valueNode.kind === Kind.VARIABLE) {
	    var variableName = valueNode.name.value;
	    if (!variables || (0, _isInvalid2.default)(variables[variableName])) {
	      // No valid return value.
	      return;
	    }
	    // Note: we're not doing any checking that this variable is correct. We're
	    // assuming that this query has been validated and the variable usage here
	    // is of the correct type.
	    return variables[variableName];
	  }
	
	  if (type instanceof _definition.GraphQLList) {
	    var itemType = type.ofType;
	    if (valueNode.kind === Kind.LIST) {
	      var coercedValues = [];
	      var itemNodes = valueNode.values;
	      for (var i = 0; i < itemNodes.length; i++) {
	        if (isMissingVariable(itemNodes[i], variables)) {
	          // If an array contains a missing variable, it is either coerced to
	          // null or if the item type is non-null, it considered invalid.
	          if (itemType instanceof _definition.GraphQLNonNull) {
	            return; // Invalid: intentionally return no value.
	          }
	          coercedValues.push(null);
	        } else {
	          var itemValue = valueFromAST(itemNodes[i], itemType, variables);
	          if ((0, _isInvalid2.default)(itemValue)) {
	            return; // Invalid: intentionally return no value.
	          }
	          coercedValues.push(itemValue);
	        }
	      }
	      return coercedValues;
	    }
	    var coercedValue = valueFromAST(valueNode, itemType, variables);
	    if ((0, _isInvalid2.default)(coercedValue)) {
	      return; // Invalid: intentionally return no value.
	    }
	    return [coercedValue];
	  }
	
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    if (valueNode.kind !== Kind.OBJECT) {
	      return; // Invalid: intentionally return no value.
	    }
	    var coercedObj = Object.create(null);
	    var fields = type.getFields();
	    var fieldNodes = (0, _keyMap2.default)(valueNode.fields, function (field) {
	      return field.name.value;
	    });
	    var fieldNames = Object.keys(fields);
	    for (var _i = 0; _i < fieldNames.length; _i++) {
	      var fieldName = fieldNames[_i];
	      var field = fields[fieldName];
	      var fieldNode = fieldNodes[fieldName];
	      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
	        if (!(0, _isInvalid2.default)(field.defaultValue)) {
	          coercedObj[fieldName] = field.defaultValue;
	        } else if (field.type instanceof _definition.GraphQLNonNull) {
	          return; // Invalid: intentionally return no value.
	        }
	        continue;
	      }
	      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
	      if ((0, _isInvalid2.default)(fieldValue)) {
	        return; // Invalid: intentionally return no value.
	      }
	      coercedObj[fieldName] = fieldValue;
	    }
	    return coercedObj;
	  }
	
	  !(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType) ? (0, _invariant2.default)(0, 'Must be input type') : void 0;
	
	  var parsed = type.parseLiteral(valueNode);
	  if ((0, _isNullish2.default)(parsed) && !type.isValidLiteral(valueNode)) {
	    // Invalid values represent a failure to parse correctly, in which case
	    // no value is returned.
	    return;
	  }
	
	  return parsed;
	}
	
	// Returns true if the provided valueNode is a variable which is not defined
	// in the set of variables.
	function isMissingVariable(valueNode, variables) {
	  return valueNode.kind === Kind.VARIABLE && (!variables || (0, _isInvalid2.default)(variables[valueNode.name.value]));
	}

/***/ }),
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellDataGetterParams", {
	  value: {
	    columnData: __webpack_require__(1).any,
	    dataKey: __webpack_require__(1).string.isRequired,
	    rowData: __webpack_require__(1).any.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRendererParams", {
	  value: {
	    cellData: __webpack_require__(1).any,
	    columnData: __webpack_require__(1).any,
	    dataKey: __webpack_require__(1).string.isRequired,
	    rowData: __webpack_require__(1).any.isRequired,
	    rowIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams", {
	  value: {
	    className: __webpack_require__(1).string.isRequired,
	    columns: __webpack_require__(1).arrayOf(__webpack_require__(1).any).isRequired,
	    style: __webpack_require__(1).any.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_HeaderRendererParams", {
	  value: {
	    columnData: __webpack_require__(1).any,
	    dataKey: __webpack_require__(1).string.isRequired,
	    disableSort: __webpack_require__(1).bool,
	    label: __webpack_require__(1).any,
	    sortBy: __webpack_require__(1).string,
	    sortDirection: __webpack_require__(1).string
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RowRendererParams", {
	  value: {
	    className: __webpack_require__(1).string.isRequired,
	    columns: __webpack_require__(1).arrayOf(__webpack_require__(1).any).isRequired,
	    index: __webpack_require__(1).number.isRequired,
	    isScrolling: __webpack_require__(1).bool.isRequired,
	    onRowClick: __webpack_require__(1).func,
	    onRowDoubleClick: __webpack_require__(1).func,
	    onRowMouseOver: __webpack_require__(1).func,
	    onRowMouseOut: __webpack_require__(1).func,
	    rowData: __webpack_require__(1).any.isRequired,
	    style: __webpack_require__(1).any.isRequired
	  },
	  configurable: true
	});

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.requestAnimationTimeout = exports.cancelAnimationTimeout = undefined;
	
	var _animationFrame = __webpack_require__(844);
	
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId', {
	  value: {
	    id: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	var cancelAnimationTimeout = exports.cancelAnimationTimeout = function cancelAnimationTimeout(frame) {
	  return (0, _animationFrame.caf)(frame.id);
	};
	
	/**
	 * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.
	 * When the delay time has been reached the function you're timing out will be called.
	 *
	 * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)
	 */
	var requestAnimationTimeout = exports.requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {
	  var start = Date.now();
	
	  var timeout = function timeout() {
	    if (Date.now() - start >= delay) {
	      callback.call();
	    } else {
	      frame.id = (0, _animationFrame.raf)(timeout);
	    }
	  };
	
	  var frame = {
	    id: (0, _animationFrame.raf)(timeout)
	  };
	
	  return frame;
	};

/***/ }),
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// Open simple dialogs on top of an editor. Relies on dialog.css.
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  function dialogDiv(cm, template, bottom) {
	    var wrap = cm.getWrapperElement();
	    var dialog;
	    dialog = wrap.appendChild(document.createElement("div"));
	    if (bottom)
	      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
	    else
	      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";
	
	    if (typeof template == "string") {
	      dialog.innerHTML = template;
	    } else { // Assuming it's a detached DOM element.
	      dialog.appendChild(template);
	    }
	    return dialog;
	  }
	
	  function closeNotification(cm, newVal) {
	    if (cm.state.currentNotificationClose)
	      cm.state.currentNotificationClose();
	    cm.state.currentNotificationClose = newVal;
	  }
	
	  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
	    if (!options) options = {};
	
	    closeNotification(this, null);
	
	    var dialog = dialogDiv(this, template, options.bottom);
	    var closed = false, me = this;
	    function close(newVal) {
	      if (typeof newVal == 'string') {
	        inp.value = newVal;
	      } else {
	        if (closed) return;
	        closed = true;
	        dialog.parentNode.removeChild(dialog);
	        me.focus();
	
	        if (options.onClose) options.onClose(dialog);
	      }
	    }
	
	    var inp = dialog.getElementsByTagName("input")[0], button;
	    if (inp) {
	      inp.focus();
	
	      if (options.value) {
	        inp.value = options.value;
	        if (options.selectValueOnOpen !== false) {
	          inp.select();
	        }
	      }
	
	      if (options.onInput)
	        CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
	      if (options.onKeyUp)
	        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});
	
	      CodeMirror.on(inp, "keydown", function(e) {
	        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
	        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
	          inp.blur();
	          CodeMirror.e_stop(e);
	          close();
	        }
	        if (e.keyCode == 13) callback(inp.value, e);
	      });
	
	      if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);
	    } else if (button = dialog.getElementsByTagName("button")[0]) {
	      CodeMirror.on(button, "click", function() {
	        close();
	        me.focus();
	      });
	
	      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);
	
	      button.focus();
	    }
	    return close;
	  });
	
	  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
	    closeNotification(this, null);
	    var dialog = dialogDiv(this, template, options && options.bottom);
	    var buttons = dialog.getElementsByTagName("button");
	    var closed = false, me = this, blurring = 1;
	    function close() {
	      if (closed) return;
	      closed = true;
	      dialog.parentNode.removeChild(dialog);
	      me.focus();
	    }
	    buttons[0].focus();
	    for (var i = 0; i < buttons.length; ++i) {
	      var b = buttons[i];
	      (function(callback) {
	        CodeMirror.on(b, "click", function(e) {
	          CodeMirror.e_preventDefault(e);
	          close();
	          if (callback) callback(me);
	        });
	      })(callbacks[i]);
	      CodeMirror.on(b, "blur", function() {
	        --blurring;
	        setTimeout(function() { if (blurring <= 0) close(); }, 200);
	      });
	      CodeMirror.on(b, "focus", function() { ++blurring; });
	    }
	  });
	
	  /*
	   * openNotification
	   * Opens a notification, that can be closed with an optional timer
	   * (default 5000ms timer) and always closes on click.
	   *
	   * If a notification is opened while another is opened, it will close the
	   * currently opened one and open the new one immediately.
	   */
	  CodeMirror.defineExtension("openNotification", function(template, options) {
	    closeNotification(this, close);
	    var dialog = dialogDiv(this, template, options && options.bottom);
	    var closed = false, doneTimer;
	    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;
	
	    function close() {
	      if (closed) return;
	      closed = true;
	      clearTimeout(doneTimer);
	      dialog.parentNode.removeChild(dialog);
	    }
	
	    CodeMirror.on(dialog, 'click', function(e) {
	      CodeMirror.e_preventDefault(e);
	      close();
	    });
	
	    if (duration)
	      doneTimer = setTimeout(close, duration);
	
	    return close;
	  });
	});


/***/ }),
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `load` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on JS-YAML's default safe schema and includes
	// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
	//
	// Also this schema is used as default base schema at `Schema.create` function.
	
	
	'use strict';
	
	
	var Schema = __webpack_require__(56);
	
	
	module.exports = Schema.DEFAULT = new Schema({
	  include: [
	    __webpack_require__(76)
	  ],
	  explicit: [
	    __webpack_require__(527),
	    __webpack_require__(526),
	    __webpack_require__(525)
	  ]
	});


/***/ }),
/* 101 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.introspectionQuery = "\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n";
	exports.defaultQuery = "# Welcome to Graphcool's custom GraphiQL \u270C\n#\n# GraphiQL is an in-browser IDE for writing, validating, and\n# testing GraphQL queries.\n#\n# In Graphcool's custom GraphiQL you can additionally generate\n# code examples and download the result JSON.\n#\n# Type queries into this side of the screen, and you will\n# see intelligent typeaheads aware of the current GraphQL type schema and\n# live syntax and validation errors highlighted within the text.\n#\n# To bring up the auto-complete at any point, just press Ctrl-Space.\n#\n# Press the run button above, or Cmd-Enter to execute the query, and the result\n# will appear in the pane to the right.\n\n";
	exports.modalStyle = {
	    overlay: {
	        zIndex: 20,
	        backgroundColor: 'rgba(15,32,46,.9)',
	        display: 'flex',
	        alignItems: 'center',
	        justifyContent: 'center'
	    },
	    content: {
	        position: 'relative',
	        width: 976,
	        height: 'auto',
	        top: 'initial',
	        left: 'initial',
	        right: 'initial',
	        bottom: 'initial',
	        borderRadius: 2,
	        padding: 0,
	        border: 'none',
	        background: 'none',
	        boxShadow: '0 1px 7px rgba(0,0,0,.2)'
	    }
	};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getDefinitionState = getDefinitionState;
	exports.getFieldDef = getFieldDef;
	exports.forEachState = forEachState;
	exports.objectValues = objectValues;
	exports.hintList = hintList;
	
	var _graphql = __webpack_require__(12);
	
	var _introspection = __webpack_require__(41);
	
	// Utility for returning the state representing the Definition this token state
	// is within, if any.
	function getDefinitionState(tokenState) {
	  var definitionState = void 0;
	
	  forEachState(tokenState, function (state) {
	    switch (state.kind) {
	      case 'Query':
	      case 'ShortQuery':
	      case 'Mutation':
	      case 'Subscription':
	      case 'FragmentDefinition':
	        definitionState = state;
	        break;
	    }
	  });
	
	  return definitionState;
	}
	
	// Gets the field definition given a type and field name
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	function getFieldDef(schema, type, fieldName) {
	  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === type) {
	    return _introspection.SchemaMetaFieldDef;
	  }
	  if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === type) {
	    return _introspection.TypeMetaFieldDef;
	  }
	  if (fieldName === _introspection.TypeNameMetaFieldDef.name && (0, _graphql.isCompositeType)(type)) {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	  if (type.getFields && typeof type.getFields === 'function') {
	    return type.getFields()[fieldName];
	  }
	
	  return null;
	}
	
	// Utility for iterating through a CodeMirror parse state stack bottom-up.
	function forEachState(stack, fn) {
	  var reverseStateStack = [];
	  var state = stack;
	  while (state && state.kind) {
	    reverseStateStack.push(state);
	    state = state.prevState;
	  }
	  for (var i = reverseStateStack.length - 1; i >= 0; i--) {
	    fn(reverseStateStack[i]);
	  }
	}
	
	function objectValues(object) {
	  var keys = Object.keys(object);
	  var len = keys.length;
	  var values = new Array(len);
	  for (var i = 0; i < len; ++i) {
	    values[i] = object[keys[i]];
	  }
	  return values;
	}
	
	// Create the expected hint response given a possible list and a token
	function hintList(token, list) {
	  return filterAndSortList(list, normalizeText(token.string));
	}
	
	// Given a list of hint entries and currently typed text, sort and filter to
	// provide a concise list.
	function filterAndSortList(list, text) {
	  if (!text) {
	    return filterNonEmpty(list, function (entry) {
	      return !entry.isDeprecated;
	    });
	  }
	
	  var byProximity = list.map(function (entry) {
	    return {
	      proximity: getProximity(normalizeText(entry.label), text),
	      entry: entry
	    };
	  });
	
	  var conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, function (pair) {
	    return pair.proximity <= 2;
	  }), function (pair) {
	    return !pair.entry.isDeprecated;
	  });
	
	  var sortedMatches = conciseMatches.sort(function (a, b) {
	    return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length;
	  });
	
	  return sortedMatches.map(function (pair) {
	    return pair.entry;
	  });
	}
	
	// Filters the array by the predicate, unless it results in an empty array,
	// in which case return the original array.
	function filterNonEmpty(array, predicate) {
	  var filtered = array.filter(predicate);
	  return filtered.length === 0 ? array : filtered;
	}
	
	function normalizeText(text) {
	  return text.toLowerCase().replace(/\W/g, '');
	}
	
	// Determine a numeric proximity for a suggestion based on current text.
	function getProximity(suggestion, text) {
	  // start with lexical distance
	  var proximity = lexicalDistance(text, suggestion);
	  if (suggestion.length > text.length) {
	    // do not penalize long suggestions.
	    proximity -= suggestion.length - text.length - 1;
	    // penalize suggestions not starting with this phrase
	    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
	  }
	  return proximity;
	}
	
	/**
	 * Computes the lexical distance between strings A and B.
	 *
	 * The "distance" between two strings is given by counting the minimum number
	 * of edits needed to transform string A into string B. An edit can be an
	 * insertion, deletion, or substitution of a single character, or a swap of two
	 * adjacent characters.
	 *
	 * This distance can be useful for detecting typos in input or sorting
	 *
	 * @param {string} a
	 * @param {string} b
	 * @return {int} distance in number of edits
	 */
	function lexicalDistance(a, b) {
	  var i = void 0;
	  var j = void 0;
	  var d = [];
	  var aLength = a.length;
	  var bLength = b.length;
	
	  for (i = 0; i <= aLength; i++) {
	    d[i] = [i];
	  }
	
	  for (j = 1; j <= bLength; j++) {
	    d[0][j] = j;
	  }
	
	  for (i = 1; i <= aLength; i++) {
	    for (j = 1; j <= bLength; j++) {
	      var cost = a[i - 1] === b[j - 1] ? 0 : 1;
	
	      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
	
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
	      }
	    }
	  }
	
	  return d[aLength][bLength];
	}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
	                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                   *  All rights reserved.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  
	                                                                                                                                                                                                                                                                   */
	
	exports.getAutocompleteSuggestions = getAutocompleteSuggestions;
	
	var _graphql = __webpack_require__(12);
	
	var _graphqlLanguageServiceParser = __webpack_require__(78);
	
	var _autocompleteUtils = __webpack_require__(102);
	
	/**
	 * Given GraphQLSchema, queryText, and context of the current position within
	 * the source text, provide a list of typeahead entries.
	 */
	function getAutocompleteSuggestions(schema, queryText, cursor, contextToken) {
	  var token = contextToken || getTokenAtPosition(queryText, cursor);
	
	  var state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;
	
	  // relieve flow errors by checking if `state` exists
	  if (!state) {
	    return [];
	  }
	
	  var kind = state.kind;
	  var step = state.step;
	  var typeInfo = getTypeInfo(schema, token.state);
	
	  // Definition kinds
	  if (kind === 'Document') {
	    return (0, _autocompleteUtils.hintList)(token, [{ label: 'query' }, { label: 'mutation' }, { label: 'subscription' }, { label: 'fragment' }, { label: '{' }]);
	  }
	
	  // Field names
	  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {
	    return getSuggestionsForFieldNames(token, typeInfo, schema);
	  }
	
	  // Argument names
	  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {
	    var argDefs = typeInfo.argDefs;
	    if (argDefs) {
	      return (0, _autocompleteUtils.hintList)(token, argDefs.map(function (argDef) {
	        return {
	          label: argDef.name,
	          detail: String(argDef.type),
	          documentation: argDef.description
	        };
	      }));
	    }
	  }
	
	  // Input Object fields
	  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {
	    if (typeInfo.objectFieldDefs) {
	      var objectFields = (0, _autocompleteUtils.objectValues)(typeInfo.objectFieldDefs);
	      return (0, _autocompleteUtils.hintList)(token, objectFields.map(function (field) {
	        return {
	          label: field.name,
	          detail: String(field.type),
	          documentation: field.description
	        };
	      }));
	    }
	  }
	
	  // Input values: Enum and Boolean
	  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {
	    return getSuggestionsForInputValues(token, typeInfo);
	  }
	
	  // Fragment type conditions
	  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState != null && state.prevState.kind === 'TypeCondition') {
	    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);
	  }
	
	  // Fragment spread names
	  if (kind === 'FragmentSpread' && step === 1) {
	    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText);
	  }
	
	  // Variable definition types
	  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && state.prevState && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {
	    return getSuggestionsForVariableDefinition(token, schema);
	  }
	
	  // Directive names
	  if (kind === 'Directive') {
	    return getSuggestionsForDirective(token, state, schema);
	  }
	
	  return [];
	}
	
	// Helper functions to get suggestions for each kinds
	function getSuggestionsForFieldNames(token, typeInfo, schema) {
	  if (typeInfo.parentType) {
	    var parentType = typeInfo.parentType;
	    var fields = parentType.getFields instanceof Function ? (0, _autocompleteUtils.objectValues)(parentType.getFields()) : [];
	    if ((0, _graphql.isAbstractType)(parentType)) {
	      fields.push(_graphql.TypeNameMetaFieldDef);
	    }
	    if (parentType === schema.getQueryType()) {
	      fields.push(_graphql.SchemaMetaFieldDef, _graphql.TypeMetaFieldDef);
	    }
	    return (0, _autocompleteUtils.hintList)(token, fields.map(function (field) {
	      return {
	        label: field.name,
	        detail: String(field.type),
	        documentation: field.description,
	        isDeprecated: field.isDeprecated,
	        deprecationReason: field.deprecationReason
	      };
	    }));
	  }
	  return [];
	}
	
	function getSuggestionsForInputValues(token, typeInfo) {
	  var namedInputType = (0, _graphql.getNamedType)(typeInfo.inputType);
	  if (namedInputType instanceof _graphql.GraphQLEnumType) {
	    var values = namedInputType.getValues();
	    return (0, _autocompleteUtils.hintList)(token, values.map(function (value) {
	      return {
	        label: value.name,
	        detail: String(namedInputType),
	        documentation: value.description,
	        isDeprecated: value.isDeprecated,
	        deprecationReason: value.deprecationReason
	      };
	    }));
	  } else if (namedInputType === _graphql.GraphQLBoolean) {
	    return (0, _autocompleteUtils.hintList)(token, [{
	      label: 'true',
	      detail: String(_graphql.GraphQLBoolean),
	      documentation: 'Not false.'
	    }, {
	      label: 'false',
	      detail: String(_graphql.GraphQLBoolean),
	      documentation: 'Not true.'
	    }]);
	  }
	
	  return [];
	}
	
	function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema) {
	  var possibleTypes = void 0;
	  if (typeInfo.parentType) {
	    if ((0, _graphql.isAbstractType)(typeInfo.parentType)) {
	      var abstractType = (0, _graphql.assertAbstractType)(typeInfo.parentType);
	      // Collect both the possible Object types as well as the interfaces
	      // they implement.
	      var possibleObjTypes = schema.getPossibleTypes(abstractType);
	      var possibleIfaceMap = Object.create(null);
	      possibleObjTypes.forEach(function (type) {
	        type.getInterfaces().forEach(function (iface) {
	          possibleIfaceMap[iface.name] = iface;
	        });
	      });
	      possibleTypes = possibleObjTypes.concat((0, _autocompleteUtils.objectValues)(possibleIfaceMap));
	    } else {
	      // The parent type is a non-abstract Object type, so the only possible
	      // type that can be used is that same type.
	      possibleTypes = [typeInfo.parentType];
	    }
	  } else {
	    var typeMap = schema.getTypeMap();
	    possibleTypes = (0, _autocompleteUtils.objectValues)(typeMap).filter(_graphql.isCompositeType);
	  }
	  return (0, _autocompleteUtils.hintList)(token, possibleTypes.map(function (type) {
	    var namedType = (0, _graphql.getNamedType)(type);
	    return {
	      label: String(type),
	      documentation: namedType && namedType.description || ''
	    };
	  }));
	}
	
	function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText) {
	  var typeMap = schema.getTypeMap();
	  var defState = (0, _autocompleteUtils.getDefinitionState)(token.state);
	  var fragments = getFragmentDefinitions(queryText);
	
	  // Filter down to only the fragments which may exist here.
	  var relevantFrags = fragments.filter(function (frag) {
	    return (
	      // Only include fragments with known types.
	      typeMap[frag.typeCondition.name.value] &&
	      // Only include fragments which are not cyclic.
	      !(defState && defState.kind === 'FragmentDefinition' && defState.name === frag.name.value) &&
	      // Only include fragments which could possibly be spread here.
	      (0, _graphql.isCompositeType)(typeInfo.parentType) && (0, _graphql.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, _graphql.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value])
	    );
	  });
	
	  return (0, _autocompleteUtils.hintList)(token, relevantFrags.map(function (frag) {
	    return {
	      label: frag.name.value,
	      detail: String(typeMap[frag.typeCondition.name.value]),
	      documentation: 'fragment ' + frag.name.value + ' on ' + frag.typeCondition.name.value
	    };
	  }));
	}
	
	function getFragmentDefinitions(queryText) {
	  var fragmentDefs = [];
	  runOnlineParser(queryText, function (_, state) {
	    if (state.kind === 'FragmentDefinition' && state.name && state.type) {
	      fragmentDefs.push({
	        kind: 'FragmentDefinition',
	        name: {
	          kind: 'Name',
	          value: state.name
	        },
	        selectionSet: {
	          kind: 'SelectionSet',
	          selections: []
	        },
	        typeCondition: {
	          kind: 'NamedType',
	          name: {
	            kind: 'Name',
	            value: state.type
	          }
	        }
	      });
	    }
	  });
	
	  return fragmentDefs;
	}
	
	function getSuggestionsForVariableDefinition(token, schema) {
	  var inputTypeMap = schema.getTypeMap();
	  var inputTypes = (0, _autocompleteUtils.objectValues)(inputTypeMap).filter(_graphql.isInputType);
	  return (0, _autocompleteUtils.hintList)(token, inputTypes.map(function (type) {
	    return {
	      label: type.name,
	      documentation: type.description
	    };
	  }));
	}
	
	function getSuggestionsForDirective(token, state, schema) {
	  if (state.prevState && state.prevState.kind) {
	    var directives = schema.getDirectives().filter(function (directive) {
	      return canUseDirective(state.prevState, directive);
	    });
	    return (0, _autocompleteUtils.hintList)(token, directives.map(function (directive) {
	      return {
	        label: directive.name,
	        documentation: directive.description || ''
	      };
	    }));
	  }
	  return [];
	}
	
	function getTokenAtPosition(queryText, cursor) {
	  var styleAtCursor = null;
	  var stateAtCursor = null;
	  var stringAtCursor = null;
	  var token = runOnlineParser(queryText, function (stream, state, style, index) {
	    if (index === cursor.line) {
	      if (stream.getCurrentPosition() >= cursor.character) {
	        styleAtCursor = style;
	        stateAtCursor = _extends({}, state);
	        stringAtCursor = stream.current();
	        return 'BREAK';
	      }
	    }
	  });
	
	  // Return the state/style of parsed token in case those at cursor aren't
	  // available.
	  return {
	    start: token.start,
	    end: token.end,
	    string: stringAtCursor || token.string,
	    state: stateAtCursor || token.state,
	    style: styleAtCursor || token.style
	  };
	}
	
	/**
	 * Provides an utility function to parse a given query text and construct a
	 * `token` context object.
	 * A token context provides useful information about the token/style that
	 * CharacterStream currently possesses, as well as the end state and style
	 * of the token.
	 */
	
	
	function runOnlineParser(queryText, callback) {
	  var lines = queryText.split('\n');
	  var parser = (0, _graphqlLanguageServiceParser.onlineParser)();
	  var state = parser.startState();
	  var style = '';
	
	  var stream = new _graphqlLanguageServiceParser.CharacterStream('');
	
	  for (var i = 0; i < lines.length; i++) {
	    stream = new _graphqlLanguageServiceParser.CharacterStream(lines[i]);
	    while (!stream.eol()) {
	      style = parser.token(stream, state);
	      var code = callback(stream, state, style, i);
	      if (code === 'BREAK') {
	        break;
	      }
	    }
	
	    // Above while loop won't run if there is an empty line.
	    // Run the callback one more time to catch this.
	    callback(stream, state, style, i);
	
	    if (!state.kind) {
	      state = parser.startState();
	    }
	  }
	
	  return {
	    start: stream.getStartOfToken(),
	    end: stream.getCurrentPosition(),
	    string: stream.current(),
	    state: state,
	    style: style
	  };
	}
	
	function canUseDirective(state, directive) {
	  if (!state || !state.kind) {
	    return false;
	  }
	  var kind = state.kind;
	  var locations = directive.locations;
	  switch (kind) {
	    case 'Query':
	      return locations.indexOf('QUERY') !== -1;
	    case 'Mutation':
	      return locations.indexOf('MUTATION') !== -1;
	    case 'Subscription':
	      return locations.indexOf('SUBSCRIPTION') !== -1;
	    case 'Field':
	    case 'AliasedField':
	      return locations.indexOf('FIELD') !== -1;
	    case 'FragmentDefinition':
	      return locations.indexOf('FRAGMENT_DEFINITION') !== -1;
	    case 'FragmentSpread':
	      return locations.indexOf('FRAGMENT_SPREAD') !== -1;
	    case 'InlineFragment':
	      return locations.indexOf('INLINE_FRAGMENT') !== -1;
	
	    // Schema Definitions
	    case 'SchemaDef':
	      return locations.indexOf('SCHEMA') !== -1;
	    case 'ScalarDef':
	      return locations.indexOf('SCALAR') !== -1;
	    case 'ObjectTypeDef':
	      return locations.indexOf('OBJECT') !== -1;
	    case 'FieldDef':
	      return locations.indexOf('FIELD_DEFINITION') !== -1;
	    case 'InterfaceDef':
	      return locations.indexOf('INTERFACE') !== -1;
	    case 'UnionDef':
	      return locations.indexOf('UNION') !== -1;
	    case 'EnumDef':
	      return locations.indexOf('ENUM') !== -1;
	    case 'EnumValue':
	      return locations.indexOf('ENUM_VALUE') !== -1;
	    case 'InputDef':
	      return locations.indexOf('INPUT_OBJECT') !== -1;
	    case 'InputValueDef':
	      var prevStateKind = state.prevState && state.prevState.kind;
	      switch (prevStateKind) {
	        case 'ArgumentsDef':
	          return locations.indexOf('ARGUMENT_DEFINITION') !== -1;
	        case 'InputDef':
	          return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;
	      }
	  }
	  return false;
	}
	
	// Utility for collecting rich type information given any token's state
	// from the graphql-mode parser.
	function getTypeInfo(schema, tokenState) {
	  var argDef = void 0;
	  var argDefs = void 0;
	  var directiveDef = void 0;
	  var enumValue = void 0;
	  var fieldDef = void 0;
	  var inputType = void 0;
	  var objectFieldDefs = void 0;
	  var parentType = void 0;
	  var type = void 0;
	
	  (0, _autocompleteUtils.forEachState)(tokenState, function (state) {
	    switch (state.kind) {
	      case 'Query':
	      case 'ShortQuery':
	        type = schema.getQueryType();
	        break;
	      case 'Mutation':
	        type = schema.getMutationType();
	        break;
	      case 'Subscription':
	        type = schema.getSubscriptionType();
	        break;
	      case 'InlineFragment':
	      case 'FragmentDefinition':
	        if (state.type) {
	          type = schema.getType(state.type);
	        }
	        break;
	      case 'Field':
	      case 'AliasedField':
	        if (!type || !state.name) {
	          fieldDef = null;
	        } else {
	          fieldDef = parentType ? (0, _autocompleteUtils.getFieldDef)(schema, parentType, state.name) : null;
	          type = fieldDef ? fieldDef.type : null;
	        }
	        break;
	      case 'SelectionSet':
	        parentType = (0, _graphql.getNamedType)(type);
	        break;
	      case 'Directive':
	        directiveDef = state.name ? schema.getDirective(state.name) : null;
	        break;
	      case 'Arguments':
	        if (!state.prevState) {
	          argDefs = null;
	        } else {
	          switch (state.prevState.kind) {
	            case 'Field':
	              argDefs = fieldDef && fieldDef.args;
	              break;
	            case 'Directive':
	              argDefs = directiveDef && directiveDef.args;
	              break;
	            case 'AliasedField':
	              var name = state.prevState && state.prevState.name;
	              if (!name) {
	                argDefs = null;
	                break;
	              }
	              var field = parentType ? (0, _autocompleteUtils.getFieldDef)(schema, parentType, name) : null;
	              if (!field) {
	                argDefs = null;
	                break;
	              }
	              argDefs = field.args;
	              break;
	            default:
	              argDefs = null;
	              break;
	          }
	        }
	        break;
	      case 'Argument':
	        if (argDefs) {
	          for (var i = 0; i < argDefs.length; i++) {
	            if (argDefs[i].name === state.name) {
	              argDef = argDefs[i];
	              break;
	            }
	          }
	        }
	        inputType = argDef && argDef.type;
	        break;
	      case 'EnumValue':
	        var enumType = (0, _graphql.getNamedType)(inputType);
	        enumValue = enumType instanceof _graphql.GraphQLEnumType ? find(enumType.getValues(), function (val) {
	          return val.value === state.name;
	        }) : null;
	        break;
	      case 'ListValue':
	        var nullableType = (0, _graphql.getNullableType)(inputType);
	        inputType = nullableType instanceof _graphql.GraphQLList ? nullableType.ofType : null;
	        break;
	      case 'ObjectValue':
	        var objectType = (0, _graphql.getNamedType)(inputType);
	        objectFieldDefs = objectType instanceof _graphql.GraphQLInputObjectType ? objectType.getFields() : null;
	        break;
	      case 'ObjectField':
	        var objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
	        inputType = objectField && objectField.type;
	        break;
	      case 'NamedType':
	        if (state.name) {
	          type = schema.getType(state.name);
	        }
	        break;
	    }
	  });
	
	  return {
	    argDef: argDef,
	    argDefs: argDefs,
	    directiveDef: directiveDef,
	    enumValue: enumValue,
	    fieldDef: fieldDef,
	    inputType: inputType,
	    objectFieldDefs: objectFieldDefs,
	    parentType: parentType,
	    type: type
	  };
	}
	
	// Returns the first item in the array which causes predicate to return truthy.
	function find(array, predicate) {
	  for (var i = 0; i < array.length; i++) {
	    if (predicate(array[i])) {
	      return array[i];
	    }
	  }
	  return null;
	}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LANGUAGE = undefined;
	exports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;
	exports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;
	
	var _graphqlLanguageServiceUtils = __webpack_require__(107);
	
	var _assert = __webpack_require__(208);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	var LANGUAGE = exports.LANGUAGE = 'GraphQL';
	
	function getRange(text, node) {
	  var location = node.loc;
	  (0, _assert2.default)(location, 'Expected ASTNode to have a location.');
	  return (0, _graphqlLanguageServiceUtils.locToRange)(text, location);
	}
	
	function getPosition(text, node) {
	  var location = node.loc;
	  (0, _assert2.default)(location, 'Expected ASTNode to have a location.');
	  return (0, _graphqlLanguageServiceUtils.offsetToPosition)(text, location.start);
	}
	
	function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {
	  var name, defNodes, definitions;
	  return regeneratorRuntime.async(function getDefinitionQueryResultForFragmentSpread$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          name = fragment.name.value;
	          defNodes = dependencies.filter(function (_ref) {
	            var definition = _ref.definition;
	            return definition.name.value === name;
	          });
	
	          if (!(defNodes.length === 0)) {
	            _context.next = 5;
	            break;
	          }
	
	          process.stderr.write('Definition not found for GraphQL fragment ' + name);
	          return _context.abrupt('return', { queryRange: [], definitions: [] });
	
	        case 5:
	          definitions = defNodes.map(function (_ref2) {
	            var filePath = _ref2.filePath,
	                content = _ref2.content,
	                definition = _ref2.definition;
	            return getDefinitionForFragmentDefinition(filePath || '', content, definition);
	          });
	          return _context.abrupt('return', {
	            definitions: definitions,
	            queryRange: definitions.map(function (_) {
	              return getRange(text, fragment);
	            })
	          });
	
	        case 7:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, null, this);
	}
	
	function getDefinitionQueryResultForDefinitionNode(path, text, definition) {
	  return {
	    definitions: [getDefinitionForFragmentDefinition(path, text, definition)],
	    queryRange: definition.name ? [getRange(text, definition.name)] : []
	  };
	}
	
	function getDefinitionForFragmentDefinition(path, text, definition) {
	  var name = definition.name;
	  (0, _assert2.default)(name, 'Expected ASTNode to have a Name.');
	  return {
	    path: path,
	    position: getPosition(text, name),
	    range: getRange(text, definition),
	    name: name.value || '',
	    language: LANGUAGE,
	    // This is a file inside the project root, good enough for now
	    projectRoot: path
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SEVERITY = undefined;
	exports.getDiagnostics = getDiagnostics;
	
	var _assert = __webpack_require__(208);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _graphql = __webpack_require__(12);
	
	var _graphqlLanguageServiceParser = __webpack_require__(78);
	
	var _graphqlLanguageServiceUtils = __webpack_require__(107);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	var SEVERITY = exports.SEVERITY = {
	  ERROR: 1,
	  WARNING: 2,
	  INFORMATION: 3,
	  HINT: 4
	};
	
	function getDiagnostics(queryText) {
	  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  var customRules = arguments[2];
	
	  var ast = null;
	  try {
	    ast = (0, _graphql.parse)(queryText);
	  } catch (error) {
	    var range = getRange(error.locations[0], queryText);
	
	    return [{
	      severity: SEVERITY.ERROR,
	      message: error.message,
	      source: 'GraphQL: Syntax',
	      range: range
	    }];
	  }
	
	  // We cannot validate the query unless a schema is provided.
	  if (!schema) {
	    return [];
	  }
	
	  var validationErrorAnnotations = mapCat((0, _graphqlLanguageServiceUtils.validateWithCustomRules)(schema, ast, customRules), function (error) {
	    return annotations(error, SEVERITY.ERROR, 'Validation');
	  });
	  // Note: findDeprecatedUsages was added in graphql@0.9.0, but we want to
	  // support older versions of graphql-js.
	  var deprecationWarningAnnotations = !_graphql.findDeprecatedUsages ? [] : mapCat((0, _graphql.findDeprecatedUsages)(schema, ast), function (error) {
	    return annotations(error, SEVERITY.WARNING, 'Deprecation');
	  });
	  return validationErrorAnnotations.concat(deprecationWarningAnnotations);
	}
	
	// General utility for map-cating (aka flat-mapping).
	function mapCat(array, mapper) {
	  return Array.prototype.concat.apply([], array.map(mapper));
	}
	
	function annotations(error, severity, type) {
	  if (!error.nodes) {
	    return [];
	  }
	  return error.nodes.map(function (node) {
	    var highlightNode = node.kind !== 'Variable' && node.name ? node.name : node.variable ? node.variable : node;
	
	    (0, _assert2.default)(error.locations, 'GraphQL validation error requires locations.');
	    var loc = error.locations[0];
	    var highlightLoc = getLocation(highlightNode);
	    var end = loc.column + (highlightLoc.end - highlightLoc.start);
	    return {
	      source: 'GraphQL: ' + type,
	      message: error.message,
	      severity: severity,
	      range: new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(loc.line - 1, loc.column - 1), new _graphqlLanguageServiceUtils.Position(loc.line - 1, end))
	    };
	  });
	}
	
	/**
	 * Get location info from a node in a type-safe way.
	 *
	 * The only way a node could not have a location is if we initialized the parser
	 * (and therefore the lexer) with the `noLocation` option, but we always
	 * call `parse` without options above.
	 */
	function getLocation(node) {
	  var typeCastedNode = node;
	  var location = typeCastedNode.loc;
	  (0, _assert2.default)(location, 'Expected ASTNode to have a location.');
	  return location;
	}
	
	function getRange(location, queryText) {
	  var parser = (0, _graphqlLanguageServiceParser.onlineParser)();
	  var state = parser.startState();
	  var lines = queryText.split('\n');
	
	  (0, _assert2.default)(lines.length >= location.line, 'Query text must have more lines than where the error happened');
	
	  var stream = null;
	
	  for (var i = 0; i < location.line; i++) {
	    stream = new _graphqlLanguageServiceParser.CharacterStream(lines[i]);
	    while (!stream.eol()) {
	      var style = parser.token(stream, state);
	      if (style === 'invalidchar') {
	        break;
	      }
	    }
	  }
	
	  (0, _assert2.default)(stream, 'Expected Parser stream to be available.');
	
	  var line = location.line - 1;
	  var start = stream.getStartOfToken();
	  var end = stream.getCurrentPosition();
	
	  return new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(line, start), new _graphqlLanguageServiceUtils.Position(line, end));
	}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _autocompleteUtils = __webpack_require__(102);
	
	Object.defineProperty(exports, 'getDefinitionState', {
	  enumerable: true,
	  get: function get() {
	    return _autocompleteUtils.getDefinitionState;
	  }
	});
	Object.defineProperty(exports, 'getFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _autocompleteUtils.getFieldDef;
	  }
	});
	Object.defineProperty(exports, 'forEachState', {
	  enumerable: true,
	  get: function get() {
	    return _autocompleteUtils.forEachState;
	  }
	});
	Object.defineProperty(exports, 'objectValues', {
	  enumerable: true,
	  get: function get() {
	    return _autocompleteUtils.objectValues;
	  }
	});
	Object.defineProperty(exports, 'hintList', {
	  enumerable: true,
	  get: function get() {
	    return _autocompleteUtils.hintList;
	  }
	});
	
	var _getAutocompleteSuggestions = __webpack_require__(103);
	
	Object.defineProperty(exports, 'getAutocompleteSuggestions', {
	  enumerable: true,
	  get: function get() {
	    return _getAutocompleteSuggestions.getAutocompleteSuggestions;
	  }
	});
	
	var _getDefinition = __webpack_require__(104);
	
	Object.defineProperty(exports, 'LANGUAGE', {
	  enumerable: true,
	  get: function get() {
	    return _getDefinition.LANGUAGE;
	  }
	});
	Object.defineProperty(exports, 'getDefinitionQueryResultForFragmentSpread', {
	  enumerable: true,
	  get: function get() {
	    return _getDefinition.getDefinitionQueryResultForFragmentSpread;
	  }
	});
	Object.defineProperty(exports, 'getDefinitionQueryResultForDefinitionNode', {
	  enumerable: true,
	  get: function get() {
	    return _getDefinition.getDefinitionQueryResultForDefinitionNode;
	  }
	});
	
	var _getDiagnostics = __webpack_require__(105);
	
	Object.defineProperty(exports, 'getDiagnostics', {
	  enumerable: true,
	  get: function get() {
	    return _getDiagnostics.getDiagnostics;
	  }
	});
	
	var _getOutline = __webpack_require__(158);
	
	Object.defineProperty(exports, 'getOutline', {
	  enumerable: true,
	  get: function get() {
	    return _getOutline.getOutline;
	  }
	});
	
	var _GraphQLLanguageService = __webpack_require__(157);
	
	Object.defineProperty(exports, 'GraphQLLanguageService', {
	  enumerable: true,
	  get: function get() {
	    return _GraphQLLanguageService.GraphQLLanguageService;
	  }
	});

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getASTNodeAtPosition = __webpack_require__(607);
	
	Object.defineProperty(exports, 'getASTNodeAtPosition', {
	  enumerable: true,
	  get: function get() {
	    return _getASTNodeAtPosition.getASTNodeAtPosition;
	  }
	});
	Object.defineProperty(exports, 'pointToOffset', {
	  enumerable: true,
	  get: function get() {
	    return _getASTNodeAtPosition.pointToOffset;
	  }
	});
	
	var _Range = __webpack_require__(258);
	
	Object.defineProperty(exports, 'Position', {
	  enumerable: true,
	  get: function get() {
	    return _Range.Position;
	  }
	});
	Object.defineProperty(exports, 'Range', {
	  enumerable: true,
	  get: function get() {
	    return _Range.Range;
	  }
	});
	Object.defineProperty(exports, 'locToRange', {
	  enumerable: true,
	  get: function get() {
	    return _Range.locToRange;
	  }
	});
	Object.defineProperty(exports, 'offsetToPosition', {
	  enumerable: true,
	  get: function get() {
	    return _Range.offsetToPosition;
	  }
	});
	
	var _validateWithCustomRules = __webpack_require__(608);
	
	Object.defineProperty(exports, 'validateWithCustomRules', {
	  enumerable: true,
	  get: function get() {
	    return _validateWithCustomRules.validateWithCustomRules;
	  }
	});

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;
	exports.parseValue = parseValue;
	exports.parseType = parseType;
	exports.parseConstValue = parseConstValue;
	exports.parseTypeReference = parseTypeReference;
	exports.parseNamedType = parseNamedType;
	
	var _source = __webpack_require__(260);
	
	var _error = __webpack_require__(4);
	
	var _lexer = __webpack_require__(164);
	
	var _kinds = __webpack_require__(14);
	
	/**
	 * Given a GraphQL source, parses it into a Document.
	 * Throws GraphQLError if a syntax error is encountered.
	 */
	
	
	/**
	 * Configuration options to control parser behavior
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function parse(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  if (!(sourceObj instanceof _source.Source)) {
	    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));
	  }
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  return parseDocument(lexer);
	}
	
	/**
	 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
	 * that value.
	 * Throws GraphQLError if a syntax error is encountered.
	 *
	 * This is useful within tools that operate upon GraphQL Values directly and
	 * in isolation of complete GraphQL documents.
	 *
	 * Consider providing the results to the utility function: valueFromAST().
	 */
	function parseValue(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  expect(lexer, _lexer.TokenKind.SOF);
	  var value = parseValueLiteral(lexer, false);
	  expect(lexer, _lexer.TokenKind.EOF);
	  return value;
	}
	
	/**
	 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
	 * that type.
	 * Throws GraphQLError if a syntax error is encountered.
	 *
	 * This is useful within tools that operate upon GraphQL Types directly and
	 * in isolation of complete GraphQL documents.
	 *
	 * Consider providing the results to the utility function: typeFromAST().
	 */
	function parseType(source, options) {
	  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
	  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
	  expect(lexer, _lexer.TokenKind.SOF);
	  var type = parseTypeReference(lexer);
	  expect(lexer, _lexer.TokenKind.EOF);
	  return type;
	}
	
	/**
	 * Converts a name lex token into a name parse node.
	 */
	function parseName(lexer) {
	  var token = expect(lexer, _lexer.TokenKind.NAME);
	  return {
	    kind: _kinds.NAME,
	    value: token.value,
	    loc: loc(lexer, token)
	  };
	}
	
	// Implements the parsing rules in the Document section.
	
	/**
	 * Document : Definition+
	 */
	function parseDocument(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.SOF);
	  var definitions = [];
	  do {
	    definitions.push(parseDefinition(lexer));
	  } while (!skip(lexer, _lexer.TokenKind.EOF));
	
	  return {
	    kind: _kinds.DOCUMENT,
	    definitions: definitions,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * Definition :
	 *   - OperationDefinition
	 *   - FragmentDefinition
	 *   - TypeSystemDefinition
	 */
	function parseDefinition(lexer) {
	  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
	    return parseOperationDefinition(lexer);
	  }
	
	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    switch (lexer.token.value) {
	      // Note: subscription is an experimental non-spec addition.
	      case 'query':
	      case 'mutation':
	      case 'subscription':
	        return parseOperationDefinition(lexer);
	
	      case 'fragment':
	        return parseFragmentDefinition(lexer);
	
	      // Note: the Type System IDL is an experimental non-spec addition.
	      case 'schema':
	      case 'scalar':
	      case 'type':
	      case 'interface':
	      case 'union':
	      case 'enum':
	      case 'input':
	      case 'extend':
	      case 'directive':
	        return parseTypeSystemDefinition(lexer);
	    }
	  }
	
	  throw unexpected(lexer);
	}
	
	// Implements the parsing rules in the Operations section.
	
	/**
	 * OperationDefinition :
	 *  - SelectionSet
	 *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
	 */
	function parseOperationDefinition(lexer) {
	  var start = lexer.token;
	  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
	    return {
	      kind: _kinds.OPERATION_DEFINITION,
	      operation: 'query',
	      name: null,
	      variableDefinitions: null,
	      directives: [],
	      selectionSet: parseSelectionSet(lexer),
	      loc: loc(lexer, start)
	    };
	  }
	  var operation = parseOperationType(lexer);
	  var name = void 0;
	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    name = parseName(lexer);
	  }
	  return {
	    kind: _kinds.OPERATION_DEFINITION,
	    operation: operation,
	    name: name,
	    variableDefinitions: parseVariableDefinitions(lexer),
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * OperationType : one of query mutation subscription
	 */
	function parseOperationType(lexer) {
	  var operationToken = expect(lexer, _lexer.TokenKind.NAME);
	  switch (operationToken.value) {
	    case 'query':
	      return 'query';
	    case 'mutation':
	      return 'mutation';
	    // Note: subscription is an experimental non-spec addition.
	    case 'subscription':
	      return 'subscription';
	  }
	
	  throw unexpected(lexer, operationToken);
	}
	
	/**
	 * VariableDefinitions : ( VariableDefinition+ )
	 */
	function parseVariableDefinitions(lexer) {
	  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];
	}
	
	/**
	 * VariableDefinition : Variable : Type DefaultValue?
	 */
	function parseVariableDefinition(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.VARIABLE_DEFINITION,
	    variable: parseVariable(lexer),
	    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),
	    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * Variable : $ Name
	 */
	function parseVariable(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.DOLLAR);
	  return {
	    kind: _kinds.VARIABLE,
	    name: parseName(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * SelectionSet : { Selection+ }
	 */
	function parseSelectionSet(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.SELECTION_SET,
	    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * Selection :
	 *   - Field
	 *   - FragmentSpread
	 *   - InlineFragment
	 */
	function parseSelection(lexer) {
	  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);
	}
	
	/**
	 * Field : Alias? Name Arguments? Directives? SelectionSet?
	 *
	 * Alias : Name :
	 */
	function parseField(lexer) {
	  var start = lexer.token;
	
	  var nameOrAlias = parseName(lexer);
	  var alias = void 0;
	  var name = void 0;
	  if (skip(lexer, _lexer.TokenKind.COLON)) {
	    alias = nameOrAlias;
	    name = parseName(lexer);
	  } else {
	    alias = null;
	    name = nameOrAlias;
	  }
	
	  return {
	    kind: _kinds.FIELD,
	    alias: alias,
	    name: name,
	    arguments: parseArguments(lexer),
	    directives: parseDirectives(lexer),
	    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * Arguments : ( Argument+ )
	 */
	function parseArguments(lexer) {
	  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];
	}
	
	/**
	 * Argument : Name : Value
	 */
	function parseArgument(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.ARGUMENT,
	    name: parseName(lexer),
	    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),
	    loc: loc(lexer, start)
	  };
	}
	
	// Implements the parsing rules in the Fragments section.
	
	/**
	 * Corresponds to both FragmentSpread and InlineFragment in the spec.
	 *
	 * FragmentSpread : ... FragmentName Directives?
	 *
	 * InlineFragment : ... TypeCondition? Directives? SelectionSet
	 */
	function parseFragment(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.SPREAD);
	  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {
	    return {
	      kind: _kinds.FRAGMENT_SPREAD,
	      name: parseFragmentName(lexer),
	      directives: parseDirectives(lexer),
	      loc: loc(lexer, start)
	    };
	  }
	  var typeCondition = null;
	  if (lexer.token.value === 'on') {
	    lexer.advance();
	    typeCondition = parseNamedType(lexer);
	  }
	  return {
	    kind: _kinds.INLINE_FRAGMENT,
	    typeCondition: typeCondition,
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * FragmentDefinition :
	 *   - fragment FragmentName on TypeCondition Directives? SelectionSet
	 *
	 * TypeCondition : NamedType
	 */
	function parseFragmentDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'fragment');
	  return {
	    kind: _kinds.FRAGMENT_DEFINITION,
	    name: parseFragmentName(lexer),
	    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
	    directives: parseDirectives(lexer),
	    selectionSet: parseSelectionSet(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * FragmentName : Name but not `on`
	 */
	function parseFragmentName(lexer) {
	  if (lexer.token.value === 'on') {
	    throw unexpected(lexer);
	  }
	  return parseName(lexer);
	}
	
	// Implements the parsing rules in the Values section.
	
	/**
	 * Value[Const] :
	 *   - [~Const] Variable
	 *   - IntValue
	 *   - FloatValue
	 *   - StringValue
	 *   - BooleanValue
	 *   - NullValue
	 *   - EnumValue
	 *   - ListValue[?Const]
	 *   - ObjectValue[?Const]
	 *
	 * BooleanValue : one of `true` `false`
	 *
	 * NullValue : `null`
	 *
	 * EnumValue : Name but not `true`, `false` or `null`
	 */
	function parseValueLiteral(lexer, isConst) {
	  var token = lexer.token;
	  switch (token.kind) {
	    case _lexer.TokenKind.BRACKET_L:
	      return parseList(lexer, isConst);
	    case _lexer.TokenKind.BRACE_L:
	      return parseObject(lexer, isConst);
	    case _lexer.TokenKind.INT:
	      lexer.advance();
	      return {
	        kind: _kinds.INT,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.FLOAT:
	      lexer.advance();
	      return {
	        kind: _kinds.FLOAT,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.STRING:
	      lexer.advance();
	      return {
	        kind: _kinds.STRING,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.NAME:
	      if (token.value === 'true' || token.value === 'false') {
	        lexer.advance();
	        return {
	          kind: _kinds.BOOLEAN,
	          value: token.value === 'true',
	          loc: loc(lexer, token)
	        };
	      } else if (token.value === 'null') {
	        lexer.advance();
	        return {
	          kind: _kinds.NULL,
	          loc: loc(lexer, token)
	        };
	      }
	      lexer.advance();
	      return {
	        kind: _kinds.ENUM,
	        value: token.value,
	        loc: loc(lexer, token)
	      };
	    case _lexer.TokenKind.DOLLAR:
	      if (!isConst) {
	        return parseVariable(lexer);
	      }
	      break;
	  }
	  throw unexpected(lexer);
	}
	
	function parseConstValue(lexer) {
	  return parseValueLiteral(lexer, true);
	}
	
	function parseValueValue(lexer) {
	  return parseValueLiteral(lexer, false);
	}
	
	/**
	 * ListValue[Const] :
	 *   - [ ]
	 *   - [ Value[?Const]+ ]
	 */
	function parseList(lexer, isConst) {
	  var start = lexer.token;
	  var item = isConst ? parseConstValue : parseValueValue;
	  return {
	    kind: _kinds.LIST,
	    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ObjectValue[Const] :
	 *   - { }
	 *   - { ObjectField[?Const]+ }
	 */
	function parseObject(lexer, isConst) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.BRACE_L);
	  var fields = [];
	  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {
	    fields.push(parseObjectField(lexer, isConst));
	  }
	  return {
	    kind: _kinds.OBJECT,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ObjectField[Const] : Name : Value[?Const]
	 */
	function parseObjectField(lexer, isConst) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.OBJECT_FIELD,
	    name: parseName(lexer),
	    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),
	    loc: loc(lexer, start)
	  };
	}
	
	// Implements the parsing rules in the Directives section.
	
	/**
	 * Directives : Directive+
	 */
	function parseDirectives(lexer) {
	  var directives = [];
	  while (peek(lexer, _lexer.TokenKind.AT)) {
	    directives.push(parseDirective(lexer));
	  }
	  return directives;
	}
	
	/**
	 * Directive : @ Name Arguments?
	 */
	function parseDirective(lexer) {
	  var start = lexer.token;
	  expect(lexer, _lexer.TokenKind.AT);
	  return {
	    kind: _kinds.DIRECTIVE,
	    name: parseName(lexer),
	    arguments: parseArguments(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	// Implements the parsing rules in the Types section.
	
	/**
	 * Type :
	 *   - NamedType
	 *   - ListType
	 *   - NonNullType
	 */
	function parseTypeReference(lexer) {
	  var start = lexer.token;
	  var type = void 0;
	  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {
	    type = parseTypeReference(lexer);
	    expect(lexer, _lexer.TokenKind.BRACKET_R);
	    type = {
	      kind: _kinds.LIST_TYPE,
	      type: type,
	      loc: loc(lexer, start)
	    };
	  } else {
	    type = parseNamedType(lexer);
	  }
	  if (skip(lexer, _lexer.TokenKind.BANG)) {
	    return {
	      kind: _kinds.NON_NULL_TYPE,
	      type: type,
	      loc: loc(lexer, start)
	    };
	  }
	  return type;
	}
	
	/**
	 * NamedType : Name
	 */
	function parseNamedType(lexer) {
	  var start = lexer.token;
	  return {
	    kind: _kinds.NAMED_TYPE,
	    name: parseName(lexer),
	    loc: loc(lexer, start)
	  };
	}
	
	// Implements the parsing rules in the Type Definition section.
	
	/**
	 * TypeSystemDefinition :
	 *   - SchemaDefinition
	 *   - TypeDefinition
	 *   - TypeExtensionDefinition
	 *   - DirectiveDefinition
	 *
	 * TypeDefinition :
	 *   - ScalarTypeDefinition
	 *   - ObjectTypeDefinition
	 *   - InterfaceTypeDefinition
	 *   - UnionTypeDefinition
	 *   - EnumTypeDefinition
	 *   - InputObjectTypeDefinition
	 */
	function parseTypeSystemDefinition(lexer) {
	  if (peek(lexer, _lexer.TokenKind.NAME)) {
	    switch (lexer.token.value) {
	      case 'schema':
	        return parseSchemaDefinition(lexer);
	      case 'scalar':
	        return parseScalarTypeDefinition(lexer);
	      case 'type':
	        return parseObjectTypeDefinition(lexer);
	      case 'interface':
	        return parseInterfaceTypeDefinition(lexer);
	      case 'union':
	        return parseUnionTypeDefinition(lexer);
	      case 'enum':
	        return parseEnumTypeDefinition(lexer);
	      case 'input':
	        return parseInputObjectTypeDefinition(lexer);
	      case 'extend':
	        return parseTypeExtensionDefinition(lexer);
	      case 'directive':
	        return parseDirectiveDefinition(lexer);
	    }
	  }
	
	  throw unexpected(lexer);
	}
	
	/**
	 * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }
	 *
	 * OperationTypeDefinition : OperationType : NamedType
	 */
	function parseSchemaDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'schema');
	  var directives = parseDirectives(lexer);
	  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.SCHEMA_DEFINITION,
	    directives: directives,
	    operationTypes: operationTypes,
	    loc: loc(lexer, start)
	  };
	}
	
	function parseOperationTypeDefinition(lexer) {
	  var start = lexer.token;
	  var operation = parseOperationType(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseNamedType(lexer);
	  return {
	    kind: _kinds.OPERATION_TYPE_DEFINITION,
	    operation: operation,
	    type: type,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ScalarTypeDefinition : scalar Name Directives?
	 */
	function parseScalarTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'scalar');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.SCALAR_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ObjectTypeDefinition :
	 *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }
	 */
	function parseObjectTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'type');
	  var name = parseName(lexer);
	  var interfaces = parseImplementsInterfaces(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.OBJECT_TYPE_DEFINITION,
	    name: name,
	    interfaces: interfaces,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ImplementsInterfaces : implements NamedType+
	 */
	function parseImplementsInterfaces(lexer) {
	  var types = [];
	  if (lexer.token.value === 'implements') {
	    lexer.advance();
	    do {
	      types.push(parseNamedType(lexer));
	    } while (peek(lexer, _lexer.TokenKind.NAME));
	  }
	  return types;
	}
	
	/**
	 * FieldDefinition : Name ArgumentsDefinition? : Type Directives?
	 */
	function parseFieldDefinition(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  var args = parseArgumentDefs(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseTypeReference(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.FIELD_DEFINITION,
	    name: name,
	    arguments: args,
	    type: type,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * ArgumentsDefinition : ( InputValueDefinition+ )
	 */
	function parseArgumentDefs(lexer) {
	  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {
	    return [];
	  }
	  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);
	}
	
	/**
	 * InputValueDefinition : Name : Type DefaultValue? Directives?
	 */
	function parseInputValueDef(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  expect(lexer, _lexer.TokenKind.COLON);
	  var type = parseTypeReference(lexer);
	  var defaultValue = null;
	  if (skip(lexer, _lexer.TokenKind.EQUALS)) {
	    defaultValue = parseConstValue(lexer);
	  }
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.INPUT_VALUE_DEFINITION,
	    name: name,
	    type: type,
	    defaultValue: defaultValue,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }
	 */
	function parseInterfaceTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'interface');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.INTERFACE_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * UnionTypeDefinition : union Name Directives? = UnionMembers
	 */
	function parseUnionTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'union');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  expect(lexer, _lexer.TokenKind.EQUALS);
	  var types = parseUnionMembers(lexer);
	  return {
	    kind: _kinds.UNION_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    types: types,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * UnionMembers :
	 *   - `|`? NamedType
	 *   - UnionMembers | NamedType
	 */
	function parseUnionMembers(lexer) {
	  // Optional leading pipe
	  skip(lexer, _lexer.TokenKind.PIPE);
	  var members = [];
	  do {
	    members.push(parseNamedType(lexer));
	  } while (skip(lexer, _lexer.TokenKind.PIPE));
	  return members;
	}
	
	/**
	 * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }
	 */
	function parseEnumTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'enum');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.ENUM_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    values: values,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * EnumValueDefinition : EnumValue Directives?
	 *
	 * EnumValue : Name
	 */
	function parseEnumValueDefinition(lexer) {
	  var start = lexer.token;
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  return {
	    kind: _kinds.ENUM_VALUE_DEFINITION,
	    name: name,
	    directives: directives,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }
	 */
	function parseInputObjectTypeDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'input');
	  var name = parseName(lexer);
	  var directives = parseDirectives(lexer);
	  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);
	  return {
	    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,
	    name: name,
	    directives: directives,
	    fields: fields,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * TypeExtensionDefinition : extend ObjectTypeDefinition
	 */
	function parseTypeExtensionDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'extend');
	  var definition = parseObjectTypeDefinition(lexer);
	  return {
	    kind: _kinds.TYPE_EXTENSION_DEFINITION,
	    definition: definition,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * DirectiveDefinition :
	 *   - directive @ Name ArgumentsDefinition? on DirectiveLocations
	 */
	function parseDirectiveDefinition(lexer) {
	  var start = lexer.token;
	  expectKeyword(lexer, 'directive');
	  expect(lexer, _lexer.TokenKind.AT);
	  var name = parseName(lexer);
	  var args = parseArgumentDefs(lexer);
	  expectKeyword(lexer, 'on');
	  var locations = parseDirectiveLocations(lexer);
	  return {
	    kind: _kinds.DIRECTIVE_DEFINITION,
	    name: name,
	    arguments: args,
	    locations: locations,
	    loc: loc(lexer, start)
	  };
	}
	
	/**
	 * DirectiveLocations :
	 *   - `|`? Name
	 *   - DirectiveLocations | Name
	 */
	function parseDirectiveLocations(lexer) {
	  // Optional leading pipe
	  skip(lexer, _lexer.TokenKind.PIPE);
	  var locations = [];
	  do {
	    locations.push(parseName(lexer));
	  } while (skip(lexer, _lexer.TokenKind.PIPE));
	  return locations;
	}
	
	// Core parsing utility functions
	
	/**
	 * Returns a location object, used to identify the place in
	 * the source that created a given parsed object.
	 */
	function loc(lexer, startToken) {
	  if (!lexer.options.noLocation) {
	    return new Loc(startToken, lexer.lastToken, lexer.source);
	  }
	}
	
	function Loc(startToken, endToken, source) {
	  this.start = startToken.start;
	  this.end = endToken.end;
	  this.startToken = startToken;
	  this.endToken = endToken;
	  this.source = source;
	}
	
	// Print a simplified form when appearing in JSON/util.inspect.
	Loc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {
	  return { start: this.start, end: this.end };
	};
	
	/**
	 * Determines if the next token is of a given kind
	 */
	function peek(lexer, kind) {
	  return lexer.token.kind === kind;
	}
	
	/**
	 * If the next token is of the given kind, return true after advancing
	 * the lexer. Otherwise, do not change the parser state and return false.
	 */
	function skip(lexer, kind) {
	  var match = lexer.token.kind === kind;
	  if (match) {
	    lexer.advance();
	  }
	  return match;
	}
	
	/**
	 * If the next token is of the given kind, return that token after advancing
	 * the lexer. Otherwise, do not change the parser state and throw an error.
	 */
	function expect(lexer, kind) {
	  var token = lexer.token;
	  if (token.kind === kind) {
	    lexer.advance();
	    return token;
	  }
	  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));
	}
	
	/**
	 * If the next token is a keyword with the given value, return that token after
	 * advancing the lexer. Otherwise, do not change the parser state and return
	 * false.
	 */
	function expectKeyword(lexer, value) {
	  var token = lexer.token;
	  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {
	    lexer.advance();
	    return token;
	  }
	  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected "' + value + '", found ' + (0, _lexer.getTokenDesc)(token));
	}
	
	/**
	 * Helper function for creating an error when an unexpected lexed token
	 * is encountered.
	 */
	function unexpected(lexer, atToken) {
	  var token = atToken || lexer.token;
	  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));
	}
	
	/**
	 * Returns a possibly empty list of parse nodes, determined by
	 * the parseFn. This list begins with a lex token of openKind
	 * and ends with a lex token of closeKind. Advances the parser
	 * to the next lex token after the closing token.
	 */
	function any(lexer, openKind, parseFn, closeKind) {
	  expect(lexer, openKind);
	  var nodes = [];
	  while (!skip(lexer, closeKind)) {
	    nodes.push(parseFn(lexer));
	  }
	  return nodes;
	}
	
	/**
	 * Returns a non-empty list of parse nodes, determined by
	 * the parseFn. This list begins with a lex token of openKind
	 * and ends with a lex token of closeKind. Advances the parser
	 * to the next lex token after the closing token.
	 */
	function many(lexer, openKind, parseFn, closeKind) {
	  expect(lexer, openKind);
	  var nodes = [parseFn(lexer)];
	  while (!skip(lexer, closeKind)) {
	    nodes.push(parseFn(lexer));
	  }
	  return nodes;
	}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isValidLiteralValue = isValidLiteralValue;
	
	var _printer = __webpack_require__(27);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _definition = __webpack_require__(7);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Utility for validators which determines if a value literal node is valid
	 * given an input type.
	 *
	 * Note that this only validates literal values, variables are assumed to
	 * provide values of the correct type.
	 */
	function isValidLiteralValue(type, valueNode) {
	  // A value must be provided if the type is non-null.
	  if (type instanceof _definition.GraphQLNonNull) {
	    if (!valueNode || valueNode.kind === Kind.NULL) {
	      return ['Expected "' + String(type) + '", found null.'];
	    }
	    return isValidLiteralValue(type.ofType, valueNode);
	  }
	
	  if (!valueNode || valueNode.kind === Kind.NULL) {
	    return [];
	  }
	
	  // This function only tests literals, and assumes variables will provide
	  // values of the correct type.
	  if (valueNode.kind === Kind.VARIABLE) {
	    return [];
	  }
	
	  // Lists accept a non-list value as a list of one.
	  if (type instanceof _definition.GraphQLList) {
	    var itemType = type.ofType;
	    if (valueNode.kind === Kind.LIST) {
	      return valueNode.values.reduce(function (acc, item, index) {
	        var errors = isValidLiteralValue(itemType, item);
	        return acc.concat(errors.map(function (error) {
	          return 'In element #' + index + ': ' + error;
	        }));
	      }, []);
	    }
	    return isValidLiteralValue(itemType, valueNode);
	  }
	
	  // Input objects check each defined field and look for undefined fields.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    if (valueNode.kind !== Kind.OBJECT) {
	      return ['Expected "' + type.name + '", found not an object.'];
	    }
	    var fields = type.getFields();
	
	    var errors = [];
	
	    // Ensure every provided field is defined.
	    var fieldNodes = valueNode.fields;
	    fieldNodes.forEach(function (providedFieldNode) {
	      if (!fields[providedFieldNode.name.value]) {
	        errors.push('In field "' + providedFieldNode.name.value + '": Unknown field.');
	      }
	    });
	
	    // Ensure every defined field is valid.
	    var fieldNodeMap = (0, _keyMap2.default)(fieldNodes, function (fieldNode) {
	      return fieldNode.name.value;
	    });
	    Object.keys(fields).forEach(function (fieldName) {
	      var result = isValidLiteralValue(fields[fieldName].type, fieldNodeMap[fieldName] && fieldNodeMap[fieldName].value);
	      errors.push.apply(errors, result.map(function (error) {
	        return 'In field "' + fieldName + '": ' + error;
	      }));
	    });
	
	    return errors;
	  }
	
	  !(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType) ? (0, _invariant2.default)(0, 'Must be input type') : void 0;
	
	  // Scalars determine if a literal values is valid.
	  if (!type.isValidLiteral(valueNode)) {
	    return ['Expected type "' + type.name + '", found ' + (0, _printer.print)(valueNode) + '.'];
	  }
	
	  return [];
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isEqualType = isEqualType;
	exports.isTypeSubTypeOf = isTypeSubTypeOf;
	exports.doTypesOverlap = doTypesOverlap;
	
	var _definition = __webpack_require__(7);
	
	/**
	 * Provided two types, return true if the types are equal (invariant).
	 */
	function isEqualType(typeA, typeB) {
	  // Equivalent types are equal.
	  if (typeA === typeB) {
	    return true;
	  }
	
	  // If either type is non-null, the other must also be non-null.
	  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {
	    return isEqualType(typeA.ofType, typeB.ofType);
	  }
	
	  // If either type is a list, the other must also be a list.
	  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {
	    return isEqualType(typeA.ofType, typeB.ofType);
	  }
	
	  // Otherwise the types are not equal.
	  return false;
	}
	
	/**
	 * Provided a type and a super type, return true if the first type is either
	 * equal or a subset of the second super type (covariant).
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function isTypeSubTypeOf(schema, maybeSubType, superType) {
	  // Equivalent type is a valid subtype
	  if (maybeSubType === superType) {
	    return true;
	  }
	
	  // If superType is non-null, maybeSubType must also be non-null.
	  if (superType instanceof _definition.GraphQLNonNull) {
	    if (maybeSubType instanceof _definition.GraphQLNonNull) {
	      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
	    }
	    return false;
	  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {
	    // If superType is nullable, maybeSubType may be non-null or nullable.
	    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
	  }
	
	  // If superType type is a list, maybeSubType type must also be a list.
	  if (superType instanceof _definition.GraphQLList) {
	    if (maybeSubType instanceof _definition.GraphQLList) {
	      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
	    }
	    return false;
	  } else if (maybeSubType instanceof _definition.GraphQLList) {
	    // If superType is not a list, maybeSubType must also be not a list.
	    return false;
	  }
	
	  // If superType type is an abstract type, maybeSubType type may be a currently
	  // possible object type.
	  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {
	    return true;
	  }
	
	  // Otherwise, the child type is not a valid subtype of the parent type.
	  return false;
	}
	
	/**
	 * Provided two composite types, determine if they "overlap". Two composite
	 * types overlap when the Sets of possible concrete types for each intersect.
	 *
	 * This is often used to determine if a fragment of a given type could possibly
	 * be visited in a context of another type.
	 *
	 * This function is commutative.
	 */
	function doTypesOverlap(schema, typeA, typeB) {
	  // So flow is aware this is constant
	  var _typeB = typeB;
	
	  // Equivalent types overlap
	  if (typeA === _typeB) {
	    return true;
	  }
	
	  if ((0, _definition.isAbstractType)(typeA)) {
	    if ((0, _definition.isAbstractType)(_typeB)) {
	      // If both types are abstract, then determine if there is any intersection
	      // between possible concrete types of each.
	      return schema.getPossibleTypes(typeA).some(function (type) {
	        return schema.isPossibleType(_typeB, type);
	      });
	    }
	    // Determine if the latter type is a possible concrete type of the former.
	    return schema.isPossibleType(typeA, _typeB);
	  }
	
	  if ((0, _definition.isAbstractType)(_typeB)) {
	    // Determine if the former type is a possible concrete type of the latter.
	    return schema.isPossibleType(_typeB, typeA);
	  }
	
	  // Otherwise the types do not overlap.
	  return false;
	}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var bind = __webpack_require__(151);
	
	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),
/* 112 */,
/* 113 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = decimal;
	
	/* Check if the given character code, or the character
	 * code at the first character, is decimal. */
	function decimal(character) {
	  var code = typeof character === 'string' ?
	    character.charCodeAt(0) : character;
	
	  return code >= 48 && code <= 57; /* 0-9 */
	}


/***/ }),
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SortDirection = {
	  /**
	   * Sort items in ascending order.
	   * This means arranging from the lowest value to the highest (e.g. a-z, 0-9).
	   */
	  ASC: 'ASC',
	
	  /**
	   * Sort items in descending order.
	   * This means arranging from the highest value to the lowest (e.g. z-a, 9-0).
	   */
	  DESC: 'DESC'
	};
	
	exports.default = SortDirection;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* Expose. */
	module.exports = visit;
	
	var is = __webpack_require__(1057);
	
	/* Visit. */
	function visit(tree, test, visitor, reverse) {
	  if (typeof test === 'function' && typeof visitor !== 'function') {
	    reverse = visitor;
	    visitor = test;
	    test = null;
	  }
	
	  one(tree);
	
	  /* Visit a single node. */
	  function one(node, index, parent) {
	    var result;
	
	    index = index || (parent ? 0 : null);
	
	    if (!test || node.type === test || is(test, node, index, parent || null)) {
	      result = visitor(node, index, parent || null);
	    }
	
	    if (node.children && result !== false) {
	      return all(node.children, node);
	    }
	
	    return result;
	  }
	
	  /* Visit children in `parent`. */
	  function all(children, parent) {
	    var step = reverse ? -1 : 1;
	    var max = children.length;
	    var min = -1;
	    var index = (reverse ? max : min) + step;
	    var child;
	
	    while (index > min && index < max) {
	      child = children[index];
	
	      if (child && one(child, index, parent) === false) {
	        return false;
	      }
	
	      index += step;
	    }
	
	    return true;
	  }
	}


/***/ }),
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */
/***/ (function(module, exports) {

	"use strict";
	function createDummyElement(text, options) {
	    var element = document.createElement('div');
	    var textNode = document.createTextNode(text);
	    element.appendChild(textNode);
	    element.style.fontFamily = options.font;
	    element.style.fontSize = options.fontSize;
	    element.style.fontWeight = options.fontWeight;
	    element.style.position = 'absolute';
	    element.style.visibility = 'hidden';
	    element.style.left = '-999px';
	    element.style.top = '-999px';
	    element.style.width = options.width;
	    element.style.height = 'auto';
	    document.body.appendChild(element);
	    return element;
	}
	function destroyElement(element) {
	    element.parentNode.removeChild(element);
	}
	var cache = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = function (text, options) {
	    if (options === void 0) { options = {}; }
	    var cacheKey = JSON.stringify({ text: text, options: options });
	    if (cache[cacheKey]) {
	        return cache[cacheKey];
	    }
	    options.font = options.font || 'Times';
	    options.fontSize = options.fontSize || '16px';
	    options.fontWeight = options.fontWeight || 'normal';
	    options.width = options.width || 'auto';
	    var element = createDummyElement(text, options);
	    var size = {
	        width: element.offsetWidth,
	        height: element.offsetHeight,
	    };
	    destroyElement(element);
	    cache[cacheKey] = size;
	    return size;
	};
	//# sourceMappingURL=index.js.map

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
	    (document.documentMode == null || document.documentMode < 8);
	
	  var Pos = CodeMirror.Pos;
	
	  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};
	
	  function findMatchingBracket(cm, where, config) {
	    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
	    var afterCursor = config && config.afterCursor
	    if (afterCursor == null)
	      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)
	
	    // A cursor is defined as between two characters, but in in vim command mode
	    // (i.e. not insert mode), the cursor is visually represented as a
	    // highlighted box on top of the 2nd character. Otherwise, we allow matches
	    // from before or after the cursor.
	    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||
	        matching[line.text.charAt(++pos)];
	    if (!match) return null;
	    var dir = match.charAt(1) == ">" ? 1 : -1;
	    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;
	    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
	
	    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
	    if (found == null) return null;
	    return {from: Pos(where.line, pos), to: found && found.pos,
	            match: found && found.ch == match.charAt(0), forward: dir > 0};
	  }
	
	  // bracketRegex is used to specify which type of bracket to scan
	  // should be a regexp, e.g. /[[\]]/
	  //
	  // Note: If "where" is on an open bracket, then this bracket is ignored.
	  //
	  // Returns false when no bracket was found, null when it reached
	  // maxScanLines and gave up
	  function scanForBracket(cm, where, dir, style, config) {
	    var maxScanLen = (config && config.maxScanLineLength) || 10000;
	    var maxScanLines = (config && config.maxScanLines) || 1000;
	
	    var stack = [];
	    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
	    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
	                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
	    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
	      var line = cm.getLine(lineNo);
	      if (!line) continue;
	      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
	      if (line.length > maxScanLen) continue;
	      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
	      for (; pos != end; pos += dir) {
	        var ch = line.charAt(pos);
	        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
	          var match = matching[ch];
	          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
	          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
	          else stack.pop();
	        }
	      }
	    }
	    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
	  }
	
	  function matchBrackets(cm, autoclear, config) {
	    // Disable brace matching in long lines, since it'll cause hugely slow updates
	    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
	    var marks = [], ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
	      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
	        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
	        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
	        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
	          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
	      }
	    }
	
	    if (marks.length) {
	      // Kludge to work around the IE bug from issue #1193, where text
	      // input stops going to the textare whever this fires.
	      if (ie_lt8 && cm.state.focused) cm.focus();
	
	      var clear = function() {
	        cm.operation(function() {
	          for (var i = 0; i < marks.length; i++) marks[i].clear();
	        });
	      };
	      if (autoclear) setTimeout(clear, 800);
	      else return clear;
	    }
	  }
	
	  var currentlyHighlighted = null;
	  function doMatchBrackets(cm) {
	    cm.operation(function() {
	      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
	      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
	    });
	  }
	
	  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.off("cursorActivity", doMatchBrackets);
	      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
	    }
	    if (val) {
	      cm.state.matchBrackets = typeof val == "object" ? val : {};
	      cm.on("cursorActivity", doMatchBrackets);
	    }
	  });
	
	  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
	  CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig){
	    // Backwards-compatibility kludge
	    if (oldConfig || typeof config == "boolean") {
	      if (!oldConfig) {
	        config = config ? {strict: true} : null
	      } else {
	        oldConfig.strict = config
	        config = oldConfig
	      }
	    }
	    return findMatchingBracket(this, pos, config)
	  });
	  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
	    return scanForBracket(this, pos, dir, style, config);
	  });
	});


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.registerHelper("fold", "brace", function(cm, start) {
	  var line = start.line, lineText = cm.getLine(line);
	  var tokenType;
	
	  function findOpening(openCh) {
	    for (var at = start.ch, pass = 0;;) {
	      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
	      if (found == -1) {
	        if (pass == 1) break;
	        pass = 1;
	        at = lineText.length;
	        continue;
	      }
	      if (pass == 1 && found < start.ch) break;
	      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
	      if (!/^(comment|string)/.test(tokenType)) return found + 1;
	      at = found - 1;
	    }
	  }
	
	  var startToken = "{", endToken = "}", startCh = findOpening("{");
	  if (startCh == null) {
	    startToken = "[", endToken = "]";
	    startCh = findOpening("[");
	  }
	
	  if (startCh == null) return;
	  var count = 1, lastLine = cm.lastLine(), end, endCh;
	  outer: for (var i = line; i <= lastLine; ++i) {
	    var text = cm.getLine(i), pos = i == line ? startCh : 0;
	    for (;;) {
	      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
	      if (nextOpen < 0) nextOpen = text.length;
	      if (nextClose < 0) nextClose = text.length;
	      pos = Math.min(nextOpen, nextClose);
	      if (pos == text.length) break;
	      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
	        if (pos == nextOpen) ++count;
	        else if (!--count) { end = i; endCh = pos; break outer; }
	      }
	      ++pos;
	    }
	  }
	  if (end == null || line == end && endCh == startCh) return;
	  return {from: CodeMirror.Pos(line, startCh),
	          to: CodeMirror.Pos(end, endCh)};
	});
	
	CodeMirror.registerHelper("fold", "import", function(cm, start) {
	  function hasImport(line) {
	    if (line < cm.firstLine() || line > cm.lastLine()) return null;
	    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
	    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
	    if (start.type != "keyword" || start.string != "import") return null;
	    // Now find closing semicolon, return its position
	    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
	      var text = cm.getLine(i), semi = text.indexOf(";");
	      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
	    }
	  }
	
	  var startLine = start.line, has = hasImport(startLine), prev;
	  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))
	    return null;
	  for (var end = has.end;;) {
	    var next = hasImport(end.line + 1);
	    if (next == null) break;
	    end = next.end;
	  }
	  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};
	});
	
	CodeMirror.registerHelper("fold", "include", function(cm, start) {
	  function hasInclude(line) {
	    if (line < cm.firstLine() || line > cm.lastLine()) return null;
	    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
	    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
	    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
	  }
	
	  var startLine = start.line, has = hasInclude(startLine);
	  if (has == null || hasInclude(startLine - 1) != null) return null;
	  for (var end = startLine;;) {
	    var next = hasInclude(end + 1);
	    if (next == null) break;
	    ++end;
	  }
	  return {from: CodeMirror.Pos(startLine, has + 1),
	          to: cm.clipPos(CodeMirror.Pos(end))};
	});
	
	});


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5), __webpack_require__(404));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "./foldcode"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.clearGutter(cm.state.foldGutter.options.gutter);
	      cm.state.foldGutter = null;
	      cm.off("gutterClick", onGutterClick);
	      cm.off("change", onChange);
	      cm.off("viewportChange", onViewportChange);
	      cm.off("fold", onFold);
	      cm.off("unfold", onFold);
	      cm.off("swapDoc", onChange);
	    }
	    if (val) {
	      cm.state.foldGutter = new State(parseOptions(val));
	      updateInViewport(cm);
	      cm.on("gutterClick", onGutterClick);
	      cm.on("change", onChange);
	      cm.on("viewportChange", onViewportChange);
	      cm.on("fold", onFold);
	      cm.on("unfold", onFold);
	      cm.on("swapDoc", onChange);
	    }
	  });
	
	  var Pos = CodeMirror.Pos;
	
	  function State(options) {
	    this.options = options;
	    this.from = this.to = 0;
	  }
	
	  function parseOptions(opts) {
	    if (opts === true) opts = {};
	    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
	    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
	    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
	    return opts;
	  }
	
	  function isFolded(cm, line) {
	    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
	    for (var i = 0; i < marks.length; ++i)
	      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];
	  }
	
	  function marker(spec) {
	    if (typeof spec == "string") {
	      var elt = document.createElement("div");
	      elt.className = spec + " CodeMirror-guttermarker-subtle";
	      return elt;
	    } else {
	      return spec.cloneNode(true);
	    }
	  }
	
	  function updateFoldInfo(cm, from, to) {
	    var opts = cm.state.foldGutter.options, cur = from;
	    var minSize = cm.foldOption(opts, "minFoldSize");
	    var func = cm.foldOption(opts, "rangeFinder");
	    cm.eachLine(from, to, function(line) {
	      var mark = null;
	      if (isFolded(cm, cur)) {
	        mark = marker(opts.indicatorFolded);
	      } else {
	        var pos = Pos(cur, 0);
	        var range = func && func(cm, pos);
	        if (range && range.to.line - range.from.line >= minSize)
	          mark = marker(opts.indicatorOpen);
	      }
	      cm.setGutterMarker(line, opts.gutter, mark);
	      ++cur;
	    });
	  }
	
	  function updateInViewport(cm) {
	    var vp = cm.getViewport(), state = cm.state.foldGutter;
	    if (!state) return;
	    cm.operation(function() {
	      updateFoldInfo(cm, vp.from, vp.to);
	    });
	    state.from = vp.from; state.to = vp.to;
	  }
	
	  function onGutterClick(cm, line, gutter) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    if (gutter != opts.gutter) return;
	    var folded = isFolded(cm, line);
	    if (folded) folded.clear();
	    else cm.foldCode(Pos(line, 0), opts.rangeFinder);
	  }
	
	  function onChange(cm) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    state.from = state.to = 0;
	    clearTimeout(state.changeUpdate);
	    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
	  }
	
	  function onViewportChange(cm) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    clearTimeout(state.changeUpdate);
	    state.changeUpdate = setTimeout(function() {
	      var vp = cm.getViewport();
	      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
	        updateInViewport(cm);
	      } else {
	        cm.operation(function() {
	          if (vp.from < state.from) {
	            updateFoldInfo(cm, vp.from, state.from);
	            state.from = vp.from;
	          }
	          if (vp.to > state.to) {
	            updateFoldInfo(cm, state.to, vp.to);
	            state.to = vp.to;
	          }
	        });
	      }
	    }, opts.updateViewportTimeSpan || 400);
	  }
	
	  function onFold(cm, from) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var line = from.line;
	    if (line >= state.from && line < state.to)
	      updateFoldInfo(cm, line, line + 1);
	  }
	});


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5))
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod)
	  else // Plain browser env
	    mod(CodeMirror)
	})(function(CodeMirror) {
	  "use strict"
	  var Pos = CodeMirror.Pos
	
	  function regexpFlags(regexp) {
	    var flags = regexp.flags
	    return flags != null ? flags : (regexp.ignoreCase ? "i" : "")
	      + (regexp.global ? "g" : "")
	      + (regexp.multiline ? "m" : "")
	  }
	
	  function ensureGlobal(regexp) {
	    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + "g")
	  }
	
	  function maybeMultiline(regexp) {
	    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
	  }
	
	  function searchRegexpForward(doc, regexp, start) {
	    regexp = ensureGlobal(regexp)
	    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
	      regexp.lastIndex = ch
	      var string = doc.getLine(line), match = regexp.exec(string)
	      if (match)
	        return {from: Pos(line, match.index),
	                to: Pos(line, match.index + match[0].length),
	                match: match}
	    }
	  }
	
	  function searchRegexpForwardMultiline(doc, regexp, start) {
	    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)
	
	    regexp = ensureGlobal(regexp)
	    var string, chunk = 1
	    for (var line = start.line, last = doc.lastLine(); line <= last;) {
	      // This grows the search buffer in exponentially-sized chunks
	      // between matches, so that nearby matches are fast and don't
	      // require concatenating the whole document (in case we're
	      // searching for something that has tons of matches), but at the
	      // same time, the amount of retries is limited.
	      for (var i = 0; i < chunk; i++) {
	        var curLine = doc.getLine(line++)
	        string = string == null ? curLine : string + "\n" + curLine
	      }
	      chunk = chunk * 2
	      regexp.lastIndex = start.ch
	      var match = regexp.exec(string)
	      if (match) {
	        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
	        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length
	        return {from: Pos(startLine, startCh),
	                to: Pos(startLine + inside.length - 1,
	                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
	                match: match}
	      }
	    }
	  }
	
	  function lastMatchIn(string, regexp) {
	    var cutOff = 0, match
	    for (;;) {
	      regexp.lastIndex = cutOff
	      var newMatch = regexp.exec(string)
	      if (!newMatch) return match
	      match = newMatch
	      cutOff = match.index + (match[0].length || 1)
	      if (cutOff == string.length) return match
	    }
	  }
	
	  function searchRegexpBackward(doc, regexp, start) {
	    regexp = ensureGlobal(regexp)
	    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
	      var string = doc.getLine(line)
	      if (ch > -1) string = string.slice(0, ch)
	      var match = lastMatchIn(string, regexp)
	      if (match)
	        return {from: Pos(line, match.index),
	                to: Pos(line, match.index + match[0].length),
	                match: match}
	    }
	  }
	
	  function searchRegexpBackwardMultiline(doc, regexp, start) {
	    regexp = ensureGlobal(regexp)
	    var string, chunk = 1
	    for (var line = start.line, first = doc.firstLine(); line >= first;) {
	      for (var i = 0; i < chunk; i++) {
	        var curLine = doc.getLine(line--)
	        string = string == null ? curLine.slice(0, start.ch) : curLine + "\n" + string
	      }
	      chunk *= 2
	
	      var match = lastMatchIn(string, regexp)
	      if (match) {
	        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
	        var startLine = line + before.length, startCh = before[before.length - 1].length
	        return {from: Pos(startLine, startCh),
	                to: Pos(startLine + inside.length - 1,
	                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
	                match: match}
	      }
	    }
	  }
	
	  var doFold, noFold
	  if (String.prototype.normalize) {
	    doFold = function(str) { return str.normalize("NFD").toLowerCase() }
	    noFold = function(str) { return str.normalize("NFD") }
	  } else {
	    doFold = function(str) { return str.toLowerCase() }
	    noFold = function(str) { return str }
	  }
	
	  // Maps a position in a case-folded line back to a position in the original line
	  // (compensating for codepoints increasing in number during folding)
	  function adjustPos(orig, folded, pos, foldFunc) {
	    if (orig.length == folded.length) return pos
	    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
	      if (min == max) return min
	      var mid = (min + max) >> 1
	      var len = foldFunc(orig.slice(0, mid)).length
	      if (len == pos) return mid
	      else if (len > pos) max = mid
	      else min = mid + 1
	    }
	  }
	
	  function searchStringForward(doc, query, start, caseFold) {
	    // Empty string would match anything and never progress, so we
	    // define it to match nothing instead.
	    if (!query.length) return null
	    var fold = caseFold ? doFold : noFold
	    var lines = fold(query).split(/\r|\n\r?/)
	
	    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
	      var orig = doc.getLine(line).slice(ch), string = fold(orig)
	      if (lines.length == 1) {
	        var found = string.indexOf(lines[0])
	        if (found == -1) continue search
	        var start = adjustPos(orig, string, found, fold) + ch
	        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),
	                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}
	      } else {
	        var cutFrom = string.length - lines[0].length
	        if (string.slice(cutFrom) != lines[0]) continue search
	        for (var i = 1; i < lines.length - 1; i++)
	          if (fold(doc.getLine(line + i)) != lines[i]) continue search
	        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]
	        if (end.slice(0, lastLine.length) != lastLine) continue search
	        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
	                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}
	      }
	    }
	  }
	
	  function searchStringBackward(doc, query, start, caseFold) {
	    if (!query.length) return null
	    var fold = caseFold ? doFold : noFold
	    var lines = fold(query).split(/\r|\n\r?/)
	
	    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
	      var orig = doc.getLine(line)
	      if (ch > -1) orig = orig.slice(0, ch)
	      var string = fold(orig)
	      if (lines.length == 1) {
	        var found = string.lastIndexOf(lines[0])
	        if (found == -1) continue search
	        return {from: Pos(line, adjustPos(orig, string, found, fold)),
	                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}
	      } else {
	        var lastLine = lines[lines.length - 1]
	        if (string.slice(0, lastLine.length) != lastLine) continue search
	        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
	          if (fold(doc.getLine(start + i)) != lines[i]) continue search
	        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)
	        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search
	        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
	                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}
	      }
	    }
	  }
	
	  function SearchCursor(doc, query, pos, options) {
	    this.atOccurrence = false
	    this.doc = doc
	    pos = pos ? doc.clipPos(pos) : Pos(0, 0)
	    this.pos = {from: pos, to: pos}
	
	    var caseFold
	    if (typeof options == "object") {
	      caseFold = options.caseFold
	    } else { // Backwards compat for when caseFold was the 4th argument
	      caseFold = options
	      options = null
	    }
	
	    if (typeof query == "string") {
	      if (caseFold == null) caseFold = false
	      this.matches = function(reverse, pos) {
	        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
	      }
	    } else {
	      query = ensureGlobal(query)
	      if (!options || options.multiline !== false)
	        this.matches = function(reverse, pos) {
	          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
	        }
	      else
	        this.matches = function(reverse, pos) {
	          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
	        }
	    }
	  }
	
	  SearchCursor.prototype = {
	    findNext: function() {return this.find(false)},
	    findPrevious: function() {return this.find(true)},
	
	    find: function(reverse) {
	      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))
	
	      // Implements weird auto-growing behavior on null-matches for
	      // backwards-compatiblity with the vim code (unfortunately)
	      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
	        if (reverse) {
	          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)
	          else if (result.from.line == this.doc.firstLine()) result = null
	          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))
	        } else {
	          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)
	          else if (result.to.line == this.doc.lastLine()) result = null
	          else result = this.matches(reverse, Pos(result.to.line + 1, 0))
	        }
	      }
	
	      if (result) {
	        this.pos = result
	        this.atOccurrence = true
	        return this.pos.match || true
	      } else {
	        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)
	        this.pos = {from: end, to: end}
	        return this.atOccurrence = false
	      }
	    },
	
	    from: function() {if (this.atOccurrence) return this.pos.from},
	    to: function() {if (this.atOccurrence) return this.pos.to},
	
	    replace: function(newText, origin) {
	      if (!this.atOccurrence) return
	      var lines = CodeMirror.splitLines(newText)
	      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)
	      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
	                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))
	    }
	  }
	
	  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this.doc, query, pos, caseFold)
	  })
	  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this, query, pos, caseFold)
	  })
	
	  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
	    var ranges = []
	    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold)
	    while (cur.findNext()) {
	      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break
	      ranges.push({anchor: cur.from(), head: cur.to()})
	    }
	    if (ranges.length)
	      this.setSelections(ranges, 0)
	  })
	});


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// A rough approximation of Sublime Text's keybindings
	// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5), __webpack_require__(130), __webpack_require__(127));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  var cmds = CodeMirror.commands;
	  var Pos = CodeMirror.Pos;
	
	  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.
	  function findPosSubword(doc, start, dir) {
	    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
	    var line = doc.getLine(start.line);
	    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
	    var state = "start", type;
	    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
	      var next = line.charAt(dir < 0 ? pos - 1 : pos);
	      var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
	      if (cat == "w" && next.toUpperCase() == next) cat = "W";
	      if (state == "start") {
	        if (cat != "o") { state = "in"; type = cat; }
	      } else if (state == "in") {
	        if (type != cat) {
	          if (type == "w" && cat == "W" && dir < 0) pos--;
	          if (type == "W" && cat == "w" && dir > 0) { type = "w"; continue; }
	          break;
	        }
	      }
	    }
	    return Pos(start.line, pos);
	  }
	
	  function moveSubword(cm, dir) {
	    cm.extendSelectionsBy(function(range) {
	      if (cm.display.shift || cm.doc.extend || range.empty())
	        return findPosSubword(cm.doc, range.head, dir);
	      else
	        return dir < 0 ? range.from() : range.to();
	    });
	  }
	
	  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };
	  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };
	
	  cmds.scrollLineUp = function(cm) {
	    var info = cm.getScrollInfo();
	    if (!cm.somethingSelected()) {
	      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
	      if (cm.getCursor().line >= visibleBottomLine)
	        cm.execCommand("goLineUp");
	    }
	    cm.scrollTo(null, info.top - cm.defaultTextHeight());
	  };
	  cmds.scrollLineDown = function(cm) {
	    var info = cm.getScrollInfo();
	    if (!cm.somethingSelected()) {
	      var visibleTopLine = cm.lineAtHeight(info.top, "local")+1;
	      if (cm.getCursor().line <= visibleTopLine)
	        cm.execCommand("goLineDown");
	    }
	    cm.scrollTo(null, info.top + cm.defaultTextHeight());
	  };
	
	  cmds.splitSelectionByLine = function(cm) {
	    var ranges = cm.listSelections(), lineRanges = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var from = ranges[i].from(), to = ranges[i].to();
	      for (var line = from.line; line <= to.line; ++line)
	        if (!(to.line > from.line && line == to.line && to.ch == 0))
	          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),
	                           head: line == to.line ? to : Pos(line)});
	    }
	    cm.setSelections(lineRanges, 0);
	  };
	
	  cmds.singleSelectionTop = function(cm) {
	    var range = cm.listSelections()[0];
	    cm.setSelection(range.anchor, range.head, {scroll: false});
	  };
	
	  cmds.selectLine = function(cm) {
	    var ranges = cm.listSelections(), extended = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i];
	      extended.push({anchor: Pos(range.from().line, 0),
	                     head: Pos(range.to().line + 1, 0)});
	    }
	    cm.setSelections(extended);
	  };
	
	  function insertLine(cm, above) {
	    if (cm.isReadOnly()) return CodeMirror.Pass
	    cm.operation(function() {
	      var len = cm.listSelections().length, newSelection = [], last = -1;
	      for (var i = 0; i < len; i++) {
	        var head = cm.listSelections()[i].head;
	        if (head.line <= last) continue;
	        var at = Pos(head.line + (above ? 0 : 1), 0);
	        cm.replaceRange("\n", at, null, "+insertLine");
	        cm.indentLine(at.line, null, true);
	        newSelection.push({head: at, anchor: at});
	        last = head.line + 1;
	      }
	      cm.setSelections(newSelection);
	    });
	    cm.execCommand("indentAuto");
	  }
	
	  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };
	
	  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };
	
	  function wordAt(cm, pos) {
	    var start = pos.ch, end = start, line = cm.getLine(pos.line);
	    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;
	    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;
	    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};
	  }
	
	  cmds.selectNextOccurrence = function(cm) {
	    var from = cm.getCursor("from"), to = cm.getCursor("to");
	    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
	    if (CodeMirror.cmpPos(from, to) == 0) {
	      var word = wordAt(cm, from);
	      if (!word.word) return;
	      cm.setSelection(word.from, word.to);
	      fullWord = true;
	    } else {
	      var text = cm.getRange(from, to);
	      var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
	      var cur = cm.getSearchCursor(query, to);
	      var found = cur.findNext();
	      if (!found) {
	        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
	        found = cur.findNext();
	      }
	      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))
	        return CodeMirror.Pass
	      cm.addSelection(cur.from(), cur.to());
	    }
	    if (fullWord)
	      cm.state.sublimeFindFullWord = cm.doc.sel;
	  };
	
	  function addCursorToSelection(cm, dir) {
	    var ranges = cm.listSelections(), newRanges = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i];
	      var newAnchor = cm.findPosV(range.anchor, dir, "line");
	      var newHead = cm.findPosV(range.head, dir, "line");
	      var newRange = {anchor: newAnchor, head: newHead};
	      newRanges.push(range);
	      newRanges.push(newRange);
	    }
	    cm.setSelections(newRanges);
	  }
	  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };
	  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };
	
	  function isSelectedRange(ranges, from, to) {
	    for (var i = 0; i < ranges.length; i++)
	      if (ranges[i].from() == from && ranges[i].to() == to) return true
	    return false
	  }
	
	  var mirror = "(){}[]";
	  function selectBetweenBrackets(cm) {
	    var ranges = cm.listSelections(), newRanges = []
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);
	      if (!opening) return false;
	      for (;;) {
	        var closing = cm.scanForBracket(pos, 1);
	        if (!closing) return false;
	        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
	          newRanges.push({anchor: Pos(opening.pos.line, opening.pos.ch + 1),
	                          head: closing.pos});
	          break;
	        }
	        pos = Pos(closing.pos.line, closing.pos.ch + 1);
	      }
	    }
	    cm.setSelections(newRanges);
	    return true;
	  }
	
	  cmds.selectScope = function(cm) {
	    selectBetweenBrackets(cm) || cm.execCommand("selectAll");
	  };
	  cmds.selectBetweenBrackets = function(cm) {
	    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
	  };
	
	  cmds.goToBracket = function(cm) {
	    cm.extendSelectionsBy(function(range) {
	      var next = cm.scanForBracket(range.head, 1);
	      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
	      var prev = cm.scanForBracket(range.head, -1);
	      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
	    });
	  };
	
	  cmds.swapLineUp = function(cm) {
	    if (cm.isReadOnly()) return CodeMirror.Pass
	    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i], from = range.from().line - 1, to = range.to().line;
	      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),
	                    head: Pos(range.head.line - 1, range.head.ch)});
	      if (range.to().ch == 0 && !range.empty()) --to;
	      if (from > at) linesToMove.push(from, to);
	      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
	      at = to;
	    }
	    cm.operation(function() {
	      for (var i = 0; i < linesToMove.length; i += 2) {
	        var from = linesToMove[i], to = linesToMove[i + 1];
	        var line = cm.getLine(from);
	        cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
	        if (to > cm.lastLine())
	          cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");
	        else
	          cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
	      }
	      cm.setSelections(newSels);
	      cm.scrollIntoView();
	    });
	  };
	
	  cmds.swapLineDown = function(cm) {
	    if (cm.isReadOnly()) return CodeMirror.Pass
	    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
	    for (var i = ranges.length - 1; i >= 0; i--) {
	      var range = ranges[i], from = range.to().line + 1, to = range.from().line;
	      if (range.to().ch == 0 && !range.empty()) from--;
	      if (from < at) linesToMove.push(from, to);
	      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
	      at = to;
	    }
	    cm.operation(function() {
	      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
	        var from = linesToMove[i], to = linesToMove[i + 1];
	        var line = cm.getLine(from);
	        if (from == cm.lastLine())
	          cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");
	        else
	          cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
	        cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
	      }
	      cm.scrollIntoView();
	    });
	  };
	
	  cmds.toggleCommentIndented = function(cm) {
	    cm.toggleComment({ indent: true });
	  }
	
	  cmds.joinLines = function(cm) {
	    var ranges = cm.listSelections(), joined = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i], from = range.from();
	      var start = from.line, end = range.to().line;
	      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)
	        end = ranges[++i].to().line;
	      joined.push({start: start, end: end, anchor: !range.empty() && from});
	    }
	    cm.operation(function() {
	      var offset = 0, ranges = [];
	      for (var i = 0; i < joined.length; i++) {
	        var obj = joined[i];
	        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;
	        for (var line = obj.start; line <= obj.end; line++) {
	          var actual = line - offset;
	          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
	          if (actual < cm.lastLine()) {
	            cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
	            ++offset;
	          }
	        }
	        ranges.push({anchor: anchor || head, head: head});
	      }
	      cm.setSelections(ranges, 0);
	    });
	  };
	
	  cmds.duplicateLine = function(cm) {
	    cm.operation(function() {
	      var rangeCount = cm.listSelections().length;
	      for (var i = 0; i < rangeCount; i++) {
	        var range = cm.listSelections()[i];
	        if (range.empty())
	          cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));
	        else
	          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
	      }
	      cm.scrollIntoView();
	    });
	  };
	
	
	  function sortLines(cm, caseSensitive) {
	    if (cm.isReadOnly()) return CodeMirror.Pass
	    var ranges = cm.listSelections(), toSort = [], selected;
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i];
	      if (range.empty()) continue;
	      var from = range.from().line, to = range.to().line;
	      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)
	        to = ranges[++i].to().line;
	      if (!ranges[i].to().ch) to--;
	      toSort.push(from, to);
	    }
	    if (toSort.length) selected = true;
	    else toSort.push(cm.firstLine(), cm.lastLine());
	
	    cm.operation(function() {
	      var ranges = [];
	      for (var i = 0; i < toSort.length; i += 2) {
	        var from = toSort[i], to = toSort[i + 1];
	        var start = Pos(from, 0), end = Pos(to);
	        var lines = cm.getRange(start, end, false);
	        if (caseSensitive)
	          lines.sort();
	        else
	          lines.sort(function(a, b) {
	            var au = a.toUpperCase(), bu = b.toUpperCase();
	            if (au != bu) { a = au; b = bu; }
	            return a < b ? -1 : a == b ? 0 : 1;
	          });
	        cm.replaceRange(lines, start, end);
	        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});
	      }
	      if (selected) cm.setSelections(ranges, 0);
	    });
	  }
	
	  cmds.sortLines = function(cm) { sortLines(cm, true); };
	  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false); };
	
	  cmds.nextBookmark = function(cm) {
	    var marks = cm.state.sublimeBookmarks;
	    if (marks) while (marks.length) {
	      var current = marks.shift();
	      var found = current.find();
	      if (found) {
	        marks.push(current);
	        return cm.setSelection(found.from, found.to);
	      }
	    }
	  };
	
	  cmds.prevBookmark = function(cm) {
	    var marks = cm.state.sublimeBookmarks;
	    if (marks) while (marks.length) {
	      marks.unshift(marks.pop());
	      var found = marks[marks.length - 1].find();
	      if (!found)
	        marks.pop();
	      else
	        return cm.setSelection(found.from, found.to);
	    }
	  };
	
	  cmds.toggleBookmark = function(cm) {
	    var ranges = cm.listSelections();
	    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
	    for (var i = 0; i < ranges.length; i++) {
	      var from = ranges[i].from(), to = ranges[i].to();
	      var found = cm.findMarks(from, to);
	      for (var j = 0; j < found.length; j++) {
	        if (found[j].sublimeBookmark) {
	          found[j].clear();
	          for (var k = 0; k < marks.length; k++)
	            if (marks[k] == found[j])
	              marks.splice(k--, 1);
	          break;
	        }
	      }
	      if (j == found.length)
	        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));
	    }
	  };
	
	  cmds.clearBookmarks = function(cm) {
	    var marks = cm.state.sublimeBookmarks;
	    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
	    marks.length = 0;
	  };
	
	  cmds.selectBookmarks = function(cm) {
	    var marks = cm.state.sublimeBookmarks, ranges = [];
	    if (marks) for (var i = 0; i < marks.length; i++) {
	      var found = marks[i].find();
	      if (!found)
	        marks.splice(i--, 0);
	      else
	        ranges.push({anchor: found.from, head: found.to});
	    }
	    if (ranges.length)
	      cm.setSelections(ranges, 0);
	  };
	
	  function modifyWordOrSelection(cm, mod) {
	    cm.operation(function() {
	      var ranges = cm.listSelections(), indices = [], replacements = [];
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (range.empty()) { indices.push(i); replacements.push(""); }
	        else replacements.push(mod(cm.getRange(range.from(), range.to())));
	      }
	      cm.replaceSelections(replacements, "around", "case");
	      for (var i = indices.length - 1, at; i >= 0; i--) {
	        var range = ranges[indices[i]];
	        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
	        var word = wordAt(cm, range.head);
	        at = word.from;
	        cm.replaceRange(mod(word.word), word.from, word.to);
	      }
	    });
	  }
	
	  cmds.smartBackspace = function(cm) {
	    if (cm.somethingSelected()) return CodeMirror.Pass;
	
	    cm.operation(function() {
	      var cursors = cm.listSelections();
	      var indentUnit = cm.getOption("indentUnit");
	
	      for (var i = cursors.length - 1; i >= 0; i--) {
	        var cursor = cursors[i].head;
	        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);
	        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize"));
	
	        // Delete by one character by default
	        var deletePos = cm.findPosH(cursor, -1, "char", false);
	
	        if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
	          var prevIndent = new Pos(cursor.line,
	            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));
	
	          // Smart delete only if we found a valid prevIndent location
	          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;
	        }
	
	        cm.replaceRange("", deletePos, cursor, "+delete");
	      }
	    });
	  };
	
	  cmds.delLineRight = function(cm) {
	    cm.operation(function() {
	      var ranges = cm.listSelections();
	      for (var i = ranges.length - 1; i >= 0; i--)
	        cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
	      cm.scrollIntoView();
	    });
	  };
	
	  cmds.upcaseAtCursor = function(cm) {
	    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });
	  };
	  cmds.downcaseAtCursor = function(cm) {
	    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });
	  };
	
	  cmds.setSublimeMark = function(cm) {
	    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
	    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
	  };
	  cmds.selectToSublimeMark = function(cm) {
	    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
	    if (found) cm.setSelection(cm.getCursor(), found);
	  };
	  cmds.deleteToSublimeMark = function(cm) {
	    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
	    if (found) {
	      var from = cm.getCursor(), to = found;
	      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }
	      cm.state.sublimeKilled = cm.getRange(from, to);
	      cm.replaceRange("", from, to);
	    }
	  };
	  cmds.swapWithSublimeMark = function(cm) {
	    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
	    if (found) {
	      cm.state.sublimeMark.clear();
	      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
	      cm.setCursor(found);
	    }
	  };
	  cmds.sublimeYank = function(cm) {
	    if (cm.state.sublimeKilled != null)
	      cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
	  };
	
	  cmds.showInCenter = function(cm) {
	    var pos = cm.cursorCoords(null, "local");
	    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
	  };
	
	  cmds.selectLinesUpward = function(cm) {
	    cm.operation(function() {
	      var ranges = cm.listSelections();
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (range.head.line > cm.firstLine())
	          cm.addSelection(Pos(range.head.line - 1, range.head.ch));
	      }
	    });
	  };
	  cmds.selectLinesDownward = function(cm) {
	    cm.operation(function() {
	      var ranges = cm.listSelections();
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (range.head.line < cm.lastLine())
	          cm.addSelection(Pos(range.head.line + 1, range.head.ch));
	      }
	    });
	  };
	
	  function getTarget(cm) {
	    var from = cm.getCursor("from"), to = cm.getCursor("to");
	    if (CodeMirror.cmpPos(from, to) == 0) {
	      var word = wordAt(cm, from);
	      if (!word.word) return;
	      from = word.from;
	      to = word.to;
	    }
	    return {from: from, to: to, query: cm.getRange(from, to), word: word};
	  }
	
	  function findAndGoTo(cm, forward) {
	    var target = getTarget(cm);
	    if (!target) return;
	    var query = target.query;
	    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);
	
	    if (forward ? cur.findNext() : cur.findPrevious()) {
	      cm.setSelection(cur.from(), cur.to());
	    } else {
	      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)
	                                              : cm.clipPos(Pos(cm.lastLine())));
	      if (forward ? cur.findNext() : cur.findPrevious())
	        cm.setSelection(cur.from(), cur.to());
	      else if (target.word)
	        cm.setSelection(target.from, target.to);
	    }
	  };
	  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };
	  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };
	  cmds.findAllUnder = function(cm) {
	    var target = getTarget(cm);
	    if (!target) return;
	    var cur = cm.getSearchCursor(target.query);
	    var matches = [];
	    var primaryIndex = -1;
	    while (cur.findNext()) {
	      matches.push({anchor: cur.from(), head: cur.to()});
	      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)
	        primaryIndex++;
	    }
	    cm.setSelections(matches, primaryIndex);
	  };
	
	
	  var keyMap = CodeMirror.keyMap;
	  keyMap.macSublime = {
	    "Cmd-Left": "goLineStartSmart",
	    "Shift-Tab": "indentLess",
	    "Shift-Ctrl-K": "deleteLine",
	    "Alt-Q": "wrapLines",
	    "Ctrl-Left": "goSubwordLeft",
	    "Ctrl-Right": "goSubwordRight",
	    "Ctrl-Alt-Up": "scrollLineUp",
	    "Ctrl-Alt-Down": "scrollLineDown",
	    "Cmd-L": "selectLine",
	    "Shift-Cmd-L": "splitSelectionByLine",
	    "Esc": "singleSelectionTop",
	    "Cmd-Enter": "insertLineAfter",
	    "Shift-Cmd-Enter": "insertLineBefore",
	    "Cmd-D": "selectNextOccurrence",
	    "Shift-Cmd-Up": "addCursorToPrevLine",
	    "Shift-Cmd-Down": "addCursorToNextLine",
	    "Shift-Cmd-Space": "selectScope",
	    "Shift-Cmd-M": "selectBetweenBrackets",
	    "Cmd-M": "goToBracket",
	    "Cmd-Ctrl-Up": "swapLineUp",
	    "Cmd-Ctrl-Down": "swapLineDown",
	    "Cmd-/": "toggleCommentIndented",
	    "Cmd-J": "joinLines",
	    "Shift-Cmd-D": "duplicateLine",
	    "F9": "sortLines",
	    "Cmd-F9": "sortLinesInsensitive",
	    "F2": "nextBookmark",
	    "Shift-F2": "prevBookmark",
	    "Cmd-F2": "toggleBookmark",
	    "Shift-Cmd-F2": "clearBookmarks",
	    "Alt-F2": "selectBookmarks",
	    "Backspace": "smartBackspace",
	    "Cmd-K Cmd-K": "delLineRight",
	    "Cmd-K Cmd-U": "upcaseAtCursor",
	    "Cmd-K Cmd-L": "downcaseAtCursor",
	    "Cmd-K Cmd-Space": "setSublimeMark",
	    "Cmd-K Cmd-A": "selectToSublimeMark",
	    "Cmd-K Cmd-W": "deleteToSublimeMark",
	    "Cmd-K Cmd-X": "swapWithSublimeMark",
	    "Cmd-K Cmd-Y": "sublimeYank",
	    "Cmd-K Cmd-C": "showInCenter",
	    "Cmd-K Cmd-G": "clearBookmarks",
	    "Cmd-K Cmd-Backspace": "delLineLeft",
	    "Cmd-K Cmd-0": "unfoldAll",
	    "Cmd-K Cmd-J": "unfoldAll",
	    "Ctrl-Shift-Up": "selectLinesUpward",
	    "Ctrl-Shift-Down": "selectLinesDownward",
	    "Cmd-F3": "findUnder",
	    "Shift-Cmd-F3": "findUnderPrevious",
	    "Alt-F3": "findAllUnder",
	    "Shift-Cmd-[": "fold",
	    "Shift-Cmd-]": "unfold",
	    "Cmd-I": "findIncremental",
	    "Shift-Cmd-I": "findIncrementalReverse",
	    "Cmd-H": "replace",
	    "F3": "findNext",
	    "Shift-F3": "findPrev",
	    "fallthrough": "macDefault"
	  };
	  CodeMirror.normalizeKeyMap(keyMap.macSublime);
	
	  keyMap.pcSublime = {
	    "Shift-Tab": "indentLess",
	    "Shift-Ctrl-K": "deleteLine",
	    "Alt-Q": "wrapLines",
	    "Ctrl-T": "transposeChars",
	    "Alt-Left": "goSubwordLeft",
	    "Alt-Right": "goSubwordRight",
	    "Ctrl-Up": "scrollLineUp",
	    "Ctrl-Down": "scrollLineDown",
	    "Ctrl-L": "selectLine",
	    "Shift-Ctrl-L": "splitSelectionByLine",
	    "Esc": "singleSelectionTop",
	    "Ctrl-Enter": "insertLineAfter",
	    "Shift-Ctrl-Enter": "insertLineBefore",
	    "Ctrl-D": "selectNextOccurrence",
	    "Alt-CtrlUp": "addCursorToPrevLine",
	    "Alt-CtrlDown": "addCursorToNextLine",
	    "Shift-Ctrl-Space": "selectScope",
	    "Shift-Ctrl-M": "selectBetweenBrackets",
	    "Ctrl-M": "goToBracket",
	    "Shift-Ctrl-Up": "swapLineUp",
	    "Shift-Ctrl-Down": "swapLineDown",
	    "Ctrl-/": "toggleCommentIndented",
	    "Ctrl-J": "joinLines",
	    "Shift-Ctrl-D": "duplicateLine",
	    "F9": "sortLines",
	    "Ctrl-F9": "sortLinesInsensitive",
	    "F2": "nextBookmark",
	    "Shift-F2": "prevBookmark",
	    "Ctrl-F2": "toggleBookmark",
	    "Shift-Ctrl-F2": "clearBookmarks",
	    "Alt-F2": "selectBookmarks",
	    "Backspace": "smartBackspace",
	    "Ctrl-K Ctrl-K": "delLineRight",
	    "Ctrl-K Ctrl-U": "upcaseAtCursor",
	    "Ctrl-K Ctrl-L": "downcaseAtCursor",
	    "Ctrl-K Ctrl-Space": "setSublimeMark",
	    "Ctrl-K Ctrl-A": "selectToSublimeMark",
	    "Ctrl-K Ctrl-W": "deleteToSublimeMark",
	    "Ctrl-K Ctrl-X": "swapWithSublimeMark",
	    "Ctrl-K Ctrl-Y": "sublimeYank",
	    "Ctrl-K Ctrl-C": "showInCenter",
	    "Ctrl-K Ctrl-G": "clearBookmarks",
	    "Ctrl-K Ctrl-Backspace": "delLineLeft",
	    "Ctrl-K Ctrl-0": "unfoldAll",
	    "Ctrl-K Ctrl-J": "unfoldAll",
	    "Ctrl-Alt-Up": "selectLinesUpward",
	    "Ctrl-Alt-Down": "selectLinesDownward",
	    "Ctrl-F3": "findUnder",
	    "Shift-Ctrl-F3": "findUnderPrevious",
	    "Alt-F3": "findAllUnder",
	    "Shift-Ctrl-[": "fold",
	    "Shift-Ctrl-]": "unfold",
	    "Ctrl-I": "findIncremental",
	    "Shift-Ctrl-I": "findIncrementalReverse",
	    "Ctrl-H": "replace",
	    "F3": "findNext",
	    "Shift-F3": "findPrev",
	    "fallthrough": "pcDefault"
	  };
	  CodeMirror.normalizeKeyMap(keyMap.pcSublime);
	
	  var mac = keyMap.default == keyMap.macDefault;
	  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
	});


/***/ }),
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2015 Jed Watson.
	  Based on code that is Copyright 2013-2015, Facebook, Inc.
	  All rights reserved.
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var canUseDOM = !!(
			typeof window !== 'undefined' &&
			window.document &&
			window.document.createElement
		);
	
		var ExecutionEnvironment = {
	
			canUseDOM: canUseDOM,
	
			canUseWorkers: typeof Worker !== 'undefined',
	
			canUseEventListeners:
				canUseDOM && !!(window.addEventListener || window.attachEvent),
	
			canUseViewport: canUseDOM && !!window.screen
	
		};
	
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return ExecutionEnvironment;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && module.exports) {
			module.exports = ExecutionEnvironment;
		} else {
			window.ExecutionEnvironment = ExecutionEnvironment;
		}
	
	}());


/***/ }),
/* 149 */,
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	// Standard YAML's Failsafe schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2802346
	
	
	'use strict';
	
	
	var Schema = __webpack_require__(56);
	
	
	module.exports = new Schema({
	  explicit: [
	    __webpack_require__(535),
	    __webpack_require__(533),
	    __webpack_require__(528)
	  ]
	});


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var implementation = __webpack_require__(537);
	
	module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 152 */,
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var debounce_1 = __webpack_require__(156);
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	var SearchBox = function (_super) {
	    __extends(SearchBox, _super);
	    function SearchBox(props) {
	        var _this = _super.call(this, props) || this;
	        _this.handleChange = function (event) {
	            _this.setState({ value: event.target.value });
	            _this._debouncedOnSearch();
	        };
	        _this.state = { value: '' };
	        _this._debouncedOnSearch = debounce_1.default(200, function () {
	            _this.props.onSearch(_this.state.value);
	        });
	        return _this;
	    }
	    SearchBox.prototype.shouldComponentUpdate = function (nextProps, nextState) {
	        return nextProps.isShown !== this.props.isShown || nextState.value !== this.state.value;
	    };
	    SearchBox.prototype.render = function () {
	        return React.createElement(
	            "div",
	            { className: cx(!this.props.clean && 'root'), "data-jsx": 1554949702
	            },
	            React.createElement(_style2.default, {
	                styleId: 1554949702,
	                css: ".label[data-jsx=\"1554949702\"] {padding: 12px 14px 13px 15px;box-shadow: 0 1px 3px rgba(0, 0, 0, .1);}.pa25,\n.root[data-jsx=\"1554949702\"] {padding: 25px;}.bgBlack02,\n.root[data-jsx=\"1554949702\"] {background-color: rgba(0,0,0,.02);}.bgWhite,\n.label[data-jsx=\"1554949702\"] {background-color: #fff;}.bbox,\n.label[data-jsx=\"1554949702\"] {box-sizing: border-box;}.w100,\n.label[data-jsx=\"1554949702\"] {width: 100%;}.flex,\n.label[data-jsx=\"1554949702\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.label[data-jsx=\"1554949702\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.bgWhite,\n.label[data-jsx=\"1554949702\"] {background-color: #fff;}.f16,\n.input[data-jsx=\"1554949702\"] {font-size: 16px;}.ml10,\n.input[data-jsx=\"1554949702\"] {margin-left: 10px;}"
	            }),
	            this.props.isShown && React.createElement(
	                "label",
	                { className: "label", "data-jsx": 1554949702
	                },
	                React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(1061), stroke: true, strokeWidth: 3 }),
	                React.createElement("input", { className: "input", onChange: this.handleChange, type: "text", value: this.state.value, placeholder: this.props.placeholder || 'Search the schema ...', "data-jsx": 1554949702
	                })
	            )
	        );
	    };
	    return SearchBox;
	}(React.Component);
	exports.default = SearchBox;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Argument;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _TypeLink = __webpack_require__(77);
	
	var _TypeLink2 = _interopRequireDefault(_TypeLink);
	
	var _DefaultValue = __webpack_require__(253);
	
	var _DefaultValue2 = _interopRequireDefault(_DefaultValue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	function Argument(_ref) {
	  var arg = _ref.arg,
	      onClickType = _ref.onClickType,
	      showDefaultValue = _ref.showDefaultValue;
	
	  return _react2.default.createElement(
	    'span',
	    { className: 'arg' },
	    _react2.default.createElement(
	      'span',
	      { className: 'arg-name' },
	      arg.name
	    ),
	    ': ',
	    _react2.default.createElement(_TypeLink2.default, { type: arg.type, onClick: onClickType }),
	    showDefaultValue !== false && _react2.default.createElement(_DefaultValue2.default, { field: arg })
	  );
	}
	
	Argument.propTypes = {
	  arg: _propTypes2.default.object.isRequired,
	  onClickType: _propTypes2.default.func.isRequired,
	  showDefaultValue: _propTypes2.default.bool
	};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _marked = __webpack_require__(297);
	
	var _marked2 = _interopRequireDefault(_marked);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var MarkdownContent = function (_React$Component) {
	  _inherits(MarkdownContent, _React$Component);
	
	  function MarkdownContent() {
	    _classCallCheck(this, MarkdownContent);
	
	    return _possibleConstructorReturn(this, (MarkdownContent.__proto__ || Object.getPrototypeOf(MarkdownContent)).apply(this, arguments));
	  }
	
	  _createClass(MarkdownContent, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps) {
	      return this.props.markdown !== nextProps.markdown;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var markdown = this.props.markdown;
	      if (!markdown) {
	        return _react2.default.createElement('div', null);
	      }
	
	      var html = (0, _marked2.default)(markdown, { sanitize: true });
	      return _react2.default.createElement('div', {
	        className: this.props.className,
	        dangerouslySetInnerHTML: { __html: html }
	      });
	    }
	  }]);
	
	  return MarkdownContent;
	}(_react2.default.Component);
	
	MarkdownContent.propTypes = {
	  markdown: _propTypes2.default.string,
	  className: _propTypes2.default.string
	};
	exports.default = MarkdownContent;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = debounce;
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	/**
	 * Provided a duration and a function, returns a new function which is called
	 * `duration` milliseconds after the last call.
	 */
	function debounce(duration, fn) {
	  var timeout = void 0;
	  return function () {
	    var _this = this,
	        _arguments = arguments;
	
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      timeout = null;
	      fn.apply(_this, _arguments);
	    }, duration);
	  };
	}

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GraphQLLanguageService = undefined;
	
	var _kinds = __webpack_require__(14);
	
	var _graphql = __webpack_require__(12);
	
	var _getAutocompleteSuggestions2 = __webpack_require__(103);
	
	var _getDiagnostics = __webpack_require__(105);
	
	var _getDefinition = __webpack_require__(104);
	
	var _graphqlLanguageServiceUtils = __webpack_require__(107);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           *  Copyright (c) Facebook, Inc.
	                                                                                                                                                           *  All rights reserved.
	                                                                                                                                                           *
	                                                                                                                                                           *  This source code is licensed under the license found in the
	                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           *  
	                                                                                                                                                           */
	
	var GraphQLLanguageService = exports.GraphQLLanguageService = function () {
	  function GraphQLLanguageService(cache) {
	    _classCallCheck(this, GraphQLLanguageService);
	
	    this._graphQLCache = cache;
	    this._graphQLConfig = cache.getGraphQLConfig();
	  }
	
	  GraphQLLanguageService.prototype.getDiagnostics = function getDiagnostics(query, uri) {
	    var source, appName, schema, customRules, fragmentDefinitions, fragmentDependencies, dependenciesSource, customRulesModulePath, rulesPath;
	    return regeneratorRuntime.async(function getDiagnostics$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            source = query;
	            appName = this._graphQLConfig.getAppConfigNameByFilePath(uri);
	            // If there's a matching config, proceed to prepare to run validation
	
	            schema = void 0;
	            customRules = void 0;
	
	            if (!this._graphQLConfig.getSchemaPath(appName)) {
	              _context.next = 18;
	              break;
	            }
	
	            _context.next = 7;
	            return regeneratorRuntime.awrap(this._graphQLCache.getSchema(this._graphQLConfig.getSchemaPath(appName)));
	
	          case 7:
	            schema = _context.sent;
	            _context.next = 10;
	            return regeneratorRuntime.awrap(this._graphQLCache.getFragmentDefinitions(this._graphQLConfig, appName));
	
	          case 10:
	            fragmentDefinitions = _context.sent;
	            _context.next = 13;
	            return regeneratorRuntime.awrap(this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions));
	
	          case 13:
	            fragmentDependencies = _context.sent;
	            dependenciesSource = fragmentDependencies.reduce(function (prev, cur) {
	              return prev + ' ' + (0, _graphql.print)(cur.definition);
	            }, '');
	
	
	            source = source + ' ' + dependenciesSource;
	
	            // Check if there are custom validation rules to be used
	            customRulesModulePath = this._graphQLConfig.getCustomValidationRulesModulePath(appName);
	
	            if (customRulesModulePath) {
	              /* eslint-disable no-implicit-coercion */
	              rulesPath = /*require.resolve*/(__webpack_require__(255).resolve("" + customRulesModulePath));
	
	              if (rulesPath) {
	                customRules = __webpack_require__(255)("" + rulesPath)(this._graphQLConfig);
	              }
	              /* eslint-enable no-implicit-coercion */
	            }
	
	          case 18:
	            return _context.abrupt('return', (0, _getDiagnostics.getDiagnostics)(source, schema, customRules));
	
	          case 19:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  };
	
	  GraphQLLanguageService.prototype.getAutocompleteSuggestions = function getAutocompleteSuggestions(query, position, filePath) {
	    var appName, schema;
	    return regeneratorRuntime.async(function getAutocompleteSuggestions$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            appName = this._graphQLConfig.getAppConfigNameByFilePath(filePath);
	            schema = void 0;
	
	            if (!this._graphQLConfig.getSchemaPath(appName)) {
	              _context2.next = 8;
	              break;
	            }
	
	            _context2.next = 5;
	            return regeneratorRuntime.awrap(this._graphQLCache.getSchema(this._graphQLConfig.getSchemaPath(appName)));
	
	          case 5:
	            schema = _context2.sent;
	
	            if (!schema) {
	              _context2.next = 8;
	              break;
	            }
	
	            return _context2.abrupt('return', (0, _getAutocompleteSuggestions2.getAutocompleteSuggestions)(schema, query, position));
	
	          case 8:
	            return _context2.abrupt('return', []);
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  };
	
	  GraphQLLanguageService.prototype.getDefinition = function getDefinition(query, position, filePath) {
	    var appName, ast, node;
	    return regeneratorRuntime.async(function getDefinition$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            appName = this._graphQLConfig.getAppConfigNameByFilePath(filePath);
	            ast = void 0;
	            _context3.prev = 2;
	
	            ast = (0, _graphql.parse)(query);
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.prev = 6;
	            _context3.t0 = _context3['catch'](2);
	            return _context3.abrupt('return', null);
	
	          case 9:
	            node = (0, _graphqlLanguageServiceUtils.getASTNodeAtPosition)(query, ast, position);
	
	            if (!node) {
	              _context3.next = 16;
	              break;
	            }
	
	            _context3.t1 = node.kind;
	            _context3.next = _context3.t1 === _kinds.FRAGMENT_SPREAD ? 14 : _context3.t1 === _kinds.FRAGMENT_DEFINITION ? 15 : _context3.t1 === _kinds.OPERATION_DEFINITION ? 15 : 16;
	            break;
	
	          case 14:
	            return _context3.abrupt('return', this._getDefinitionForFragmentSpread(query, ast, node, filePath, this._graphQLConfig, appName));
	
	          case 15:
	            return _context3.abrupt('return', (0, _getDefinition.getDefinitionQueryResultForDefinitionNode)(filePath, query, node));
	
	          case 16:
	            return _context3.abrupt('return', null);
	
	          case 17:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, null, this, [[2, 6]]);
	  };
	
	  GraphQLLanguageService.prototype._getDefinitionForFragmentSpread = function _getDefinitionForFragmentSpread(query, ast, node, filePath, graphQLConfig, appName) {
	    var fragmentDefinitions, dependencies, localFragDefinitions, typeCastedDefs, localFragInfos, result;
	    return regeneratorRuntime.async(function _getDefinitionForFragmentSpread$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return regeneratorRuntime.awrap(this._graphQLCache.getFragmentDefinitions(graphQLConfig, appName));
	
	          case 2:
	            fragmentDefinitions = _context4.sent;
	            _context4.next = 5;
	            return regeneratorRuntime.awrap(this._graphQLCache.getFragmentDependenciesForAST(ast, fragmentDefinitions));
	
	          case 5:
	            dependencies = _context4.sent;
	            localFragDefinitions = ast.definitions.filter(function (definition) {
	              return definition.kind === _kinds.FRAGMENT_DEFINITION;
	            });
	            typeCastedDefs = localFragDefinitions;
	            localFragInfos = typeCastedDefs.map(function (definition) {
	              return {
	                filePath: filePath,
	                content: query,
	                definition: definition
	              };
	            });
	            _context4.next = 11;
	            return regeneratorRuntime.awrap((0, _getDefinition.getDefinitionQueryResultForFragmentSpread)(query, node, dependencies.concat(localFragInfos)));
	
	          case 11:
	            result = _context4.sent;
	            return _context4.abrupt('return', result);
	
	          case 13:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, null, this);
	  };
	
	  return GraphQLLanguageService;
	}();

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
	                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                   *  All rights reserved.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  
	                                                                                                                                                                                                                                                                   */
	
	exports.getOutline = getOutline;
	
	var _graphql = __webpack_require__(12);
	
	var _kinds = __webpack_require__(14);
	
	var _graphqlLanguageServiceUtils = __webpack_require__(107);
	
	var OUTLINEABLE_KINDS = {
	  Field: true,
	  OperationDefinition: true,
	  Document: true,
	  SelectionSet: true,
	  Name: true,
	  FragmentDefinition: true,
	  FragmentSpread: true,
	  InlineFragment: true
	};
	
	function getOutline(queryText) {
	  var ast = void 0;
	  try {
	    ast = (0, _graphql.parse)(queryText);
	  } catch (error) {
	    return null;
	  }
	
	  var visitorFns = outlineTreeConverter(queryText);
	  var outlineTrees = (0, _graphql.visit)(ast, {
	    leave: function leave(node) {
	      if (OUTLINEABLE_KINDS[node.kind] && visitorFns[node.kind]) {
	        return visitorFns[node.kind](node);
	      }
	      return null;
	    }
	  });
	  return { outlineTrees: outlineTrees };
	}
	
	function outlineTreeConverter(docText) {
	  var meta = function meta(node) {
	    return {
	      representativeName: node.name,
	      startPosition: (0, _graphqlLanguageServiceUtils.offsetToPosition)(docText, node.loc.start),
	      endPosition: (0, _graphqlLanguageServiceUtils.offsetToPosition)(docText, node.loc.end),
	      children: node.selectionSet || []
	    };
	  };
	  return {
	    Field: function Field(node) {
	      var tokenizedText = node.alias ? [buildToken('plain', node.alias), buildToken('plain', ': ')] : [];
	      tokenizedText.push(buildToken('plain', node.name));
	      return _extends({ tokenizedText: tokenizedText }, meta(node));
	    },
	    OperationDefinition: function OperationDefinition(node) {
	      return _extends({
	        tokenizedText: [buildToken('keyword', node.operation), buildToken('whitespace', ' '), buildToken('class-name', node.name)]
	      }, meta(node));
	    },
	    Document: function Document(node) {
	      return node.definitions;
	    },
	    SelectionSet: function SelectionSet(node) {
	      return concatMap(node.selections, function (child) {
	        return child.kind === _kinds.INLINE_FRAGMENT ? child.selectionSet : child;
	      });
	    },
	    Name: function Name(node) {
	      return node.value;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      return _extends({
	        tokenizedText: [buildToken('keyword', 'fragment'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]
	      }, meta(node));
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      return _extends({
	        tokenizedText: [buildToken('plain', '...'), buildToken('class-name', node.name)]
	      }, meta(node));
	    },
	    InlineFragment: function InlineFragment(node) {
	      return node.selectionSet;
	    }
	  };
	}
	
	function buildToken(kind, value) {
	  return { kind: kind, value: value };
	}
	
	function concatMap(arr, fn) {
	  var res = [];
	  for (var i = 0; i < arr.length; i++) {
	    var x = fn(arr[i], i);
	    if (Array.isArray(x)) {
	      res.push.apply(res, x);
	    } else {
	      res.push(x);
	    }
	  }
	  return res;
	}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defaultFieldResolver = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * 
	                                                                                                                                                                                                                                                                               */
	
	exports.execute = execute;
	exports.responsePathAsArray = responsePathAsArray;
	exports.addPath = addPath;
	exports.assertValidExecutionArguments = assertValidExecutionArguments;
	exports.buildExecutionContext = buildExecutionContext;
	exports.getOperationRootType = getOperationRootType;
	exports.collectFields = collectFields;
	exports.buildResolveInfo = buildResolveInfo;
	exports.resolveFieldValueOrError = resolveFieldValueOrError;
	exports.getFieldDef = getFieldDef;
	
	var _iterall = __webpack_require__(61);
	
	var _error = __webpack_require__(4);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _typeFromAST = __webpack_require__(35);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _values = __webpack_require__(160);
	
	var _definition = __webpack_require__(7);
	
	var _schema = __webpack_require__(34);
	
	var _introspection = __webpack_require__(41);
	
	var _directives = __webpack_require__(33);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Terminology
	 *
	 * "Definitions" are the generic name for top-level statements in the document.
	 * Examples of this include:
	 * 1) Operations (such as a query)
	 * 2) Fragments
	 *
	 * "Operations" are a generic name for requests in the document.
	 * Examples of this include:
	 * 1) query,
	 * 2) mutation
	 *
	 * "Selections" are the definitions that can appear legally and at
	 * single level of the query. These include:
	 * 1) field references e.g "a"
	 * 2) fragment "spreads" e.g. "...c"
	 * 3) inline fragment "spreads" e.g. "...on Type { a }"
	 */
	
	/**
	 * Data that must be available at all points during query execution.
	 *
	 * Namely, schema of the type system that is currently executing,
	 * and the fragments defined in the query document
	 */
	
	
	/**
	 * The result of GraphQL execution.
	 *
	 *   - `errors` is included when any errors occurred as a non-empty array.
	 *   - `data` is the result of a successful execution of the query.
	 */
	
	
	/**
	 * Implements the "Evaluating requests" section of the GraphQL specification.
	 *
	 * Returns a Promise that will eventually be resolved and never rejected.
	 *
	 * If the arguments to this function do not result in a legal execution context,
	 * a GraphQLError will be thrown immediately explaining the invalid input.
	 *
	 * Accepts either an object with named arguments, or individual arguments.
	 */
	
	/* eslint-disable no-redeclare */
	function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
	  // Extract arguments from object args if provided.
	  return arguments.length === 1 ? executeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : executeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
	}
	
	function executeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
	  // If arguments are missing or incorrect, throw an error.
	  assertValidExecutionArguments(schema, document, variableValues);
	
	  // If a valid context cannot be created due to incorrect arguments,
	  // a "Response" with only errors is returned.
	  var context = void 0;
	  try {
	    context = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
	  } catch (error) {
	    return Promise.resolve({ errors: [error] });
	  }
	
	  // Return a Promise that will eventually resolve to the data described by
	  // The "Response" section of the GraphQL specification.
	  //
	  // If errors are encountered while executing a GraphQL field, only that
	  // field and its descendants will be omitted, and sibling fields will still
	  // be executed. An execution which encounters errors will still result in a
	  // resolved Promise.
	  return Promise.resolve(executeOperation(context, context.operation, rootValue)).then(function (data) {
	    return context.errors.length === 0 ? { data: data } : { errors: context.errors, data: data };
	  });
	}
	
	/**
	 * Given a ResponsePath (found in the `path` entry in the information provided
	 * as the last argument to a field resolver), return an Array of the path keys.
	 */
	function responsePathAsArray(path) {
	  var flattened = [];
	  var curr = path;
	  while (curr) {
	    flattened.push(curr.key);
	    curr = curr.prev;
	  }
	  return flattened.reverse();
	}
	
	/**
	 * Given a ResponsePath and a key, return a new ResponsePath containing the
	 * new key.
	 */
	function addPath(prev, key) {
	  return { prev: prev, key: key };
	}
	
	/**
	 * Essential assertions before executing to provide developer feedback for
	 * improper use of the GraphQL library.
	 */
	function assertValidExecutionArguments(schema, document, rawVariableValues) {
	  !schema ? (0, _invariant2.default)(0, 'Must provide schema') : void 0;
	  !document ? (0, _invariant2.default)(0, 'Must provide document') : void 0;
	  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.') : void 0;
	
	  // Variables, if provided, must be an object.
	  !(!rawVariableValues || (typeof rawVariableValues === 'undefined' ? 'undefined' : _typeof(rawVariableValues)) === 'object') ? (0, _invariant2.default)(0, 'Variables must be provided as an Object where each property is a ' + 'variable value. Perhaps look to see if an unparsed JSON string ' + 'was provided.') : void 0;
	}
	
	/**
	 * Constructs a ExecutionContext object from the arguments passed to
	 * execute, which we will pass throughout the other execution methods.
	 *
	 * Throws a GraphQLError if a valid execution context cannot be created.
	 */
	function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver) {
	  var errors = [];
	  var operation = void 0;
	  var fragments = Object.create(null);
	  document.definitions.forEach(function (definition) {
	    switch (definition.kind) {
	      case Kind.OPERATION_DEFINITION:
	        if (!operationName && operation) {
	          throw new _error.GraphQLError('Must provide operation name if query contains multiple operations.');
	        }
	        if (!operationName || definition.name && definition.name.value === operationName) {
	          operation = definition;
	        }
	        break;
	      case Kind.FRAGMENT_DEFINITION:
	        fragments[definition.name.value] = definition;
	        break;
	      default:
	        throw new _error.GraphQLError('GraphQL cannot execute a request containing a ' + definition.kind + '.', [definition]);
	    }
	  });
	  if (!operation) {
	    if (operationName) {
	      throw new _error.GraphQLError('Unknown operation named "' + operationName + '".');
	    } else {
	      throw new _error.GraphQLError('Must provide an operation.');
	    }
	  }
	  var variableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});
	
	  return {
	    schema: schema,
	    fragments: fragments,
	    rootValue: rootValue,
	    contextValue: contextValue,
	    operation: operation,
	    variableValues: variableValues,
	    fieldResolver: fieldResolver || defaultFieldResolver,
	    errors: errors
	  };
	}
	
	/**
	 * Implements the "Evaluating operations" section of the spec.
	 */
	function executeOperation(exeContext, operation, rootValue) {
	  var type = getOperationRootType(exeContext.schema, operation);
	  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
	
	  var path = undefined;
	
	  // Errors from sub-fields of a NonNull type may propagate to the top level,
	  // at which point we still log the error and null the parent field, which
	  // in this case is the entire response.
	  //
	  // Similar to completeValueCatchingError.
	  try {
	    var result = operation.operation === 'mutation' ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);
	    var promise = getPromise(result);
	    if (promise) {
	      return promise.then(undefined, function (error) {
	        exeContext.errors.push(error);
	        return Promise.resolve(null);
	      });
	    }
	    return result;
	  } catch (error) {
	    exeContext.errors.push(error);
	    return null;
	  }
	}
	
	/**
	 * Extracts the root type of the operation from the schema.
	 */
	function getOperationRootType(schema, operation) {
	  switch (operation.operation) {
	    case 'query':
	      return schema.getQueryType();
	    case 'mutation':
	      var mutationType = schema.getMutationType();
	      if (!mutationType) {
	        throw new _error.GraphQLError('Schema is not configured for mutations', [operation]);
	      }
	      return mutationType;
	    case 'subscription':
	      var subscriptionType = schema.getSubscriptionType();
	      if (!subscriptionType) {
	        throw new _error.GraphQLError('Schema is not configured for subscriptions', [operation]);
	      }
	      return subscriptionType;
	    default:
	      throw new _error.GraphQLError('Can only execute queries, mutations and subscriptions', [operation]);
	  }
	}
	
	/**
	 * Implements the "Evaluating selection sets" section of the spec
	 * for "write" mode.
	 */
	function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
	  return Object.keys(fields).reduce(function (prevPromise, responseName) {
	    return prevPromise.then(function (results) {
	      var fieldNodes = fields[responseName];
	      var fieldPath = addPath(path, responseName);
	      var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
	      if (result === undefined) {
	        return results;
	      }
	      var promise = getPromise(result);
	      if (promise) {
	        return promise.then(function (resolvedResult) {
	          results[responseName] = resolvedResult;
	          return results;
	        });
	      }
	      results[responseName] = result;
	      return results;
	    });
	  }, Promise.resolve({}));
	}
	
	/**
	 * Implements the "Evaluating selection sets" section of the spec
	 * for "read" mode.
	 */
	function executeFields(exeContext, parentType, sourceValue, path, fields) {
	  var containsPromise = false;
	
	  var finalResults = Object.keys(fields).reduce(function (results, responseName) {
	    var fieldNodes = fields[responseName];
	    var fieldPath = addPath(path, responseName);
	    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
	    if (result === undefined) {
	      return results;
	    }
	    results[responseName] = result;
	    if (getPromise(result)) {
	      containsPromise = true;
	    }
	    return results;
	  }, Object.create(null));
	
	  // If there are no promises, we can just return the object
	  if (!containsPromise) {
	    return finalResults;
	  }
	
	  // Otherwise, results is a map from field name to the result
	  // of resolving that field, which is possibly a promise. Return
	  // a promise that will return this same map, but with any
	  // promises replaced with the values they resolved to.
	  return promiseForObject(finalResults);
	}
	
	/**
	 * Given a selectionSet, adds all of the fields in that selection to
	 * the passed in map of fields, and returns it at the end.
	 *
	 * CollectFields requires the "runtime type" of an object. For a field which
	 * returns an Interface or Union type, the "runtime type" will be the actual
	 * Object type returned by that field.
	 */
	function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
	  for (var i = 0; i < selectionSet.selections.length; i++) {
	    var selection = selectionSet.selections[i];
	    switch (selection.kind) {
	      case Kind.FIELD:
	        if (!shouldIncludeNode(exeContext, selection)) {
	          continue;
	        }
	        var name = getFieldEntryKey(selection);
	        if (!fields[name]) {
	          fields[name] = [];
	        }
	        fields[name].push(selection);
	        break;
	      case Kind.INLINE_FRAGMENT:
	        if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
	          continue;
	        }
	        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
	        break;
	      case Kind.FRAGMENT_SPREAD:
	        var fragName = selection.name.value;
	        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
	          continue;
	        }
	        visitedFragmentNames[fragName] = true;
	        var fragment = exeContext.fragments[fragName];
	        if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
	          continue;
	        }
	        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
	        break;
	    }
	  }
	  return fields;
	}
	
	/**
	 * Determines if a field should be included based on the @include and @skip
	 * directives, where @skip has higher precidence than @include.
	 */
	function shouldIncludeNode(exeContext, node) {
	  var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);
	  if (skip && skip.if === true) {
	    return false;
	  }
	
	  var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);
	  if (include && include.if === false) {
	    return false;
	  }
	  return true;
	}
	
	/**
	 * Determines if a fragment is applicable to the given type.
	 */
	function doesFragmentConditionMatch(exeContext, fragment, type) {
	  var typeConditionNode = fragment.typeCondition;
	  if (!typeConditionNode) {
	    return true;
	  }
	  var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);
	  if (conditionalType === type) {
	    return true;
	  }
	  if ((0, _definition.isAbstractType)(conditionalType)) {
	    return exeContext.schema.isPossibleType(conditionalType, type);
	  }
	  return false;
	}
	
	/**
	 * This function transforms a JS object `ObjMap<Promise<T>>` into
	 * a `Promise<ObjMap<T>>`
	 *
	 * This is akin to bluebird's `Promise.props`, but implemented only using
	 * `Promise.all` so it will work with any implementation of ES6 promises.
	 */
	function promiseForObject(object) {
	  var keys = Object.keys(object);
	  var valuesAndPromises = keys.map(function (name) {
	    return object[name];
	  });
	  return Promise.all(valuesAndPromises).then(function (values) {
	    return values.reduce(function (resolvedObject, value, i) {
	      resolvedObject[keys[i]] = value;
	      return resolvedObject;
	    }, Object.create(null));
	  });
	}
	
	/**
	 * Implements the logic to compute the key of a given field's entry
	 */
	function getFieldEntryKey(node) {
	  return node.alias ? node.alias.value : node.name.value;
	}
	
	/**
	 * Resolves the field on the given source object. In particular, this
	 * figures out the value that the field returns by calling its resolve function,
	 * then calls completeValue to complete promises, serialize scalars, or execute
	 * the sub-selection-set for objects.
	 */
	function resolveField(exeContext, parentType, source, fieldNodes, path) {
	  var fieldNode = fieldNodes[0];
	  var fieldName = fieldNode.name.value;
	
	  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
	  if (!fieldDef) {
	    return;
	  }
	
	  var resolveFn = fieldDef.resolve || exeContext.fieldResolver;
	
	  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
	
	  // Get the resolve function, regardless of if its result is normal
	  // or abrupt (error).
	  var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);
	
	  return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);
	}
	
	function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
	  // The resolve function's optional fourth argument is a collection of
	  // information about the current execution state.
	  return {
	    fieldName: fieldNodes[0].name.value,
	    fieldNodes: fieldNodes,
	    returnType: fieldDef.type,
	    parentType: parentType,
	    path: path,
	    schema: exeContext.schema,
	    fragments: exeContext.fragments,
	    rootValue: exeContext.rootValue,
	    operation: exeContext.operation,
	    variableValues: exeContext.variableValues
	  };
	}
	
	// Isolates the "ReturnOrAbrupt" behavior to not de-opt the `resolveField`
	// function. Returns the result of resolveFn or the abrupt-return Error object.
	function resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {
	  try {
	    // Build a JS object of arguments from the field.arguments AST, using the
	    // variables scope to fulfill any variable references.
	    // TODO: find a way to memoize, in case this field is within a List type.
	    var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
	
	    // The resolve function's optional third argument is a context value that
	    // is provided to every resolve function within an execution. It is commonly
	    // used to represent an authenticated user, or request-specific caches.
	    var context = exeContext.contextValue;
	
	    return resolveFn(source, args, context, info);
	  } catch (error) {
	    // Sometimes a non-error is thrown, wrap it as an Error for a
	    // consistent interface.
	    return error instanceof Error ? error : new Error(error);
	  }
	}
	
	// This is a small wrapper around completeValue which detects and logs errors
	// in the execution context.
	function completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {
	  // If the field type is non-nullable, then it is resolved without any
	  // protection from errors, however it still properly locates the error.
	  if (returnType instanceof _definition.GraphQLNonNull) {
	    return completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result);
	  }
	
	  // Otherwise, error protection is applied, logging the error and resolving
	  // a null value for this field if one is encountered.
	  try {
	    var completed = completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result);
	    var promise = getPromise(completed);
	    if (promise) {
	      // If `completeValueWithLocatedError` returned a rejected promise, log
	      // the rejection error and resolve to null.
	      // Note: we don't rely on a `catch` method, but we do expect "thenable"
	      // to take a second callback for the error case.
	      return promise.then(undefined, function (error) {
	        exeContext.errors.push(error);
	        return Promise.resolve(null);
	      });
	    }
	    return completed;
	  } catch (error) {
	    // If `completeValueWithLocatedError` returned abruptly (threw an error),
	    // log the error and return null.
	    exeContext.errors.push(error);
	    return null;
	  }
	}
	
	// This is a small wrapper around completeValue which annotates errors with
	// location information.
	function completeValueWithLocatedError(exeContext, returnType, fieldNodes, info, path, result) {
	  try {
	    var completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
	    var promise = getPromise(completed);
	    if (promise) {
	      return promise.then(undefined, function (error) {
	        return Promise.reject((0, _error.locatedError)(error, fieldNodes, responsePathAsArray(path)));
	      });
	    }
	    return completed;
	  } catch (error) {
	    throw (0, _error.locatedError)(error, fieldNodes, responsePathAsArray(path));
	  }
	}
	
	/**
	 * Implements the instructions for completeValue as defined in the
	 * "Field entries" section of the spec.
	 *
	 * If the field type is Non-Null, then this recursively completes the value
	 * for the inner type. It throws a field error if that completion returns null,
	 * as per the "Nullability" section of the spec.
	 *
	 * If the field type is a List, then this recursively completes the value
	 * for the inner type on each item in the list.
	 *
	 * If the field type is a Scalar or Enum, ensures the completed value is a legal
	 * value of the type by calling the `serialize` method of GraphQL type
	 * definition.
	 *
	 * If the field is an abstract type, determine the runtime type of the value
	 * and then complete based on that type
	 *
	 * Otherwise, the field type expects a sub-selection set, and will complete the
	 * value by evaluating all sub-selections.
	 */
	function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
	  // If result is a Promise, apply-lift over completeValue.
	  var promise = getPromise(result);
	  if (promise) {
	    return promise.then(function (resolved) {
	      return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
	    });
	  }
	
	  // If result is an Error, throw a located error.
	  if (result instanceof Error) {
	    throw result;
	  }
	
	  // If field type is NonNull, complete for inner type, and throw field error
	  // if result is null.
	  if (returnType instanceof _definition.GraphQLNonNull) {
	    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
	    if (completed === null) {
	      throw new Error('Cannot return null for non-nullable field ' + info.parentType.name + '.' + info.fieldName + '.');
	    }
	    return completed;
	  }
	
	  // If result value is null-ish (null, undefined, or NaN) then return null.
	  if ((0, _isNullish2.default)(result)) {
	    return null;
	  }
	
	  // If field type is List, complete each item in the list with the inner type
	  if (returnType instanceof _definition.GraphQLList) {
	    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
	  }
	
	  // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
	  // returning null if serialization is not possible.
	  if ((0, _definition.isLeafType)(returnType)) {
	    return completeLeafValue(returnType, result);
	  }
	
	  // If field type is an abstract type, Interface or Union, determine the
	  // runtime Object type and complete for that type.
	  if ((0, _definition.isAbstractType)(returnType)) {
	    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
	  }
	
	  // If field type is Object, execute and complete all sub-selections.
	  if (returnType instanceof _definition.GraphQLObjectType) {
	    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
	  }
	
	  // Not reachable. All possible output types have been considered.
	  throw new Error('Cannot complete value of unexpected type "' + String(returnType) + '".');
	}
	
	/**
	 * Complete a list value by completing each item in the list with the
	 * inner type
	 */
	function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
	  !(0, _iterall.isCollection)(result) ? (0, _invariant2.default)(0, 'Expected Iterable, but did not find one for field ' + info.parentType.name + '.' + info.fieldName + '.') : void 0;
	
	  // This is specified as a simple map, however we're optimizing the path
	  // where the list contains no Promises by avoiding creating another Promise.
	  var itemType = returnType.ofType;
	  var containsPromise = false;
	  var completedResults = [];
	  (0, _iterall.forEach)(result, function (item, index) {
	    // No need to modify the info object containing the path,
	    // since from here on it is not ever accessed by resolver functions.
	    var fieldPath = addPath(path, index);
	    var completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);
	
	    if (!containsPromise && getPromise(completedItem)) {
	      containsPromise = true;
	    }
	    completedResults.push(completedItem);
	  });
	
	  return containsPromise ? Promise.all(completedResults) : completedResults;
	}
	
	/**
	 * Complete a Scalar or Enum by serializing to a valid value, returning
	 * null if serialization is not possible.
	 */
	function completeLeafValue(returnType, result) {
	  !returnType.serialize ? (0, _invariant2.default)(0, 'Missing serialize method on type') : void 0;
	  var serializedResult = returnType.serialize(result);
	  if ((0, _isNullish2.default)(serializedResult)) {
	    throw new Error('Expected a value of type "' + String(returnType) + '" but ' + ('received: ' + String(result)));
	  }
	  return serializedResult;
	}
	
	/**
	 * Complete a value of an abstract type by determining the runtime object type
	 * of that value, then complete the value for that type.
	 */
	function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
	  var runtimeType = returnType.resolveType ? returnType.resolveType(result, exeContext.contextValue, info) : defaultResolveTypeFn(result, exeContext.contextValue, info, returnType);
	
	  var promise = getPromise(runtimeType);
	  if (promise) {
	    return promise.then(function (resolvedRuntimeType) {
	      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
	    });
	  }
	
	  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
	}
	
	function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
	  var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;
	
	  if (!(runtimeType instanceof _definition.GraphQLObjectType)) {
	    throw new _error.GraphQLError('Abstract type ' + returnType.name + ' must resolve to an Object type at ' + ('runtime for field ' + info.parentType.name + '.' + info.fieldName + ' with ') + ('value "' + String(result) + '", received "' + String(runtimeType) + '".'), fieldNodes);
	  }
	
	  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
	    throw new _error.GraphQLError('Runtime Object type "' + runtimeType.name + '" is not a possible type ' + ('for "' + returnType.name + '".'), fieldNodes);
	  }
	
	  return runtimeType;
	}
	
	/**
	 * Complete an Object value by executing all sub-selections.
	 */
	function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
	  // If there is an isTypeOf predicate function, call it with the
	  // current result. If isTypeOf returns false, then raise an error rather
	  // than continuing execution.
	  if (returnType.isTypeOf) {
	    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
	
	    var promise = getPromise(isTypeOf);
	    if (promise) {
	      return promise.then(function (isTypeOfResult) {
	        if (!isTypeOfResult) {
	          throw invalidReturnTypeError(returnType, result, fieldNodes);
	        }
	        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result);
	      });
	    }
	
	    if (!isTypeOf) {
	      throw invalidReturnTypeError(returnType, result, fieldNodes);
	    }
	  }
	
	  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result);
	}
	
	function invalidReturnTypeError(returnType, result, fieldNodes) {
	  return new _error.GraphQLError('Expected value of type "' + returnType.name + '" but got: ' + String(result) + '.', fieldNodes);
	}
	
	function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, info, path, result) {
	  // Collect sub-fields to execute to complete this value.
	  var subFieldNodes = Object.create(null);
	  var visitedFragmentNames = Object.create(null);
	  for (var i = 0; i < fieldNodes.length; i++) {
	    var selectionSet = fieldNodes[i].selectionSet;
	    if (selectionSet) {
	      subFieldNodes = collectFields(exeContext, returnType, selectionSet, subFieldNodes, visitedFragmentNames);
	    }
	  }
	
	  return executeFields(exeContext, returnType, result, path, subFieldNodes);
	}
	
	/**
	 * If a resolveType function is not given, then a default resolve behavior is
	 * used which tests each possible type for the abstract type by calling
	 * isTypeOf for the object being coerced, returning the first type that matches.
	 */
	function defaultResolveTypeFn(value, context, info, abstractType) {
	  var possibleTypes = info.schema.getPossibleTypes(abstractType);
	  var promisedIsTypeOfResults = [];
	
	  for (var i = 0; i < possibleTypes.length; i++) {
	    var type = possibleTypes[i];
	
	    if (type.isTypeOf) {
	      var isTypeOfResult = type.isTypeOf(value, context, info);
	
	      var promise = getPromise(isTypeOfResult);
	      if (promise) {
	        promisedIsTypeOfResults[i] = promise;
	      } else if (isTypeOfResult) {
	        return type;
	      }
	    }
	  }
	
	  if (promisedIsTypeOfResults.length) {
	    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {
	      for (var _i = 0; _i < isTypeOfResults.length; _i++) {
	        if (isTypeOfResults[_i]) {
	          return possibleTypes[_i];
	        }
	      }
	    });
	  }
	}
	
	/**
	 * If a resolve function is not given, then a default resolve behavior is used
	 * which takes the property of the source object of the same name as the field
	 * and returns it as the result, or if it's a function, returns the result
	 * of calling that function while passing along args and context.
	 */
	var defaultFieldResolver = exports.defaultFieldResolver = function defaultFieldResolver(source, args, context, info) {
	  // ensure source is a value for which property access is acceptable.
	  if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' || typeof source === 'function') {
	    var property = source[info.fieldName];
	    if (typeof property === 'function') {
	      return source[info.fieldName](args, context, info);
	    }
	    return property;
	  }
	};
	
	/**
	 * Only returns the value if it acts like a Promise, i.e. has a "then" function,
	 * otherwise returns void.
	 */
	function getPromise(value) {
	  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.then === 'function') {
	    return value;
	  }
	}
	
	/**
	 * This method looks up the field on the given type defintion.
	 * It has special casing for the two introspection fields, __schema
	 * and __typename. __typename is special because it can always be
	 * queried as a field, even in situations where no other fields
	 * are allowed, like on a Union. __schema could get automatically
	 * added to the query type, but that would require mutating type
	 * definitions, which would cause issues.
	 */
	function getFieldDef(schema, parentType, fieldName) {
	  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.SchemaMetaFieldDef;
	  } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.TypeMetaFieldDef;
	  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	  return parentType.getFields()[fieldName];
	}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * 
	                                                                                                                                                                                                                                                                               */
	
	exports.getVariableValues = getVariableValues;
	exports.getArgumentValues = getArgumentValues;
	exports.getDirectiveValues = getDirectiveValues;
	exports.coerceValue = coerceValue;
	
	var _iterall = __webpack_require__(61);
	
	var _error = __webpack_require__(4);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _isInvalid = __webpack_require__(79);
	
	var _isInvalid2 = _interopRequireDefault(_isInvalid);
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	var _typeFromAST = __webpack_require__(35);
	
	var _valueFromAST = __webpack_require__(81);
	
	var _isValidJSValue = __webpack_require__(263);
	
	var _isValidLiteralValue = __webpack_require__(109);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Prepares an object map of variableValues of the correct type based on the
	 * provided variable definitions and arbitrary input. If the input cannot be
	 * parsed to match the variable definitions, a GraphQLError will be thrown.
	 *
	 * Note: The returned value is a plain Object with a prototype, since it is
	 * exposed to user code. Care should be taken to not pull values from the
	 * Object prototype.
	 */
	function getVariableValues(schema, varDefNodes, inputs) {
	  var coercedValues = {};
	  for (var i = 0; i < varDefNodes.length; i++) {
	    var varDefNode = varDefNodes[i];
	    var varName = varDefNode.variable.name.value;
	    var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
	    if (!(0, _definition.isInputType)(varType)) {
	      throw new _error.GraphQLError('Variable "$' + varName + '" expected value of type ' + ('"' + (0, _printer.print)(varDefNode.type) + '" which cannot be used as an input type.'), [varDefNode.type]);
	    }
	
	    var value = inputs[varName];
	    if ((0, _isInvalid2.default)(value)) {
	      var defaultValue = varDefNode.defaultValue;
	      if (defaultValue) {
	        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(defaultValue, varType);
	      }
	      if (varType instanceof _definition.GraphQLNonNull) {
	        throw new _error.GraphQLError('Variable "$' + varName + '" of required type ' + ('"' + String(varType) + '" was not provided.'), [varDefNode]);
	      }
	    } else {
	      var errors = (0, _isValidJSValue.isValidJSValue)(value, varType);
	      if (errors.length) {
	        var message = errors ? '\n' + errors.join('\n') : '';
	        throw new _error.GraphQLError('Variable "$' + varName + '" got invalid value ' + (JSON.stringify(value) + '.' + message), [varDefNode]);
	      }
	
	      var coercedValue = coerceValue(varType, value);
	      !!(0, _isInvalid2.default)(coercedValue) ? (0, _invariant2.default)(0, 'Should have reported error.') : void 0;
	      coercedValues[varName] = coercedValue;
	    }
	  }
	  return coercedValues;
	}
	
	/**
	 * Prepares an object map of argument values given a list of argument
	 * definitions and list of argument AST nodes.
	 *
	 * Note: The returned value is a plain Object with a prototype, since it is
	 * exposed to user code. Care should be taken to not pull values from the
	 * Object prototype.
	 */
	function getArgumentValues(def, node, variableValues) {
	  var coercedValues = {};
	  var argDefs = def.args;
	  var argNodes = node.arguments;
	  if (!argDefs || !argNodes) {
	    return coercedValues;
	  }
	  var argNodeMap = (0, _keyMap2.default)(argNodes, function (arg) {
	    return arg.name.value;
	  });
	  for (var i = 0; i < argDefs.length; i++) {
	    var argDef = argDefs[i];
	    var name = argDef.name;
	    var argType = argDef.type;
	    var argumentNode = argNodeMap[name];
	    var defaultValue = argDef.defaultValue;
	    if (!argumentNode) {
	      if (!(0, _isInvalid2.default)(defaultValue)) {
	        coercedValues[name] = defaultValue;
	      } else if (argType instanceof _definition.GraphQLNonNull) {
	        throw new _error.GraphQLError('Argument "' + name + '" of required type ' + ('"' + String(argType) + '" was not provided.'), [node]);
	      }
	    } else if (argumentNode.value.kind === Kind.VARIABLE) {
	      var variableName = argumentNode.value.name.value;
	      if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !(0, _isInvalid2.default)(variableValues[variableName])) {
	        // Note: this does not check that this variable value is correct.
	        // This assumes that this query has been validated and the variable
	        // usage here is of the correct type.
	        coercedValues[name] = variableValues[variableName];
	      } else if (!(0, _isInvalid2.default)(defaultValue)) {
	        coercedValues[name] = defaultValue;
	      } else if (argType instanceof _definition.GraphQLNonNull) {
	        throw new _error.GraphQLError('Argument "' + name + '" of required type "' + String(argType) + '" was ' + ('provided the variable "$' + variableName + '" which was not provided ') + 'a runtime value.', [argumentNode.value]);
	      }
	    } else {
	      var valueNode = argumentNode.value;
	      var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
	      if ((0, _isInvalid2.default)(coercedValue)) {
	        var errors = (0, _isValidLiteralValue.isValidLiteralValue)(argType, valueNode);
	        var message = errors ? '\n' + errors.join('\n') : '';
	        throw new _error.GraphQLError('Argument "' + name + '" got invalid value ' + (0, _printer.print)(valueNode) + '.' + message, [argumentNode.value]);
	      }
	      coercedValues[name] = coercedValue;
	    }
	  }
	  return coercedValues;
	}
	
	/**
	 * Prepares an object map of argument values given a directive definition
	 * and a AST node which may contain directives. Optionally also accepts a map
	 * of variable values.
	 *
	 * If the directive does not exist on the node, returns undefined.
	 *
	 * Note: The returned value is a plain Object with a prototype, since it is
	 * exposed to user code. Care should be taken to not pull values from the
	 * Object prototype.
	 */
	function getDirectiveValues(directiveDef, node, variableValues) {
	  var directiveNode = node.directives && (0, _find2.default)(node.directives, function (directive) {
	    return directive.name.value === directiveDef.name;
	  });
	
	  if (directiveNode) {
	    return getArgumentValues(directiveDef, directiveNode, variableValues);
	  }
	}
	
	/**
	 * Given a type and any value, return a runtime value coerced to match the type.
	 */
	function coerceValue(type, value) {
	  // Ensure flow knows that we treat function params as const.
	  var _value = value;
	
	  if ((0, _isInvalid2.default)(_value)) {
	    return; // Intentionally return no value.
	  }
	
	  if (type instanceof _definition.GraphQLNonNull) {
	    if (_value === null) {
	      return; // Intentionally return no value.
	    }
	    return coerceValue(type.ofType, _value);
	  }
	
	  if (_value === null) {
	    // Intentionally return the value null.
	    return null;
	  }
	
	  if (type instanceof _definition.GraphQLList) {
	    var itemType = type.ofType;
	    if ((0, _iterall.isCollection)(_value)) {
	      var coercedValues = [];
	      var valueIter = (0, _iterall.createIterator)(_value);
	      if (!valueIter) {
	        return; // Intentionally return no value.
	      }
	      var step = void 0;
	      while (!(step = valueIter.next()).done) {
	        var itemValue = coerceValue(itemType, step.value);
	        if ((0, _isInvalid2.default)(itemValue)) {
	          return; // Intentionally return no value.
	        }
	        coercedValues.push(itemValue);
	      }
	      return coercedValues;
	    }
	    var coercedValue = coerceValue(itemType, _value);
	    if ((0, _isInvalid2.default)(coercedValue)) {
	      return; // Intentionally return no value.
	    }
	    return [coerceValue(itemType, _value)];
	  }
	
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    if ((typeof _value === 'undefined' ? 'undefined' : _typeof(_value)) !== 'object') {
	      return; // Intentionally return no value.
	    }
	    var coercedObj = Object.create(null);
	    var fields = type.getFields();
	    var fieldNames = Object.keys(fields);
	    for (var i = 0; i < fieldNames.length; i++) {
	      var fieldName = fieldNames[i];
	      var field = fields[fieldName];
	      if ((0, _isInvalid2.default)(_value[fieldName])) {
	        if (!(0, _isInvalid2.default)(field.defaultValue)) {
	          coercedObj[fieldName] = field.defaultValue;
	        } else if (field.type instanceof _definition.GraphQLNonNull) {
	          return; // Intentionally return no value.
	        }
	        continue;
	      }
	      var fieldValue = coerceValue(field.type, _value[fieldName]);
	      if ((0, _isInvalid2.default)(fieldValue)) {
	        return; // Intentionally return no value.
	      }
	      coercedObj[fieldName] = fieldValue;
	    }
	    return coercedObj;
	  }
	
	  !(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType) ? (0, _invariant2.default)(0, 'Must be input type') : void 0;
	
	  var parsed = type.parseValue(_value);
	  if ((0, _isNullish2.default)(parsed)) {
	    // null or invalid values represent a failure to parse correctly,
	    // in which case no value is returned.
	    return;
	  }
	
	  return parsed;
	}

/***/ }),
/* 161 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = keyValMap;
	
	
	/**
	 * Creates a keyed JS object from an array, given a function to produce the keys
	 * and a function to produce the values from each item in the array.
	 *
	 *     const phoneBook = [
	 *       { name: 'Jon', num: '555-1234' },
	 *       { name: 'Jenny', num: '867-5309' }
	 *     ]
	 *
	 *     // { Jon: '555-1234', Jenny: '867-5309' }
	 *     const phonesByName = keyValMap(
	 *       phoneBook,
	 *       entry => entry.name,
	 *       entry => entry.num
	 *     )
	 *
	 */
	function keyValMap(list, keyFn, valFn) {
	  return list.reduce(function (map, item) {
	    return map[keyFn(item)] = valFn(item), map;
	  }, Object.create(null));
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 162 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = quotedOrList;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var MAX_LENGTH = 5;
	
	/**
	 * Given [ A, B, C ] return '"A", "B", or "C"'.
	 */
	function quotedOrList(items) {
	  var selected = items.slice(0, MAX_LENGTH);
	  return selected.map(function (item) {
	    return '"' + item + '"';
	  }).reduce(function (list, quoted, index) {
	    return list + (selected.length > 2 ? ', ' : ' ') + (index === selected.length - 1 ? 'or ' : '') + quoted;
	  });
	}

/***/ }),
/* 163 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = suggestionList;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	/**
	 * Given an invalid input string and a list of valid options, returns a filtered
	 * list of valid options sorted based on their similarity with the input.
	 */
	function suggestionList(input, options) {
	  var optionsByDistance = Object.create(null);
	  var oLength = options.length;
	  var inputThreshold = input.length / 2;
	  for (var i = 0; i < oLength; i++) {
	    var distance = lexicalDistance(input, options[i]);
	    var threshold = Math.max(inputThreshold, options[i].length / 2, 1);
	    if (distance <= threshold) {
	      optionsByDistance[options[i]] = distance;
	    }
	  }
	  return Object.keys(optionsByDistance).sort(function (a, b) {
	    return optionsByDistance[a] - optionsByDistance[b];
	  });
	}
	
	/**
	 * Computes the lexical distance between strings A and B.
	 *
	 * The "distance" between two strings is given by counting the minimum number
	 * of edits needed to transform string A into string B. An edit can be an
	 * insertion, deletion, or substitution of a single character, or a swap of two
	 * adjacent characters.
	 *
	 * This distance can be useful for detecting typos in input or sorting
	 *
	 * @param {string} a
	 * @param {string} b
	 * @return {int} distance in number of edits
	 */
	function lexicalDistance(a, b) {
	  var i = void 0;
	  var j = void 0;
	  var d = [];
	  var aLength = a.length;
	  var bLength = b.length;
	
	  for (i = 0; i <= aLength; i++) {
	    d[i] = [i];
	  }
	
	  for (j = 1; j <= bLength; j++) {
	    d[0][j] = j;
	  }
	
	  for (i = 1; i <= aLength; i++) {
	    for (j = 1; j <= bLength; j++) {
	      var cost = a[i - 1] === b[j - 1] ? 0 : 1;
	
	      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
	
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
	      }
	    }
	  }
	
	  return d[aLength][bLength];
	}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TokenKind = undefined;
	exports.createLexer = createLexer;
	exports.getTokenDesc = getTokenDesc;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Given a Source object, this returns a Lexer for that source.
	 * A Lexer is a stateful stream generator in that every time
	 * it is advanced, it returns the next token in the Source. Assuming the
	 * source lexes, the final Token emitted by the lexer will be of kind
	 * EOF, after which the lexer will repeatedly return the same EOF token
	 * whenever called.
	 */
	function createLexer(source, options) {
	  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);
	  var lexer = {
	    source: source,
	    options: options,
	    lastToken: startOfFileToken,
	    token: startOfFileToken,
	    line: 1,
	    lineStart: 0,
	    advance: advanceLexer
	  };
	  return lexer;
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function advanceLexer() {
	  var token = this.lastToken = this.token;
	  if (token.kind !== EOF) {
	    do {
	      token = token.next = readToken(this, token);
	    } while (token.kind === COMMENT);
	    this.token = token;
	  }
	  return token;
	}
	
	/**
	 * The return type of createLexer.
	 */
	
	
	// Each kind of token.
	var SOF = '<SOF>';
	var EOF = '<EOF>';
	var BANG = '!';
	var DOLLAR = '$';
	var PAREN_L = '(';
	var PAREN_R = ')';
	var SPREAD = '...';
	var COLON = ':';
	var EQUALS = '=';
	var AT = '@';
	var BRACKET_L = '[';
	var BRACKET_R = ']';
	var BRACE_L = '{';
	var PIPE = '|';
	var BRACE_R = '}';
	var NAME = 'Name';
	var INT = 'Int';
	var FLOAT = 'Float';
	var STRING = 'String';
	var COMMENT = 'Comment';
	
	/**
	 * An exported enum describing the different kinds of tokens that the
	 * lexer emits.
	 */
	var TokenKind = exports.TokenKind = {
	  SOF: SOF,
	  EOF: EOF,
	  BANG: BANG,
	  DOLLAR: DOLLAR,
	  PAREN_L: PAREN_L,
	  PAREN_R: PAREN_R,
	  SPREAD: SPREAD,
	  COLON: COLON,
	  EQUALS: EQUALS,
	  AT: AT,
	  BRACKET_L: BRACKET_L,
	  BRACKET_R: BRACKET_R,
	  BRACE_L: BRACE_L,
	  PIPE: PIPE,
	  BRACE_R: BRACE_R,
	  NAME: NAME,
	  INT: INT,
	  FLOAT: FLOAT,
	  STRING: STRING,
	  COMMENT: COMMENT
	};
	
	/**
	 * A helper function to describe a token as a string for debugging
	 */
	function getTokenDesc(token) {
	  var value = token.value;
	  return value ? token.kind + ' "' + value + '"' : token.kind;
	}
	
	var charCodeAt = String.prototype.charCodeAt;
	var slice = String.prototype.slice;
	
	/**
	 * Helper function for constructing the Token object.
	 */
	function Tok(kind, start, end, line, column, prev, value) {
	  this.kind = kind;
	  this.start = start;
	  this.end = end;
	  this.line = line;
	  this.column = column;
	  this.value = value;
	  this.prev = prev;
	  this.next = null;
	}
	
	// Print a simplified form when appearing in JSON/util.inspect.
	Tok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {
	  return {
	    kind: this.kind,
	    value: this.value,
	    line: this.line,
	    column: this.column
	  };
	};
	
	function printCharCode(code) {
	  return (
	    // NaN/undefined represents access beyond the end of the file.
	    isNaN(code) ? EOF :
	    // Trust JSON for ASCII.
	    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :
	    // Otherwise print the escaped form.
	    '"\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '"'
	  );
	}
	
	/**
	 * Gets the next token from the source starting at the given position.
	 *
	 * This skips over whitespace and comments until it finds the next lexable
	 * token, then lexes punctuators immediately or calls the appropriate helper
	 * function for more complicated tokens.
	 */
	function readToken(lexer, prev) {
	  var source = lexer.source;
	  var body = source.body;
	  var bodyLength = body.length;
	
	  var position = positionAfterWhitespace(body, prev.end, lexer);
	  var line = lexer.line;
	  var col = 1 + position - lexer.lineStart;
	
	  if (position >= bodyLength) {
	    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);
	  }
	
	  var code = charCodeAt.call(body, position);
	
	  // SourceCharacter
	  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {
	    throw (0, _error.syntaxError)(source, position, 'Cannot contain the invalid character ' + printCharCode(code) + '.');
	  }
	
	  switch (code) {
	    // !
	    case 33:
	      return new Tok(BANG, position, position + 1, line, col, prev);
	    // #
	    case 35:
	      return readComment(source, position, line, col, prev);
	    // $
	    case 36:
	      return new Tok(DOLLAR, position, position + 1, line, col, prev);
	    // (
	    case 40:
	      return new Tok(PAREN_L, position, position + 1, line, col, prev);
	    // )
	    case 41:
	      return new Tok(PAREN_R, position, position + 1, line, col, prev);
	    // .
	    case 46:
	      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {
	        return new Tok(SPREAD, position, position + 3, line, col, prev);
	      }
	      break;
	    // :
	    case 58:
	      return new Tok(COLON, position, position + 1, line, col, prev);
	    // =
	    case 61:
	      return new Tok(EQUALS, position, position + 1, line, col, prev);
	    // @
	    case 64:
	      return new Tok(AT, position, position + 1, line, col, prev);
	    // [
	    case 91:
	      return new Tok(BRACKET_L, position, position + 1, line, col, prev);
	    // ]
	    case 93:
	      return new Tok(BRACKET_R, position, position + 1, line, col, prev);
	    // {
	    case 123:
	      return new Tok(BRACE_L, position, position + 1, line, col, prev);
	    // |
	    case 124:
	      return new Tok(PIPE, position, position + 1, line, col, prev);
	    // }
	    case 125:
	      return new Tok(BRACE_R, position, position + 1, line, col, prev);
	    // A-Z _ a-z
	    case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:
	    case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:
	    case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:
	    case 89:case 90:
	    case 95:
	    case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:
	    case 105:case 106:case 107:case 108:case 109:case 110:case 111:
	    case 112:case 113:case 114:case 115:case 116:case 117:case 118:
	    case 119:case 120:case 121:case 122:
	      return readName(source, position, line, col, prev);
	    // - 0-9
	    case 45:
	    case 48:case 49:case 50:case 51:case 52:
	    case 53:case 54:case 55:case 56:case 57:
	      return readNumber(source, position, code, line, col, prev);
	    // "
	    case 34:
	      return readString(source, position, line, col, prev);
	  }
	
	  throw (0, _error.syntaxError)(source, position, unexpectedCharacterMessage(code));
	}
	
	/**
	 * Report a message that an unexpected character was encountered.
	 */
	function unexpectedCharacterMessage(code) {
	  if (code === 39) {
	    // '
	    return 'Unexpected single quote character (\'), did you mean to use ' + 'a double quote (")?';
	  }
	
	  return 'Cannot parse the unexpected character ' + printCharCode(code) + '.';
	}
	
	/**
	 * Reads from body starting at startPosition until it finds a non-whitespace
	 * or commented character, then returns the position of that character for
	 * lexing.
	 */
	function positionAfterWhitespace(body, startPosition, lexer) {
	  var bodyLength = body.length;
	  var position = startPosition;
	  while (position < bodyLength) {
	    var code = charCodeAt.call(body, position);
	    // tab | space | comma | BOM
	    if (code === 9 || code === 32 || code === 44 || code === 0xFEFF) {
	      ++position;
	    } else if (code === 10) {
	      // new line
	      ++position;
	      ++lexer.line;
	      lexer.lineStart = position;
	    } else if (code === 13) {
	      // carriage return
	      if (charCodeAt.call(body, position + 1) === 10) {
	        position += 2;
	      } else {
	        ++position;
	      }
	      ++lexer.line;
	      lexer.lineStart = position;
	    } else {
	      break;
	    }
	  }
	  return position;
	}
	
	/**
	 * Reads a comment token from the source file.
	 *
	 * #[\u0009\u0020-\uFFFF]*
	 */
	function readComment(source, start, line, col, prev) {
	  var body = source.body;
	  var code = void 0;
	  var position = start;
	
	  do {
	    code = charCodeAt.call(body, ++position);
	  } while (code !== null && (
	  // SourceCharacter but not LineTerminator
	  code > 0x001F || code === 0x0009));
	
	  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));
	}
	
	/**
	 * Reads a number token from the source file, either a float
	 * or an int depending on whether a decimal point appears.
	 *
	 * Int:   -?(0|[1-9][0-9]*)
	 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
	 */
	function readNumber(source, start, firstCode, line, col, prev) {
	  var body = source.body;
	  var code = firstCode;
	  var position = start;
	  var isFloat = false;
	
	  if (code === 45) {
	    // -
	    code = charCodeAt.call(body, ++position);
	  }
	
	  if (code === 48) {
	    // 0
	    code = charCodeAt.call(body, ++position);
	    if (code >= 48 && code <= 57) {
	      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');
	    }
	  } else {
	    position = readDigits(source, position, code);
	    code = charCodeAt.call(body, position);
	  }
	
	  if (code === 46) {
	    // .
	    isFloat = true;
	
	    code = charCodeAt.call(body, ++position);
	    position = readDigits(source, position, code);
	    code = charCodeAt.call(body, position);
	  }
	
	  if (code === 69 || code === 101) {
	    // E e
	    isFloat = true;
	
	    code = charCodeAt.call(body, ++position);
	    if (code === 43 || code === 45) {
	      // + -
	      code = charCodeAt.call(body, ++position);
	    }
	    position = readDigits(source, position, code);
	  }
	
	  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));
	}
	
	/**
	 * Returns the new position in the source after reading digits.
	 */
	function readDigits(source, start, firstCode) {
	  var body = source.body;
	  var position = start;
	  var code = firstCode;
	  if (code >= 48 && code <= 57) {
	    // 0 - 9
	    do {
	      code = charCodeAt.call(body, ++position);
	    } while (code >= 48 && code <= 57); // 0 - 9
	    return position;
	  }
	  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');
	}
	
	/**
	 * Reads a string token from the source file.
	 *
	 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
	 */
	function readString(source, start, line, col, prev) {
	  var body = source.body;
	  var position = start + 1;
	  var chunkStart = position;
	  var code = 0;
	  var value = '';
	
	  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&
	  // not LineTerminator
	  code !== 0x000A && code !== 0x000D &&
	  // not Quote (")
	  code !== 34) {
	    // SourceCharacter
	    if (code < 0x0020 && code !== 0x0009) {
	      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');
	    }
	
	    ++position;
	    if (code === 92) {
	      // \
	      value += slice.call(body, chunkStart, position - 1);
	      code = charCodeAt.call(body, position);
	      switch (code) {
	        case 34:
	          value += '"';break;
	        case 47:
	          value += '/';break;
	        case 92:
	          value += '\\';break;
	        case 98:
	          value += '\b';break;
	        case 102:
	          value += '\f';break;
	        case 110:
	          value += '\n';break;
	        case 114:
	          value += '\r';break;
	        case 116:
	          value += '\t';break;
	        case 117:
	          // u
	          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));
	          if (charCode < 0) {
	            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\u' + body.slice(position + 1, position + 5) + '.'));
	          }
	          value += String.fromCharCode(charCode);
	          position += 4;
	          break;
	        default:
	          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\' + String.fromCharCode(code) + '.');
	      }
	      ++position;
	      chunkStart = position;
	    }
	  }
	
	  if (code !== 34) {
	    // quote (")
	    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');
	  }
	
	  value += slice.call(body, chunkStart, position);
	  return new Tok(STRING, start, position + 1, line, col, prev, value);
	}
	
	/**
	 * Converts four hexidecimal chars to the integer that the
	 * string represents. For example, uniCharCode('0','0','0','f')
	 * will return 15, and uniCharCode('0','0','f','f') returns 255.
	 *
	 * Returns a negative number on error, if a char was invalid.
	 *
	 * This is implemented by noting that char2hex() returns -1 on error,
	 * which means the result of ORing the char2hex() will also be negative.
	 */
	function uniCharCode(a, b, c, d) {
	  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
	}
	
	/**
	 * Converts a hex character to its integer value.
	 * '0' becomes 0, '9' becomes 9
	 * 'A' becomes 10, 'F' becomes 15
	 * 'a' becomes 10, 'f' becomes 15
	 *
	 * Returns -1 on error.
	 */
	function char2hex(a) {
	  return a >= 48 && a <= 57 ? a - 48 : // 0-9
	  a >= 65 && a <= 70 ? a - 55 : // A-F
	  a >= 97 && a <= 102 ? a - 87 : // a-f
	  -1;
	}
	
	/**
	 * Reads an alphanumeric + underscore name from the source.
	 *
	 * [_A-Za-z][_0-9A-Za-z]*
	 */
	function readName(source, position, line, col, prev) {
	  var body = source.body;
	  var bodyLength = body.length;
	  var end = position + 1;
	  var code = 0;
	  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _
	  code >= 48 && code <= 57 || // 0-9
	  code >= 65 && code <= 90 || // A-Z
	  code >= 97 && code <= 122 // a-z
	  )) {
	    ++end;
	  }
	  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));
	}

/***/ }),
/* 165 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getLocation = getLocation;
	
	
	/**
	 * Takes a Source and a UTF-8 character offset, and returns the corresponding
	 * line and column as a SourceLocation.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function getLocation(source, position) {
	  var lineRegexp = /\r\n|[\n\r]/g;
	  var line = 1;
	  var column = position + 1;
	  var match = void 0;
	  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
	    line += 1;
	    column = position + 1 - (match.index + match[0].length);
	  }
	  return { line: line, column: column };
	}
	
	/**
	 * Represents a location in a Source.
	 */

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TypeInfo = undefined;
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _definition = __webpack_require__(7);
	
	var _introspection = __webpack_require__(41);
	
	var _typeFromAST = __webpack_require__(35);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	/**
	 * TypeInfo is a utility class which, given a GraphQL schema, can keep track
	 * of the current field and type definitions at any point in a GraphQL document
	 * AST during a recursive descent by calling `enter(node)` and `leave(node)`.
	 */
	var TypeInfo = exports.TypeInfo = function () {
	  function TypeInfo(schema,
	  // NOTE: this experimental optional second parameter is only needed in order
	  // to support non-spec-compliant codebases. You should never need to use it.
	  getFieldDefFn) {
	    _classCallCheck(this, TypeInfo);
	
	    this._schema = schema;
	    this._typeStack = [];
	    this._parentTypeStack = [];
	    this._inputTypeStack = [];
	    this._fieldDefStack = [];
	    this._directive = null;
	    this._argument = null;
	    this._enumValue = null;
	    this._getFieldDef = getFieldDefFn || getFieldDef;
	  }
	
	  TypeInfo.prototype.getType = function getType() {
	    if (this._typeStack.length > 0) {
	      return this._typeStack[this._typeStack.length - 1];
	    }
	  };
	
	  TypeInfo.prototype.getParentType = function getParentType() {
	    if (this._parentTypeStack.length > 0) {
	      return this._parentTypeStack[this._parentTypeStack.length - 1];
	    }
	  };
	
	  TypeInfo.prototype.getInputType = function getInputType() {
	    if (this._inputTypeStack.length > 0) {
	      return this._inputTypeStack[this._inputTypeStack.length - 1];
	    }
	  };
	
	  TypeInfo.prototype.getFieldDef = function getFieldDef() {
	    if (this._fieldDefStack.length > 0) {
	      return this._fieldDefStack[this._fieldDefStack.length - 1];
	    }
	  };
	
	  TypeInfo.prototype.getDirective = function getDirective() {
	    return this._directive;
	  };
	
	  TypeInfo.prototype.getArgument = function getArgument() {
	    return this._argument;
	  };
	
	  TypeInfo.prototype.getEnumValue = function getEnumValue() {
	    return this._enumValue;
	  };
	
	  // Flow does not yet handle this case.
	
	
	  TypeInfo.prototype.enter = function enter(node /* ASTNode */) {
	    var schema = this._schema;
	    switch (node.kind) {
	      case Kind.SELECTION_SET:
	        var namedType = (0, _definition.getNamedType)(this.getType());
	        this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);
	        break;
	      case Kind.FIELD:
	        var parentType = this.getParentType();
	        var fieldDef = void 0;
	        if (parentType) {
	          fieldDef = this._getFieldDef(schema, parentType, node);
	        }
	        this._fieldDefStack.push(fieldDef);
	        this._typeStack.push(fieldDef && fieldDef.type);
	        break;
	      case Kind.DIRECTIVE:
	        this._directive = schema.getDirective(node.name.value);
	        break;
	      case Kind.OPERATION_DEFINITION:
	        var type = void 0;
	        if (node.operation === 'query') {
	          type = schema.getQueryType();
	        } else if (node.operation === 'mutation') {
	          type = schema.getMutationType();
	        } else if (node.operation === 'subscription') {
	          type = schema.getSubscriptionType();
	        }
	        this._typeStack.push(type);
	        break;
	      case Kind.INLINE_FRAGMENT:
	      case Kind.FRAGMENT_DEFINITION:
	        var typeConditionAST = node.typeCondition;
	        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();
	        this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);
	        break;
	      case Kind.VARIABLE_DEFINITION:
	        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
	        this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);
	        break;
	      case Kind.ARGUMENT:
	        var argDef = void 0;
	        var argType = void 0;
	        var fieldOrDirective = this.getDirective() || this.getFieldDef();
	        if (fieldOrDirective) {
	          argDef = (0, _find2.default)(fieldOrDirective.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (argDef) {
	            argType = argDef.type;
	          }
	        }
	        this._argument = argDef;
	        this._inputTypeStack.push(argType);
	        break;
	      case Kind.LIST:
	        var listType = (0, _definition.getNullableType)(this.getInputType());
	        this._inputTypeStack.push(listType instanceof _definition.GraphQLList ? listType.ofType : undefined);
	        break;
	      case Kind.OBJECT_FIELD:
	        var objectType = (0, _definition.getNamedType)(this.getInputType());
	        var fieldType = void 0;
	        if (objectType instanceof _definition.GraphQLInputObjectType) {
	          var inputField = objectType.getFields()[node.name.value];
	          fieldType = inputField ? inputField.type : undefined;
	        }
	        this._inputTypeStack.push(fieldType);
	        break;
	      case Kind.ENUM:
	        var enumType = (0, _definition.getNamedType)(this.getInputType());
	        var enumValue = void 0;
	        if (enumType instanceof _definition.GraphQLEnumType) {
	          enumValue = enumType.getValue(node.value);
	        }
	        this._enumValue = enumValue;
	        break;
	    }
	  };
	
	  TypeInfo.prototype.leave = function leave(node) {
	    switch (node.kind) {
	      case Kind.SELECTION_SET:
	        this._parentTypeStack.pop();
	        break;
	      case Kind.FIELD:
	        this._fieldDefStack.pop();
	        this._typeStack.pop();
	        break;
	      case Kind.DIRECTIVE:
	        this._directive = null;
	        break;
	      case Kind.OPERATION_DEFINITION:
	      case Kind.INLINE_FRAGMENT:
	      case Kind.FRAGMENT_DEFINITION:
	        this._typeStack.pop();
	        break;
	      case Kind.VARIABLE_DEFINITION:
	        this._inputTypeStack.pop();
	        break;
	      case Kind.ARGUMENT:
	        this._argument = null;
	        this._inputTypeStack.pop();
	        break;
	      case Kind.LIST:
	      case Kind.OBJECT_FIELD:
	        this._inputTypeStack.pop();
	        break;
	      case Kind.ENUM:
	        this._enumValue = null;
	        break;
	    }
	  };
	
	  return TypeInfo;
	}();
	
	/**
	 * Not exactly the same as the executor's definition of getFieldDef, in this
	 * statically evaluated environment we do not always have an Object type,
	 * and need to handle Interface and Union types.
	 */
	
	
	function getFieldDef(schema, parentType, fieldNode) {
	  var name = fieldNode.name.value;
	  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.SchemaMetaFieldDef;
	  }
	  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
	    return _introspection.TypeMetaFieldDef;
	  }
	  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	  if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {
	    return parentType.getFields()[name];
	  }
	}

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.assertValidName = assertValidName;
	exports.formatWarning = formatWarning;
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
	var ERROR_PREFIX_RX = /^Error: /;
	
	// Silences warnings if an environment flag is enabled
	var noNameWarning = Boolean(process && ({"NODE_ENV":"production","PUBLIC_DIR":"/Users/home/Development/veritone-docs/public"}) && ({"NODE_ENV":"production","PUBLIC_DIR":"/Users/home/Development/veritone-docs/public"}).GRAPHQL_NO_NAME_WARNING);
	
	// Ensures console warnings are only issued once.
	var hasWarnedAboutDunder = false;
	
	/**
	 * Upholds the spec rules about naming.
	 */
	function assertValidName(name, isIntrospection) {
	  if (!name || typeof name !== 'string') {
	    throw new Error('Must be named. Unexpected name: ' + name + '.');
	  }
	  if (!isIntrospection && !hasWarnedAboutDunder && !noNameWarning && name.slice(0, 2) === '__') {
	    hasWarnedAboutDunder = true;
	    /* eslint-disable no-console */
	    if (console && console.warn) {
	      var error = new Error('Name "' + name + '" must not begin with "__", which is reserved by ' + 'GraphQL introspection. In a future release of graphql this will ' + 'become a hard error.');
	      console.warn(formatWarning(error));
	    }
	    /* eslint-enable no-console */
	  }
	  if (!NAME_RX.test(name)) {
	    throw new Error('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "' + name + '" does not.');
	  }
	}
	
	/**
	 * Returns a human-readable warning based an the supplied Error object,
	 * including stack trace information if available.
	 */
	function formatWarning(error) {
	  var formatted = '';
	  var errorString = String(error).replace(ERROR_PREFIX_RX, '');
	  var stack = error.stack;
	  if (stack) {
	    formatted = stack.replace(ERROR_PREFIX_RX, '');
	  }
	  if (formatted.indexOf(errorString) === -1) {
	    formatted = errorString + '\n' + formatted;
	  }
	  return formatted.trim();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * 
	                                                                                                                                                                                                                                                                               */
	
	exports.astFromValue = astFromValue;
	
	var _iterall = __webpack_require__(61);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _isInvalid = __webpack_require__(79);
	
	var _isInvalid2 = _interopRequireDefault(_isInvalid);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _definition = __webpack_require__(7);
	
	var _scalars = __webpack_require__(42);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Produces a GraphQL Value AST given a JavaScript value.
	 *
	 * A GraphQL type must be provided, which will be used to interpret different
	 * JavaScript values.
	 *
	 * | JSON Value    | GraphQL Value        |
	 * | ------------- | -------------------- |
	 * | Object        | Input Object         |
	 * | Array         | List                 |
	 * | Boolean       | Boolean              |
	 * | String        | String / Enum Value  |
	 * | Number        | Int / Float          |
	 * | Mixed         | Enum Value           |
	 * | null          | NullValue            |
	 *
	 */
	function astFromValue(value, type) {
	  // Ensure flow knows that we treat function params as const.
	  var _value = value;
	
	  if (type instanceof _definition.GraphQLNonNull) {
	    var astValue = astFromValue(_value, type.ofType);
	    if (astValue && astValue.kind === Kind.NULL) {
	      return null;
	    }
	    return astValue;
	  }
	
	  // only explicit null, not undefined, NaN
	  if (_value === null) {
	    return { kind: Kind.NULL };
	  }
	
	  // undefined, NaN
	  if ((0, _isInvalid2.default)(_value)) {
	    return null;
	  }
	
	  // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
	  // the value is not an array, convert the value using the list's item type.
	  if (type instanceof _definition.GraphQLList) {
	    var itemType = type.ofType;
	    if ((0, _iterall.isCollection)(_value)) {
	      var valuesNodes = [];
	      (0, _iterall.forEach)(_value, function (item) {
	        var itemNode = astFromValue(item, itemType);
	        if (itemNode) {
	          valuesNodes.push(itemNode);
	        }
	      });
	      return { kind: Kind.LIST, values: valuesNodes };
	    }
	    return astFromValue(_value, itemType);
	  }
	
	  // Populate the fields of the input object by creating ASTs from each value
	  // in the JavaScript object according to the fields in the input type.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    if (_value === null || (typeof _value === 'undefined' ? 'undefined' : _typeof(_value)) !== 'object') {
	      return null;
	    }
	    var fields = type.getFields();
	    var fieldNodes = [];
	    Object.keys(fields).forEach(function (fieldName) {
	      var fieldType = fields[fieldName].type;
	      var fieldValue = astFromValue(_value[fieldName], fieldType);
	      if (fieldValue) {
	        fieldNodes.push({
	          kind: Kind.OBJECT_FIELD,
	          name: { kind: Kind.NAME, value: fieldName },
	          value: fieldValue
	        });
	      }
	    });
	    return { kind: Kind.OBJECT, fields: fieldNodes };
	  }
	
	  !(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType) ? (0, _invariant2.default)(0, 'Must provide Input Type, cannot use: ' + String(type)) : void 0;
	
	  // Since value is an internally represented value, it must be serialized
	  // to an externally represented value before converting into an AST.
	  var serialized = type.serialize(_value);
	  if ((0, _isNullish2.default)(serialized)) {
	    return null;
	  }
	
	  // Others serialize based on their corresponding JavaScript scalar types.
	  if (typeof serialized === 'boolean') {
	    return { kind: Kind.BOOLEAN, value: serialized };
	  }
	
	  // JavaScript numbers can be Int or Float values.
	  if (typeof serialized === 'number') {
	    var stringNum = String(serialized);
	    return (/^[0-9]+$/.test(stringNum) ? { kind: Kind.INT, value: stringNum } : { kind: Kind.FLOAT, value: stringNum }
	    );
	  }
	
	  if (typeof serialized === 'string') {
	    // Enum types use Enum literals.
	    if (type instanceof _definition.GraphQLEnumType) {
	      return { kind: Kind.ENUM, value: serialized };
	    }
	
	    // ID types can use Int literals.
	    if (type === _scalars.GraphQLID && /^[0-9]+$/.test(serialized)) {
	      return { kind: Kind.INT, value: serialized };
	    }
	
	    // Use JSON stringify, which uses the same string encoding as GraphQL,
	    // then remove the quotes.
	    return {
	      kind: Kind.STRING,
	      value: JSON.stringify(serialized).slice(1, -1)
	    };
	  }
	
	  throw new TypeError('Cannot convert value to AST: ' + String(serialized));
	}

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unusedFragMessage = unusedFragMessage;
	exports.NoUnusedFragments = NoUnusedFragments;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function unusedFragMessage(fragName) {
	  return 'Fragment "' + fragName + '" is never used.';
	}
	
	/**
	 * No unused fragments
	 *
	 * A GraphQL document is only valid if all fragment definitions are spread
	 * within operations, or spread within other fragments spread within operations.
	 */
	function NoUnusedFragments(context) {
	  var operationDefs = [];
	  var fragmentDefs = [];
	
	  return {
	    OperationDefinition: function OperationDefinition(node) {
	      operationDefs.push(node);
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      fragmentDefs.push(node);
	      return false;
	    },
	
	    Document: {
	      leave: function leave() {
	        var fragmentNameUsed = Object.create(null);
	        operationDefs.forEach(function (operation) {
	          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {
	            fragmentNameUsed[fragment.name.value] = true;
	          });
	        });
	
	        fragmentDefs.forEach(function (fragmentDef) {
	          var fragName = fragmentDef.name.value;
	          if (fragmentNameUsed[fragName] !== true) {
	            context.reportError(new _error.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));
	          }
	        });
	      }
	    }
	  };
	}

/***/ }),
/* 170 */,
/* 171 */,
/* 172 */
/***/ (function(module, exports) {

	'use strict';
	
	var fnToStr = Function.prototype.toString;
	
	var constructorRegex = /^\s*class /;
	var isES6ClassFn = function isES6ClassFn(value) {
		try {
			var fnStr = fnToStr.call(value);
			var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
			var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
			var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
			return constructorRegex.test(spaceStripped);
		} catch (e) {
			return false; // not a function
		}
	};
	
	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	
	module.exports = function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	// the whatwg-fetch polyfill installs the fetch() function
	// on the global object (window or self)
	//
	// Return that as the export for use in Webpack, Browserify etc.
	__webpack_require__(1071);
	module.exports = self.fetch.bind(self);


/***/ }),
/* 174 */,
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* Dependencies. */
	var characterEntities = __webpack_require__(660);
	var legacy = __webpack_require__(659);
	var invalid = __webpack_require__(661);
	var decimal = __webpack_require__(113);
	var hexadecimal = __webpack_require__(637);
	var alphanumerical = __webpack_require__(634);
	
	/* Expose. */
	module.exports = wrapper;
	
	/* Methods. */
	var own = {}.hasOwnProperty;
	var fromCharCode = String.fromCharCode;
	var noop = Function.prototype;
	
	/* Characters. */
	var REPLACEMENT = '\uFFFD';
	var FORM_FEED = '\f';
	var AMPERSAND = '&';
	var OCTOTHORP = '#';
	var SEMICOLON = ';';
	var NEWLINE = '\n';
	var X_LOWER = 'x';
	var X_UPPER = 'X';
	var SPACE = ' ';
	var LESS_THAN = '<';
	var EQUAL = '=';
	var EMPTY = '';
	var TAB = '\t';
	
	/* Default settings. */
	var defaults = {
	  warning: null,
	  reference: null,
	  text: null,
	  warningContext: null,
	  referenceContext: null,
	  textContext: null,
	  position: {},
	  additional: null,
	  attribute: false,
	  nonTerminated: true
	};
	
	/* Reference types. */
	var NAMED = 'named';
	var HEXADECIMAL = 'hexadecimal';
	var DECIMAL = 'decimal';
	
	/* Map of bases. */
	var BASE = {};
	
	BASE[HEXADECIMAL] = 16;
	BASE[DECIMAL] = 10;
	
	/* Map of types to tests. Each type of character reference
	 * accepts different characters. This test is used to
	 * detect whether a reference has ended (as the semicolon
	 * is not strictly needed). */
	var TESTS = {};
	
	TESTS[NAMED] = alphanumerical;
	TESTS[DECIMAL] = decimal;
	TESTS[HEXADECIMAL] = hexadecimal;
	
	/* Warning messages. */
	var NAMED_NOT_TERMINATED = 1;
	var NUMERIC_NOT_TERMINATED = 2;
	var NAMED_EMPTY = 3;
	var NUMERIC_EMPTY = 4;
	var NAMED_UNKNOWN = 5;
	var NUMERIC_DISALLOWED = 6;
	var NUMERIC_PROHIBITED = 7;
	
	var NUMERIC_REFERENCE = 'Numeric character references';
	var NAMED_REFERENCE = 'Named character references';
	var TERMINATED = ' must be terminated by a semicolon';
	var VOID = ' cannot be empty';
	
	var MESSAGES = {};
	
	MESSAGES[NAMED_NOT_TERMINATED] = NAMED_REFERENCE + TERMINATED;
	MESSAGES[NUMERIC_NOT_TERMINATED] = NUMERIC_REFERENCE + TERMINATED;
	MESSAGES[NAMED_EMPTY] = NAMED_REFERENCE + VOID;
	MESSAGES[NUMERIC_EMPTY] = NUMERIC_REFERENCE + VOID;
	MESSAGES[NAMED_UNKNOWN] = NAMED_REFERENCE + ' must be known';
	MESSAGES[NUMERIC_DISALLOWED] = NUMERIC_REFERENCE + ' cannot be disallowed';
	MESSAGES[NUMERIC_PROHIBITED] = NUMERIC_REFERENCE + ' cannot be outside the ' +
	    'permissible Unicode range';
	
	/* Wrap to ensure clean parameters are given to `parse`. */
	function wrapper(value, options) {
	  var settings = {};
	  var option;
	  var key;
	
	  if (!options) {
	    options = {};
	  }
	
	  for (key in defaults) {
	    option = options[key];
	    settings[key] = option === null || option === undefined ? defaults[key] : option;
	  }
	
	  if (settings.position.indent || settings.position.start) {
	    settings.indent = settings.position.indent || [];
	    settings.position = settings.position.start;
	  }
	
	  return parse(value, settings);
	}
	
	/* Parse entities. */
	function parse(value, settings) {
	  var additional = settings.additional;
	  var nonTerminated = settings.nonTerminated;
	  var handleText = settings.text;
	  var handleReference = settings.reference;
	  var handleWarning = settings.warning;
	  var textContext = settings.textContext;
	  var referenceContext = settings.referenceContext;
	  var warningContext = settings.warningContext;
	  var pos = settings.position;
	  var indent = settings.indent || [];
	  var length = value.length;
	  var index = 0;
	  var lines = -1;
	  var column = pos.column || 1;
	  var line = pos.line || 1;
	  var queue = EMPTY;
	  var result = [];
	  var entityCharacters;
	  var terminated;
	  var characters;
	  var character;
	  var reference;
	  var following;
	  var warning;
	  var reason;
	  var output;
	  var entity;
	  var begin;
	  var start;
	  var type;
	  var test;
	  var prev;
	  var next;
	  var diff;
	  var end;
	
	  /* Cache the current point. */
	  prev = now();
	
	  /* Wrap `handleWarning`. */
	  warning = handleWarning ? parseError : noop;
	
	  /* Ensure the algorithm walks over the first character
	   * and the end (inclusive). */
	  index--;
	  length++;
	
	  while (++index < length) {
	    /* If the previous character was a newline. */
	    if (character === NEWLINE) {
	      column = indent[lines] || 1;
	    }
	
	    character = at(index);
	
	    /* Handle anything other than an ampersand,
	     * including newlines and EOF. */
	    if (character !== AMPERSAND) {
	      if (character === NEWLINE) {
	        line++;
	        lines++;
	        column = 0;
	      }
	
	      if (character) {
	        queue += character;
	        column++;
	      } else {
	        flush();
	      }
	    } else {
	      following = at(index + 1);
	
	      /* The behaviour depends on the identity of the next
	       * character. */
	      if (
	        following === TAB ||
	        following === NEWLINE ||
	        following === FORM_FEED ||
	        following === SPACE ||
	        following === LESS_THAN ||
	        following === AMPERSAND ||
	        following === EMPTY ||
	        (additional && following === additional)
	      ) {
	        /* Not a character reference. No characters
	         * are consumed, and nothing is returned.
	         * This is not an error, either. */
	        queue += character;
	        column++;
	
	        continue;
	      }
	
	      start = index + 1;
	      begin = start;
	      end = start;
	
	      /* Numerical entity. */
	      if (following !== OCTOTHORP) {
	        type = NAMED;
	      } else {
	        end = ++begin;
	
	        /* The behaviour further depends on the
	         * character after the U+0023 NUMBER SIGN. */
	        following = at(end);
	
	        if (following === X_LOWER || following === X_UPPER) {
	          /* ASCII hex digits. */
	          type = HEXADECIMAL;
	          end = ++begin;
	        } else {
	          /* ASCII digits. */
	          type = DECIMAL;
	        }
	      }
	
	      entityCharacters = EMPTY;
	      entity = EMPTY;
	      characters = EMPTY;
	      test = TESTS[type];
	      end--;
	
	      while (++end < length) {
	        following = at(end);
	
	        if (!test(following)) {
	          break;
	        }
	
	        characters += following;
	
	        /* Check if we can match a legacy named
	         * reference.  If so, we cache that as the
	         * last viable named reference.  This
	         * ensures we do not need to walk backwards
	         * later. */
	        if (type === NAMED && own.call(legacy, characters)) {
	          entityCharacters = characters;
	          entity = legacy[characters];
	        }
	      }
	
	      terminated = at(end) === SEMICOLON;
	
	      if (terminated) {
	        end++;
	
	        if (type === NAMED && own.call(characterEntities, characters)) {
	          entityCharacters = characters;
	          entity = characterEntities[characters];
	        }
	      }
	
	      diff = 1 + end - start;
	
	      if (!terminated && !nonTerminated) {
	        /* Empty. */
	      } else if (!characters) {
	        /* An empty (possible) entity is valid, unless
	         * its numeric (thus an ampersand followed by
	         * an octothorp). */
	        if (type !== NAMED) {
	          warning(NUMERIC_EMPTY, diff);
	        }
	      } else if (type === NAMED) {
	        /* An ampersand followed by anything
	         * unknown, and not terminated, is invalid. */
	        if (terminated && !entity) {
	          warning(NAMED_UNKNOWN, 1);
	        } else {
	          /* If theres something after an entity
	           * name which is not known, cap the
	           * reference. */
	          if (entityCharacters !== characters) {
	            end = begin + entityCharacters.length;
	            diff = 1 + end - begin;
	            terminated = false;
	          }
	
	          /* If the reference is not terminated,
	           * warn. */
	          if (!terminated) {
	            reason = entityCharacters ?
	              NAMED_NOT_TERMINATED :
	              NAMED_EMPTY;
	
	            if (!settings.attribute) {
	              warning(reason, diff);
	            } else {
	              following = at(end);
	
	              if (following === EQUAL) {
	                warning(reason, diff);
	                entity = null;
	              } else if (alphanumerical(following)) {
	                entity = null;
	              } else {
	                warning(reason, diff);
	              }
	            }
	          }
	        }
	
	        reference = entity;
	      } else {
	        if (!terminated) {
	          /* All non-terminated numeric entities are
	           * not rendered, and trigger a warning. */
	          warning(NUMERIC_NOT_TERMINATED, diff);
	        }
	
	        /* When terminated and number, parse as
	         * either hexadecimal or decimal. */
	        reference = parseInt(characters, BASE[type]);
	
	        /* Trigger a warning when the parsed number
	         * is prohibited, and replace with
	         * replacement character. */
	        if (isProhibited(reference)) {
	          warning(NUMERIC_PROHIBITED, diff);
	
	          reference = REPLACEMENT;
	        } else if (reference in invalid) {
	          /* Trigger a warning when the parsed number
	           * is disallowed, and replace by an
	           * alternative. */
	          warning(NUMERIC_DISALLOWED, diff);
	
	          reference = invalid[reference];
	        } else {
	          /* Parse the number. */
	          output = EMPTY;
	
	          /* Trigger a warning when the parsed
	           * number should not be used. */
	          if (isWarning(reference)) {
	            warning(NUMERIC_DISALLOWED, diff);
	          }
	
	          /* Stringify the number. */
	          if (reference > 0xFFFF) {
	            reference -= 0x10000;
	            output += fromCharCode((reference >>> (10 & 0x3FF)) | 0xD800);
	            reference = 0xDC00 | (reference & 0x3FF);
	          }
	
	          reference = output + fromCharCode(reference);
	        }
	      }
	
	      /* If we could not find a reference, queue the
	       * checked characters (as normal characters),
	       * and move the pointer to their end. This is
	       * possible because we can be certain neither
	       * newlines nor ampersands are included. */
	      if (!reference) {
	        characters = value.slice(start - 1, end);
	        queue += characters;
	        column += characters.length;
	        index = end - 1;
	      } else {
	        /* Found it! First eat the queued
	         * characters as normal text, then eat
	         * an entity. */
	        flush();
	
	        prev = now();
	        index = end - 1;
	        column += end - start + 1;
	        result.push(reference);
	        next = now();
	        next.offset++;
	
	        if (handleReference) {
	          handleReference.call(referenceContext, reference, {
	            start: prev,
	            end: next
	          }, value.slice(start - 1, end));
	        }
	
	        prev = next;
	      }
	    }
	  }
	
	  /* Return the reduced nodes, and any possible warnings. */
	  return result.join(EMPTY);
	
	  /* Get current position. */
	  function now() {
	    return {
	      line: line,
	      column: column,
	      offset: index + (pos.offset || 0)
	    };
	  }
	
	  /* “Throw” a parse-error: a warning. */
	  function parseError(code, offset) {
	    var position = now();
	
	    position.column += offset;
	    position.offset += offset;
	
	    handleWarning.call(warningContext, MESSAGES[code], position, code);
	  }
	
	  /* Get character at position. */
	  function at(position) {
	    return value.charAt(position);
	  }
	
	  /* Flush `queue` (normal text). Macro invoked before
	   * each entity and at the end of `value`.
	   * Does nothing when `queue` is empty. */
	  function flush() {
	    if (queue) {
	      result.push(queue);
	
	      if (handleText) {
	        handleText.call(textContext, queue, {
	          start: prev,
	          end: now()
	        });
	      }
	
	      queue = EMPTY;
	    }
	  }
	}
	
	/* Check if `character` is outside the permissible
	 * unicode range. */
	function isProhibited(code) {
	  return (code >= 0xD800 && code <= 0xDFFF) || (code > 0x10FFFF);
	}
	
	/* Check if `character` is disallowed. */
	function isWarning(code) {
	  if (
	    (code >= 0x0001 && code <= 0x0008) ||
	    code === 0x000B ||
	    (code >= 0x000D && code <= 0x001F) ||
	    (code >= 0x007F && code <= 0x009F) ||
	    (code >= 0xFDD0 && code <= 0xFDEF) ||
	    (code & 0xFFFF) === 0xFFFF ||
	    (code & 0xFFFF) === 0xFFFE
	  ) {
	    return true;
	  }
	
	  return false;
	}


/***/ }),
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Modal = __webpack_require__(752);
	
	var _Modal2 = _interopRequireDefault(_Modal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _Modal2.default;
	module.exports = exports["default"];

/***/ }),
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DEFAULT_MAX_SCROLL_SIZE = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _CellSizeAndPositionManager = __webpack_require__(822);
	
	var _CellSizeAndPositionManager2 = _interopRequireDefault(_CellSizeAndPositionManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var babelPluginFlowReactPropTypes_proptype_VisibleCellRange = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_VisibleCellRange || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(1).any;
	
	/**
	 * Browsers have scroll offset limitations (eg Chrome stops scrolling at ~33.5M pixels where as Edge tops out at ~1.5M pixels).
	 * After a certain position, the browser won't allow the user to scroll further (even via JavaScript scroll offset adjustments).
	 * This util picks a lower ceiling for max size and artificially adjusts positions within to make it transparent for users.
	 */
	var DEFAULT_MAX_SCROLL_SIZE = exports.DEFAULT_MAX_SCROLL_SIZE = 1500000;
	
	/**
	 * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.
	 */
	var ScalingCellSizeAndPositionManager = function () {
	  function ScalingCellSizeAndPositionManager(_ref) {
	    var _ref$maxScrollSize = _ref.maxScrollSize,
	        maxScrollSize = _ref$maxScrollSize === undefined ? DEFAULT_MAX_SCROLL_SIZE : _ref$maxScrollSize,
	        params = _objectWithoutProperties(_ref, ['maxScrollSize']);
	
	    _classCallCheck(this, ScalingCellSizeAndPositionManager);
	
	    // Favor composition over inheritance to simplify IE10 support
	    this._cellSizeAndPositionManager = new _CellSizeAndPositionManager2.default(params);
	    this._maxScrollSize = maxScrollSize;
	  }
	
	  _createClass(ScalingCellSizeAndPositionManager, [{
	    key: 'areOffsetsAdjusted',
	    value: function areOffsetsAdjusted() {
	      return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
	    }
	  }, {
	    key: 'configure',
	    value: function configure(params) {
	      this._cellSizeAndPositionManager.configure(params);
	    }
	  }, {
	    key: 'getCellCount',
	    value: function getCellCount() {
	      return this._cellSizeAndPositionManager.getCellCount();
	    }
	  }, {
	    key: 'getEstimatedCellSize',
	    value: function getEstimatedCellSize() {
	      return this._cellSizeAndPositionManager.getEstimatedCellSize();
	    }
	  }, {
	    key: 'getLastMeasuredIndex',
	    value: function getLastMeasuredIndex() {
	      return this._cellSizeAndPositionManager.getLastMeasuredIndex();
	    }
	
	    /**
	     * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.
	     * The offset passed to this function is scaled (safe) as well.
	     */
	
	  }, {
	    key: 'getOffsetAdjustment',
	    value: function getOffsetAdjustment(_ref2) {
	      var containerSize = _ref2.containerSize,
	          offset = _ref2.offset;
	
	      var totalSize = this._cellSizeAndPositionManager.getTotalSize();
	      var safeTotalSize = this.getTotalSize();
	      var offsetPercentage = this._getOffsetPercentage({
	        containerSize: containerSize,
	        offset: offset,
	        totalSize: safeTotalSize
	      });
	
	      return Math.round(offsetPercentage * (safeTotalSize - totalSize));
	    }
	  }, {
	    key: 'getSizeAndPositionOfCell',
	    value: function getSizeAndPositionOfCell(index) {
	      return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
	    }
	  }, {
	    key: 'getSizeAndPositionOfLastMeasuredCell',
	    value: function getSizeAndPositionOfLastMeasuredCell() {
	      return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
	    }
	
	    /** See CellSizeAndPositionManager#getTotalSize */
	
	  }, {
	    key: 'getTotalSize',
	    value: function getTotalSize() {
	      return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
	    }
	
	    /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */
	
	  }, {
	    key: 'getUpdatedOffsetForIndex',
	    value: function getUpdatedOffsetForIndex(_ref3) {
	      var _ref3$align = _ref3.align,
	          align = _ref3$align === undefined ? 'auto' : _ref3$align,
	          containerSize = _ref3.containerSize,
	          currentOffset = _ref3.currentOffset,
	          targetIndex = _ref3.targetIndex;
	
	      currentOffset = this._safeOffsetToOffset({
	        containerSize: containerSize,
	        offset: currentOffset
	      });
	
	      var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
	        align: align,
	        containerSize: containerSize,
	        currentOffset: currentOffset,
	        targetIndex: targetIndex
	      });
	
	      return this._offsetToSafeOffset({
	        containerSize: containerSize,
	        offset: offset
	      });
	    }
	
	    /** See CellSizeAndPositionManager#getVisibleCellRange */
	
	  }, {
	    key: 'getVisibleCellRange',
	    value: function getVisibleCellRange(_ref4) {
	      var containerSize = _ref4.containerSize,
	          offset = _ref4.offset;
	
	      offset = this._safeOffsetToOffset({
	        containerSize: containerSize,
	        offset: offset
	      });
	
	      return this._cellSizeAndPositionManager.getVisibleCellRange({
	        containerSize: containerSize,
	        offset: offset
	      });
	    }
	  }, {
	    key: 'resetCell',
	    value: function resetCell(index) {
	      this._cellSizeAndPositionManager.resetCell(index);
	    }
	  }, {
	    key: '_getOffsetPercentage',
	    value: function _getOffsetPercentage(_ref5) {
	      var containerSize = _ref5.containerSize,
	          offset = _ref5.offset,
	          totalSize = _ref5.totalSize;
	
	      return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
	    }
	  }, {
	    key: '_offsetToSafeOffset',
	    value: function _offsetToSafeOffset(_ref6) {
	      var containerSize = _ref6.containerSize,
	          offset = _ref6.offset;
	
	      var totalSize = this._cellSizeAndPositionManager.getTotalSize();
	      var safeTotalSize = this.getTotalSize();
	
	      if (totalSize === safeTotalSize) {
	        return offset;
	      } else {
	        var offsetPercentage = this._getOffsetPercentage({
	          containerSize: containerSize,
	          offset: offset,
	          totalSize: totalSize
	        });
	
	        return Math.round(offsetPercentage * (safeTotalSize - containerSize));
	      }
	    }
	  }, {
	    key: '_safeOffsetToOffset',
	    value: function _safeOffsetToOffset(_ref7) {
	      var containerSize = _ref7.containerSize,
	          offset = _ref7.offset;
	
	      var totalSize = this._cellSizeAndPositionManager.getTotalSize();
	      var safeTotalSize = this.getTotalSize();
	
	      if (totalSize === safeTotalSize) {
	        return offset;
	      } else {
	        var offsetPercentage = this._getOffsetPercentage({
	          containerSize: containerSize,
	          offset: offset,
	          totalSize: safeTotalSize
	        });
	
	        return Math.round(offsetPercentage * (totalSize - containerSize));
	      }
	    }
	  }]);
	
	  return ScalingCellSizeAndPositionManager;
	}();
	
	exports.default = ScalingCellSizeAndPositionManager;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RowRendererParams', {
	  value: {
	    index: __webpack_require__(1).number.isRequired,
	    isScrolling: __webpack_require__(1).bool.isRequired,
	    isVisible: __webpack_require__(1).bool.isRequired,
	    key: __webpack_require__(1).string.isRequired,
	    parent: __webpack_require__(1).object.isRequired,
	    style: __webpack_require__(1).object.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RowRenderer', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RenderedRows', {
	  value: {
	    overscanStartIndex: __webpack_require__(1).number.isRequired,
	    overscanStopIndex: __webpack_require__(1).number.isRequired,
	    startIndex: __webpack_require__(1).number.isRequired,
	    stopIndex: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Scroll', {
	  value: {
	    clientHeight: __webpack_require__(1).number.isRequired,
	    scrollHeight: __webpack_require__(1).number.isRequired,
	    scrollTop: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _PositionCache = __webpack_require__(829);
	
	var _PositionCache2 = _interopRequireDefault(_PositionCache);
	
	var _requestAnimationTimeout = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId = __webpack_require__(87).babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId || __webpack_require__(1).any;
	
	var emptyObject = {};
	
	/**
	 * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
	 * This improves performance and makes scrolling smoother.
	 */
	var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
	
	/**
	 * This component efficiently displays arbitrarily positioned cells using windowing techniques.
	 * Cell position is determined by an injected `cellPositioner` property.
	 * Windowing is vertical; this component does not support horizontal scrolling.
	 *
	 * Rendering occurs in two phases:
	 * 1) First pass uses estimated cell sizes (provided by the cache) to determine how many cells to measure in a batch.
	 *    Batch size is chosen using a fast, naive layout algorithm that stacks images in order until the viewport has been filled.
	 *    After measurement is complete (componentDidMount or componentDidUpdate) this component evaluates positioned cells
	 *    in order to determine if another measurement pass is required (eg if actual cell sizes were less than estimated sizes).
	 *    All measurements are permanently cached (keyed by `keyMapper`) for performance purposes.
	 * 2) Second pass uses the external `cellPositioner` to layout cells.
	 *    At this time the positioner has access to cached size measurements for all cells.
	 *    The positions it returns are cached by Masonry for fast access later.
	 *    Phase one is repeated if the user scrolls beyond the current layout's bounds.
	 *    If the layout is invalidated due to eg a resize, cached positions can be cleared using `recomputeCellPositions()`.
	 *
	 * Animation constraints:
	 *   Simple animations are supported (eg translate/slide into place on initial reveal).
	 *   More complex animations are not (eg flying from one position to another on resize).
	 *
	 * Layout constraints:
	 *   This component supports multi-column layout.
	 *   The height of each item may vary.
	 *   The width of each item must not exceed the width of the column it is "in".
	 *   The left position of all items within a column must align.
	 *   (Items may not span multiple columns.)
	 */
	
	var Masonry = function (_PureComponent) {
	  _inherits(Masonry, _PureComponent);
	
	  function Masonry(props, context) {
	    _classCallCheck(this, Masonry);
	
	    var _this = _possibleConstructorReturn(this, (Masonry.__proto__ || Object.getPrototypeOf(Masonry)).call(this, props, context));
	
	    _this._invalidateOnUpdateStartIndex = null;
	    _this._invalidateOnUpdateStopIndex = null;
	    _this._positionCache = new _PositionCache2.default();
	    _this._startIndex = null;
	    _this._startIndexMemoized = null;
	    _this._stopIndex = null;
	    _this._stopIndexMemoized = null;
	
	
	    _this.state = {
	      isScrolling: false,
	      scrollTop: 0
	    };
	
	    _this._debounceResetIsScrollingCallback = _this._debounceResetIsScrollingCallback.bind(_this);
	    _this._setScrollingContainerRef = _this._setScrollingContainerRef.bind(_this);
	    _this._onScroll = _this._onScroll.bind(_this);
	    return _this;
	  }
	
	  _createClass(Masonry, [{
	    key: 'clearCellPositions',
	    value: function clearCellPositions() {
	      this._positionCache = new _PositionCache2.default();
	      this.forceUpdate();
	    }
	
	    // HACK This method signature was intended for Grid
	
	  }, {
	    key: 'invalidateCellSizeAfterRender',
	    value: function invalidateCellSizeAfterRender(_ref) {
	      var index = _ref.rowIndex;
	
	      if (this._invalidateOnUpdateStartIndex === null) {
	        this._invalidateOnUpdateStartIndex = index;
	        this._invalidateOnUpdateStopIndex = index;
	      } else {
	        this._invalidateOnUpdateStartIndex = Math.min(this._invalidateOnUpdateStartIndex, index);
	        this._invalidateOnUpdateStopIndex = Math.max(this._invalidateOnUpdateStopIndex, index);
	      }
	    }
	  }, {
	    key: 'recomputeCellPositions',
	    value: function recomputeCellPositions() {
	      var stopIndex = this._positionCache.count - 1;
	
	      this._positionCache = new _PositionCache2.default();
	      this._populatePositionCache(0, stopIndex);
	
	      this.forceUpdate();
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this._checkInvalidateOnUpdate();
	      this._invokeOnScrollCallback();
	      this._invokeOnCellsRenderedCallback();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._checkInvalidateOnUpdate();
	      this._invokeOnScrollCallback();
	      this._invokeOnCellsRenderedCallback();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      if (this._debounceResetIsScrollingId) {
	        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var scrollTop = this.props.scrollTop;
	
	
	      if (scrollTop !== nextProps.scrollTop) {
	        this._debounceResetIsScrolling();
	
	        this.setState({
	          isScrolling: true,
	          scrollTop: nextProps.scrollTop
	        });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var _props = this.props,
	          autoHeight = _props.autoHeight,
	          cellCount = _props.cellCount,
	          cellMeasurerCache = _props.cellMeasurerCache,
	          cellRenderer = _props.cellRenderer,
	          className = _props.className,
	          height = _props.height,
	          id = _props.id,
	          keyMapper = _props.keyMapper,
	          overscanByPixels = _props.overscanByPixels,
	          role = _props.role,
	          style = _props.style,
	          tabIndex = _props.tabIndex,
	          width = _props.width;
	      var _state = this.state,
	          isScrolling = _state.isScrolling,
	          scrollTop = _state.scrollTop;
	
	
	      var children = [];
	
	      var estimateTotalHeight = this._getEstimatedTotalHeight();
	
	      var shortestColumnSize = this._positionCache.shortestColumnSize;
	      var measuredCellCount = this._positionCache.count;
	
	      var startIndex = 0;
	      var stopIndex = void 0;
	
	      this._positionCache.range(Math.max(0, scrollTop - overscanByPixels), height + overscanByPixels * 2, function (index, left, top) {
	        if (typeof stopIndex === 'undefined') {
	          startIndex = index;
	          stopIndex = index;
	        } else {
	          startIndex = Math.min(startIndex, index);
	          stopIndex = Math.max(stopIndex, index);
	        }
	
	        children.push(cellRenderer({
	          index: index,
	          isScrolling: isScrolling,
	          key: keyMapper(index),
	          parent: _this2,
	          style: {
	            height: cellMeasurerCache.getHeight(index),
	            left: left,
	            position: 'absolute',
	            top: top,
	            width: cellMeasurerCache.getWidth(index)
	          }
	        }));
	      });
	
	      // We need to measure additional cells for this layout
	      if (shortestColumnSize < scrollTop + height + overscanByPixels && measuredCellCount < cellCount) {
	        var batchSize = Math.min(cellCount - measuredCellCount, Math.ceil((scrollTop + height + overscanByPixels - shortestColumnSize) / cellMeasurerCache.defaultHeight * width / cellMeasurerCache.defaultWidth));
	
	        for (var _index = measuredCellCount; _index < measuredCellCount + batchSize; _index++) {
	          stopIndex = _index;
	
	          children.push(cellRenderer({
	            index: _index,
	            isScrolling: isScrolling,
	            key: keyMapper(_index),
	            parent: this,
	            style: {
	              width: cellMeasurerCache.getWidth(_index)
	            }
	          }));
	        }
	      }
	
	      this._startIndex = startIndex;
	      this._stopIndex = stopIndex;
	
	      return _react2.default.createElement(
	        'div',
	        {
	          ref: this._setScrollingContainerRef,
	          'aria-label': this.props['aria-label'],
	          className: (0, _classnames2.default)('ReactVirtualized__Masonry', className),
	          id: id,
	          onScroll: this._onScroll,
	          role: role,
	          style: _extends({
	            boxSizing: 'border-box',
	            direction: 'ltr',
	            height: autoHeight ? 'auto' : height,
	            overflowX: 'hidden',
	            overflowY: estimateTotalHeight < height ? 'hidden' : 'auto',
	            position: 'relative',
	            width: width,
	            WebkitOverflowScrolling: 'touch',
	            willChange: 'transform'
	          }, style),
	          tabIndex: tabIndex },
	        _react2.default.createElement(
	          'div',
	          {
	            className: 'ReactVirtualized__Masonry__innerScrollContainer',
	            style: {
	              width: '100%',
	              height: estimateTotalHeight,
	              maxWidth: '100%',
	              maxHeight: estimateTotalHeight,
	              overflow: 'hidden',
	              pointerEvents: isScrolling ? 'none' : '',
	              position: 'relative'
	            } },
	          children
	        )
	      );
	    }
	  }, {
	    key: '_checkInvalidateOnUpdate',
	    value: function _checkInvalidateOnUpdate() {
	      if (typeof this._invalidateOnUpdateStartIndex === 'number') {
	        var _startIndex = this._invalidateOnUpdateStartIndex;
	        var _stopIndex = this._invalidateOnUpdateStopIndex;
	
	        this._invalidateOnUpdateStartIndex = null;
	        this._invalidateOnUpdateStopIndex = null;
	
	        // Query external layout logic for position of newly-measured cells
	        this._populatePositionCache(_startIndex, _stopIndex);
	
	        this.forceUpdate();
	      }
	    }
	  }, {
	    key: '_debounceResetIsScrolling',
	    value: function _debounceResetIsScrolling() {
	      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
	
	
	      if (this._debounceResetIsScrollingId) {
	        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
	      }
	
	      this._debounceResetIsScrollingId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceResetIsScrollingCallback, scrollingResetTimeInterval);
	    }
	  }, {
	    key: '_debounceResetIsScrollingCallback',
	    value: function _debounceResetIsScrollingCallback() {
	      this.setState({
	        isScrolling: false
	      });
	    }
	  }, {
	    key: '_getEstimatedTotalHeight',
	    value: function _getEstimatedTotalHeight() {
	      var _props2 = this.props,
	          cellCount = _props2.cellCount,
	          cellMeasurerCache = _props2.cellMeasurerCache,
	          width = _props2.width;
	
	
	      var estimatedColumnCount = Math.floor(width / cellMeasurerCache.defaultWidth);
	
	      return this._positionCache.estimateTotalHeight(cellCount, estimatedColumnCount, cellMeasurerCache.defaultHeight);
	    }
	  }, {
	    key: '_invokeOnScrollCallback',
	    value: function _invokeOnScrollCallback() {
	      var _props3 = this.props,
	          height = _props3.height,
	          onScroll = _props3.onScroll;
	      var scrollTop = this.state.scrollTop;
	
	
	      if (this._onScrollMemoized !== scrollTop) {
	        onScroll({
	          clientHeight: height,
	          scrollHeight: this._getEstimatedTotalHeight(),
	          scrollTop: scrollTop
	        });
	
	        this._onScrollMemoized = scrollTop;
	      }
	    }
	  }, {
	    key: '_invokeOnCellsRenderedCallback',
	    value: function _invokeOnCellsRenderedCallback() {
	      if (this._startIndexMemoized !== this._startIndex || this._stopIndexMemoized !== this._stopIndex) {
	        var _onCellsRendered = this.props.onCellsRendered;
	
	
	        _onCellsRendered({
	          startIndex: this._startIndex,
	          stopIndex: this._stopIndex
	        });
	
	        this._startIndexMemoized = this._startIndex;
	        this._stopIndexMemoized = this._stopIndex;
	      }
	    }
	  }, {
	    key: '_populatePositionCache',
	    value: function _populatePositionCache(startIndex, stopIndex) {
	      var _props4 = this.props,
	          cellMeasurerCache = _props4.cellMeasurerCache,
	          cellPositioner = _props4.cellPositioner;
	
	
	      for (var _index2 = startIndex; _index2 <= stopIndex; _index2++) {
	        var _cellPositioner = cellPositioner(_index2),
	            _left = _cellPositioner.left,
	            _top = _cellPositioner.top;
	
	        this._positionCache.setPosition(_index2, _left, _top, cellMeasurerCache.getHeight(_index2));
	      }
	    }
	  }, {
	    key: '_setScrollingContainerRef',
	    value: function _setScrollingContainerRef(ref) {
	      this._scrollingContainer = ref;
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(event) {
	      var height = this.props.height;
	
	
	      var eventScrollTop = event.target.scrollTop;
	
	      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
	      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
	      // This causes a series of rapid renders that is slow for long lists.
	      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.
	      var scrollTop = Math.min(Math.max(0, this._getEstimatedTotalHeight() - height), eventScrollTop);
	
	      // On iOS, we can arrive at negative offsets by swiping past the start or end.
	      // Avoid re-rendering in this case as it can cause problems; see #532 for more.
	      if (eventScrollTop !== scrollTop) {
	        return;
	      }
	
	      // Prevent pointer events from interrupting a smooth scroll
	      this._debounceResetIsScrolling();
	
	      // Certain devices (like Apple touchpad) rapid-fire duplicate events.
	      // Don't force a re-render if this is the case.
	      // The mouse may move faster then the animation frame does.
	      // Use requestAnimationFrame to avoid over-updating.
	      if (this.state.scrollTop !== scrollTop) {
	        this.setState({
	          isScrolling: true,
	          scrollTop: scrollTop
	        });
	      }
	    }
	  }]);
	
	  return Masonry;
	}(_react.PureComponent);
	
	Masonry.defaultProps = {
	  autoHeight: false,
	  keyMapper: identity,
	  onCellsRendered: noop,
	  onScroll: noop,
	  overscanByPixels: 20,
	  role: 'grid',
	  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
	  style: emptyObject,
	  tabIndex: 0
	};
	exports.default = Masonry;
	
	
	function identity(value) {
	  return value;
	}
	
	function noop() {}
	
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellMeasurerCache', {
	  value: {
	    defaultHeight: __webpack_require__(1).number.isRequired,
	    defaultWidth: __webpack_require__(1).number.isRequired,
	    getHeight: __webpack_require__(1).func.isRequired,
	    getWidth: __webpack_require__(1).func.isRequired
	  },
	  configurable: true
	});
	if (true) Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Positioner', {
	  value: __webpack_require__(1).func,
	  configurable: true
	});

/***/ }),
/* 199 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createCallbackMemoizer;
	/**
	 * Helper utility that updates the specified callback whenever any of the specified indices have changed.
	 */
	function createCallbackMemoizer() {
	  var requireAllKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	  var cachedIndices = {};
	
	  return function (_ref) {
	    var callback = _ref.callback,
	        indices = _ref.indices;
	
	    var keys = Object.keys(indices);
	    var allInitialized = !requireAllKeys || keys.every(function (key) {
	      var value = indices[key];
	      return Array.isArray(value) ? value.length > 0 : value >= 0;
	    });
	    var indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function (key) {
	      var cachedValue = cachedIndices[key];
	      var value = indices[key];
	
	      return Array.isArray(value) ? cachedValue.join(',') !== value.join(',') : cachedValue !== value;
	    });
	
	    cachedIndices = indices;
	
	    if (allInitialized && indexChanged) {
	      callback(indices);
	    }
	  };
	}

/***/ }),
/* 200 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = interrupt;
	
	function interrupt(interruptors, tokenizers, ctx, params) {
	  var bools = ['pedantic', 'commonmark'];
	  var count = bools.length;
	  var length = interruptors.length;
	  var index = -1;
	  var interruptor;
	  var config;
	  var fn;
	  var offset;
	  var bool;
	  var ignore;
	
	  while (++index < length) {
	    interruptor = interruptors[index];
	    config = interruptor[1] || {};
	    fn = interruptor[0];
	    offset = -1;
	    ignore = false;
	
	    while (++offset < count) {
	      bool = bools[offset];
	
	      if (config[bool] !== undefined && config[bool] !== ctx.options[bool]) {
	        ignore = true;
	        break;
	      }
	    }
	
	    if (ignore) {
	      continue;
	    }
	
	    if (tokenizers[fn].apply(ctx, params)) {
	      return true;
	    }
	  }
	
	  return false;
	}


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var collapseWhiteSpace = __webpack_require__(409);
	
	module.exports = normalize;
	
	/* Normalize an identifier.  Collapses multiple white space
	 * characters into a single space, and removes casing. */
	function normalize(value) {
	  return collapseWhiteSpace(value).toLowerCase();
	}


/***/ }),
/* 202 */
/***/ (function(module, exports) {

	/*!
	 * repeat-string <https://github.com/jonschlinkert/repeat-string>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Results cache
	 */
	
	var res = '';
	var cache;
	
	/**
	 * Expose `repeat`
	 */
	
	module.exports = repeat;
	
	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */
	
	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }
	
	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;
	
	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }
	
	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }
	
	    num >>= 1;
	    str += str;
	  }
	
	  res += str;
	  res = res.substr(0, max);
	  return res;
	}


/***/ }),
/* 203 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	// CommonJS / Node have global context exposed as "global" variable.
	// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
	// the global "global" var for now.
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _root = __window || __global || __self;
	exports.root = _root;
	// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
	// This is needed when used with angular/tsickle which inserts a goog.module statement.
	// Wrap in IIFE
	(function () {
	    if (!_root) {
	        throw new Error('RxJS could not find any global context (window, self, global)');
	    }
	})();
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 204 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = trimTrailingLines;
	
	var line = '\n';
	
	/* Remove final newline characters from `value`. */
	function trimTrailingLines(value) {
	  var val = String(value);
	  var index = val.length;
	
	  while (val.charAt(--index) === line) { /* empty */ }
	
	  return val.slice(0, index + 1);
	}


/***/ }),
/* 205 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjxzdmcgd2lkdGg9IjUwcHgiIGhlaWdodD0iNTBweCIgdmlld0JveD0iMCAwIDUwIDUwIj4NCgk8cGF0aCBpZD0iWE1MSURfM18iIGQ9Ik00Mi4xNiwzNi4zN2wtMTAuNDYtMy43M3YtNS4xNWMzLjItMi42Myw1LjMxLTcsNS4zMS0xMS45NWMwLTAuMTYtMC4wMi0wLjMyLTAuMDItMC40OA0KCQljLTAuNywwLjI1LTEuNDcsMC40OC0yLjIyLDAuNDhjLTMuNywwLTYuMjYtMC41OS04LjQxLTMuNDdjLTEuOTEsMi4wMS01LjI4LDMuNDctOC4zNiwzLjQ3Yy0xLjQ1LDAtMy44NS0wLjkzLTUuNS0xLjY3DQoJCWMtMC4wNSwwLjU1LTAuMDksMS4xMS0wLjA5LDEuNjdjMCw1LjIzLDIuMzUsOS44LDUuODcsMTIuMzZ2NC43M0w3LjgzLDM2LjM3Yy0zLjExLDEuMTEtNS4xOSw0LjA3LTUuMTksNy4zN1Y0OWg0NC43MnYtNS4yNg0KCQlDNDcuMzYsNDAuNDQsNDUuMjcsMzcuNDgsNDIuMTYsMzYuMzd6Ii8+DQoJPHBhdGggaWQ9IlhNTElEXzJfIiBkPSJNMjUuNDQsOS41OGwwLjk1LTEuODFsMS4wMiwxLjc4YzEuODQsMy4yMSwzLjc2LDMuNzUsNy4zOCwzLjc1YzAuNTgsMCwxLjM3LTAuMjksMi0wLjU1DQoJCUMzNS42OCw2LjA2LDMwLjY5LDEsMjQuNzIsMUMxOS4xLDEsMTQuMzYsNS40OCwxMi45LDExLjU4YzEuNzIsMC44MSw0LjExLDEuNzIsNS4xMiwxLjcyQzIwLjk0LDEzLjMsMjQuNDEsMTEuNTYsMjUuNDQsOS41OHoiLz4NCjwvc3ZnPg0K"

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTRweCIgaGVpZ2h0PSIxNHB4IiB2aWV3Qm94PSIwIDMgMTQgMTQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgIDxwYXRoIGQ9Ik0xMi40MDksNS41NjMgQzEyLjM2NCw1LjYzNiAxMi4zMDcsNS42OTggMTIuMjc3LDUuNzg0IEMxMi4yODMsNS43ODUgMTEuOTU0LDcuNTE3IDEwLjYxNSw4LjE4NiBDMTAuNTA3LDguMjQgMTAuMzg1LDguMjUzIDEwLjI3MSw4LjIyNSBDOS41NTUsOC4wNDUgOS4wOSw4LjExMSA5LjA4OCw4LjExMiBDOS4wODMsOC4xOTEgOS4yMjUsOC41OTIgOS4zMDEsOC44MDYgQzkuMzMyLDguODk1IDkuMzYyLDguOTgxIDkuMzkxLDkuMDY2IEM5LjQ3Miw5LjA0MSA5LjU2NSw5LjAwNSA5LjYwNSw4Ljk4NiBDOS44NTUsOC44NjcgMTAuMTQ5LDguOTY2IDEwLjI3Myw5LjIwOCBDMTAuNzY4LDEwLjE4NCAxMC44NjEsMTEuMDQyIDEwLjU1MywxMS43NTkgQzEwLjIyNywxMi41MTQgOS41NDcsMTIuODU4IDkuMjU2LDEyLjk3NSBDOC43OTUsMTMuNDQ2IDguNTQ2LDEzLjc5NCA4LjM0NSwxNC4wNzcgQzcuODU1LDE0Ljc2MiA3LjU2NCwxNS4wMjEgNi40MzYsMTUuMDIxIEM1LjcwOSwxNS4wMjEgNS4wODcsMTMuNDcyIDUuMDg3LDEzLjEwOCBDNS4wODcsMTEuMjk4IDQuMjk3LDExLjA2NiAzLjYwOSwxMS4wNjYgQzIuNjg0LDExLjA2NiAyLjI2MiwxMC4yMiAyLjI2Miw5LjQzNSBDMi4yNjIsOS4zMzcgMi4yODIsNy4wNDIgNC4wNzYsNi42ODQgQzQuOTM5LDYuNTEyIDUuNTIsNi41OTIgNS44NSw2LjkyMiBDNS45MSw2Ljk4MiA1Ljk1NCw3LjA0MyA1Ljk4OCw3LjEwMyBDNi4yNzEsNy4wOTQgNi41NDIsNi45MzcgNi42MTIsNi43MzMgQzYuNjkzLDYuNDk2IDYuNDg1LDYuMTYyIDYuMDQzLDUuODE3IEM1LjgxOSw1LjY0NCA1LjcxNyw1LjM5NSA1Ljc2MSw1LjEzMyBDNS44NTksNC41NTYgNi44NjIsMy45NDIgOC43NDEsMy4zMDkgQzguNzU3LDMuMyA4Ljc4OCwzLjI3NyA4LjgyMiwzLjI0OSBDOC4yNCwzLjA5MiA3LjYzMSwzIDcsMyBDMy4xNDEsMyAwLDYuMTQgMCwxMCBDMCwxMy44NiAzLjE0MSwxNyA3LDE3IEMxMC44NTksMTcgMTQsMTMuODYgMTQsMTAgQzE0LDguMzE3IDEzLjQwMiw2Ljc3MSAxMi40MDksNS41NjMgWiI+PC9wYXRoPgo8L3N2Zz4="

/***/ }),
/* 207 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(1065);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var defaults = {
	    pairs: "()[]{}''\"\"",
	    triples: "",
	    explode: "[]{}"
	  };
	
	  var Pos = CodeMirror.Pos;
	
	  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.removeKeyMap(keyMap);
	      cm.state.closeBrackets = null;
	    }
	    if (val) {
	      ensureBound(getOption(val, "pairs"))
	      cm.state.closeBrackets = val;
	      cm.addKeyMap(keyMap);
	    }
	  });
	
	  function getOption(conf, name) {
	    if (name == "pairs" && typeof conf == "string") return conf;
	    if (typeof conf == "object" && conf[name] != null) return conf[name];
	    return defaults[name];
	  }
	
	  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
	  function ensureBound(chars) {
	    for (var i = 0; i < chars.length; i++) {
	      var ch = chars.charAt(i), key = "'" + ch + "'"
	      if (!keyMap[key]) keyMap[key] = handler(ch)
	    }
	  }
	  ensureBound(defaults.pairs + "`")
	
	  function handler(ch) {
	    return function(cm) { return handleChar(cm, ch); };
	  }
	
	  function getConfig(cm) {
	    var deflt = cm.state.closeBrackets;
	    if (!deflt || deflt.override) return deflt;
	    var mode = cm.getModeAt(cm.getCursor());
	    return mode.closeBrackets || deflt;
	  }
	
	  function handleBackspace(cm) {
	    var conf = getConfig(cm);
	    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
	
	    var pairs = getOption(conf, "pairs");
	    var ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) return CodeMirror.Pass;
	      var around = charsAround(cm, ranges[i].head);
	      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	    }
	    for (var i = ranges.length - 1; i >= 0; i--) {
	      var cur = ranges[i].head;
	      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
	    }
	  }
	
	  function handleEnter(cm) {
	    var conf = getConfig(cm);
	    var explode = conf && getOption(conf, "explode");
	    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;
	
	    var ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) return CodeMirror.Pass;
	      var around = charsAround(cm, ranges[i].head);
	      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	    }
	    cm.operation(function() {
	      var linesep = cm.lineSeparator() || "\n";
	      cm.replaceSelection(linesep + linesep, null);
	      cm.execCommand("goCharLeft");
	      ranges = cm.listSelections();
	      for (var i = 0; i < ranges.length; i++) {
	        var line = ranges[i].head.line;
	        cm.indentLine(line, null, true);
	        cm.indentLine(line + 1, null, true);
	      }
	    });
	  }
	
	  function contractSelection(sel) {
	    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
	    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
	            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
	  }
	
	  function handleChar(cm, ch) {
	    var conf = getConfig(cm);
	    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
	
	    var pairs = getOption(conf, "pairs");
	    var pos = pairs.indexOf(ch);
	    if (pos == -1) return CodeMirror.Pass;
	    var triples = getOption(conf, "triples");
	
	    var identical = pairs.charAt(pos + 1) == ch;
	    var ranges = cm.listSelections();
	    var opening = pos % 2 == 0;
	
	    var type;
	    for (var i = 0; i < ranges.length; i++) {
	      var range = ranges[i], cur = range.head, curType;
	      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
	      if (opening && !range.empty()) {
	        curType = "surround";
	      } else if ((identical || !opening) && next == ch) {
	        if (identical && stringStartsAfter(cm, cur))
	          curType = "both";
	        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
	          curType = "skipThree";
	        else
	          curType = "skip";
	      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
	                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&
	                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {
	        curType = "addFour";
	      } else if (identical) {
	        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = "both";
	        else return CodeMirror.Pass;
	      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||
	                             isClosingBracket(next, pairs) ||
	                             /\s/.test(next))) {
	        curType = "both";
	      } else {
	        return CodeMirror.Pass;
	      }
	      if (!type) type = curType;
	      else if (type != curType) return CodeMirror.Pass;
	    }
	
	    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
	    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
	    cm.operation(function() {
	      if (type == "skip") {
	        cm.execCommand("goCharRight");
	      } else if (type == "skipThree") {
	        for (var i = 0; i < 3; i++)
	          cm.execCommand("goCharRight");
	      } else if (type == "surround") {
	        var sels = cm.getSelections();
	        for (var i = 0; i < sels.length; i++)
	          sels[i] = left + sels[i] + right;
	        cm.replaceSelections(sels, "around");
	        sels = cm.listSelections().slice();
	        for (var i = 0; i < sels.length; i++)
	          sels[i] = contractSelection(sels[i]);
	        cm.setSelections(sels);
	      } else if (type == "both") {
	        cm.replaceSelection(left + right, null);
	        cm.triggerElectric(left + right);
	        cm.execCommand("goCharLeft");
	      } else if (type == "addFour") {
	        cm.replaceSelection(left + left + left + left, "before");
	        cm.execCommand("goCharRight");
	      }
	    });
	  }
	
	  function isClosingBracket(ch, pairs) {
	    var pos = pairs.lastIndexOf(ch);
	    return pos > -1 && pos % 2 == 1;
	  }
	
	  function charsAround(cm, pos) {
	    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
	                          Pos(pos.line, pos.ch + 1));
	    return str.length == 2 ? str : null;
	  }
	
	  // Project the token type that will exists after the given char is
	  // typed, and use it to determine whether it would cause the start
	  // of a string token.
	  function enteringString(cm, pos, ch) {
	    var line = cm.getLine(pos.line);
	    var token = cm.getTokenAt(pos);
	    if (/\bstring2?\b/.test(token.type) || stringStartsAfter(cm, pos)) return false;
	    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);
	    stream.pos = stream.start = token.start;
	    for (;;) {
	      var type1 = cm.getMode().token(stream, token.state);
	      if (stream.pos >= pos.ch + 1) return /\bstring2?\b/.test(type1);
	      stream.start = stream.pos;
	    }
	  }
	
	  function stringStartsAfter(cm, pos) {
	    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))
	    return /\bstring/.test(token.type) && token.start == pos.ch
	  }
	});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
	  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
	
	  // This is the old interface, kept around for now to stay
	  // backwards-compatible.
	  CodeMirror.showHint = function(cm, getHints, options) {
	    if (!getHints) return cm.showHint(options);
	    if (options && options.async) getHints.async = true;
	    var newOpts = {hint: getHints};
	    if (options) for (var prop in options) newOpts[prop] = options[prop];
	    return cm.showHint(newOpts);
	  };
	
	  CodeMirror.defineExtension("showHint", function(options) {
	    options = parseOptions(this, this.getCursor("start"), options);
	    var selections = this.listSelections()
	    if (selections.length > 1) return;
	    // By default, don't allow completion when something is selected.
	    // A hint function can have a `supportsSelection` property to
	    // indicate that it can handle selections.
	    if (this.somethingSelected()) {
	      if (!options.hint.supportsSelection) return;
	      // Don't try with cross-line selections
	      for (var i = 0; i < selections.length; i++)
	        if (selections[i].head.line != selections[i].anchor.line) return;
	    }
	
	    if (this.state.completionActive) this.state.completionActive.close();
	    var completion = this.state.completionActive = new Completion(this, options);
	    if (!completion.options.hint) return;
	
	    CodeMirror.signal(this, "startCompletion", this);
	    completion.update(true);
	  });
	
	  function Completion(cm, options) {
	    this.cm = cm;
	    this.options = options;
	    this.widget = null;
	    this.debounce = 0;
	    this.tick = 0;
	    this.startPos = this.cm.getCursor("start");
	    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
	
	    var self = this;
	    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
	  }
	
	  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
	    return setTimeout(fn, 1000/60);
	  };
	  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
	
	  Completion.prototype = {
	    close: function() {
	      if (!this.active()) return;
	      this.cm.state.completionActive = null;
	      this.tick = null;
	      this.cm.off("cursorActivity", this.activityFunc);
	
	      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
	      if (this.widget) this.widget.close();
	      CodeMirror.signal(this.cm, "endCompletion", this.cm);
	    },
	
	    active: function() {
	      return this.cm.state.completionActive == this;
	    },
	
	    pick: function(data, i) {
	      var completion = data.list[i];
	      if (completion.hint) completion.hint(this.cm, data, completion);
	      else this.cm.replaceRange(getText(completion), completion.from || data.from,
	                                completion.to || data.to, "complete");
	      CodeMirror.signal(data, "pick", completion);
	      this.close();
	    },
	
	    cursorActivity: function() {
	      if (this.debounce) {
	        cancelAnimationFrame(this.debounce);
	        this.debounce = 0;
	      }
	
	      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
	      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
	          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
	          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
	        this.close();
	      } else {
	        var self = this;
	        this.debounce = requestAnimationFrame(function() {self.update();});
	        if (this.widget) this.widget.disable();
	      }
	    },
	
	    update: function(first) {
	      if (this.tick == null) return
	      var self = this, myTick = ++this.tick
	      fetchHints(this.options.hint, this.cm, this.options, function(data) {
	        if (self.tick == myTick) self.finishUpdate(data, first)
	      })
	    },
	
	    finishUpdate: function(data, first) {
	      if (this.data) CodeMirror.signal(this.data, "update");
	
	      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
	      if (this.widget) this.widget.close();
	
	      if (data && this.data && isNewCompletion(this.data, data)) return;
	      this.data = data;
	
	      if (data && data.list.length) {
	        if (picked && data.list.length == 1) {
	          this.pick(data, 0);
	        } else {
	          this.widget = new Widget(this, data);
	          CodeMirror.signal(data, "shown");
	        }
	      }
	    }
	  };
	
	  function isNewCompletion(old, nw) {
	    var moved = CodeMirror.cmpPos(nw.from, old.from)
	    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch
	  }
	
	  function parseOptions(cm, pos, options) {
	    var editor = cm.options.hintOptions;
	    var out = {};
	    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
	    if (editor) for (var prop in editor)
	      if (editor[prop] !== undefined) out[prop] = editor[prop];
	    if (options) for (var prop in options)
	      if (options[prop] !== undefined) out[prop] = options[prop];
	    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
	    return out;
	  }
	
	  function getText(completion) {
	    if (typeof completion == "string") return completion;
	    else return completion.text;
	  }
	
	  function buildKeyMap(completion, handle) {
	    var baseMap = {
	      Up: function() {handle.moveFocus(-1);},
	      Down: function() {handle.moveFocus(1);},
	      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
	      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
	      Home: function() {handle.setFocus(0);},
	      End: function() {handle.setFocus(handle.length - 1);},
	      Enter: handle.pick,
	      Tab: handle.pick,
	      Esc: handle.close
	    };
	    var custom = completion.options.customKeys;
	    var ourMap = custom ? {} : baseMap;
	    function addBinding(key, val) {
	      var bound;
	      if (typeof val != "string")
	        bound = function(cm) { return val(cm, handle); };
	      // This mechanism is deprecated
	      else if (baseMap.hasOwnProperty(val))
	        bound = baseMap[val];
	      else
	        bound = val;
	      ourMap[key] = bound;
	    }
	    if (custom)
	      for (var key in custom) if (custom.hasOwnProperty(key))
	        addBinding(key, custom[key]);
	    var extra = completion.options.extraKeys;
	    if (extra)
	      for (var key in extra) if (extra.hasOwnProperty(key))
	        addBinding(key, extra[key]);
	    return ourMap;
	  }
	
	  function getHintElement(hintsElement, el) {
	    while (el && el != hintsElement) {
	      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
	      el = el.parentNode;
	    }
	  }
	
	  function Widget(completion, data) {
	    this.completion = completion;
	    this.data = data;
	    this.picked = false;
	    var widget = this, cm = completion.cm;
	
	    var hints = this.hints = document.createElement("ul");
	    hints.className = "CodeMirror-hints";
	    this.selectedHint = data.selectedHint || 0;
	
	    var completions = data.list;
	    for (var i = 0; i < completions.length; ++i) {
	      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
	      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
	      if (cur.className != null) className = cur.className + " " + className;
	      elt.className = className;
	      if (cur.render) cur.render(elt, data, cur);
	      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
	      elt.hintId = i;
	    }
	
	    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
	    var left = pos.left, top = pos.bottom, below = true;
	    hints.style.left = left + "px";
	    hints.style.top = top + "px";
	    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
	    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
	    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
	    (completion.options.container || document.body).appendChild(hints);
	    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
	    var scrolls = hints.scrollHeight > hints.clientHeight + 1
	    var startScroll = cm.getScrollInfo();
	
	    if (overlapY > 0) {
	      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
	      if (curTop - height > 0) { // Fits above cursor
	        hints.style.top = (top = pos.top - height) + "px";
	        below = false;
	      } else if (height > winH) {
	        hints.style.height = (winH - 5) + "px";
	        hints.style.top = (top = pos.bottom - box.top) + "px";
	        var cursor = cm.getCursor();
	        if (data.from.ch != cursor.ch) {
	          pos = cm.cursorCoords(cursor);
	          hints.style.left = (left = pos.left) + "px";
	          box = hints.getBoundingClientRect();
	        }
	      }
	    }
	    var overlapX = box.right - winW;
	    if (overlapX > 0) {
	      if (box.right - box.left > winW) {
	        hints.style.width = (winW - 5) + "px";
	        overlapX -= (box.right - box.left) - winW;
	      }
	      hints.style.left = (left = pos.left - overlapX) + "px";
	    }
	    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
	      node.style.paddingRight = cm.display.nativeBarWidth + "px"
	
	    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
	      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
	      setFocus: function(n) { widget.changeActive(n); },
	      menuSize: function() { return widget.screenAmount(); },
	      length: completions.length,
	      close: function() { completion.close(); },
	      pick: function() { widget.pick(); },
	      data: data
	    }));
	
	    if (completion.options.closeOnUnfocus) {
	      var closingOnBlur;
	      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
	      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
	    }
	
	    cm.on("scroll", this.onScroll = function() {
	      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
	      var newTop = top + startScroll.top - curScroll.top;
	      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
	      if (!below) point += hints.offsetHeight;
	      if (point <= editor.top || point >= editor.bottom) return completion.close();
	      hints.style.top = newTop + "px";
	      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
	    });
	
	    CodeMirror.on(hints, "dblclick", function(e) {
	      var t = getHintElement(hints, e.target || e.srcElement);
	      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
	    });
	
	    CodeMirror.on(hints, "click", function(e) {
	      var t = getHintElement(hints, e.target || e.srcElement);
	      if (t && t.hintId != null) {
	        widget.changeActive(t.hintId);
	        if (completion.options.completeOnSingleClick) widget.pick();
	      }
	    });
	
	    CodeMirror.on(hints, "mousedown", function() {
	      setTimeout(function(){cm.focus();}, 20);
	    });
	
	    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
	    return true;
	  }
	
	  Widget.prototype = {
	    close: function() {
	      if (this.completion.widget != this) return;
	      this.completion.widget = null;
	      this.hints.parentNode.removeChild(this.hints);
	      this.completion.cm.removeKeyMap(this.keyMap);
	
	      var cm = this.completion.cm;
	      if (this.completion.options.closeOnUnfocus) {
	        cm.off("blur", this.onBlur);
	        cm.off("focus", this.onFocus);
	      }
	      cm.off("scroll", this.onScroll);
	    },
	
	    disable: function() {
	      this.completion.cm.removeKeyMap(this.keyMap);
	      var widget = this;
	      this.keyMap = {Enter: function() { widget.picked = true; }};
	      this.completion.cm.addKeyMap(this.keyMap);
	    },
	
	    pick: function() {
	      this.completion.pick(this.data, this.selectedHint);
	    },
	
	    changeActive: function(i, avoidWrap) {
	      if (i >= this.data.list.length)
	        i = avoidWrap ? this.data.list.length - 1 : 0;
	      else if (i < 0)
	        i = avoidWrap ? 0  : this.data.list.length - 1;
	      if (this.selectedHint == i) return;
	      var node = this.hints.childNodes[this.selectedHint];
	      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
	      node = this.hints.childNodes[this.selectedHint = i];
	      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
	      if (node.offsetTop < this.hints.scrollTop)
	        this.hints.scrollTop = node.offsetTop - 3;
	      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
	        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
	      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
	    },
	
	    screenAmount: function() {
	      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
	    }
	  };
	
	  function applicableHelpers(cm, helpers) {
	    if (!cm.somethingSelected()) return helpers
	    var result = []
	    for (var i = 0; i < helpers.length; i++)
	      if (helpers[i].supportsSelection) result.push(helpers[i])
	    return result
	  }
	
	  function fetchHints(hint, cm, options, callback) {
	    if (hint.async) {
	      hint(cm, callback, options)
	    } else {
	      var result = hint(cm, options)
	      if (result && result.then) result.then(callback)
	      else callback(result)
	    }
	  }
	
	  function resolveAutoHints(cm, pos) {
	    var helpers = cm.getHelpers(pos, "hint"), words
	    if (helpers.length) {
	      var resolved = function(cm, callback, options) {
	        var app = applicableHelpers(cm, helpers);
	        function run(i) {
	          if (i == app.length) return callback(null)
	          fetchHints(app[i], cm, options, function(result) {
	            if (result && result.list.length > 0) callback(result)
	            else run(i + 1)
	          })
	        }
	        run(0)
	      }
	      resolved.async = true
	      resolved.supportsSelection = true
	      return resolved
	    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
	      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
	    } else if (CodeMirror.hint.anyword) {
	      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
	    } else {
	      return function() {}
	    }
	  }
	
	  CodeMirror.registerHelper("hint", "auto", {
	    resolve: resolveAutoHints
	  });
	
	  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
	    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
	    var to = CodeMirror.Pos(cur.line, token.end);
	    if (token.string && /\w/.test(token.string[token.string.length - 1])) {
	      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);
	    } else {
	      var term = "", from = to;
	    }
	    var found = [];
	    for (var i = 0; i < options.words.length; i++) {
	      var word = options.words[i];
	      if (word.slice(0, term.length) == term)
	        found.push(word);
	    }
	
	    if (found.length) return {list: found, from: from, to: to};
	  });
	
	  CodeMirror.commands.autocomplete = CodeMirror.showHint;
	
	  var defaultOptions = {
	    hint: CodeMirror.hint.auto,
	    completeSingle: true,
	    alignWithWord: true,
	    closeCharacters: /[\s()\[\]{};:>,]/,
	    closeOnUnfocus: true,
	    completeOnSingleClick: true,
	    container: null,
	    customKeys: null,
	    extraKeys: null
	  };
	
	  CodeMirror.defineOption("hintOptions", null);
	});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var GUTTER_ID = "CodeMirror-lint-markers";
	
	  function showTooltip(e, content) {
	    var tt = document.createElement("div");
	    tt.className = "CodeMirror-lint-tooltip";
	    tt.appendChild(content.cloneNode(true));
	    document.body.appendChild(tt);
	
	    function position(e) {
	      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
	      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
	      tt.style.left = (e.clientX + 5) + "px";
	    }
	    CodeMirror.on(document, "mousemove", position);
	    position(e);
	    if (tt.style.opacity != null) tt.style.opacity = 1;
	    return tt;
	  }
	  function rm(elt) {
	    if (elt.parentNode) elt.parentNode.removeChild(elt);
	  }
	  function hideTooltip(tt) {
	    if (!tt.parentNode) return;
	    if (tt.style.opacity == null) rm(tt);
	    tt.style.opacity = 0;
	    setTimeout(function() { rm(tt); }, 600);
	  }
	
	  function showTooltipFor(e, content, node) {
	    var tooltip = showTooltip(e, content);
	    function hide() {
	      CodeMirror.off(node, "mouseout", hide);
	      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
	    }
	    var poll = setInterval(function() {
	      if (tooltip) for (var n = node;; n = n.parentNode) {
	        if (n && n.nodeType == 11) n = n.host;
	        if (n == document.body) return;
	        if (!n) { hide(); break; }
	      }
	      if (!tooltip) return clearInterval(poll);
	    }, 400);
	    CodeMirror.on(node, "mouseout", hide);
	  }
	
	  function LintState(cm, options, hasGutter) {
	    this.marked = [];
	    this.options = options;
	    this.timeout = null;
	    this.hasGutter = hasGutter;
	    this.onMouseOver = function(e) { onMouseOver(cm, e); };
	    this.waitingFor = 0
	  }
	
	  function parseOptions(_cm, options) {
	    if (options instanceof Function) return {getAnnotations: options};
	    if (!options || options === true) options = {};
	    return options;
	  }
	
	  function clearMarks(cm) {
	    var state = cm.state.lint;
	    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
	    for (var i = 0; i < state.marked.length; ++i)
	      state.marked[i].clear();
	    state.marked.length = 0;
	  }
	
	  function makeMarker(labels, severity, multiple, tooltips) {
	    var marker = document.createElement("div"), inner = marker;
	    marker.className = "CodeMirror-lint-marker-" + severity;
	    if (multiple) {
	      inner = marker.appendChild(document.createElement("div"));
	      inner.className = "CodeMirror-lint-marker-multiple";
	    }
	
	    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
	      showTooltipFor(e, labels, inner);
	    });
	
	    return marker;
	  }
	
	  function getMaxSeverity(a, b) {
	    if (a == "error") return a;
	    else return b;
	  }
	
	  function groupByLine(annotations) {
	    var lines = [];
	    for (var i = 0; i < annotations.length; ++i) {
	      var ann = annotations[i], line = ann.from.line;
	      (lines[line] || (lines[line] = [])).push(ann);
	    }
	    return lines;
	  }
	
	  function annotationTooltip(ann) {
	    var severity = ann.severity;
	    if (!severity) severity = "error";
	    var tip = document.createElement("div");
	    tip.className = "CodeMirror-lint-message-" + severity;
	    if (typeof ann.messageHTML != 'undefined') {
	        tip.innerHTML = ann.messageHTML;
	    } else {
	        tip.appendChild(document.createTextNode(ann.message));
	    }
	    return tip;
	  }
	
	  function lintAsync(cm, getAnnotations, passOptions) {
	    var state = cm.state.lint
	    var id = ++state.waitingFor
	    function abort() {
	      id = -1
	      cm.off("change", abort)
	    }
	    cm.on("change", abort)
	    getAnnotations(cm.getValue(), function(annotations, arg2) {
	      cm.off("change", abort)
	      if (state.waitingFor != id) return
	      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
	      updateLinting(cm, annotations)
	    }, passOptions, cm);
	  }
	
	  function startLinting(cm) {
	    var state = cm.state.lint, options = state.options;
	    /*
	     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
	     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
	     */
	    var passOptions = options.options || options;
	    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
	    if (!getAnnotations) return;
	    if (options.async || getAnnotations.async) {
	      lintAsync(cm, getAnnotations, passOptions)
	    } else {
	      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
	      if (!annotations) return;
	      if (annotations.then) annotations.then(function(issues) {
	        updateLinting(cm, issues);
	      });
	      else updateLinting(cm, annotations);
	    }
	  }
	
	  function updateLinting(cm, annotationsNotSorted) {
	    clearMarks(cm);
	    var state = cm.state.lint, options = state.options;
	
	    var annotations = groupByLine(annotationsNotSorted);
	
	    for (var line = 0; line < annotations.length; ++line) {
	      var anns = annotations[line];
	      if (!anns) continue;
	
	      var maxSeverity = null;
	      var tipLabel = state.hasGutter && document.createDocumentFragment();
	
	      for (var i = 0; i < anns.length; ++i) {
	        var ann = anns[i];
	        var severity = ann.severity;
	        if (!severity) severity = "error";
	        maxSeverity = getMaxSeverity(maxSeverity, severity);
	
	        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
	        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));
	
	        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
	          className: "CodeMirror-lint-mark-" + severity,
	          __annotation: ann
	        }));
	      }
	
	      if (state.hasGutter)
	        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
	                                                       state.options.tooltips));
	    }
	    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
	  }
	
	  function onChange(cm) {
	    var state = cm.state.lint;
	    if (!state) return;
	    clearTimeout(state.timeout);
	    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
	  }
	
	  function popupTooltips(annotations, e) {
	    var target = e.target || e.srcElement;
	    var tooltip = document.createDocumentFragment();
	    for (var i = 0; i < annotations.length; i++) {
	      var ann = annotations[i];
	      tooltip.appendChild(annotationTooltip(ann));
	    }
	    showTooltipFor(e, tooltip, target);
	  }
	
	  function onMouseOver(cm, e) {
	    var target = e.target || e.srcElement;
	    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
	    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
	    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));
	
	    var annotations = [];
	    for (var i = 0; i < spans.length; ++i) {
	      var ann = spans[i].__annotation;
	      if (ann) annotations.push(ann);
	    }
	    if (annotations.length) popupTooltips(annotations, e);
	  }
	
	  CodeMirror.defineOption("lint", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      clearMarks(cm);
	      if (cm.state.lint.options.lintOnChange !== false)
	        cm.off("change", onChange);
	      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
	      clearTimeout(cm.state.lint.timeout);
	      delete cm.state.lint;
	    }
	
	    if (val) {
	      var gutters = cm.getOption("gutters"), hasLintGutter = false;
	      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
	      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
	      if (state.options.lintOnChange !== false)
	        cm.on("change", onChange);
	      if (state.options.tooltips != false && state.options.tooltips != "gutter")
	        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
	
	      startLinting(cm);
	    }
	  });
	
	  CodeMirror.defineExtension("performLint", function() {
	    if (this.state.lint) startLinting(this);
	  });
	});


/***/ }),
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys = __webpack_require__(670);
	var foreach = __webpack_require__(514);
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';
	
	var toStr = Object.prototype.toString;
	
	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};
	
	var arePropertyDescriptorsSupported = function () {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        /* eslint-disable no-unused-vars, no-restricted-syntax */
	        for (var _ in obj) { return false; }
	        /* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) { /* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();
	
	var defineProperty = function (object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};
	
	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};
	
	defineProperties.supportsDescriptors = !!supportsDescriptors;
	
	module.exports = defineProperties;


/***/ }),
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */
/***/ (function(module, exports) {

	var has = Object.prototype.hasOwnProperty;
	module.exports = function assign(target, source) {
		if (Object.assign) {
			return Object.assign(target, source);
		}
		for (var key in source) {
			if (has.call(source, key)) {
				target[key] = source[key];
			}
		}
		return target;
	};


/***/ }),
/* 241 */
/***/ (function(module, exports) {

	var $isNaN = Number.isNaN || function (a) { return a !== a; };
	
	module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ }),
/* 242 */
/***/ (function(module, exports) {

	module.exports = Number.isNaN || function isNaN(a) {
		return a !== a;
	};


/***/ }),
/* 243 */
/***/ (function(module, exports) {

	module.exports = function mod(number, modulo) {
		var remain = number % modulo;
		return Math.floor(remain >= 0 ? remain : remain + modulo);
	};


/***/ }),
/* 244 */
/***/ (function(module, exports) {

	module.exports = function sign(number) {
		return number >= 0 ? 1 : -1;
	};


/***/ }),
/* 245 */
/***/ (function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ }),
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	// Standard YAML's Core schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2804923
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, Core schema has no distinctions from JSON schema is JS-YAML.
	
	
	'use strict';
	
	
	var Schema = __webpack_require__(56);
	
	
	module.exports = new Schema({
	  include: [
	    __webpack_require__(250)
	  ]
	});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	// Standard YAML's JSON schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2803231
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, this schema is not such strict as defined in the YAML specification.
	// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
	
	
	'use strict';
	
	
	var Schema = __webpack_require__(56);
	
	
	module.exports = new Schema({
	  include: [
	    __webpack_require__(150)
	  ],
	  implicit: [
	    __webpack_require__(530),
	    __webpack_require__(522),
	    __webpack_require__(524),
	    __webpack_require__(523)
	  ]
	});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	var __assign = undefined && undefined.__assign || Object.assign || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) {
	            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(36);
	var graphql_1 = __webpack_require__(12);
	var cn = __webpack_require__(13);
	var ExecuteButton_1 = __webpack_require__(570);
	var ToolbarButton_1 = __webpack_require__(595);
	var QueryEditor_1 = __webpack_require__(252);
	var VariableEditor_1 = __webpack_require__(596);
	var DocExplorer_1 = __webpack_require__(568);
	var CodeMirrorSizer_1 = __webpack_require__(597);
	var getQueryFacts_1 = __webpack_require__(601);
	var getSelectedOperationName_1 = __webpack_require__(602);
	var debounce_1 = __webpack_require__(156);
	var find_1 = __webpack_require__(600);
	var fillLeafs_1 = __webpack_require__(599);
	var elementPosition_1 = __webpack_require__(598);
	var introspectionQueries_1 = __webpack_require__(603);
	var index_1 = __webpack_require__(581);
	var QueryHeader_1 = __webpack_require__(571);
	var ResultHeader_1 = __webpack_require__(574);
	var ResultViewer_1 = __webpack_require__(576);
	var ageOfDate_1 = __webpack_require__(579);
	var SchemaExplorer_1 = __webpack_require__(577);
	var CSSTransitionGroup = __webpack_require__(801);
	var CustomGraphiQL = function (_super) {
	    __extends(CustomGraphiQL, _super);
	    function CustomGraphiQL(props) {
	        var _this = _super.call(this, props) || this;
	        _this._updateQueryFacts = debounce_1.default(150, function (query) {
	            var queryFacts = getQueryFacts_1.default(_this.state.schema, query);
	            if (queryFacts) {
	                // Update operation name should any query names change.
	                var operationName = getSelectedOperationName_1.default(_this.state.operations, _this.state.operationName, queryFacts.operations);
	                // Report changing of operationName if it changed.
	                var onEditOperationName = _this.props.onEditOperationName;
	                if (onEditOperationName && operationName !== _this.state.operationName) {
	                    onEditOperationName(operationName);
	                }
	                _this.setState(__assign({ operationName: operationName }, queryFacts));
	            }
	        });
	        _this.handleRunQuery = function (selectedOperationName) {
	            _this._editorQueryID++;
	            var queryID = _this._editorQueryID;
	            // Use the edited query after autoCompleteLeafs() runs or,
	            // in case autoCompletion fails (the function returns undefined),
	            // the current query from the editor.
	            var editedQuery = _this.autoCompleteLeafs() || _this.state.query;
	            var variables = _this.state.variables;
	            var operationName = _this.state.operationName;
	            // If an operation was explicitly provided, different from the current
	            // operation name, then report that it changed.
	            if (selectedOperationName && selectedOperationName !== operationName) {
	                operationName = selectedOperationName;
	                var onEditOperationName = _this.props.onEditOperationName;
	                if (onEditOperationName) {
	                    onEditOperationName(operationName);
	                }
	            }
	            try {
	                _this.setState({
	                    isWaitingForResponse: true,
	                    responses: [{ date: null, time: new Date() }],
	                    operationName: operationName
	                });
	                // _fetchQuery may return a subscription.
	                var subscription = _this._fetchQuery(editedQuery, variables, operationName, function (result) {
	                    if (queryID === _this._editorQueryID) {
	                        var isSubscription = false;
	                        if (result.isSubscription) {
	                            isSubscription = true;
	                            delete result.isSubscription;
	                        }
	                        var responses = void 0;
	                        var response = JSON.stringify(result, null, 2);
	                        if (isSubscription) {
	                            responses = _this.state.responses.filter(function (response) {
	                                return response && response.date;
	                            }).concat({ date: response, time: new Date() });
	                        } else {
	                            responses = [{ date: response, time: new Date() }];
	                        }
	                        _this.setState({
	                            isWaitingForResponse: false,
	                            responses: responses
	                        });
	                    }
	                });
	                _this.setState({ subscription: subscription });
	            } catch (error) {
	                _this.setState({
	                    isWaitingForResponse: false,
	                    responses: [{ date: error.message, time: new Date() }]
	                });
	            }
	        };
	        _this.handleStopQuery = function () {
	            var subscription = _this.state.subscription;
	            _this.setState({
	                isWaitingForResponse: false,
	                subscription: null
	            });
	            if (subscription) {
	                subscription.unsubscribe();
	            }
	        };
	        _this.handlePrettifyQuery = function () {
	            var query = graphql_1.print(graphql_1.parse(_this.state.query));
	            var editor = _this.queryEditorComponent.getCodeMirror();
	            editor.setValue(query);
	        };
	        _this.handleEditQuery = function (value) {
	            if (_this.state.schema) {
	                _this._updateQueryFacts(value);
	            }
	            _this.setState({ query: value });
	            if (_this.props.onEditQuery) {
	                return _this.props.onEditQuery(value);
	            }
	            return null;
	        };
	        _this.handleEditVariables = function (value) {
	            _this.setState({ variables: value });
	            if (_this.props.onEditVariables) {
	                _this.props.onEditVariables(value);
	            }
	        };
	        _this.handleHintInformationRender = function (elem) {
	            elem.addEventListener('click', _this._onClickHintInformation);
	            var _onRemoveFn;
	            elem.addEventListener('DOMNodeRemoved', _onRemoveFn = function onRemoveFn() {
	                elem.removeEventListener('DOMNodeRemoved', _onRemoveFn);
	                elem.removeEventListener('click', _this._onClickHintInformation);
	            });
	        };
	        _this.handleEditorRunQuery = function () {
	            _this._runQueryAtCursor();
	        };
	        _this._onClickHintInformation = function (event) {
	            if (event.target.className === 'typeName') {
	                var typeName = event.target.innerHTML;
	                var schema = _this.state.schema;
	                if (schema) {
	                    var type_1 = schema.getType(typeName);
	                    if (type_1) {
	                        _this.setState({ docExplorerOpen: true }, function () {
	                            _this.docExplorerComponent.showDoc(type_1);
	                        });
	                    }
	                }
	            }
	        };
	        _this.handleToggleDocs = function () {
	            if (typeof _this.props.onToggleDocs === 'function') {
	                _this.props.onToggleDocs(!_this.state.docExplorerOpen);
	            }
	            _this.setState({ docExplorerOpen: !_this.state.docExplorerOpen });
	        };
	        _this.handleToggleSchema = function () {
	            _this.setState({ schemaExplorerOpen: !_this.state.schemaExplorerOpen });
	        };
	        _this.handleResizeStart = function (downEvent) {
	            if (_this.props.disableResize) {
	                return;
	            }
	            if (!_this._didClickDragBar(downEvent)) {
	                return;
	            }
	            downEvent.preventDefault();
	            var offset = downEvent.clientX - elementPosition_1.getLeft(downEvent.target);
	            var onMouseMove = function onMouseMove(moveEvent) {
	                if (moveEvent.buttons === 0) {
	                    return _onMouseUp();
	                }
	                var editorBar = ReactDOM.findDOMNode(_this.editorBarComponent);
	                var leftSize = moveEvent.clientX - elementPosition_1.getLeft(editorBar) - offset;
	                var rightSize = editorBar.clientWidth - leftSize;
	                _this.setState({ editorFlex: leftSize / rightSize });
	            };
	            var _onMouseUp = function onMouseUp() {
	                document.removeEventListener('mousemove', onMouseMove);
	                document.removeEventListener('mouseup', _onMouseUp);
	                onMouseMove = null;
	                _onMouseUp = null;
	            };
	            document.addEventListener('mousemove', onMouseMove);
	            document.addEventListener('mouseup', _onMouseUp);
	        };
	        _this.handleDocsResizeStart = function (downEvent) {
	            downEvent.preventDefault();
	            var hadWidth = _this.state.docExplorerWidth;
	            var offset = downEvent.clientX - elementPosition_1.getLeft(downEvent.target);
	            var onMouseMove = function onMouseMove(moveEvent) {
	                if (moveEvent.buttons === 0) {
	                    return _onMouseUp2();
	                }
	                var app = ReactDOM.findDOMNode(_this);
	                var cursorPos = moveEvent.clientX - elementPosition_1.getLeft(app) - offset;
	                var docsSize = app.clientWidth - cursorPos;
	                if (docsSize < 100) {
	                    _this.setState({ docExplorerOpen: false });
	                } else {
	                    _this.setState({
	                        docExplorerOpen: true,
	                        docExplorerWidth: Math.min(docsSize, 850)
	                    });
	                }
	            };
	            var _onMouseUp2 = function onMouseUp() {
	                if (!_this.state.docExplorerOpen) {
	                    _this.setState({ docExplorerWidth: hadWidth });
	                }
	                document.removeEventListener('mousemove', onMouseMove);
	                document.removeEventListener('mouseup', _onMouseUp2);
	                onMouseMove = null;
	                _onMouseUp2 = null;
	            };
	            document.addEventListener('mousemove', onMouseMove);
	            document.addEventListener('mouseup', _onMouseUp2);
	        };
	        _this.handleSchemaResizeStart = function (downEvent) {
	            downEvent.preventDefault();
	            var hadWidth = _this.state.schemaExplorerWidth;
	            var offset = downEvent.clientX - elementPosition_1.getLeft(downEvent.target);
	            var onMouseMove = function onMouseMove(moveEvent) {
	                if (moveEvent.buttons === 0) {
	                    return _onMouseUp3();
	                }
	                var app = ReactDOM.findDOMNode(_this);
	                var cursorPos = moveEvent.clientX - elementPosition_1.getLeft(app) - offset;
	                var schemaSize = app.clientWidth - cursorPos;
	                if (schemaSize < 100) {
	                    _this.setState({ schemaExplorerOpen: false });
	                } else {
	                    _this.setState({
	                        schemaExplorerOpen: true,
	                        schemaExplorerWidth: Math.min(schemaSize, 850)
	                    });
	                }
	            };
	            var _onMouseUp3 = function onMouseUp() {
	                if (!_this.state.schemaExplorerOpen) {
	                    _this.setState({ schemaExplorerWidth: hadWidth });
	                }
	                document.removeEventListener('mousemove', onMouseMove);
	                document.removeEventListener('mouseup', _onMouseUp3);
	                onMouseMove = null;
	                _onMouseUp3 = null;
	            };
	            document.addEventListener('mousemove', onMouseMove);
	            document.addEventListener('mouseup', _onMouseUp3);
	        };
	        _this.handleVariableResizeStart = function (downEvent) {
	            downEvent.preventDefault();
	            var didMove = false;
	            var wasOpen = _this.state.variableEditorOpen;
	            var hadHeight = _this.state.variableEditorHeight;
	            var offset = downEvent.clientY - elementPosition_1.getTop(downEvent.target);
	            var onMouseMove = function onMouseMove(moveEvent) {
	                if (moveEvent.buttons === 0) {
	                    return _onMouseUp4();
	                }
	                didMove = true;
	                var editorBar = ReactDOM.findDOMNode(_this.editorBarComponent);
	                var topSize = moveEvent.clientY - elementPosition_1.getTop(editorBar) - offset;
	                var bottomSize = editorBar.clientHeight - topSize;
	                if (bottomSize < 60) {
	                    _this.setState({
	                        variableEditorOpen: false,
	                        variableEditorHeight: hadHeight
	                    });
	                } else {
	                    _this.setState({
	                        variableEditorOpen: true,
	                        variableEditorHeight: bottomSize
	                    });
	                }
	            };
	            var _onMouseUp4 = function onMouseUp() {
	                if (!didMove) {
	                    _this.setState({ variableEditorOpen: !wasOpen });
	                }
	                document.removeEventListener('mousemove', onMouseMove);
	                document.removeEventListener('mouseup', _onMouseUp4);
	                onMouseMove = null;
	                _onMouseUp4 = null;
	            };
	            document.addEventListener('mousemove', onMouseMove);
	            document.addEventListener('mouseup', _onMouseUp4);
	        };
	        _this.handleDownloadJSON = function () {
	            index_1.download(_this.state.responses[0].date, 'result.json', 'application/json');
	        };
	        // Ensure props are correct
	        if (typeof props.fetcher !== 'function') {
	            throw new TypeError('CustomGraphiQL requires a fetcher function.');
	        }
	        // Cache the storage instance
	        _this._storage = props.storage || typeof window !== 'undefined' ? window.localStorage : {
	            setItem: function setItem() {
	                return null;
	            },
	            removeItem: function removeItem() {
	                return null;
	            },
	            getItem: function getItem() {
	                return null;
	            }
	        };
	        // Determine the initial query to display.
	        var query = props.query !== undefined ? props.query : _this._storageGet('query') !== null ? _this._storageGet('query') : props.defaultQuery !== undefined ? props.defaultQuery : defaultQuery;
	        // Get the initial query facts.
	        var queryFacts = getQueryFacts_1.default(props.schema, query);
	        // Determine the initial variables to display.
	        var variables = props.variables !== undefined ? props.variables : _this._storageGet('variables');
	        // Determine the initial operationName to use.
	        var operationName = props.operationName !== undefined ? props.operationName : getSelectedOperationName_1.default(null, _this._storageGet('operationName'), queryFacts && queryFacts.operations);
	        // Initialize state
	        _this.state = __assign({ schema: props.schema, query: query,
	            variables: variables,
	            operationName: operationName, responses: props.responses || [], editorFlex: Number(_this._storageGet('editorFlex')) || 1, variableEditorOpen: Boolean(variables), variableEditorHeight: Number(_this._storageGet('variableEditorHeight')) || 200, docExplorerOpen: _this._storageGet('docExplorerOpen') === 'true' || false, docExplorerWidth: Number(_this._storageGet('docExplorerWidth')) || 350, schemaExplorerOpen: false, schemaExplorerWidth: Number(_this._storageGet('schemaExplorerWidth')) || 350, isWaitingForResponse: false, subscription: null }, queryFacts);
	        // Ensure only the last executed editor query is rendered.
	        _this._editorQueryID = 0;
	        // Subscribe to the browser window closing, treating it as an unmount.
	        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
	            window.addEventListener('beforeunload', function () {
	                return _this.componentWillUnmount();
	            });
	        }
	        return _this;
	    }
	    CustomGraphiQL.prototype.componentDidMount = function () {
	        // Ensure a form of a schema exists (including `null`) and
	        // if not, fetch one using an introspection query.
	        this._ensureOfSchema();
	        // Utility for keeping CodeMirror correctly sized.
	        this.codeMirrorSizer = new CodeMirrorSizer_1.default();
	        global['g'] = this;
	    };
	    CustomGraphiQL.prototype.componentWillReceiveProps = function (nextProps) {
	        var nextSchema = this.state.schema;
	        var nextQuery = this.state.query;
	        var nextVariables = this.state.variables;
	        var nextOperationName = this.state.operationName;
	        var nextResponses = this.state.responses;
	        if (nextProps.schema !== undefined) {
	            nextSchema = nextProps.schema;
	        }
	        if (nextProps.query !== undefined && (this.props.rerenderQuery || nextProps.rerenderQuery)) {
	            nextQuery = nextProps.query;
	        }
	        if (nextProps.variables !== undefined) {
	            nextVariables = nextProps.variables;
	        }
	        if (nextProps.operationName !== undefined) {
	            nextOperationName = nextProps.operationName;
	        }
	        if (nextProps.responses !== undefined) {
	            nextResponses = nextProps.responses;
	        }
	        if (nextSchema !== this.state.schema || nextQuery !== this.state.query || nextOperationName !== this.state.operationName) {
	            this._updateQueryFacts(nextQuery);
	        }
	        this.setState({
	            schema: nextSchema,
	            query: nextQuery,
	            variables: nextVariables,
	            operationName: nextOperationName,
	            responses: nextResponses
	        });
	    };
	    CustomGraphiQL.prototype.componentDidUpdate = function () {
	        // If this update caused DOM nodes to have changed sizes, update the
	        // corresponding CodeMirror instance sizes to match.
	        var components = [this.queryEditorComponent, this.variableEditorComponent];
	        this.codeMirrorSizer.updateSizes(components);
	        if (this.resultComponent && Boolean(this.state.subscription)) {
	            this.resultComponent.scrollTop = this.resultComponent.scrollHeight;
	        }
	    };
	    // When the component is about to unmount, store any persistable state, such
	    // that when the component is remounted, it will use the last used values.
	    CustomGraphiQL.prototype.componentWillUnmount = function () {
	        this._storageSet('query', this.state.query);
	        this._storageSet('variables', this.state.variables);
	        this._storageSet('operationName', this.state.operationName);
	        this._storageSet('editorFlex', this.state.editorFlex);
	        this._storageSet('variableEditorHeight', this.state.variableEditorHeight);
	        this._storageSet('docExplorerWidth', this.state.docExplorerWidth);
	        this._storageSet('docExplorerOpen', this.state.docExplorerOpen);
	    };
	    CustomGraphiQL.prototype.render = function () {
	        var _this = this;
	        var children = React.Children.toArray(this.props.children);
	        // const logo =
	        //   find(children, child => child.type === CustomGraphiQL.Logo) ||
	        {}
	        {}
	        {}
	        {}
	        var footer = find_1.default(children, function (child) {
	            return child.type === CustomGraphiQL.Footer;
	        });
	        var queryWrapStyle = {
	            WebkitFlex: this.state.editorFlex,
	            flex: this.state.editorFlex
	        };
	        var docWrapStyle = {
	            height: '100%',
	            // display: this.state.docExplorerOpen ? 'block':'none',
	            width: this.state.docExplorerOpen ? this.state.docExplorerWidth : 0
	        };
	        var schemaWrapStyle = {
	            height: '100%',
	            // display: this.state.docExplorerOpen ? 'block':'none',
	            width: this.state.schemaExplorerOpen ? this.state.schemaExplorerWidth : 0
	        };
	        var docExplorerWrapClasses = 'docExplorerWrap' + (this.state.docExplorerWidth < 200 ? ' doc-explorer-narrow' : '');
	        var variableOpen = this.state.variableEditorOpen;
	        var variableStyle = {
	            height: variableOpen ? this.state.variableEditorHeight : null
	        };
	        var subscriptionResponse = this.state.responses.length > 1;
	        var Tether = this.props.tether;
	        return React.createElement(
	            "div",
	            { className: "graphiql-container", "data-jsx": 491787499
	            },
	            React.createElement(_style2.default, {
	                styleId: 1041892734,
	                css: ".graphiql-container[data-jsx=\"491787499\"] {font-family: Open Sans,sans-serif;}.docs-button[data-jsx=\"491787499\"],.schema-button[data-jsx=\"491787499\"] {padding-bottom: 8px;-webkit-transform: rotate(-90deg);transform: rotate(-90deg);left: -44px;top: 195px;}div.schema-button[data-jsx=\"491787499\"] {left: -53px;top: 120px;}.queryWrap[data-jsx=\"491787499\"] {border-top: 8px solid rgba(23, 42, 58, 1);}.graphiql-button[data-jsx=\"491787499\"] {top: -57px;right: 25px;padding: 5px 9px 6px 9px;letter-spacing: 0.53px;z-index: 2;}.download-button[data-jsx=\"491787499\"] {right: 25px;padding: 5px 9px 6px 9px;letter-spacing: 0.53px;z-index: 2;background-color: rgba(15, 32, 46, 1) !important;top: auto !important;top: initial !important;bottom: 21px !important;}.intro[data-jsx=\"491787499\"] {font-family: 'Source Code Pro',              'Consolas',              'Inconsolata',              'Droid Sans Mono',              'Monaco',              monospace;letter-spacing: 0.6px;width: 235px;}.result-window.disableResize[data-jsx=\"491787499\"] .CodeMirror-gutters {cursor: default !important;}.subscription-time[data-jsx=\"491787499\"] {height: 17px;margin-top: 12px;margin-bottom: 4px}.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before {content: \"\";top: 9px;left: 95px;border-top: 1px solid rgba(255, 255, 255, .2);}.subscription-time-text[data-jsx=\"491787499\"] {padding-left: 15px;}.listening[data-jsx=\"491787499\"] {font-family: 'Source Code Pro',              'Consolas',              'Inconsolata',              'Droid Sans Mono',              'Monaco',              monospace;letter-spacing: 0.6px;padding-left: 24px;padding-bottom: 30px;}.onboarding-hint.step1[data-jsx=\"491787499\"] {top: 207px;left: 90px;}.onboarding-hint.step2[data-jsx=\"491787499\"] {top: 207px;left: 90px;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.white,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"] {color: #fff;}.bgGreen,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"] {background-color: #27ae60;}.pa6,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"] {padding: 6px;}.br2,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {border-radius: 2px;}.z2,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"] {z-index: 2;}.ttu,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {text-transform: uppercase;}.fw6,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-weight: 600;}.f14,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-size: 14px;}.ph10,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"] {padding-left: 10px;padding-right: 10px;}.pointer:hover,\n.docs-button[data-jsx=\"491787499\"]:hover,\n.schema-button[data-jsx=\"491787499\"]:hover,\n.graphiql-button[data-jsx=\"491787499\"]:hover,\n.download-button[data-jsx=\"491787499\"]:hover {cursor: pointer;}.bgLightOrange,\ndiv.schema-button[data-jsx=\"491787499\"] {background-color: #f18f01;}.relative,\n.queryWrap[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"] {position: relative;}.white50,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {color: hsla(0,0%,100%,.5);}.bgDarkBlue,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.result-window[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {background-color: #172a3a;}.ttu,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {text-transform: uppercase;}.f14,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-size: 14px;}.fw6,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-weight: 600;}.br2,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {border-radius: 2px;}.pointer:hover,\n.docs-button[data-jsx=\"491787499\"]:hover,\n.schema-button[data-jsx=\"491787499\"]:hover,\n.graphiql-button[data-jsx=\"491787499\"]:hover,\n.download-button[data-jsx=\"491787499\"]:hover {cursor: pointer;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.white50,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {color: hsla(0,0%,100%,.5);}.bgDarkBlue,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.result-window[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {background-color: #172a3a;}.ttu,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {text-transform: uppercase;}.f14,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-size: 14px;}.fw6,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"] {font-weight: 600;}.br2,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {border-radius: 2px;}.pointer:hover,\n.docs-button[data-jsx=\"491787499\"]:hover,\n.schema-button[data-jsx=\"491787499\"]:hover,\n.graphiql-button[data-jsx=\"491787499\"]:hover,\n.download-button[data-jsx=\"491787499\"]:hover {cursor: pointer;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.tlCenter,\n.intro[data-jsx=\"491787499\"] {transform: translate(-50%,-50%);}.top50,\n.intro[data-jsx=\"491787499\"] {top: 50%;}.left50,\n.intro[data-jsx=\"491787499\"] {left: 50%;}.white20,\n.intro[data-jsx=\"491787499\"] {color: hsla(0,0%,100%,.2);}.f16,\n.intro[data-jsx=\"491787499\"],\n.listening[data-jsx=\"491787499\"] {font-size: 16px;}.tc,\n.intro[data-jsx=\"491787499\"] {text-align: center;}.bgDarkBlue,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.result-window[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {background-color: #172a3a;}.nosb,\n.result-window[data-jsx=\"491787499\"] {-ms-overflow-style: none;}.nosb::-webkit-scrollbar,\n.result-window[data-jsx=\"491787499\"]::-webkit-scrollbar {display: none;}.relative,\n.queryWrap[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"] {position: relative;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.w100,\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before {width: 100%;}.bgDarkBlue,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.result-window[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {background-color: #172a3a;}.white50,\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.subscription-time-text[data-jsx=\"491787499\"] {color: hsla(0,0%,100%,.5);}.f12,\n.subscription-time-text[data-jsx=\"491787499\"] {font-size: 12px;}.f16,\n.intro[data-jsx=\"491787499\"],\n.listening[data-jsx=\"491787499\"] {font-size: 16px;}.white40,\n.listening[data-jsx=\"491787499\"] {color: hsla(0,0%,100%,.4);}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.bottom0,\n.listening[data-jsx=\"491787499\"] {bottom: 0;}.absolute,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.intro[data-jsx=\"491787499\"],\n.subscription-time[data-jsx=\"491787499\"][data-jsx=\"491787499\"]:before,\n.listening[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {position: absolute;}.br2,\n.docs-button[data-jsx=\"491787499\"],\n.schema-button[data-jsx=\"491787499\"],\n.graphiql-button[data-jsx=\"491787499\"],\n.download-button[data-jsx=\"491787499\"],\n.onboarding-hint[data-jsx=\"491787499\"] {border-radius: 2px;}.z999,\n.onboarding-hint[data-jsx=\"491787499\"] {z-index: 999;}"
	            }),
	            React.createElement(_style2.default, {
	                styleId: 1032694800,
	                css: "\n          .query-header-enter {\n            opacity: 0.01;\n          }\n\n          .query-header-enter.query-header-enter-active {\n            opacity: 1;\n            -webkit-transition: opacity 500ms ease-in;\n            transition: opacity 500ms ease-in;\n          }\n\n          .query-header-leave {\n            opacity: 1;\n          }\n\n          .query-header-leave.query-header-leave-active {\n            opacity: 0.01;\n            -webkit-transition: opacity 300ms ease-in;\n            transition: opacity 300ms ease-in;\n          }\n        "
	            }),
	            React.createElement(
	                "div",
	                { className: "editorWrap", "data-jsx": 491787499
	                },
	                React.createElement(
	                    "div",
	                    { ref: function ref(n) {
	                            _this.editorBarComponent = n;
	                        }, className: "editorBar", onMouseDown: this.handleResizeStart, "data-jsx": 491787499
	                    },
	                    React.createElement(
	                        "div",
	                        { className: "queryWrap", style: queryWrapStyle, "data-jsx": 491787499
	                        },
	                        this.props.disableAnimation ? React.createElement(QueryHeader_1.default, { selectedEndpoint: this.props.selectedEndpoint, onChangeEndpoint: this.props.onChangeEndpoint, onPrettify: this.handlePrettifyQuery, showEndpoints: this.props.showEndpoints, showQueryTitle: this.props.showQueryTitle }) : React.createElement(
	                            CSSTransitionGroup,
	                            { transitionName: "query-header", transitionEnterTimeout: 500, transitionLeaveTimeout: 300 },
	                            !this.props.disableQueryHeader && React.createElement(QueryHeader_1.default, { selectedEndpoint: this.props.selectedEndpoint, onChangeEndpoint: this.props.onChangeEndpoint, onPrettify: this.handlePrettifyQuery, showEndpoints: this.props.showEndpoints, showQueryTitle: this.props.showQueryTitle })
	                        ),
	                        React.createElement(QueryEditor_1.QueryEditor, { ref: function ref(n) {
	                                _this.queryEditorComponent = n;
	                            }, schema: this.state.schema, value: this.state.query, onEdit: this.handleEditQuery, onHintInformationRender: this.handleHintInformationRender, onRunQuery: this.handleEditorRunQuery, disableAutofocus: this.props.disableAutofocus, hideLineNumbers: this.props.hideLineNumbers, hideGutters: this.props.hideGutters, readOnly: this.props.readonly }),
	                        React.createElement(
	                            "div",
	                            { className: "variable-editor", style: variableStyle, "data-jsx": 491787499
	                            },
	                            this.props.showCodeGeneration && React.createElement(
	                                "div",
	                                { className: "graphiql-button", onClick: this.props.onClickCodeGeneration, "data-jsx": 491787499
	                                },
	                                "Generate Code"
	                            ),
	                            React.createElement(
	                                "div",
	                                { className: "variable-editor-title", style: { cursor: variableOpen ? 'row-resize' : 'n-resize' }, onMouseDown: this.handleVariableResizeStart, "data-jsx": 491787499
	                                },
	                                'Query Variables'
	                            ),
	                            React.createElement(VariableEditor_1.VariableEditor, { ref: function ref(n) {
	                                    _this.variableEditorComponent = n;
	                                }, value: this.state.variables, variableToType: this.state.variableToType, onEdit: this.handleEditVariables, onHintInformationRender: this.handleHintInformationRender, onRunQuery: this.handleEditorRunQuery })
	                        ),
	                        ['STEP3_UNCOMMENT_DESCRIPTION', 'STEP3_ENTER_MUTATION1_VALUES', 'STEP3_ENTER_MUTATION2_VALUE'].indexOf(this.props.onboardingStep || '') > -1 && React.createElement(
	                            Tether,
	                            { steps: [{
	                                    step: 'STEP3_UNCOMMENT_DESCRIPTION',
	                                    title: 'Uncomment the description',
	                                    description: 'To add the description to the query, just remove the #'
	                                }, {
	                                    step: 'STEP3_ENTER_MUTATION1_VALUES',
	                                    title: 'This is a mutation',
	                                    description: 'Enter data for the imageUrl and the description',
	                                    buttonText: 'Autofill Data'
	                                }, {
	                                    step: 'STEP3_ENTER_MUTATION2_VALUE',
	                                    title: 'Lets add some more data',
	                                    description: 'Enter data for the imageUrl and the description',
	                                    buttonText: 'Autofill Data'
	                                }], onClick: function onClick() {
	                                    if (_this.props.onboardingStep.startsWith('STEP3_ENTER_MUTATION') && typeof _this.props.autofillMutation === 'function') {
	                                        _this.props.autofillMutation();
	                                    }
	                                } },
	                            React.createElement("div", { className: cn('onboarding-hint', {
	                                    'step1': this.props.onboardingStep === 'STEP3_UNCOMMENT_DESCRIPTION',
	                                    'step2': this.props.onboardingStep === 'STEP3_ENTER_MUTATION1_VALUES' || this.props.onboardingStep === 'STEP3_ENTER_MUTATION2_VALUE'
	                                }), "data-jsx": 491787499
	                            })
	                        )
	                    ),
	                    !this.props.queryOnly && React.createElement(
	                        "div",
	                        { className: "resultWrap", "data-jsx": 491787499
	                        },
	                        React.createElement(ResultHeader_1.default, { showViewAs: this.props.showViewAs, showSelectUser: this.props.showSelectUser, selectedViewer: this.props.selectedViewer, onChangeViewer: this.props.onChangeViewer, showResponseTitle: this.props.showResponseTitle }),
	                        this.props.tether ? React.createElement(
	                            Tether,
	                            { offsetX: 18, offsetY: 25, steps: [{
	                                    step: 'STEP3_RUN_QUERY1',
	                                    title: 'Execute your first query',
	                                    description: 'You just wrote your first GraphQL Query! Click here to execute it.'
	                                }, {
	                                    step: 'STEP3_RUN_MUTATION1',
	                                    title: 'Run your first mutation',
	                                    description: 'Awesome! You just wrote your first GraphQL Mutation. Click here to execute it'
	                                }, {
	                                    step: 'STEP3_RUN_MUTATION2',
	                                    title: 'Lets add more data'
	                                }, {
	                                    step: 'STEP3_RUN_QUERY2',
	                                    title: 'Let\'s see how the data changed',
	                                    description: 'After adding data with the mutations, lets' + ' see how the result of the query changes'
	                                }] },
	                            React.createElement(ExecuteButton_1.ExecuteButton, { isRunning: Boolean(this.state.subscription), onRun: this.handleRunQuery, onStop: this.handleStopQuery, operations: this.state.operations })
	                        ) : React.createElement(ExecuteButton_1.ExecuteButton, { isRunning: Boolean(this.state.subscription), onRun: this.handleRunQuery, onStop: this.handleStopQuery, operations: this.state.operations }),
	                        this.state.isWaitingForResponse && React.createElement(
	                            "div",
	                            { className: "spinner-container", "data-jsx": 491787499
	                            },
	                            React.createElement("div", { className: "spinner", "data-jsx": 491787499
	                            })
	                        ),
	                        React.createElement(
	                            "div",
	                            { className: 'result-window' + (this.props.disableResize ? ' disableResize' : ''), ref: function ref(c) {
	                                    _this.resultComponent = c;
	                                }, "data-jsx": 491787499
	                            },
	                            this.state.responses.filter(function (res) {
	                                return res && res.date;
	                            }).map(function (response, index) {
	                                return React.createElement(
	                                    "div",
	                                    { key: response.time, "data-jsx": 491787499
	                                    },
	                                    subscriptionResponse && response.time && React.createElement(
	                                        "div",
	                                        { className: "subscription-time", "data-jsx": 491787499
	                                        },
	                                        React.createElement(
	                                            "div",
	                                            { className: "subscription-time-text", "data-jsx": 491787499
	                                            },
	                                            ageOfDate_1.default(response.time)
	                                        )
	                                    ),
	                                    React.createElement(ResultViewer_1.ResultViewer, { value: response.date, hideGutters: _this.props.hideGutters })
	                                );
	                            })
	                        ),
	                        footer,
	                        !this.state.responses || this.state.responses.length === 0 && React.createElement(
	                            "div",
	                            { className: "intro", "data-jsx": 491787499
	                            },
	                            "Hit the Play Button to get a response here"
	                        ),
	                        Boolean(this.state.subscription) && React.createElement(
	                            "div",
	                            { className: "listening", "data-jsx": 491787499
	                            },
	                            "Listening \u2026"
	                        ),
	                        this.state.responses && this.state.responses.length > 0 && this.props.showDownloadJsonButton && React.createElement(
	                            "div",
	                            { className: "download-button", onClick: this.handleDownloadJSON, "data-jsx": 491787499
	                            },
	                            "Download JSON"
	                        )
	                    )
	                )
	            ),
	            (this.props.queryOnly ? this.props.showDocs : true) && React.createElement(
	                "div",
	                { className: docExplorerWrapClasses, style: docWrapStyle, "data-jsx": 491787499
	                },
	                React.createElement(
	                    "div",
	                    { className: "docs-button " + (!this.state.docExplorerOpen && 'inactive'), onClick: this.handleToggleDocs, "data-jsx": 491787499
	                    },
	                    "Docs"
	                ),
	                React.createElement("div", { className: "docExplorerResizer", onMouseDown: this.handleDocsResizeStart, "data-jsx": 491787499
	                }),
	                this.state.docExplorerOpen && React.createElement(DocExplorer_1.DocExplorer, { ref: function ref(c) {
	                        _this.docExplorerComponent = c;
	                    }, schema: this.state.schema, open: this.state.docExploreOpen })
	            ),
	            this.props.showSchema && React.createElement(
	                "div",
	                { className: docExplorerWrapClasses, style: schemaWrapStyle, "data-jsx": 491787499
	                },
	                React.createElement(
	                    "div",
	                    { className: "schema-button " + (!this.state.schemaExplorerOpen && 'inactive'), onClick: this.handleToggleSchema, "data-jsx": 491787499
	                    },
	                    "Schema"
	                ),
	                React.createElement("div", { className: "docExplorerResizer", onMouseDown: this.handleSchemaResizeStart, "data-jsx": 491787499
	                }),
	                this.state.schemaExplorerOpen && React.createElement(SchemaExplorer_1.default, { ref: function ref(c) {
	                        _this.docExplorerComponent = c;
	                    }, idl: this.props.schemaIdl, modelName: this.props.schemaModelName })
	            )
	        );
	    };
	    /**
	     * Inspect the query, automatically filling in selection sets for non-leaf
	     * fields which do not yet have them.
	     *
	     * @public
	     */
	    CustomGraphiQL.prototype.autoCompleteLeafs = function () {
	        var _a = fillLeafs_1.fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames),
	            insertions = _a.insertions,
	            result = _a.result;
	        if (insertions && insertions.length > 0) {
	            var editor_1 = this.queryEditorComponent.getCodeMirror();
	            editor_1.operation(function () {
	                var cursor = editor_1.getCursor();
	                var cursorIndex = editor_1.indexFromPos(cursor);
	                editor_1.setValue(result);
	                var added = 0;
	                var markers = insertions.map(function (_a) {
	                    var index = _a.index,
	                        str = _a.str;
	                    return editor_1.markText(editor_1.posFromIndex(index + added), editor_1.posFromIndex(index + (added += str.length)), {
	                        className: 'autoInsertedLeaf',
	                        clearOnEnter: true,
	                        title: 'Automatically added leaf fields'
	                    });
	                });
	                setTimeout(function () {
	                    return markers.forEach(function (marker) {
	                        return marker.clear();
	                    });
	                }, 7000);
	                var newCursorIndex = cursorIndex;
	                insertions.forEach(function (_a) {
	                    var index = _a.index,
	                        str = _a.str;
	                    if (index < cursorIndex) {
	                        newCursorIndex += str.length;
	                    }
	                });
	                editor_1.setCursor(editor_1.posFromIndex(newCursorIndex));
	            });
	        }
	        return result;
	    };
	    // Private methods
	    CustomGraphiQL.prototype._ensureOfSchema = function () {
	        var _this = this;
	        // Only perform introspection if a schema is not provided (undefined)
	        if (this.state.schema !== undefined) {
	            return;
	        }
	        var fetcher = this.props.fetcher;
	        var fetch = observableToPromise(fetcher({ query: introspectionQueries_1.introspectionQuery }));
	        if (!isPromise(fetch)) {
	            this.setState({
	                responses: [{ date: 'Fetcher did not return a Promise for introspection.', time: new Date() }]
	            });
	            return;
	        }
	        fetch.then(function (result) {
	            if (result.data) {
	                return result;
	            }
	            // Try the stock introspection query first, falling back on the
	            // sans-subscriptions query for services which do not yet support it.
	            var fetch2 = observableToPromise(fetcher({
	                query: introspectionQueries_1.introspectionQuerySansSubscriptions
	            }));
	            if (!isPromise(fetch)) {
	                throw new Error('Fetcher did not return a Promise for introspection.');
	            }
	            return fetch2;
	        }).then(function (result) {
	            // If a schema was provided while this fetch was underway, then
	            // satisfy the race condition by respecting the already
	            // provided schema.
	            if (_this.state.schema !== undefined) {
	                return;
	            }
	            if (result && result.data) {
	                var schema = graphql_1.buildClientSchema(result.data);
	                var queryFacts = getQueryFacts_1.default(schema, _this.state.query);
	                _this.setState(__assign({ schema: schema }, queryFacts));
	            } else {
	                var responseString = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
	                _this.setState({
	                    // Set schema to `null` to explicitly indicate that no schema exists.
	                    schema: null,
	                    responses: [{ date: responseString, time: new Date() }]
	                });
	            }
	        }).catch(function (error) {
	            _this.setState({
	                schema: null,
	                responses: [{ date: error && String(error.stack || error), time: new Date() }]
	            });
	        });
	    };
	    CustomGraphiQL.prototype._storageGet = function (name) {
	        if (this._storage) {
	            var value = this._storage.getItem('graphiql:' + name);
	            // Clean up any inadvertently saved null/undefined values.
	            if (value === 'null' || value === 'undefined') {
	                this._storage.removeItem('graphiql:' + name);
	            } else {
	                return value;
	            }
	        }
	    };
	    CustomGraphiQL.prototype._storageSet = function (name, value) {
	        if (this._storage) {
	            if (value) {
	                this._storage.setItem('graphiql:' + name, value);
	            } else {
	                this._storage.removeItem('graphiql:' + name);
	            }
	        }
	    };
	    CustomGraphiQL.prototype._fetchQuery = function (query, variables, operationName, cb) {
	        var _this = this;
	        var fetcher = this.props.fetcher;
	        var jsonVariables = null;
	        try {
	            jsonVariables = variables && variables.trim() !== '' ? JSON.parse(variables) : null;
	        } catch (error) {
	            throw new Error("Variables are invalid JSON: " + error.message + ".");
	        }
	        if ((typeof jsonVariables === "undefined" ? "undefined" : _typeof(jsonVariables)) !== 'object') {
	            throw new Error('Variables are not a JSON object.');
	        }
	        var fetch = fetcher({
	            query: query,
	            variables: jsonVariables,
	            operationName: operationName
	        });
	        if (isPromise(fetch)) {
	            // If fetcher returned a Promise, then call the callback when the promise
	            // resolves, otherwise handle the error.
	            fetch.then(cb).catch(function (error) {
	                _this.setState({
	                    isWaitingForResponse: false,
	                    responses: [{ date: error && String(error.stack || error), time: new Date() }]
	                });
	            });
	        } else if (isObservable(fetch)) {
	            // If the fetcher returned an Observable, then subscribe to it, calling
	            // the callback on each next value, and handling both errors and the
	            // completion of the Observable. Returns a Subscription object.
	            var subscription = fetch.subscribe({
	                next: cb,
	                error: function error(_error) {
	                    _this.setState({
	                        isWaitingForResponse: false,
	                        responses: [{ date: _error && String(_error.stack || _error), time: new Date() }],
	                        subscription: null
	                    });
	                },
	                complete: function complete() {
	                    _this.setState({
	                        isWaitingForResponse: false,
	                        subscription: null
	                    });
	                }
	            });
	            return subscription;
	        } else {
	            throw new Error('Fetcher did not return Promise or Observable.');
	        }
	    };
	    CustomGraphiQL.prototype._runQueryAtCursor = function () {
	        if (this.state.subscription) {
	            this.handleStopQuery();
	            return;
	        }
	        var operationName;
	        var operations = this.state.operations;
	        if (operations) {
	            var editor = this.queryEditorComponent.getCodeMirror();
	            if (editor.hasFocus()) {
	                var cursor = editor.getCursor();
	                var cursorIndex = editor.indexFromPos(cursor);
	                // Loop through all operations to see if one contains the cursor.
	                for (var i = 0; i < operations.length; i++) {
	                    var operation = operations[i];
	                    if (operation.loc.start <= cursorIndex && operation.loc.end >= cursorIndex) {
	                        operationName = operation.name && operation.name.value;
	                        break;
	                    }
	                }
	            }
	        }
	        this.handleRunQuery(operationName);
	    };
	    CustomGraphiQL.prototype._didClickDragBar = function (event) {
	        // Only for primary unmodified clicks
	        if (event.button !== 0 || event.ctrlKey) {
	            return false;
	        }
	        var target = event.target;
	        // We use codemirror's gutter as the drag bar.
	        if (target.className.indexOf && target.className.indexOf('CodeMirror-gutter') !== 0) {
	            return false;
	        }
	        // Specifically the result window's drag bar.
	        var resultWindow = ReactDOM.findDOMNode(this.resultComponent);
	        while (target) {
	            if (target === resultWindow) {
	                return true;
	            }
	            target = target.parentNode;
	        }
	        return false;
	    };
	    return CustomGraphiQL;
	}(React.Component);
	exports.CustomGraphiQL = CustomGraphiQL;
	// Configure the UI by providing this Component as a child of CustomGraphiQL.
	CustomGraphiQL.Logo = function GraphiQLLogo(props) {
	    return React.createElement(
	        "div",
	        { className: "title" },
	        props.children || React.createElement(
	            "span",
	            null,
	            'Graph',
	            React.createElement(
	                "em",
	                null,
	                'i'
	            ),
	            'QL'
	        )
	    );
	};
	// Configure the UI by providing this Component as a child of CustomGraphiQL.
	CustomGraphiQL.Toolbar = function GraphiQLToolbar(props) {
	    return React.createElement(
	        "div",
	        { className: "toolbar" },
	        props.children
	    );
	};
	// Add a button to the Toolbar.
	CustomGraphiQL.ToolbarButton = ToolbarButton_1.ToolbarButton;
	// Configure the UI by providing this Component as a child of CustomGraphiQL.
	CustomGraphiQL.Footer = function GraphiQLFooter(props) {
	    return React.createElement(
	        "div",
	        { className: "footer" },
	        props.children
	    );
	};
	var defaultQuery = "# Welcome to Graphcool's custom GraphiQL \u270C\n#\n# GraphiQL is an in-browser IDE for writing, validating, and\n# testing GraphQL queries.\n#\n# In Graphcool's custom GraphiQL you can additionally generate\n# code examples and download the result JSON.\n#\n# Type queries into this side of the screen, and you will\n# see intelligent typeaheads aware of the current GraphQL type schema and\n# live syntax and validation errors highlighted within the text.\n#\n# To bring up the auto-complete at any point, just press Ctrl-Space.\n#\n# Press the run button above, or Cmd-Enter to execute the query, and the result\n# will appear in the pane to the right.\n\n";
	// Duck-type promise detection.
	function isPromise(value) {
	    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && typeof value.then === 'function';
	}
	// Duck-type Observable.take(1).toPromise()
	function observableToPromise(observable) {
	    if (!isObservable(observable)) {
	        return observable;
	    }
	    return new Promise(function (resolve, reject) {
	        var subscription = observable.subscribe(function (v) {
	            resolve(v);
	            subscription.unsubscribe();
	        }, reject, function () {
	            reject(new Error('no value resolved'));
	        });
	    });
	}
	// Duck-type observable detection.
	function isObservable(value) {
	    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && typeof value.subscribe === 'function';
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var onHasCompletion_1 = __webpack_require__(254);
	var QueryEditor = function (_super) {
	    __extends(QueryEditor, _super);
	    function QueryEditor(props) {
	        var _this = _super.call(this) || this;
	        _this._onKeyUp = function (cm, event) {
	            var code = event.keyCode;
	            if (code >= 65 && code <= 90 || !event.shiftKey && code >= 48 && code <= 57 || event.shiftKey && code === 189 || event.shiftKey && code === 50 || event.shiftKey && code === 57 // (
	            ) {
	                    _this.editor.execCommand('autocomplete');
	                }
	        };
	        _this._onEdit = function () {
	            if (!_this.ignoreChangeEvent) {
	                _this.cachedValue = _this.editor.getValue();
	                if (_this.props.onEdit) {
	                    _this.props.onEdit(_this.cachedValue);
	                }
	            }
	        };
	        /**
	         * Render a custom UI for CodeMirror's hint which includes additional info
	         * about the type and description for the selected context.
	         */
	        _this._onHasCompletion = function (cm, data) {
	            onHasCompletion_1.default(cm, data, _this.props.onHintInformationRender);
	        };
	        // Keep a cached version of the value, this cache will be updated when the
	        // editor is updated, which can later be used to protect the editor from
	        // unnecessary updates during the update lifecycle.
	        _this.cachedValue = props.value || '';
	        return _this;
	    }
	    QueryEditor.prototype.componentDidMount = function () {
	        var _this = this;
	        // Lazily require to ensure requiring GraphiQL outside of a Browser context
	        // does not produce an error.
	        var CodeMirror = __webpack_require__(5);
	        __webpack_require__(214);
	        __webpack_require__(402);
	        __webpack_require__(127);
	        __webpack_require__(213);
	        __webpack_require__(129);
	        __webpack_require__(128);
	        __webpack_require__(215);
	        __webpack_require__(403);
	        __webpack_require__(131);
	        __webpack_require__(392);
	        __webpack_require__(393);
	        __webpack_require__(394);
	        var gutters = [];
	        if (!this.props.hideLineNumbers) {
	            gutters.push('CodeMirror-linenumbers');
	        }
	        if (!this.props.hideGutters) {
	            gutters.push('CodeMirror-foldgutter');
	        }
	        var foldGutter = {};
	        if (!this.props.hideGutters) {
	            foldGutter = {
	                minFoldSize: 4
	            };
	        }
	        this.editor = CodeMirror(this._node, {
	            autofocus: !this.props.disableAutofocus,
	            placeholder: this.props.placeholder,
	            value: this.props.value || '',
	            lineNumbers: !this.props.hideLineNumbers,
	            tabSize: 2,
	            mode: 'graphql',
	            theme: 'graphiql',
	            keyMap: 'sublime',
	            autoCloseBrackets: true,
	            matchBrackets: true,
	            showCursorWhenSelecting: true,
	            readOnly: Boolean(this.props.readOnly),
	            foldGutter: foldGutter,
	            lint: {
	                schema: this.props.schema
	            },
	            hintOptions: {
	                schema: this.props.schema,
	                closeOnUnfocus: true,
	                completeSingle: false
	            },
	            gutters: gutters,
	            extraKeys: {
	                'Cmd-Space': function CmdSpace() {
	                    return _this.editor.showHint({ completeSingle: true });
	                },
	                'Ctrl-Space': function CtrlSpace() {
	                    return _this.editor.showHint({ completeSingle: true });
	                },
	                'Alt-Space': function AltSpace() {
	                    return _this.editor.showHint({ completeSingle: true });
	                },
	                'Shift-Space': function ShiftSpace() {
	                    return _this.editor.showHint({ completeSingle: true });
	                },
	                'Cmd-Enter': function CmdEnter() {
	                    if (_this.props.onRunQuery) {
	                        _this.props.onRunQuery();
	                    }
	                },
	                'Ctrl-Enter': function CtrlEnter() {
	                    if (_this.props.onRunQuery) {
	                        _this.props.onRunQuery();
	                    }
	                },
	                // Editor improvements
	                'Ctrl-Left': 'goSubwordLeft',
	                'Ctrl-Right': 'goSubwordRight',
	                'Alt-Left': 'goGroupLeft',
	                'Alt-Right': 'goGroupRight'
	            }
	        });
	        this.editor.on('change', this._onEdit);
	        this.editor.on('keyup', this._onKeyUp);
	        this.editor.on('hasCompletion', this._onHasCompletion);
	        global['editor'] = this.editor;
	    };
	    QueryEditor.prototype.componentDidUpdate = function (prevProps) {
	        var CodeMirror = __webpack_require__(5);
	        // Ensure the changes caused by this update are not interpretted as
	        // user-input changes which could otherwise result in an infinite
	        // event loop.
	        this.ignoreChangeEvent = true;
	        if (this.props.schema !== prevProps.schema) {
	            this.editor.options.lint.schema = this.props.schema;
	            this.editor.options.hintOptions.schema = this.props.schema;
	            CodeMirror.signal(this.editor, 'change', this.editor);
	        }
	        if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
	            this.cachedValue = this.props.value;
	            this.editor.setValue(this.props.value);
	        }
	        this.ignoreChangeEvent = false;
	    };
	    QueryEditor.prototype.componentWillUnmount = function () {
	        this.editor.off('change', this._onEdit);
	        this.editor.off('keyup', this._onKeyUp);
	        this.editor.off('hasCompletion', this._onHasCompletion);
	        this.editor = null;
	    };
	    QueryEditor.prototype.render = function () {
	        var _this = this;
	        return React.createElement("div", { className: "query-editor", ref: function ref(node) {
	                _this._node = node;
	            } });
	    };
	    /**
	     * Public API for retrieving the CodeMirror instance from this
	     * React component.
	     */
	    QueryEditor.prototype.getCodeMirror = function () {
	        return this.editor;
	    };
	    /**
	     * Public API for retrieving the DOM client height for this component.
	     */
	    QueryEditor.prototype.getClientHeight = function () {
	        return this._node && this._node.clientHeight;
	    };
	    return QueryEditor;
	}(React.Component);
	exports.QueryEditor = QueryEditor;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = DefaultValue;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _graphql = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function DefaultValue(_ref) {
	  var field = _ref.field;
	  var type = field.type,
	      defaultValue = field.defaultValue;
	
	  if (defaultValue !== undefined) {
	    return _react2.default.createElement(
	      'span',
	      null,
	      ' = ',
	      _react2.default.createElement(
	        'span',
	        { className: 'arg-default-value' },
	        (0, _graphql.print)((0, _graphql.astFromValue)(defaultValue, type))
	      )
	    );
	  }
	
	  return null;
	} /**
	   *  Copyright (c) Facebook, Inc.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the license found in the
	   *  LICENSE file in the root directory of this source tree.
	   */
	
	DefaultValue.propTypes = {
	  field: _propTypes2.default.object.isRequired
	};

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = onHasCompletion;
	
	var _graphql = __webpack_require__(12);
	
	var _marked = __webpack_require__(297);
	
	var _marked2 = _interopRequireDefault(_marked);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Render a custom UI for CodeMirror's hint which includes additional info
	 * about the type and description for the selected context.
	 */
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	function onHasCompletion(cm, data, onHintInformationRender) {
	  var CodeMirror = __webpack_require__(5);
	
	  var information = void 0;
	  var deprecation = void 0;
	
	  // When a hint result is selected, we augment the UI with information.
	  CodeMirror.on(data, 'select', function (ctx, el) {
	    // Only the first time (usually when the hint UI is first displayed)
	    // do we create the information nodes.
	    if (!information) {
	      var hintsUl = el.parentNode;
	
	      // This "information" node will contain the additional info about the
	      // highlighted typeahead option.
	      information = document.createElement('div');
	      information.className = 'CodeMirror-hint-information';
	      hintsUl.appendChild(information);
	
	      // This "deprecation" node will contain info about deprecated usage.
	      deprecation = document.createElement('div');
	      deprecation.className = 'CodeMirror-hint-deprecation';
	      hintsUl.appendChild(deprecation);
	
	      // When CodeMirror attempts to remove the hint UI, we detect that it was
	      // removed and in turn remove the information nodes.
	      var _onRemoveFn = void 0;
	      hintsUl.addEventListener('DOMNodeRemoved', _onRemoveFn = function onRemoveFn(event) {
	        if (event.target === hintsUl) {
	          hintsUl.removeEventListener('DOMNodeRemoved', _onRemoveFn);
	          information = null;
	          deprecation = null;
	          _onRemoveFn = null;
	        }
	      });
	    }
	
	    // Now that the UI has been set up, add info to information.
	    var description = ctx.description ? (0, _marked2.default)(ctx.description, { sanitize: true }) : 'Self descriptive.';
	    var type = ctx.type ? '<span class="infoType">' + renderType(ctx.type) + '</span>' : '';
	
	    information.innerHTML = '<div class="content">' + (description.slice(0, 3) === '<p>' ? '<p>' + type + description.slice(3) : type + description) + '</div>';
	
	    if (ctx.isDeprecated) {
	      var reason = ctx.deprecationReason ? (0, _marked2.default)(ctx.deprecationReason, { sanitize: true }) : '';
	      deprecation.innerHTML = '<span class="deprecation-label">Deprecated</span>' + reason;
	      deprecation.style.display = 'block';
	    } else {
	      deprecation.style.display = 'none';
	    }
	
	    // Additional rendering?
	    if (onHintInformationRender) {
	      onHintInformationRender(information);
	    }
	  });
	}
	
	function renderType(type) {
	  if (type instanceof _graphql.GraphQLNonNull) {
	    return renderType(type.ofType) + '!';
	  }
	  if (type instanceof _graphql.GraphQLList) {
	    return '[' + renderType(type.ofType) + ']';
	  }
	  return '<a class="typeName">' + type.name + '</a>';
	}

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./GraphQLLanguageService": 157,
		"./GraphQLLanguageService.js": 157,
		"./autocompleteUtils": 102,
		"./autocompleteUtils.js": 102,
		"./getAutocompleteSuggestions": 103,
		"./getAutocompleteSuggestions.js": 103,
		"./getDefinition": 104,
		"./getDefinition.js": 104,
		"./getDiagnostics": 105,
		"./getDiagnostics.js": 105,
		"./getOutline": 158,
		"./getOutline.js": 158,
		"./index": 106,
		"./index.js": 106,
		"./index.js.flow": 604
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 255;


/***/ }),
/* 256 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.opt = opt;
	exports.list = list;
	exports.butNot = butNot;
	exports.t = t;
	exports.p = p;
	
	
	// An optional rule.
	function opt(ofRule) {
	  return { ofRule: ofRule };
	}
	
	// A list of another rule.
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	// These functions help build matching rules for ParseRules.
	
	function list(ofRule, separator) {
	  return { ofRule: ofRule, isList: true, separator: separator };
	}
	
	// An constraint described as `but not` in the GraphQL spec.
	function butNot(rule, exclusions) {
	  var ruleMatch = rule.match;
	  rule.match = function (token) {
	    var check = false;
	    if (ruleMatch) {
	      check = ruleMatch(token);
	    }
	    return check && exclusions.every(function (exclusion) {
	      return exclusion.match && !exclusion.match(token);
	    });
	  };
	  return rule;
	}
	
	// Token of a kind
	function t(kind, style) {
	  return { style: style, match: function match(token) {
	      return token.kind === kind;
	    } };
	}
	
	// Punctuator
	function p(value, style) {
	  return {
	    style: style || 'punctuation',
	    match: function match(token) {
	      return token.kind === 'Punctuation' && token.value === value;
	    }
	  };
	}

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParseRules = exports.LexRules = exports.isIgnored = undefined;
	
	var _RuleHelpers = __webpack_require__(256);
	
	/**
	  * Whitespace tokens defined in GraphQL spec.
	  */
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	var isIgnored = exports.isIgnored = function isIgnored(ch) {
	  return ch === ' ' || ch === '\t' || ch === ',' || ch === '\n' || ch === '\r' || ch === '\uFEFF';
	};
	
	/**
	 * The lexer rules. These are exactly as described by the spec.
	 */
	var LexRules = exports.LexRules = {
	  // The Name token.
	  Name: /^[_A-Za-z][_0-9A-Za-z]*/,
	
	  // All Punctuation used in GraphQL
	  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|@|\[|]|\{|\||\})/,
	
	  // Combines the IntValue and FloatValue tokens.
	  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
	
	  // Note the closing quote is made optional as an IDE experience improvment.
	  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
	
	  // Comments consume entire lines.
	  Comment: /^#.*/
	};
	
	/**
	 * The parser rules. These are very close to, but not exactly the same as the
	 * spec. Minor deviations allow for a simpler implementation. The resulting
	 * parser can parse everything the spec declares possible.
	 */
	var ParseRules = exports.ParseRules = {
	  Document: [(0, _RuleHelpers.list)('Definition')],
	  Definition: function Definition(token) {
	    switch (token.value) {
	      case '{':
	        return 'ShortQuery';
	      case 'query':
	        return 'Query';
	      case 'mutation':
	        return 'Mutation';
	      case 'subscription':
	        return 'Subscription';
	      case 'fragment':
	        return 'FragmentDefinition';
	      case 'schema':
	        return 'SchemaDef';
	      case 'scalar':
	        return 'ScalarDef';
	      case 'type':
	        return 'ObjectTypeDef';
	      case 'interface':
	        return 'InterfaceDef';
	      case 'union':
	        return 'UnionDef';
	      case 'enum':
	        return 'EnumDef';
	      case 'input':
	        return 'InputDef';
	      case 'extend':
	        return 'ExtendDef';
	      case 'directive':
	        return 'DirectiveDef';
	    }
	  },
	
	  // Note: instead of "Operation", these rules have been separated out.
	  ShortQuery: ['SelectionSet'],
	  Query: [word('query'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],
	  Mutation: [word('mutation'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],
	  Subscription: [word('subscription'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],
	  VariableDefinitions: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('VariableDefinition'), (0, _RuleHelpers.p)(')')],
	  VariableDefinition: ['Variable', (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue')],
	  Variable: [(0, _RuleHelpers.p)('$', 'variable'), name('variable')],
	  DefaultValue: [(0, _RuleHelpers.p)('='), 'Value'],
	  SelectionSet: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('Selection'), (0, _RuleHelpers.p)('}')],
	  Selection: function Selection(token, stream) {
	    return token.value === '...' ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\s\u00a0,]*:/, false) ? 'AliasedField' : 'Field';
	  },
	
	  // Note: this minor deviation of "AliasedField" simplifies the lookahead.
	  AliasedField: [name('property'), (0, _RuleHelpers.p)(':'), name('qualifier'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],
	  Field: [name('property'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],
	  Arguments: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('Argument'), (0, _RuleHelpers.p)(')')],
	  Argument: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],
	  FragmentSpread: [(0, _RuleHelpers.p)('...'), name('def'), (0, _RuleHelpers.list)('Directive')],
	  InlineFragment: [(0, _RuleHelpers.p)('...'), (0, _RuleHelpers.opt)('TypeCondition'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],
	  FragmentDefinition: [word('fragment'), (0, _RuleHelpers.opt)((0, _RuleHelpers.butNot)(name('def'), [word('on')])), 'TypeCondition', (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],
	  TypeCondition: [word('on'), 'NamedType'],
	  // Variables could be parsed in cases where only Const is expected by spec.
	  Value: function Value(token) {
	    switch (token.kind) {
	      case 'Number':
	        return 'NumberValue';
	      case 'String':
	        return 'StringValue';
	      case 'Punctuation':
	        switch (token.value) {
	          case '[':
	            return 'ListValue';
	          case '{':
	            return 'ObjectValue';
	          case '$':
	            return 'Variable';
	        }
	        return null;
	      case 'Name':
	        switch (token.value) {
	          case 'true':
	          case 'false':
	            return 'BooleanValue';
	        }
	        if (token.value === 'null') {
	          return 'NullValue';
	        }
	        return 'EnumValue';
	    }
	  },
	
	  NumberValue: [(0, _RuleHelpers.t)('Number', 'number')],
	  StringValue: [(0, _RuleHelpers.t)('String', 'string')],
	  BooleanValue: [(0, _RuleHelpers.t)('Name', 'builtin')],
	  NullValue: [(0, _RuleHelpers.t)('Name', 'keyword')],
	  EnumValue: [name('string-2')],
	  ListValue: [(0, _RuleHelpers.p)('['), (0, _RuleHelpers.list)('Value'), (0, _RuleHelpers.p)(']')],
	  ObjectValue: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('ObjectField'), (0, _RuleHelpers.p)('}')],
	  ObjectField: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],
	  Type: function Type(token) {
	    return token.value === '[' ? 'ListType' : 'NonNullType';
	  },
	
	  // NonNullType has been merged into ListType to simplify.
	  ListType: [(0, _RuleHelpers.p)('['), 'Type', (0, _RuleHelpers.p)(']'), (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],
	  NonNullType: ['NamedType', (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],
	  NamedType: [type('atom')],
	  Directive: [(0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('Arguments')],
	  // GraphQL schema language
	  SchemaDef: [word('schema'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('OperationTypeDef'), (0, _RuleHelpers.p)('}')],
	  OperationTypeDef: [name('keyword'), (0, _RuleHelpers.p)(':'), name('atom')],
	  ScalarDef: [word('scalar'), name('atom'), (0, _RuleHelpers.list)('Directive')],
	  ObjectTypeDef: [word('type'), name('atom'), (0, _RuleHelpers.opt)('Implements'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],
	  Implements: [word('implements'), (0, _RuleHelpers.list)('NamedType')],
	  FieldDef: [name('property'), (0, _RuleHelpers.opt)('ArgumentsDef'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.list)('Directive')],
	  ArgumentsDef: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)(')')],
	  InputValueDef: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue'), (0, _RuleHelpers.list)('Directive')],
	  InterfaceDef: [word('interface'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],
	  UnionDef: [word('union'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('='), (0, _RuleHelpers.list)('UnionMember', (0, _RuleHelpers.p)('|'))],
	  UnionMember: ['NamedType'],
	  EnumDef: [word('enum'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('EnumValueDef'), (0, _RuleHelpers.p)('}')],
	  EnumValueDef: [name('string-2'), (0, _RuleHelpers.list)('Directive')],
	  InputDef: [word('input'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)('}')],
	  ExtendDef: [word('extend'), 'ObjectTypeDef'],
	  DirectiveDef: [word('directive'), (0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('ArgumentsDef'), word('on'), (0, _RuleHelpers.list)('DirectiveLocation', (0, _RuleHelpers.p)('|'))],
	  DirectiveLocation: [name('string-2')]
	};
	
	// A keyword Token.
	function word(value) {
	  return {
	    style: 'keyword',
	    match: function match(token) {
	      return token.kind === 'Name' && token.value === value;
	    }
	  };
	}
	
	// A Name Token which will decorate the state with a `name`.
	function name(style) {
	  return {
	    style: style,
	    match: function match(token) {
	      return token.kind === 'Name';
	    },
	    update: function update(state, token) {
	      state.name = token.value;
	    }
	  };
	}
	
	// A Name Token which will decorate the previous state with a `type`.
	function type(style) {
	  return {
	    style: style,
	    match: function match(token) {
	      return token.kind === 'Name';
	    },
	    update: function update(state, token) {
	      if (state.prevState && state.prevState.prevState) {
	        state.name = token.value;
	        state.prevState.prevState.type = token.value;
	      }
	    }
	  };
	}

/***/ }),
/* 258 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.offsetToPosition = offsetToPosition;
	exports.locToRange = locToRange;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  
	 */
	
	var Range = exports.Range = function () {
	  function Range(start, end) {
	    var _this = this;
	
	    _classCallCheck(this, Range);
	
	    this.containsPosition = function (position) {
	      if (_this.start.line === position.line) {
	        return _this.start.character <= position.character;
	      } else if (_this.end.line === position.line) {
	        return _this.end.character >= position.character;
	      } else {
	        return _this.start.line <= position.line && _this.end.line >= position.line;
	      }
	    };
	
	    this.start = start;
	    this.end = end;
	  }
	
	  Range.prototype.setStart = function setStart(line, character) {
	    this.start = new Position(line, character);
	  };
	
	  Range.prototype.setEnd = function setEnd(line, character) {
	    this.end = new Position(line, character);
	  };
	
	  return Range;
	}();
	
	var Position = exports.Position = function () {
	  function Position(line, character) {
	    var _this2 = this;
	
	    _classCallCheck(this, Position);
	
	    this.lessThanOrEqualTo = function (position) {
	      return _this2.line < position.line || _this2.line === position.line && _this2.character <= position.character;
	    };
	
	    this.line = line;
	    this.character = character;
	  }
	
	  Position.prototype.setLine = function setLine(line) {
	    this.line = line;
	  };
	
	  Position.prototype.setCharacter = function setCharacter(character) {
	    this.character = character;
	  };
	
	  return Position;
	}();
	
	function offsetToPosition(text, loc) {
	  var EOL = '\n';
	  var buf = text.slice(0, loc);
	  var lines = buf.split(EOL).length - 1;
	  var lastLineIndex = buf.lastIndexOf(EOL);
	  return new Position(lines, loc - lastLineIndex - 1);
	}
	
	function locToRange(text, loc) {
	  var start = offsetToPosition(text, loc.start);
	  var end = offsetToPosition(text, loc.end);
	  return new Range(start, end);
	}

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.locatedError = locatedError;
	
	var _GraphQLError = __webpack_require__(57);
	
	/**
	 * Given an arbitrary Error, presumably thrown while attempting to execute a
	 * GraphQL operation, produce a new GraphQLError aware of the location in the
	 * document responsible for the original Error.
	 */
	function locatedError(originalError, nodes, path) {
	  // Note: this uses a brand-check to support GraphQL errors originating from
	  // other contexts.
	  if (originalError && originalError.path) {
	    return originalError;
	  }
	
	  var message = originalError ? originalError.message || String(originalError) : 'An unknown error occurred.';
	  return new _GraphQLError.GraphQLError(message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Source = undefined;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	/**
	 * A representation of source input to GraphQL.
	 * `name` and `locationOffset` are optional. They are useful for clients who
	 * store GraphQL documents in source files; for example, if the GraphQL input
	 * starts at line 40 in a file named Foo.graphql, it might be useful for name to
	 * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
	 * line and column in locationOffset are 1-indexed
	 */
	var Source = exports.Source = function Source(body, name, locationOffset) {
	  _classCallCheck(this, Source);
	
	  this.body = body;
	  this.name = name || 'GraphQL request';
	  this.locationOffset = locationOffset || { line: 1, column: 1 };
	  !(this.locationOffset.line > 0) ? (0, _invariant2.default)(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;
	  !(this.locationOffset.column > 0) ? (0, _invariant2.default)(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;
	};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buildASTSchema = buildASTSchema;
	exports.getDeprecationReason = getDeprecationReason;
	exports.getDescription = getDescription;
	exports.buildSchema = buildSchema;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _keyValMap = __webpack_require__(161);
	
	var _keyValMap2 = _interopRequireDefault(_keyValMap);
	
	var _valueFromAST = __webpack_require__(81);
	
	var _lexer = __webpack_require__(164);
	
	var _parser = __webpack_require__(108);
	
	var _values = __webpack_require__(160);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _schema = __webpack_require__(34);
	
	var _scalars = __webpack_require__(42);
	
	var _definition = __webpack_require__(7);
	
	var _directives = __webpack_require__(33);
	
	var _introspection = __webpack_require__(41);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function buildWrappedType(innerType, inputTypeNode) {
	  if (inputTypeNode.kind === Kind.LIST_TYPE) {
	    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeNode.type));
	  }
	  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {
	    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);
	    !!(wrappedType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;
	    return new _definition.GraphQLNonNull(wrappedType);
	  }
	  return innerType;
	}
	
	function getNamedTypeNode(typeNode) {
	  var namedType = typeNode;
	  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {
	    namedType = namedType.type;
	  }
	  return namedType;
	}
	
	/**
	 * This takes the ast of a schema document produced by the parse function in
	 * src/language/parser.js.
	 *
	 * If no schema definition is provided, then it will look for types named Query
	 * and Mutation.
	 *
	 * Given that AST it constructs a GraphQLSchema. The resulting schema
	 * has no resolve methods, so execution will use default resolvers.
	 */
	function buildASTSchema(ast) {
	  if (!ast || ast.kind !== Kind.DOCUMENT) {
	    throw new Error('Must provide a document ast.');
	  }
	
	  var schemaDef = void 0;
	
	  var typeDefs = [];
	  var nodeMap = Object.create(null);
	  var directiveDefs = [];
	  for (var i = 0; i < ast.definitions.length; i++) {
	    var d = ast.definitions[i];
	    switch (d.kind) {
	      case Kind.SCHEMA_DEFINITION:
	        if (schemaDef) {
	          throw new Error('Must provide only one schema definition.');
	        }
	        schemaDef = d;
	        break;
	      case Kind.SCALAR_TYPE_DEFINITION:
	      case Kind.OBJECT_TYPE_DEFINITION:
	      case Kind.INTERFACE_TYPE_DEFINITION:
	      case Kind.ENUM_TYPE_DEFINITION:
	      case Kind.UNION_TYPE_DEFINITION:
	      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
	        var typeName = d.name.value;
	        if (nodeMap[typeName]) {
	          throw new Error('Type "' + typeName + '" was defined more than once.');
	        }
	        typeDefs.push(d);
	        nodeMap[typeName] = d;
	        break;
	      case Kind.DIRECTIVE_DEFINITION:
	        directiveDefs.push(d);
	        break;
	    }
	  }
	
	  var queryTypeName = void 0;
	  var mutationTypeName = void 0;
	  var subscriptionTypeName = void 0;
	  if (schemaDef) {
	    schemaDef.operationTypes.forEach(function (operationType) {
	      var typeName = operationType.type.name.value;
	      if (operationType.operation === 'query') {
	        if (queryTypeName) {
	          throw new Error('Must provide only one query type in schema.');
	        }
	        if (!nodeMap[typeName]) {
	          throw new Error('Specified query type "' + typeName + '" not found in document.');
	        }
	        queryTypeName = typeName;
	      } else if (operationType.operation === 'mutation') {
	        if (mutationTypeName) {
	          throw new Error('Must provide only one mutation type in schema.');
	        }
	        if (!nodeMap[typeName]) {
	          throw new Error('Specified mutation type "' + typeName + '" not found in document.');
	        }
	        mutationTypeName = typeName;
	      } else if (operationType.operation === 'subscription') {
	        if (subscriptionTypeName) {
	          throw new Error('Must provide only one subscription type in schema.');
	        }
	        if (!nodeMap[typeName]) {
	          throw new Error('Specified subscription type "' + typeName + '" not found in document.');
	        }
	        subscriptionTypeName = typeName;
	      }
	    });
	  } else {
	    if (nodeMap.Query) {
	      queryTypeName = 'Query';
	    }
	    if (nodeMap.Mutation) {
	      mutationTypeName = 'Mutation';
	    }
	    if (nodeMap.Subscription) {
	      subscriptionTypeName = 'Subscription';
	    }
	  }
	
	  if (!queryTypeName) {
	    throw new Error('Must provide schema definition with query type or a type named Query.');
	  }
	
	  var innerTypeMap = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };
	
	  var types = typeDefs.map(function (def) {
	    return typeDefNamed(def.name.value);
	  });
	
	  var directives = directiveDefs.map(getDirective);
	
	  // If specified directives were not explicitly declared, add them.
	  if (!directives.some(function (directive) {
	    return directive.name === 'skip';
	  })) {
	    directives.push(_directives.GraphQLSkipDirective);
	  }
	
	  if (!directives.some(function (directive) {
	    return directive.name === 'include';
	  })) {
	    directives.push(_directives.GraphQLIncludeDirective);
	  }
	
	  if (!directives.some(function (directive) {
	    return directive.name === 'deprecated';
	  })) {
	    directives.push(_directives.GraphQLDeprecatedDirective);
	  }
	
	  return new _schema.GraphQLSchema({
	    query: getObjectType(nodeMap[queryTypeName]),
	    mutation: mutationTypeName ? getObjectType(nodeMap[mutationTypeName]) : null,
	    subscription: subscriptionTypeName ? getObjectType(nodeMap[subscriptionTypeName]) : null,
	    types: types,
	    directives: directives,
	    astNode: schemaDef
	  });
	
	  function getDirective(directiveNode) {
	    return new _directives.GraphQLDirective({
	      name: directiveNode.name.value,
	      description: getDescription(directiveNode),
	      locations: directiveNode.locations.map(function (node) {
	        return node.value;
	      }),
	      args: directiveNode.arguments && makeInputValues(directiveNode.arguments),
	      astNode: directiveNode
	    });
	  }
	
	  function getObjectType(typeNode) {
	    var type = typeDefNamed(typeNode.name.value);
	    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'AST must provide object type.') : void 0;
	    return type;
	  }
	
	  function produceType(typeNode) {
	    var typeName = getNamedTypeNode(typeNode).name.value;
	    var typeDef = typeDefNamed(typeName);
	    return buildWrappedType(typeDef, typeNode);
	  }
	
	  function produceInputType(typeNode) {
	    return (0, _definition.assertInputType)(produceType(typeNode));
	  }
	
	  function produceOutputType(typeNode) {
	    return (0, _definition.assertOutputType)(produceType(typeNode));
	  }
	
	  function produceObjectType(typeNode) {
	    var type = produceType(typeNode);
	    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Expected Object type.') : void 0;
	    return type;
	  }
	
	  function produceInterfaceType(typeNode) {
	    var type = produceType(typeNode);
	    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Expected Interface type.') : void 0;
	    return type;
	  }
	
	  function typeDefNamed(typeName) {
	    if (!innerTypeMap[typeName]) {
	      if (!nodeMap[typeName]) {
	        throw new Error('Type "' + typeName + '" not found in document.');
	      }
	      innerTypeMap[typeName] = makeSchemaDef(nodeMap[typeName]);
	    }
	    return innerTypeMap[typeName];
	  }
	
	  function makeSchemaDef(def) {
	    switch (def.kind) {
	      case Kind.OBJECT_TYPE_DEFINITION:
	        return makeTypeDef(def);
	      case Kind.INTERFACE_TYPE_DEFINITION:
	        return makeInterfaceDef(def);
	      case Kind.ENUM_TYPE_DEFINITION:
	        return makeEnumDef(def);
	      case Kind.UNION_TYPE_DEFINITION:
	        return makeUnionDef(def);
	      case Kind.SCALAR_TYPE_DEFINITION:
	        return makeScalarDef(def);
	      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
	        return makeInputObjectDef(def);
	      default:
	        throw new Error('Type kind "' + def.kind + '" not supported.');
	    }
	  }
	
	  function makeTypeDef(def) {
	    var typeName = def.name.value;
	    return new _definition.GraphQLObjectType({
	      name: typeName,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeFieldDefMap(def);
	      },
	      interfaces: function interfaces() {
	        return makeImplementedInterfaces(def);
	      },
	      astNode: def
	    });
	  }
	
	  function makeFieldDefMap(def) {
	    return (0, _keyValMap2.default)(def.fields, function (field) {
	      return field.name.value;
	    }, function (field) {
	      return {
	        type: produceOutputType(field.type),
	        description: getDescription(field),
	        args: makeInputValues(field.arguments),
	        deprecationReason: getDeprecationReason(field),
	        astNode: field
	      };
	    });
	  }
	
	  function makeImplementedInterfaces(def) {
	    return def.interfaces && def.interfaces.map(function (iface) {
	      return produceInterfaceType(iface);
	    });
	  }
	
	  function makeInputValues(values) {
	    return (0, _keyValMap2.default)(values, function (value) {
	      return value.name.value;
	    }, function (value) {
	      var type = produceInputType(value.type);
	      return {
	        type: type,
	        description: getDescription(value),
	        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),
	        astNode: value
	      };
	    });
	  }
	
	  function makeInterfaceDef(def) {
	    return new _definition.GraphQLInterfaceType({
	      name: def.name.value,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeFieldDefMap(def);
	      },
	      astNode: def,
	      resolveType: cannotExecuteSchema
	    });
	  }
	
	  function makeEnumDef(def) {
	    return new _definition.GraphQLEnumType({
	      name: def.name.value,
	      description: getDescription(def),
	      values: (0, _keyValMap2.default)(def.values, function (enumValue) {
	        return enumValue.name.value;
	      }, function (enumValue) {
	        return {
	          description: getDescription(enumValue),
	          deprecationReason: getDeprecationReason(enumValue),
	          astNode: enumValue
	        };
	      }),
	      astNode: def
	    });
	  }
	
	  function makeUnionDef(def) {
	    return new _definition.GraphQLUnionType({
	      name: def.name.value,
	      description: getDescription(def),
	      types: def.types.map(function (t) {
	        return produceObjectType(t);
	      }),
	      resolveType: cannotExecuteSchema,
	      astNode: def
	    });
	  }
	
	  function makeScalarDef(def) {
	    return new _definition.GraphQLScalarType({
	      name: def.name.value,
	      description: getDescription(def),
	      astNode: def,
	      serialize: function serialize() {
	        return null;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }
	
	  function makeInputObjectDef(def) {
	    return new _definition.GraphQLInputObjectType({
	      name: def.name.value,
	      description: getDescription(def),
	      fields: function fields() {
	        return makeInputValues(def.fields);
	      },
	      astNode: def
	    });
	  }
	}
	
	/**
	 * Given a field or enum value node, returns the string value for the
	 * deprecation reason.
	 */
	function getDeprecationReason(node) {
	  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
	  return deprecated && deprecated.reason;
	}
	
	/**
	 * Given an ast node, returns its string description based on a contiguous
	 * block full-line of comments preceding it.
	 */
	function getDescription(node) {
	  var loc = node.loc;
	  if (!loc) {
	    return;
	  }
	  var comments = [];
	  var minSpaces = void 0;
	  var token = loc.startToken.prev;
	  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
	    var value = String(token.value);
	    var spaces = leadingSpaces(value);
	    if (minSpaces === undefined || spaces < minSpaces) {
	      minSpaces = spaces;
	    }
	    comments.push(value);
	    token = token.prev;
	  }
	  return comments.reverse().map(function (comment) {
	    return comment.slice(minSpaces);
	  }).join('\n');
	}
	
	/**
	 * A helper function to build a GraphQLSchema directly from a source
	 * document.
	 */
	function buildSchema(source) {
	  return buildASTSchema((0, _parser.parse)(source));
	}
	
	// Count the number of spaces on the starting side of a string.
	function leadingSpaces(str) {
	  var i = 0;
	  for (; i < str.length; i++) {
	    if (str[i] !== ' ') {
	      break;
	    }
	  }
	  return i;
	}
	
	function cannotExecuteSchema() {
	  throw new Error('Generated Schema cannot use Interface or Union types for execution.');
	}

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getOperationAST = getOperationAST;
	
	var _kinds = __webpack_require__(14);
	
	/**
	 * Returns an operation AST given a document AST and optionally an operation
	 * name. If a name is not provided, an operation is only returned if only one is
	 * provided in the document.
	 */
	function getOperationAST(documentAST, operationName) {
	  var operation = null;
	  for (var i = 0; i < documentAST.definitions.length; i++) {
	    var definition = documentAST.definitions[i];
	    if (definition.kind === _kinds.OPERATION_DEFINITION) {
	      if (!operationName) {
	        // If no operation name was provided, only return an Operation if there
	        // is one defined in the document. Upon encountering the second, return
	        // null.
	        if (operation) {
	          return null;
	        }
	        operation = definition;
	      } else if (definition.name && definition.name.value === operationName) {
	        return definition;
	      }
	    }
	  }
	  return operation;
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * 
	                                                                                                                                                                                                                                                                               */
	
	exports.isValidJSValue = isValidJSValue;
	
	var _iterall = __webpack_require__(61);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Given a JavaScript value and a GraphQL type, determine if the value will be
	 * accepted for that type. This is primarily useful for validating the
	 * runtime values of query variables.
	 */
	function isValidJSValue(value, type) {
	  // A value must be provided if the type is non-null.
	  if (type instanceof _definition.GraphQLNonNull) {
	    if ((0, _isNullish2.default)(value)) {
	      return ['Expected "' + String(type) + '", found null.'];
	    }
	    return isValidJSValue(value, type.ofType);
	  }
	
	  if ((0, _isNullish2.default)(value)) {
	    return [];
	  }
	
	  // Lists accept a non-list value as a list of one.
	  if (type instanceof _definition.GraphQLList) {
	    var itemType = type.ofType;
	    if ((0, _iterall.isCollection)(value)) {
	      var errors = [];
	      (0, _iterall.forEach)(value, function (item, index) {
	        errors.push.apply(errors, isValidJSValue(item, itemType).map(function (error) {
	          return 'In element #' + index + ': ' + error;
	        }));
	      });
	      return errors;
	    }
	    return isValidJSValue(value, itemType);
	  }
	
	  // Input objects check each defined field.
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
	      return ['Expected "' + type.name + '", found not an object.'];
	    }
	    var fields = type.getFields();
	
	    var _errors = [];
	
	    // Ensure every provided field is defined.
	    Object.keys(value).forEach(function (providedField) {
	      if (!fields[providedField]) {
	        _errors.push('In field "' + providedField + '": Unknown field.');
	      }
	    });
	
	    // Ensure every defined field is valid.
	    Object.keys(fields).forEach(function (fieldName) {
	      var newErrors = isValidJSValue(value[fieldName], fields[fieldName].type);
	      _errors.push.apply(_errors, newErrors.map(function (error) {
	        return 'In field "' + fieldName + '": ' + error;
	      }));
	    });
	
	    return _errors;
	  }
	
	  !(type instanceof _definition.GraphQLScalarType || type instanceof _definition.GraphQLEnumType) ? (0, _invariant2.default)(0, 'Must be input type') : void 0;
	
	  // Scalar/Enum input checks to ensure the type can parse the value to
	  // a non-null value.
	  try {
	    var parseResult = type.parseValue(value);
	    if ((0, _isNullish2.default)(parseResult) && !type.isValidValue(value)) {
	      return ['Expected type "' + type.name + '", found ' + JSON.stringify(value) + '.'];
	    }
	  } catch (error) {
	    return ['Expected type "' + type.name + '", found ' + JSON.stringify(value) + ': ' + error.message];
	  }
	
	  return [];
	}

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.badValueMessage = badValueMessage;
	exports.ArgumentsOfCorrectType = ArgumentsOfCorrectType;
	
	var _error = __webpack_require__(4);
	
	var _printer = __webpack_require__(27);
	
	var _isValidLiteralValue = __webpack_require__(109);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function badValueMessage(argName, type, value, verboseErrors) {
	  var message = verboseErrors ? '\n' + verboseErrors.join('\n') : '';
	  return 'Argument "' + argName + '" has invalid value ' + value + '.' + message;
	}
	
	/**
	 * Argument values of correct type
	 *
	 * A GraphQL document is only valid if all field argument literal values are
	 * of the type expected by their position.
	 */
	function ArgumentsOfCorrectType(context) {
	  return {
	    Argument: function Argument(node) {
	      var argDef = context.getArgument();
	      if (argDef) {
	        var errors = (0, _isValidLiteralValue.isValidLiteralValue)(argDef.type, node.value);
	        if (errors && errors.length > 0) {
	          context.reportError(new _error.GraphQLError(badValueMessage(node.name.value, argDef.type, (0, _printer.print)(node.value), errors), [node.value]));
	        }
	      }
	      return false;
	    }
	  };
	}

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defaultForNonNullArgMessage = defaultForNonNullArgMessage;
	exports.badValueForDefaultArgMessage = badValueForDefaultArgMessage;
	exports.DefaultValuesOfCorrectType = DefaultValuesOfCorrectType;
	
	var _error = __webpack_require__(4);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _isValidLiteralValue = __webpack_require__(109);
	
	function defaultForNonNullArgMessage(varName, type, guessType) {
	  return 'Variable "$' + varName + '" of type "' + String(type) + '" is required and ' + 'will not use the default value. ' + ('Perhaps you meant to use type "' + String(guessType) + '".');
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function badValueForDefaultArgMessage(varName, type, value, verboseErrors) {
	  var message = verboseErrors ? '\n' + verboseErrors.join('\n') : '';
	  return 'Variable "$' + varName + '" of type "' + String(type) + '" has invalid ' + ('default value ' + value + '.' + message);
	}
	
	/**
	 * Variable default values of correct type
	 *
	 * A GraphQL document is only valid if all variable default values are of the
	 * type expected by their definition.
	 */
	function DefaultValuesOfCorrectType(context) {
	  return {
	    VariableDefinition: function VariableDefinition(node) {
	      var name = node.variable.name.value;
	      var defaultValue = node.defaultValue;
	      var type = context.getInputType();
	      if (type instanceof _definition.GraphQLNonNull && defaultValue) {
	        context.reportError(new _error.GraphQLError(defaultForNonNullArgMessage(name, type, type.ofType), [defaultValue]));
	      }
	      if (type && defaultValue) {
	        var errors = (0, _isValidLiteralValue.isValidLiteralValue)(type, defaultValue);
	        if (errors && errors.length > 0) {
	          context.reportError(new _error.GraphQLError(badValueForDefaultArgMessage(name, type, (0, _printer.print)(defaultValue), errors), [defaultValue]));
	        }
	      }
	      return false;
	    },
	
	    SelectionSet: function SelectionSet() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition() {
	      return false;
	    }
	  };
	}

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.undefinedFieldMessage = undefinedFieldMessage;
	exports.FieldsOnCorrectType = FieldsOnCorrectType;
	
	var _error = __webpack_require__(4);
	
	var _suggestionList = __webpack_require__(163);
	
	var _suggestionList2 = _interopRequireDefault(_suggestionList);
	
	var _quotedOrList = __webpack_require__(162);
	
	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {
	  var message = 'Cannot query field "' + fieldName + '" on type "' + type + '".';
	  if (suggestedTypeNames.length !== 0) {
	    var suggestions = (0, _quotedOrList2.default)(suggestedTypeNames);
	    message += ' Did you mean to use an inline fragment on ' + suggestions + '?';
	  } else if (suggestedFieldNames.length !== 0) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedFieldNames) + '?';
	  }
	  return message;
	}
	
	/**
	 * Fields on correct type
	 *
	 * A GraphQL document is only valid if all fields selected are defined by the
	 * parent type, or are an allowed meta field such as __typename.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function FieldsOnCorrectType(context) {
	  return {
	    Field: function Field(node) {
	      var type = context.getParentType();
	      if (type) {
	        var fieldDef = context.getFieldDef();
	        if (!fieldDef) {
	          // This field doesn't exist, lets look for suggestions.
	          var schema = context.getSchema();
	          var fieldName = node.name.value;
	          // First determine if there are any suggested types to condition on.
	          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName);
	          // If there are no suggested types, then perhaps this was a typo?
	          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName);
	
	          // Report an error, including helpful suggestions.
	          context.reportError(new _error.GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));
	        }
	      }
	    }
	  };
	}
	
	/**
	 * Go through all of the implementations of type, as well as the interfaces
	 * that they implement. If any of those types include the provided field,
	 * suggest them, sorted by how often the type is referenced,  starting
	 * with Interfaces.
	 */
	function getSuggestedTypeNames(schema, type, fieldName) {
	  if ((0, _definition.isAbstractType)(type)) {
	    var suggestedObjectTypes = [];
	    var interfaceUsageCount = Object.create(null);
	    schema.getPossibleTypes(type).forEach(function (possibleType) {
	      if (!possibleType.getFields()[fieldName]) {
	        return;
	      }
	      // This object type defines this field.
	      suggestedObjectTypes.push(possibleType.name);
	      possibleType.getInterfaces().forEach(function (possibleInterface) {
	        if (!possibleInterface.getFields()[fieldName]) {
	          return;
	        }
	        // This interface type defines this field.
	        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
	      });
	    });
	
	    // Suggest interface types based on how common they are.
	    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {
	      return interfaceUsageCount[b] - interfaceUsageCount[a];
	    });
	
	    // Suggest both interface and object types.
	    return suggestedInterfaceTypes.concat(suggestedObjectTypes);
	  }
	
	  // Otherwise, must be an Object type, which does not have possible fields.
	  return [];
	}
	
	/**
	 * For the field name provided, determine if there are any similar field names
	 * that may be the result of a typo.
	 */
	function getSuggestedFieldNames(schema, type, fieldName) {
	  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {
	    var possibleFieldNames = Object.keys(type.getFields());
	    return (0, _suggestionList2.default)(fieldName, possibleFieldNames);
	  }
	  // Otherwise, must be a Union type, which does not define fields.
	  return [];
	}

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;
	exports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;
	exports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;
	
	var _error = __webpack_require__(4);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _typeFromAST = __webpack_require__(35);
	
	function inlineFragmentOnNonCompositeErrorMessage(type) {
	  return 'Fragment cannot condition on non composite type "' + String(type) + '".';
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function fragmentOnNonCompositeErrorMessage(fragName, type) {
	  return 'Fragment "' + fragName + '" cannot condition on non composite ' + ('type "' + String(type) + '".');
	}
	
	/**
	 * Fragments on composite type
	 *
	 * Fragments use a type condition to determine if they apply, since fragments
	 * can only be spread into a composite type (object, interface, or union), the
	 * type condition must also be a composite type.
	 */
	function FragmentsOnCompositeTypes(context) {
	  return {
	    InlineFragment: function InlineFragment(node) {
	      if (node.typeCondition) {
	        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
	        if (type && !(0, _definition.isCompositeType)(type)) {
	          context.reportError(new _error.GraphQLError(inlineFragmentOnNonCompositeErrorMessage((0, _printer.print)(node.typeCondition)), [node.typeCondition]));
	        }
	      }
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
	      if (type && !(0, _definition.isCompositeType)(type)) {
	        context.reportError(new _error.GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, (0, _printer.print)(node.typeCondition)), [node.typeCondition]));
	      }
	    }
	  };
	}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownArgMessage = unknownArgMessage;
	exports.unknownDirectiveArgMessage = unknownDirectiveArgMessage;
	exports.KnownArgumentNames = KnownArgumentNames;
	
	var _error = __webpack_require__(4);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _suggestionList = __webpack_require__(163);
	
	var _suggestionList2 = _interopRequireDefault(_suggestionList);
	
	var _quotedOrList = __webpack_require__(162);
	
	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function unknownArgMessage(argName, fieldName, typeName, suggestedArgs) {
	  var message = 'Unknown argument "' + argName + '" on field "' + fieldName + '" of ' + ('type "' + typeName + '".');
	  if (suggestedArgs.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedArgs) + '?';
	  }
	  return message;
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function unknownDirectiveArgMessage(argName, directiveName, suggestedArgs) {
	  var message = 'Unknown argument "' + argName + '" on directive "@' + directiveName + '".';
	  if (suggestedArgs.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedArgs) + '?';
	  }
	  return message;
	}
	
	/**
	 * Known argument names
	 *
	 * A GraphQL field is only valid if all supplied arguments are defined by
	 * that field.
	 */
	function KnownArgumentNames(context) {
	  return {
	    Argument: function Argument(node, key, parent, path, ancestors) {
	      var argumentOf = ancestors[ancestors.length - 1];
	      if (argumentOf.kind === Kind.FIELD) {
	        var fieldDef = context.getFieldDef();
	        if (fieldDef) {
	          var fieldArgDef = (0, _find2.default)(fieldDef.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (!fieldArgDef) {
	            var parentType = context.getParentType();
	            !parentType ? (0, _invariant2.default)(0) : void 0;
	            context.reportError(new _error.GraphQLError(unknownArgMessage(node.name.value, fieldDef.name, parentType.name, (0, _suggestionList2.default)(node.name.value, fieldDef.args.map(function (arg) {
	              return arg.name;
	            }))), [node]));
	          }
	        }
	      } else if (argumentOf.kind === Kind.DIRECTIVE) {
	        var directive = context.getDirective();
	        if (directive) {
	          var directiveArgDef = (0, _find2.default)(directive.args, function (arg) {
	            return arg.name === node.name.value;
	          });
	          if (!directiveArgDef) {
	            context.reportError(new _error.GraphQLError(unknownDirectiveArgMessage(node.name.value, directive.name, (0, _suggestionList2.default)(node.name.value, directive.args.map(function (arg) {
	              return arg.name;
	            }))), [node]));
	          }
	        }
	      }
	    }
	  };
	}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownDirectiveMessage = unknownDirectiveMessage;
	exports.misplacedDirectiveMessage = misplacedDirectiveMessage;
	exports.KnownDirectives = KnownDirectives;
	
	var _error = __webpack_require__(4);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _directives = __webpack_require__(33);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function unknownDirectiveMessage(directiveName) {
	  return 'Unknown directive "' + directiveName + '".';
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function misplacedDirectiveMessage(directiveName, location) {
	  return 'Directive "' + directiveName + '" may not be used on ' + location + '.';
	}
	
	/**
	 * Known directives
	 *
	 * A GraphQL document is only valid if all `@directives` are known by the
	 * schema and legally positioned.
	 */
	function KnownDirectives(context) {
	  return {
	    Directive: function Directive(node, key, parent, path, ancestors) {
	      var directiveDef = (0, _find2.default)(context.getSchema().getDirectives(), function (def) {
	        return def.name === node.name.value;
	      });
	      if (!directiveDef) {
	        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));
	        return;
	      }
	      var candidateLocation = getDirectiveLocationForASTPath(ancestors);
	      if (!candidateLocation) {
	        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, node.type), [node]));
	      } else if (directiveDef.locations.indexOf(candidateLocation) === -1) {
	        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, candidateLocation), [node]));
	      }
	    }
	  };
	}
	
	function getDirectiveLocationForASTPath(ancestors) {
	  var appliedTo = ancestors[ancestors.length - 1];
	  switch (appliedTo.kind) {
	    case Kind.OPERATION_DEFINITION:
	      switch (appliedTo.operation) {
	        case 'query':
	          return _directives.DirectiveLocation.QUERY;
	        case 'mutation':
	          return _directives.DirectiveLocation.MUTATION;
	        case 'subscription':
	          return _directives.DirectiveLocation.SUBSCRIPTION;
	      }
	      break;
	    case Kind.FIELD:
	      return _directives.DirectiveLocation.FIELD;
	    case Kind.FRAGMENT_SPREAD:
	      return _directives.DirectiveLocation.FRAGMENT_SPREAD;
	    case Kind.INLINE_FRAGMENT:
	      return _directives.DirectiveLocation.INLINE_FRAGMENT;
	    case Kind.FRAGMENT_DEFINITION:
	      return _directives.DirectiveLocation.FRAGMENT_DEFINITION;
	    case Kind.SCHEMA_DEFINITION:
	      return _directives.DirectiveLocation.SCHEMA;
	    case Kind.SCALAR_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.SCALAR;
	    case Kind.OBJECT_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.OBJECT;
	    case Kind.FIELD_DEFINITION:
	      return _directives.DirectiveLocation.FIELD_DEFINITION;
	    case Kind.INTERFACE_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.INTERFACE;
	    case Kind.UNION_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.UNION;
	    case Kind.ENUM_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.ENUM;
	    case Kind.ENUM_VALUE_DEFINITION:
	      return _directives.DirectiveLocation.ENUM_VALUE;
	    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
	      return _directives.DirectiveLocation.INPUT_OBJECT;
	    case Kind.INPUT_VALUE_DEFINITION:
	      var parentNode = ancestors[ancestors.length - 3];
	      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directives.DirectiveLocation.INPUT_FIELD_DEFINITION : _directives.DirectiveLocation.ARGUMENT_DEFINITION;
	  }
	}

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownFragmentMessage = unknownFragmentMessage;
	exports.KnownFragmentNames = KnownFragmentNames;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function unknownFragmentMessage(fragName) {
	  return 'Unknown fragment "' + fragName + '".';
	}
	
	/**
	 * Known fragment names
	 *
	 * A GraphQL document is only valid if all `...Fragment` fragment spreads refer
	 * to fragments defined in the same document.
	 */
	function KnownFragmentNames(context) {
	  return {
	    FragmentSpread: function FragmentSpread(node) {
	      var fragmentName = node.name.value;
	      var fragment = context.getFragment(fragmentName);
	      if (!fragment) {
	        context.reportError(new _error.GraphQLError(unknownFragmentMessage(fragmentName), [node.name]));
	      }
	    }
	  };
	}

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unknownTypeMessage = unknownTypeMessage;
	exports.KnownTypeNames = KnownTypeNames;
	
	var _error = __webpack_require__(4);
	
	var _suggestionList = __webpack_require__(163);
	
	var _suggestionList2 = _interopRequireDefault(_suggestionList);
	
	var _quotedOrList = __webpack_require__(162);
	
	var _quotedOrList2 = _interopRequireDefault(_quotedOrList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function unknownTypeMessage(type, suggestedTypes) {
	  var message = 'Unknown type "' + String(type) + '".';
	  if (suggestedTypes.length) {
	    message += ' Did you mean ' + (0, _quotedOrList2.default)(suggestedTypes) + '?';
	  }
	  return message;
	}
	
	/**
	 * Known type names
	 *
	 * A GraphQL document is only valid if referenced types (specifically
	 * variable definitions and fragment conditions) are defined by the type schema.
	 */
	function KnownTypeNames(context) {
	  return {
	    // TODO: when validating IDL, re-enable these. Experimental version does not
	    // add unreferenced types, resulting in false-positive errors. Squelched
	    // errors for now.
	    ObjectTypeDefinition: function ObjectTypeDefinition() {
	      return false;
	    },
	    InterfaceTypeDefinition: function InterfaceTypeDefinition() {
	      return false;
	    },
	    UnionTypeDefinition: function UnionTypeDefinition() {
	      return false;
	    },
	    InputObjectTypeDefinition: function InputObjectTypeDefinition() {
	      return false;
	    },
	    NamedType: function NamedType(node) {
	      var schema = context.getSchema();
	      var typeName = node.name.value;
	      var type = schema.getType(typeName);
	      if (!type) {
	        context.reportError(new _error.GraphQLError(unknownTypeMessage(typeName, (0, _suggestionList2.default)(typeName, Object.keys(schema.getTypeMap()))), [node]));
	      }
	    }
	  };
	}

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.anonOperationNotAloneMessage = anonOperationNotAloneMessage;
	exports.LoneAnonymousOperation = LoneAnonymousOperation;
	
	var _error = __webpack_require__(4);
	
	var _kinds = __webpack_require__(14);
	
	function anonOperationNotAloneMessage() {
	  return 'This anonymous operation must be the only defined operation.';
	}
	
	/**
	 * Lone anonymous operation
	 *
	 * A GraphQL document is only valid if when it contains an anonymous operation
	 * (the query short-hand) that it contains only that one operation definition.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function LoneAnonymousOperation(context) {
	  var operationCount = 0;
	  return {
	    Document: function Document(node) {
	      operationCount = node.definitions.filter(function (definition) {
	        return definition.kind === _kinds.OPERATION_DEFINITION;
	      }).length;
	    },
	    OperationDefinition: function OperationDefinition(node) {
	      if (!node.name && operationCount > 1) {
	        context.reportError(new _error.GraphQLError(anonOperationNotAloneMessage(), [node]));
	      }
	    }
	  };
	}

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.cycleErrorMessage = cycleErrorMessage;
	exports.NoFragmentCycles = NoFragmentCycles;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function cycleErrorMessage(fragName, spreadNames) {
	  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';
	  return 'Cannot spread fragment "' + fragName + '" within itself' + via + '.';
	}
	
	function NoFragmentCycles(context) {
	  // Tracks already visited fragments to maintain O(N) and to ensure that cycles
	  // are not redundantly reported.
	  var visitedFrags = Object.create(null);
	
	  // Array of AST nodes used to produce meaningful errors
	  var spreadPath = [];
	
	  // Position in the spread path
	  var spreadPathIndexByName = Object.create(null);
	
	  return {
	    OperationDefinition: function OperationDefinition() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      if (!visitedFrags[node.name.value]) {
	        detectCycleRecursive(node);
	      }
	      return false;
	    }
	  };
	
	  // This does a straight-forward DFS to find cycles.
	  // It does not terminate when a cycle was found but continues to explore
	  // the graph to find all possible cycles.
	  function detectCycleRecursive(fragment) {
	    var fragmentName = fragment.name.value;
	    visitedFrags[fragmentName] = true;
	
	    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
	    if (spreadNodes.length === 0) {
	      return;
	    }
	
	    spreadPathIndexByName[fragmentName] = spreadPath.length;
	
	    for (var i = 0; i < spreadNodes.length; i++) {
	      var spreadNode = spreadNodes[i];
	      var spreadName = spreadNode.name.value;
	      var cycleIndex = spreadPathIndexByName[spreadName];
	
	      if (cycleIndex === undefined) {
	        spreadPath.push(spreadNode);
	        if (!visitedFrags[spreadName]) {
	          var spreadFragment = context.getFragment(spreadName);
	          if (spreadFragment) {
	            detectCycleRecursive(spreadFragment);
	          }
	        }
	        spreadPath.pop();
	      } else {
	        var cyclePath = spreadPath.slice(cycleIndex);
	        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {
	          return s.name.value;
	        })), cyclePath.concat(spreadNode)));
	      }
	    }
	
	    spreadPathIndexByName[fragmentName] = undefined;
	  }
	}

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.undefinedVarMessage = undefinedVarMessage;
	exports.NoUndefinedVariables = NoUndefinedVariables;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function undefinedVarMessage(varName, opName) {
	  return opName ? 'Variable "$' + varName + '" is not defined by operation "' + opName + '".' : 'Variable "$' + varName + '" is not defined.';
	}
	
	/**
	 * No undefined variables
	 *
	 * A GraphQL operation is only valid if all variables encountered, both directly
	 * and via fragment spreads, are defined by that operation.
	 */
	function NoUndefinedVariables(context) {
	  var variableNameDefined = Object.create(null);
	
	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        variableNameDefined = Object.create(null);
	      },
	      leave: function leave(operation) {
	        var usages = context.getRecursiveVariableUsages(operation);
	
	        usages.forEach(function (_ref) {
	          var node = _ref.node;
	
	          var varName = node.name.value;
	          if (variableNameDefined[varName] !== true) {
	            context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(node) {
	      variableNameDefined[node.variable.name.value] = true;
	    }
	  };
	}

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.unusedVariableMessage = unusedVariableMessage;
	exports.NoUnusedVariables = NoUnusedVariables;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function unusedVariableMessage(varName, opName) {
	  return opName ? 'Variable "$' + varName + '" is never used in operation "' + opName + '".' : 'Variable "$' + varName + '" is never used.';
	}
	
	/**
	 * No unused variables
	 *
	 * A GraphQL operation is only valid if all variables defined by an operation
	 * are used, either directly or within a spread fragment.
	 */
	function NoUnusedVariables(context) {
	  var variableDefs = [];
	
	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        variableDefs = [];
	      },
	      leave: function leave(operation) {
	        var variableNameUsed = Object.create(null);
	        var usages = context.getRecursiveVariableUsages(operation);
	        var opName = operation.name ? operation.name.value : null;
	
	        usages.forEach(function (_ref) {
	          var node = _ref.node;
	
	          variableNameUsed[node.name.value] = true;
	        });
	
	        variableDefs.forEach(function (variableDef) {
	          var variableName = variableDef.variable.name.value;
	          if (variableNameUsed[variableName] !== true) {
	            context.reportError(new _error.GraphQLError(unusedVariableMessage(variableName, opName), [variableDef]));
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(def) {
	      variableDefs.push(def);
	    }
	  };
	}

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fieldsConflictMessage = fieldsConflictMessage;
	exports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;
	
	var _error = __webpack_require__(4);
	
	var _find = __webpack_require__(58);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _typeFromAST = __webpack_require__(35);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	function fieldsConflictMessage(responseName, reason) {
	  return 'Fields "' + responseName + '" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';
	}
	
	function reasonMessage(reason) {
	  if (Array.isArray(reason)) {
	    return reason.map(function (_ref) {
	      var responseName = _ref[0],
	          subreason = _ref[1];
	      return 'subfields "' + responseName + '" conflict because ' + reasonMessage(subreason);
	    }).join(' and ');
	  }
	  return reason;
	}
	
	/**
	 * Overlapping fields can be merged
	 *
	 * A selection set is only valid if all fields (including spreading any
	 * fragments) either correspond to distinct response names or can be merged
	 * without ambiguity.
	 */
	function OverlappingFieldsCanBeMerged(context) {
	  // A memoization for when two fragments are compared "between" each other for
	  // conflicts. Two fragments may be compared many times, so memoizing this can
	  // dramatically improve the performance of this validator.
	  var comparedFragments = new PairSet();
	
	  // A cache for the "field map" and list of fragment names found in any given
	  // selection set. Selection sets may be asked for this information multiple
	  // times, so this improves the performance of this validator.
	  var cachedFieldsAndFragmentNames = new Map();
	
	  return {
	    SelectionSet: function SelectionSet(selectionSet) {
	      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, context.getParentType(), selectionSet);
	      conflicts.forEach(function (_ref2) {
	        var _ref2$ = _ref2[0],
	            responseName = _ref2$[0],
	            reason = _ref2$[1],
	            fields1 = _ref2[1],
	            fields2 = _ref2[2];
	        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
	      });
	    }
	  };
	}
	// Field name and reason.
	
	// Reason is a string, or a nested list of conflicts.
	
	// Tuple defining a field node in a context.
	
	// Map of array of those.
	
	
	/**
	 * Algorithm:
	 *
	 * Conflicts occur when two fields exist in a query which will produce the same
	 * response name, but represent differing values, thus creating a conflict.
	 * The algorithm below finds all conflicts via making a series of comparisons
	 * between fields. In order to compare as few fields as possible, this makes
	 * a series of comparisons "within" sets of fields and "between" sets of fields.
	 *
	 * Given any selection set, a collection produces both a set of fields by
	 * also including all inline fragments, as well as a list of fragments
	 * referenced by fragment spreads.
	 *
	 * A) Each selection set represented in the document first compares "within" its
	 * collected set of fields, finding any conflicts between every pair of
	 * overlapping fields.
	 * Note: This is the *only time* that a the fields "within" a set are compared
	 * to each other. After this only fields "between" sets are compared.
	 *
	 * B) Also, if any fragment is referenced in a selection set, then a
	 * comparison is made "between" the original set of fields and the
	 * referenced fragment.
	 *
	 * C) Also, if multiple fragments are referenced, then comparisons
	 * are made "between" each referenced fragment.
	 *
	 * D) When comparing "between" a set of fields and a referenced fragment, first
	 * a comparison is made between each field in the original set of fields and
	 * each field in the the referenced set of fields.
	 *
	 * E) Also, if any fragment is referenced in the referenced selection set,
	 * then a comparison is made "between" the original set of fields and the
	 * referenced fragment (recursively referring to step D).
	 *
	 * F) When comparing "between" two fragments, first a comparison is made between
	 * each field in the first referenced set of fields and each field in the the
	 * second referenced set of fields.
	 *
	 * G) Also, any fragments referenced by the first must be compared to the
	 * second, and any fragments referenced by the second must be compared to the
	 * first (recursively referring to step F).
	 *
	 * H) When comparing two fields, if both have selection sets, then a comparison
	 * is made "between" both selection sets, first comparing the set of fields in
	 * the first selection set with the set of fields in the second.
	 *
	 * I) Also, if any fragment is referenced in either selection set, then a
	 * comparison is made "between" the other set of fields and the
	 * referenced fragment.
	 *
	 * J) Also, if two fragments are referenced in both selection sets, then a
	 * comparison is made "between" the two fragments.
	 *
	 */
	
	// Find all conflicts found "within" a selection set, including those found
	// via spreading in fragments. Called when visiting each SelectionSet in the
	// GraphQL Document.
	function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, parentType, selectionSet) {
	  var conflicts = [];
	
	  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),
	      fieldMap = _getFieldsAndFragment[0],
	      fragmentNames = _getFieldsAndFragment[1];
	
	  // (A) Find find all conflicts "within" the fields of this selection set.
	  // Note: this is the *only place* `collectConflictsWithin` is called.
	
	
	  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap);
	
	  // (B) Then collect conflicts between these fields and those represented by
	  // each spread fragment name found.
	  for (var i = 0; i < fragmentNames.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fieldMap, fragmentNames[i]);
	    // (C) Then compare this fragment with all other fragments found in this
	    // selection set to collect conflicts between fragments spread together.
	    // This compares each item in the list of fragment names to every other item
	    // in that same list (except for itself).
	    for (var j = i + 1; j < fragmentNames.length; j++) {
	      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fragmentNames[i], fragmentNames[j]);
	    }
	  }
	  return conflicts;
	}
	
	// Collect all conflicts found between a set of fields and a fragment reference
	// including via spreading in any nested fragments.
	function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentName) {
	  var fragment = context.getFragment(fragmentName);
	  if (!fragment) {
	    return;
	  }
	
	  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),
	      fieldMap2 = _getReferencedFieldsA[0],
	      fragmentNames2 = _getReferencedFieldsA[1];
	
	  // (D) First collect any conflicts between the provided collection of fields
	  // and the collection of fields represented by the given fragment.
	
	
	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fieldMap2);
	
	  // (E) Then collect any conflicts between the provided collection of fields
	  // and any fragment names found in the given fragment.
	  for (var i = 0; i < fragmentNames2.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
	  }
	}
	
	// Collect all conflicts found between two fragments, including via spreading in
	// any nested fragments.
	function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentName2) {
	  var fragment1 = context.getFragment(fragmentName1);
	  var fragment2 = context.getFragment(fragmentName2);
	  if (!fragment1 || !fragment2) {
	    return;
	  }
	
	  // No need to compare a fragment to itself.
	  if (fragment1 === fragment2) {
	    return;
	  }
	
	  // Memoize so two fragments are not compared for conflicts more than once.
	  if (comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
	    return;
	  }
	  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);
	
	  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),
	      fieldMap1 = _getReferencedFieldsA2[0],
	      fragmentNames1 = _getReferencedFieldsA2[1];
	
	  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),
	      fieldMap2 = _getReferencedFieldsA3[0],
	      fragmentNames2 = _getReferencedFieldsA3[1];
	
	  // (F) First, collect all conflicts between these two collections of fields
	  // (not including any nested fragments).
	
	
	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);
	
	  // (G) Then collect conflicts between the first fragment and any nested
	  // fragments spread in the second fragment.
	  for (var j = 0; j < fragmentNames2.length; j++) {
	    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
	  }
	
	  // (G) Then collect conflicts between the second fragment and any nested
	  // fragments spread in the first fragment.
	  for (var i = 0; i < fragmentNames1.length; i++) {
	    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
	  }
	}
	
	// Find all conflicts found between two selection sets, including those found
	// via spreading in fragments. Called when determining if conflicts exist
	// between the sub-fields of two overlapping fields.
	function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
	  var conflicts = [];
	
	  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),
	      fieldMap1 = _getFieldsAndFragment2[0],
	      fragmentNames1 = _getFieldsAndFragment2[1];
	
	  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),
	      fieldMap2 = _getFieldsAndFragment3[0],
	      fragmentNames2 = _getFieldsAndFragment3[1];
	
	  // (H) First, collect all conflicts between these two collections of field.
	
	
	  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);
	
	  // (I) Then collect conflicts between the first collection of fields and
	  // those referenced by each fragment name associated with the second.
	  for (var j = 0; j < fragmentNames2.length; j++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
	  }
	
	  // (I) Then collect conflicts between the second collection of fields and
	  // those referenced by each fragment name associated with the first.
	  for (var i = 0; i < fragmentNames1.length; i++) {
	    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
	  }
	
	  // (J) Also collect conflicts between any fragment names by the first and
	  // fragment names by the second. This compares each item in the first set of
	  // names to each item in the second set of names.
	  for (var _i = 0; _i < fragmentNames1.length; _i++) {
	    for (var _j = 0; _j < fragmentNames2.length; _j++) {
	      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);
	    }
	  }
	  return conflicts;
	}
	
	// Collect all Conflicts "within" one collection of fields.
	function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap) {
	  // A field map is a keyed collection, where each key represents a response
	  // name and the value at that key is a list of all fields which provide that
	  // response name. For every response name, if there are multiple fields, they
	  // must be compared to find a potential conflict.
	  Object.keys(fieldMap).forEach(function (responseName) {
	    var fields = fieldMap[responseName];
	    // This compares every field in the list to every other field in this list
	    // (except to itself). If the list only has one item, nothing needs to
	    // be compared.
	    if (fields.length > 1) {
	      for (var i = 0; i < fields.length; i++) {
	        for (var j = i + 1; j < fields.length; j++) {
	          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, false, // within one collection is never mutually exclusive
	          responseName, fields[i], fields[j]);
	          if (conflict) {
	            conflicts.push(conflict);
	          }
	        }
	      }
	    }
	  });
	}
	
	// Collect all Conflicts between two collections of fields. This is similar to,
	// but different from the `collectConflictsWithin` function above. This check
	// assumes that `collectConflictsWithin` has already been called on each
	// provided collection of fields. This is true because this validator traverses
	// each individual selection set.
	function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
	  // A field map is a keyed collection, where each key represents a response
	  // name and the value at that key is a list of all fields which provide that
	  // response name. For any response name which appears in both provided field
	  // maps, each field from the first field map must be compared to every field
	  // in the second field map to find potential conflicts.
	  Object.keys(fieldMap1).forEach(function (responseName) {
	    var fields2 = fieldMap2[responseName];
	    if (fields2) {
	      var fields1 = fieldMap1[responseName];
	      for (var i = 0; i < fields1.length; i++) {
	        for (var j = 0; j < fields2.length; j++) {
	          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
	          if (conflict) {
	            conflicts.push(conflict);
	          }
	        }
	      }
	    }
	  });
	}
	
	// Determines if there is a conflict between two particular fields, including
	// comparing their sub-fields.
	function findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
	  var parentType1 = field1[0],
	      node1 = field1[1],
	      def1 = field1[2];
	  var parentType2 = field2[0],
	      node2 = field2[1],
	      def2 = field2[2];
	
	  // If it is known that two fields could not possibly apply at the same
	  // time, due to the parent types, then it is safe to permit them to diverge
	  // in aliased field or arguments used as they will not present any ambiguity
	  // by differing.
	  // It is known that two parent types could never overlap if they are
	  // different Object types. Interface or Union types might overlap - if not
	  // in the current state of the schema, then perhaps in some future version,
	  // thus may not safely diverge.
	
	  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && parentType1 instanceof _definition.GraphQLObjectType && parentType2 instanceof _definition.GraphQLObjectType;
	
	  // The return type for each field.
	  var type1 = def1 && def1.type;
	  var type2 = def2 && def2.type;
	
	  if (!areMutuallyExclusive) {
	    // Two aliases must refer to the same field.
	    var name1 = node1.name.value;
	    var name2 = node2.name.value;
	    if (name1 !== name2) {
	      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];
	    }
	
	    // Two field calls must have the same arguments.
	    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {
	      return [[responseName, 'they have differing arguments'], [node1], [node2]];
	    }
	  }
	
	  if (type1 && type2 && doTypesConflict(type1, type2)) {
	    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];
	  }
	
	  // Collect and compare sub-fields. Use the same "visited fragment names" list
	  // for both collections so fields in a fragment reference are never
	  // compared to themselves.
	  var selectionSet1 = node1.selectionSet;
	  var selectionSet2 = node2.selectionSet;
	  if (selectionSet1 && selectionSet2) {
	    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
	    return subfieldConflicts(conflicts, responseName, node1, node2);
	  }
	}
	
	function sameArguments(arguments1, arguments2) {
	  if (arguments1.length !== arguments2.length) {
	    return false;
	  }
	  return arguments1.every(function (argument1) {
	    var argument2 = (0, _find2.default)(arguments2, function (argument) {
	      return argument.name.value === argument1.name.value;
	    });
	    if (!argument2) {
	      return false;
	    }
	    return sameValue(argument1.value, argument2.value);
	  });
	}
	
	function sameValue(value1, value2) {
	  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);
	}
	
	// Two types conflict if both types could not apply to a value simultaneously.
	// Composite types are ignored as their individual field types will be compared
	// later recursively. However List and Non-Null types must match.
	function doTypesConflict(type1, type2) {
	  if (type1 instanceof _definition.GraphQLList) {
	    return type2 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type2 instanceof _definition.GraphQLList) {
	    return type1 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type1 instanceof _definition.GraphQLNonNull) {
	    return type2 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if (type2 instanceof _definition.GraphQLNonNull) {
	    return type1 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;
	  }
	  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
	    return type1 !== type2;
	  }
	  return false;
	}
	
	// Given a selection set, return the collection of fields (a mapping of response
	// name to field nodes and definitions) as well as a list of fragment names
	// referenced via fragment spreads.
	function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
	  var cached = cachedFieldsAndFragmentNames.get(selectionSet);
	  if (!cached) {
	    var nodeAndDefs = Object.create(null);
	    var fragmentNames = Object.create(null);
	    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
	    cached = [nodeAndDefs, Object.keys(fragmentNames)];
	    cachedFieldsAndFragmentNames.set(selectionSet, cached);
	  }
	  return cached;
	}
	
	// Given a reference to a fragment, return the represented collection of fields
	// as well as a list of nested fragment names referenced via fragment spreads.
	function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
	  // Short-circuit building a type from the node if possible.
	  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
	  if (cached) {
	    return cached;
	  }
	
	  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
	  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
	}
	
	function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
	  for (var i = 0; i < selectionSet.selections.length; i++) {
	    var selection = selectionSet.selections[i];
	    switch (selection.kind) {
	      case Kind.FIELD:
	        var fieldName = selection.name.value;
	        var fieldDef = void 0;
	        if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {
	          fieldDef = parentType.getFields()[fieldName];
	        }
	        var responseName = selection.alias ? selection.alias.value : fieldName;
	        if (!nodeAndDefs[responseName]) {
	          nodeAndDefs[responseName] = [];
	        }
	        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
	        break;
	      case Kind.FRAGMENT_SPREAD:
	        fragmentNames[selection.name.value] = true;
	        break;
	      case Kind.INLINE_FRAGMENT:
	        var typeCondition = selection.typeCondition;
	        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
	        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
	        break;
	    }
	  }
	}
	
	// Given a series of Conflicts which occurred between two sub-fields, generate
	// a single Conflict.
	function subfieldConflicts(conflicts, responseName, node1, node2) {
	  if (conflicts.length > 0) {
	    return [[responseName, conflicts.map(function (_ref3) {
	      var reason = _ref3[0];
	      return reason;
	    })], conflicts.reduce(function (allFields, _ref4) {
	      var fields1 = _ref4[1];
	      return allFields.concat(fields1);
	    }, [node1]), conflicts.reduce(function (allFields, _ref5) {
	      var fields2 = _ref5[2];
	      return allFields.concat(fields2);
	    }, [node2])];
	  }
	}
	
	/**
	 * A way to keep track of pairs of things when the ordering of the pair does
	 * not matter. We do this by maintaining a sort of double adjacency sets.
	 */
	
	var PairSet = function () {
	  function PairSet() {
	    _classCallCheck(this, PairSet);
	
	    this._data = Object.create(null);
	  }
	
	  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {
	    var first = this._data[a];
	    var result = first && first[b];
	    if (result === undefined) {
	      return false;
	    }
	    // areMutuallyExclusive being false is a superset of being true,
	    // hence if we want to know if this PairSet "has" these two with no
	    // exclusivity, we have to ensure it was added as such.
	    if (areMutuallyExclusive === false) {
	      return result === false;
	    }
	    return true;
	  };
	
	  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {
	    _pairSetAdd(this._data, a, b, areMutuallyExclusive);
	    _pairSetAdd(this._data, b, a, areMutuallyExclusive);
	  };
	
	  return PairSet;
	}();
	
	function _pairSetAdd(data, a, b, areMutuallyExclusive) {
	  var map = data[a];
	  if (!map) {
	    map = Object.create(null);
	    data[a] = map;
	  }
	  map[b] = areMutuallyExclusive;
	}

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;
	exports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;
	exports.PossibleFragmentSpreads = PossibleFragmentSpreads;
	
	var _error = __webpack_require__(4);
	
	var _typeComparators = __webpack_require__(110);
	
	var _typeFromAST = __webpack_require__(35);
	
	var _definition = __webpack_require__(7);
	
	function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
	  return 'Fragment "' + fragName + '" cannot be spread here as objects of ' + ('type "' + String(parentType) + '" can never be of type "' + String(fragType) + '".');
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
	  return 'Fragment cannot be spread here as objects of ' + ('type "' + String(parentType) + '" can never be of type "' + String(fragType) + '".');
	}
	
	/**
	 * Possible fragment spread
	 *
	 * A fragment spread is only valid if the type condition could ever possibly
	 * be true: if there is a non-empty intersection of the possible parent types,
	 * and possible types which pass the type condition.
	 */
	function PossibleFragmentSpreads(context) {
	  return {
	    InlineFragment: function InlineFragment(node) {
	      var fragType = context.getType();
	      var parentType = context.getParentType();
	      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
	        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));
	      }
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      var fragName = node.name.value;
	      var fragType = getFragmentType(context, fragName);
	      var parentType = context.getParentType();
	      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
	        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));
	      }
	    }
	  };
	}
	
	function getFragmentType(context, name) {
	  var frag = context.getFragment(name);
	  return frag && (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
	}

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.missingFieldArgMessage = missingFieldArgMessage;
	exports.missingDirectiveArgMessage = missingDirectiveArgMessage;
	exports.ProvidedNonNullArguments = ProvidedNonNullArguments;
	
	var _error = __webpack_require__(4);
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	var _definition = __webpack_require__(7);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function missingFieldArgMessage(fieldName, argName, type) {
	  return 'Field "' + fieldName + '" argument "' + argName + '" of type ' + ('"' + String(type) + '" is required but not provided.');
	}
	
	function missingDirectiveArgMessage(directiveName, argName, type) {
	  return 'Directive "@' + directiveName + '" argument "' + argName + '" of type ' + ('"' + String(type) + '" is required but not provided.');
	}
	
	/**
	 * Provided required arguments
	 *
	 * A field or directive is only valid if all required (non-null) field arguments
	 * have been provided.
	 */
	function ProvidedNonNullArguments(context) {
	  return {
	    Field: {
	      // Validate on leave to allow for deeper errors to appear first.
	      leave: function leave(node) {
	        var fieldDef = context.getFieldDef();
	        if (!fieldDef) {
	          return false;
	        }
	        var argNodes = node.arguments || [];
	
	        var argNodeMap = (0, _keyMap2.default)(argNodes, function (arg) {
	          return arg.name.value;
	        });
	        fieldDef.args.forEach(function (argDef) {
	          var argNode = argNodeMap[argDef.name];
	          if (!argNode && argDef.type instanceof _definition.GraphQLNonNull) {
	            context.reportError(new _error.GraphQLError(missingFieldArgMessage(node.name.value, argDef.name, argDef.type), [node]));
	          }
	        });
	      }
	    },
	
	    Directive: {
	      // Validate on leave to allow for deeper errors to appear first.
	      leave: function leave(node) {
	        var directiveDef = context.getDirective();
	        if (!directiveDef) {
	          return false;
	        }
	        var argNodes = node.arguments || [];
	
	        var argNodeMap = (0, _keyMap2.default)(argNodes, function (arg) {
	          return arg.name.value;
	        });
	        directiveDef.args.forEach(function (argDef) {
	          var argNode = argNodeMap[argDef.name];
	          if (!argNode && argDef.type instanceof _definition.GraphQLNonNull) {
	            context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(node.name.value, argDef.name, argDef.type), [node]));
	          }
	        });
	      }
	    }
	  };
	}

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;
	exports.requiredSubselectionMessage = requiredSubselectionMessage;
	exports.ScalarLeafs = ScalarLeafs;
	
	var _error = __webpack_require__(4);
	
	var _definition = __webpack_require__(7);
	
	function noSubselectionAllowedMessage(fieldName, type) {
	  return 'Field "' + fieldName + '" must not have a selection since ' + ('type "' + String(type) + '" has no subfields.');
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function requiredSubselectionMessage(fieldName, type) {
	  return 'Field "' + fieldName + '" of type "' + String(type) + '" must have a ' + ('selection of subfields. Did you mean "' + fieldName + ' { ... }"?');
	}
	
	/**
	 * Scalar leafs
	 *
	 * A GraphQL document is valid only if all leaf fields (fields without
	 * sub selections) are of scalar or enum types.
	 */
	function ScalarLeafs(context) {
	  return {
	    Field: function Field(node) {
	      var type = context.getType();
	      if (type) {
	        if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
	          if (node.selectionSet) {
	            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [node.selectionSet]));
	          }
	        } else if (!node.selectionSet) {
	          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));
	        }
	      }
	    }
	  };
	}

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.singleFieldOnlyMessage = singleFieldOnlyMessage;
	exports.SingleFieldSubscriptions = SingleFieldSubscriptions;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function singleFieldOnlyMessage(name) {
	  return (name ? 'Subscription "' + name + '" ' : 'Anonymous Subscription ') + 'must select only one top level field.';
	}
	
	/**
	 * Subscriptions must only include one field.
	 *
	 * A GraphQL subscription is valid only if it contains a single root field.
	 */
	function SingleFieldSubscriptions(context) {
	  return {
	    OperationDefinition: function OperationDefinition(node) {
	      if (node.operation === 'subscription') {
	        if (node.selectionSet.selections.length !== 1) {
	          context.reportError(new _error.GraphQLError(singleFieldOnlyMessage(node.name && node.name.value), node.selectionSet.selections.slice(1)));
	        }
	      }
	    }
	  };
	}

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateArgMessage = duplicateArgMessage;
	exports.UniqueArgumentNames = UniqueArgumentNames;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function duplicateArgMessage(argName) {
	  return 'There can be only one argument named "' + argName + '".';
	}
	
	/**
	 * Unique argument names
	 *
	 * A GraphQL field or directive is only valid if all supplied arguments are
	 * uniquely named.
	 */
	function UniqueArgumentNames(context) {
	  var knownArgNames = Object.create(null);
	  return {
	    Field: function Field() {
	      knownArgNames = Object.create(null);
	    },
	    Directive: function Directive() {
	      knownArgNames = Object.create(null);
	    },
	    Argument: function Argument(node) {
	      var argName = node.name.value;
	      if (knownArgNames[argName]) {
	        context.reportError(new _error.GraphQLError(duplicateArgMessage(argName), [knownArgNames[argName], node.name]));
	      } else {
	        knownArgNames[argName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateDirectiveMessage = duplicateDirectiveMessage;
	exports.UniqueDirectivesPerLocation = UniqueDirectivesPerLocation;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function duplicateDirectiveMessage(directiveName) {
	  return 'The directive "' + directiveName + '" can only be used once at ' + 'this location.';
	}
	
	/**
	 * Unique directive names per location
	 *
	 * A GraphQL document is only valid if all directives at a given location
	 * are uniquely named.
	 */
	function UniqueDirectivesPerLocation(context) {
	  return {
	    // Many different AST nodes may contain directives. Rather than listing
	    // them all, just listen for entering any node, and check to see if it
	    // defines any directives.
	    enter: function enter(node) {
	      if (node.directives) {
	        var knownDirectives = Object.create(null);
	        node.directives.forEach(function (directive) {
	          var directiveName = directive.name.value;
	          if (knownDirectives[directiveName]) {
	            context.reportError(new _error.GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));
	          } else {
	            knownDirectives[directiveName] = directive;
	          }
	        });
	      }
	    }
	  };
	}

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateFragmentNameMessage = duplicateFragmentNameMessage;
	exports.UniqueFragmentNames = UniqueFragmentNames;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function duplicateFragmentNameMessage(fragName) {
	  return 'There can be only one fragment named "' + fragName + '".';
	}
	
	/**
	 * Unique fragment names
	 *
	 * A GraphQL document is only valid if all defined fragments have unique names.
	 */
	function UniqueFragmentNames(context) {
	  var knownFragmentNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition() {
	      return false;
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      var fragmentName = node.name.value;
	      if (knownFragmentNames[fragmentName]) {
	        context.reportError(new _error.GraphQLError(duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));
	      } else {
	        knownFragmentNames[fragmentName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateInputFieldMessage = duplicateInputFieldMessage;
	exports.UniqueInputFieldNames = UniqueInputFieldNames;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function duplicateInputFieldMessage(fieldName) {
	  return 'There can be only one input field named "' + fieldName + '".';
	}
	
	/**
	 * Unique input field names
	 *
	 * A GraphQL input object value is only valid if all supplied fields are
	 * uniquely named.
	 */
	function UniqueInputFieldNames(context) {
	  var knownNameStack = [];
	  var knownNames = Object.create(null);
	
	  return {
	    ObjectValue: {
	      enter: function enter() {
	        knownNameStack.push(knownNames);
	        knownNames = Object.create(null);
	      },
	      leave: function leave() {
	        knownNames = knownNameStack.pop();
	      }
	    },
	    ObjectField: function ObjectField(node) {
	      var fieldName = node.name.value;
	      if (knownNames[fieldName]) {
	        context.reportError(new _error.GraphQLError(duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));
	      } else {
	        knownNames[fieldName] = node.name;
	      }
	      return false;
	    }
	  };
	}

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateOperationNameMessage = duplicateOperationNameMessage;
	exports.UniqueOperationNames = UniqueOperationNames;
	
	var _error = __webpack_require__(4);
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function duplicateOperationNameMessage(operationName) {
	  return 'There can be only one operation named "' + operationName + '".';
	}
	
	/**
	 * Unique operation names
	 *
	 * A GraphQL document is only valid if all defined operations have unique names.
	 */
	function UniqueOperationNames(context) {
	  var knownOperationNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition(node) {
	      var operationName = node.name;
	      if (operationName) {
	        if (knownOperationNames[operationName.value]) {
	          context.reportError(new _error.GraphQLError(duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));
	        } else {
	          knownOperationNames[operationName.value] = operationName;
	        }
	      }
	      return false;
	    },
	
	    FragmentDefinition: function FragmentDefinition() {
	      return false;
	    }
	  };
	}

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.duplicateVariableMessage = duplicateVariableMessage;
	exports.UniqueVariableNames = UniqueVariableNames;
	
	var _error = __webpack_require__(4);
	
	function duplicateVariableMessage(variableName) {
	  return 'There can be only one variable named "' + variableName + '".';
	}
	
	/**
	 * Unique variable names
	 *
	 * A GraphQL operation is only valid if all its variables are uniquely named.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function UniqueVariableNames(context) {
	  var knownVariableNames = Object.create(null);
	  return {
	    OperationDefinition: function OperationDefinition() {
	      knownVariableNames = Object.create(null);
	    },
	    VariableDefinition: function VariableDefinition(node) {
	      var variableName = node.variable.name.value;
	      if (knownVariableNames[variableName]) {
	        context.reportError(new _error.GraphQLError(duplicateVariableMessage(variableName), [knownVariableNames[variableName], node.variable.name]));
	      } else {
	        knownVariableNames[variableName] = node.variable.name;
	      }
	    }
	  };
	}

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;
	exports.VariablesAreInputTypes = VariablesAreInputTypes;
	
	var _error = __webpack_require__(4);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _typeFromAST = __webpack_require__(35);
	
	function nonInputTypeOnVarMessage(variableName, typeName) {
	  return 'Variable "$' + variableName + '" cannot be non-input type "' + typeName + '".';
	}
	
	/**
	 * Variables are input types
	 *
	 * A GraphQL operation is only valid if all the variables it defines are of
	 * input types (scalar, enum, or input object).
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function VariablesAreInputTypes(context) {
	  return {
	    VariableDefinition: function VariableDefinition(node) {
	      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
	
	      // If the variable type is not an input type, return an error.
	      if (type && !(0, _definition.isInputType)(type)) {
	        var variableName = node.variable.name.value;
	        context.reportError(new _error.GraphQLError(nonInputTypeOnVarMessage(variableName, (0, _printer.print)(node.type)), [node.type]));
	      }
	    }
	  };
	}

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.badVarPosMessage = badVarPosMessage;
	exports.VariablesInAllowedPosition = VariablesInAllowedPosition;
	
	var _error = __webpack_require__(4);
	
	var _definition = __webpack_require__(7);
	
	var _typeComparators = __webpack_require__(110);
	
	var _typeFromAST = __webpack_require__(35);
	
	function badVarPosMessage(varName, varType, expectedType) {
	  return 'Variable "$' + varName + '" of type "' + String(varType) + '" used in ' + ('position expecting type "' + String(expectedType) + '".');
	}
	
	/**
	 * Variables passed to field arguments conform to type
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function VariablesInAllowedPosition(context) {
	  var varDefMap = Object.create(null);
	
	  return {
	    OperationDefinition: {
	      enter: function enter() {
	        varDefMap = Object.create(null);
	      },
	      leave: function leave(operation) {
	        var usages = context.getRecursiveVariableUsages(operation);
	
	        usages.forEach(function (_ref) {
	          var node = _ref.node,
	              type = _ref.type;
	
	          var varName = node.name.value;
	          var varDef = varDefMap[varName];
	          if (varDef && type) {
	            // A var type is allowed if it is the same or more strict (e.g. is
	            // a subtype of) than the expected type. It can be more strict if
	            // the variable type is non-null when the expected type is nullable.
	            // If both are list types, the variable item type can be more strict
	            // than the expected item type (contravariant).
	            var schema = context.getSchema();
	            var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
	            if (varType && !(0, _typeComparators.isTypeSubTypeOf)(schema, effectiveType(varType, varDef), type)) {
	              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));
	            }
	          }
	        });
	      }
	    },
	    VariableDefinition: function VariableDefinition(node) {
	      varDefMap[node.variable.name.value] = node;
	    }
	  };
	}
	
	// If a variable definition has a default value, it's effectively non-null.
	function effectiveType(varType, varDef) {
	  return !varDef.defaultValue || varType instanceof _definition.GraphQLNonNull ? varType : new _definition.GraphQLNonNull(varType);
	}

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.specifiedRules = undefined;
	
	var _UniqueOperationNames = __webpack_require__(285);
	
	var _LoneAnonymousOperation = __webpack_require__(272);
	
	var _SingleFieldSubscriptions = __webpack_require__(280);
	
	var _KnownTypeNames = __webpack_require__(271);
	
	var _FragmentsOnCompositeTypes = __webpack_require__(267);
	
	var _VariablesAreInputTypes = __webpack_require__(287);
	
	var _ScalarLeafs = __webpack_require__(279);
	
	var _FieldsOnCorrectType = __webpack_require__(266);
	
	var _UniqueFragmentNames = __webpack_require__(283);
	
	var _KnownFragmentNames = __webpack_require__(270);
	
	var _NoUnusedFragments = __webpack_require__(169);
	
	var _PossibleFragmentSpreads = __webpack_require__(277);
	
	var _NoFragmentCycles = __webpack_require__(273);
	
	var _UniqueVariableNames = __webpack_require__(286);
	
	var _NoUndefinedVariables = __webpack_require__(274);
	
	var _NoUnusedVariables = __webpack_require__(275);
	
	var _KnownDirectives = __webpack_require__(269);
	
	var _UniqueDirectivesPerLocation = __webpack_require__(282);
	
	var _KnownArgumentNames = __webpack_require__(268);
	
	var _UniqueArgumentNames = __webpack_require__(281);
	
	var _ArgumentsOfCorrectType = __webpack_require__(264);
	
	var _ProvidedNonNullArguments = __webpack_require__(278);
	
	var _DefaultValuesOfCorrectType = __webpack_require__(265);
	
	var _VariablesInAllowedPosition = __webpack_require__(288);
	
	var _OverlappingFieldsCanBeMerged = __webpack_require__(276);
	
	var _UniqueInputFieldNames = __webpack_require__(284);
	
	/**
	 * This set includes all validation rules defined by the GraphQL spec.
	 *
	 * The order of the rules in this list has been adjusted to lead to the
	 * most clear output when encountering multiple validation errors.
	 */
	
	
	// Spec Section: "Field Selection Merging"
	
	
	// Spec Section: "Variable Default Values Are Correctly Typed"
	
	
	// Spec Section: "Argument Values Type Correctness"
	
	
	// Spec Section: "Argument Names"
	
	
	// Spec Section: "Directives Are Defined"
	
	
	// Spec Section: "All Variable Used Defined"
	
	
	// Spec Section: "Fragments must not form cycles"
	
	
	// Spec Section: "Fragments must be used"
	
	
	// Spec Section: "Fragment Name Uniqueness"
	
	
	// Spec Section: "Leaf Field Selections"
	
	
	// Spec Section: "Fragments on Composite Types"
	
	
	// Spec Section: "Subscriptions with Single Root Field"
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	// Spec Section: "Operation Name Uniqueness"
	var specifiedRules = exports.specifiedRules = [_UniqueOperationNames.UniqueOperationNames, _LoneAnonymousOperation.LoneAnonymousOperation, _SingleFieldSubscriptions.SingleFieldSubscriptions, _KnownTypeNames.KnownTypeNames, _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _VariablesAreInputTypes.VariablesAreInputTypes, _ScalarLeafs.ScalarLeafs, _FieldsOnCorrectType.FieldsOnCorrectType, _UniqueFragmentNames.UniqueFragmentNames, _KnownFragmentNames.KnownFragmentNames, _NoUnusedFragments.NoUnusedFragments, _PossibleFragmentSpreads.PossibleFragmentSpreads, _NoFragmentCycles.NoFragmentCycles, _UniqueVariableNames.UniqueVariableNames, _NoUndefinedVariables.NoUndefinedVariables, _NoUnusedVariables.NoUnusedVariables, _KnownDirectives.KnownDirectives, _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation, _KnownArgumentNames.KnownArgumentNames, _UniqueArgumentNames.UniqueArgumentNames, _ArgumentsOfCorrectType.ArgumentsOfCorrectType, _ProvidedNonNullArguments.ProvidedNonNullArguments, _DefaultValuesOfCorrectType.DefaultValuesOfCorrectType, _VariablesInAllowedPosition.VariablesInAllowedPosition, _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _UniqueInputFieldNames.UniqueInputFieldNames];
	
	// Spec Section: "Input Object Field Uniqueness"
	
	
	// Spec Section: "All Variable Usages Are Allowed"
	
	
	// Spec Section: "Argument Optionality"
	
	
	// Spec Section: "Argument Uniqueness"
	
	
	// Spec Section: "Directives Are Unique Per Location"
	
	
	// Spec Section: "All Variables Used"
	
	
	// Spec Section: "Variable Uniqueness"
	
	
	// Spec Section: "Fragment spread is possible"
	
	
	// Spec Section: "Fragment spread target defined"
	
	
	// Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"
	
	
	// Spec Section: "Variables are Input Types"
	
	
	// Spec Section: "Fragment Spread Type Existence"
	
	
	// Spec Section: "Lone Anonymous Operation"

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ValidationContext = undefined;
	exports.validate = validate;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _error = __webpack_require__(4);
	
	var _visitor = __webpack_require__(80);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	var _schema = __webpack_require__(34);
	
	var _TypeInfo = __webpack_require__(166);
	
	var _specifiedRules = __webpack_require__(289);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * This source code is licensed under the MIT license found in the
	                                                                                                                                                           * LICENSE file in the root directory of this source tree.
	                                                                                                                                                           *
	                                                                                                                                                           * 
	                                                                                                                                                           */
	
	/**
	 * Implements the "Validation" section of the spec.
	 *
	 * Validation runs synchronously, returning an array of encountered errors, or
	 * an empty array if no errors were encountered and the document is valid.
	 *
	 * A list of specific validation rules may be provided. If not provided, the
	 * default list of rules defined by the GraphQL specification will be used.
	 *
	 * Each validation rules is a function which returns a visitor
	 * (see the language/visitor API). Visitor methods are expected to return
	 * GraphQLErrors, or Arrays of GraphQLErrors when invalid.
	 *
	 * Optionally a custom TypeInfo instance may be provided. If not provided, one
	 * will be created from the provided schema.
	 */
	function validate(schema, ast, rules, typeInfo) {
	  !schema ? (0, _invariant2.default)(0, 'Must provide schema') : void 0;
	  !ast ? (0, _invariant2.default)(0, 'Must provide document') : void 0;
	  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.') : void 0;
	  return visitUsingRules(schema, typeInfo || new _TypeInfo.TypeInfo(schema), ast, rules || _specifiedRules.specifiedRules);
	}
	
	/**
	 * This uses a specialized visitor which runs multiple visitors in parallel,
	 * while maintaining the visitor skip and break API.
	 *
	 * @internal
	 */
	function visitUsingRules(schema, typeInfo, documentAST, rules) {
	  var context = new ValidationContext(schema, documentAST, typeInfo);
	  var visitors = rules.map(function (rule) {
	    return rule(context);
	  });
	  // Visit the whole document with each instance of all provided rules.
	  (0, _visitor.visit)(documentAST, (0, _visitor.visitWithTypeInfo)(typeInfo, (0, _visitor.visitInParallel)(visitors)));
	  return context.getErrors();
	}
	
	/**
	 * An instance of this class is passed as the "this" context to all validators,
	 * allowing access to commonly useful contextual information from within a
	 * validation rule.
	 */
	var ValidationContext = exports.ValidationContext = function () {
	  function ValidationContext(schema, ast, typeInfo) {
	    _classCallCheck(this, ValidationContext);
	
	    this._schema = schema;
	    this._ast = ast;
	    this._typeInfo = typeInfo;
	    this._errors = [];
	    this._fragmentSpreads = new Map();
	    this._recursivelyReferencedFragments = new Map();
	    this._variableUsages = new Map();
	    this._recursiveVariableUsages = new Map();
	  }
	
	  ValidationContext.prototype.reportError = function reportError(error) {
	    this._errors.push(error);
	  };
	
	  ValidationContext.prototype.getErrors = function getErrors() {
	    return this._errors;
	  };
	
	  ValidationContext.prototype.getSchema = function getSchema() {
	    return this._schema;
	  };
	
	  ValidationContext.prototype.getDocument = function getDocument() {
	    return this._ast;
	  };
	
	  ValidationContext.prototype.getFragment = function getFragment(name) {
	    var fragments = this._fragments;
	    if (!fragments) {
	      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {
	        if (statement.kind === Kind.FRAGMENT_DEFINITION) {
	          frags[statement.name.value] = statement;
	        }
	        return frags;
	      }, Object.create(null));
	    }
	    return fragments[name];
	  };
	
	  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {
	    var spreads = this._fragmentSpreads.get(node);
	    if (!spreads) {
	      spreads = [];
	      var setsToVisit = [node];
	      while (setsToVisit.length !== 0) {
	        var set = setsToVisit.pop();
	        for (var i = 0; i < set.selections.length; i++) {
	          var selection = set.selections[i];
	          if (selection.kind === Kind.FRAGMENT_SPREAD) {
	            spreads.push(selection);
	          } else if (selection.selectionSet) {
	            setsToVisit.push(selection.selectionSet);
	          }
	        }
	      }
	      this._fragmentSpreads.set(node, spreads);
	    }
	    return spreads;
	  };
	
	  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
	    var fragments = this._recursivelyReferencedFragments.get(operation);
	    if (!fragments) {
	      fragments = [];
	      var collectedNames = Object.create(null);
	      var nodesToVisit = [operation.selectionSet];
	      while (nodesToVisit.length !== 0) {
	        var _node = nodesToVisit.pop();
	        var spreads = this.getFragmentSpreads(_node);
	        for (var i = 0; i < spreads.length; i++) {
	          var fragName = spreads[i].name.value;
	          if (collectedNames[fragName] !== true) {
	            collectedNames[fragName] = true;
	            var fragment = this.getFragment(fragName);
	            if (fragment) {
	              fragments.push(fragment);
	              nodesToVisit.push(fragment.selectionSet);
	            }
	          }
	        }
	      }
	      this._recursivelyReferencedFragments.set(operation, fragments);
	    }
	    return fragments;
	  };
	
	  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {
	    var usages = this._variableUsages.get(node);
	    if (!usages) {
	      var newUsages = [];
	      var typeInfo = new _TypeInfo.TypeInfo(this._schema);
	      (0, _visitor.visit)(node, (0, _visitor.visitWithTypeInfo)(typeInfo, {
	        VariableDefinition: function VariableDefinition() {
	          return false;
	        },
	        Variable: function Variable(variable) {
	          newUsages.push({ node: variable, type: typeInfo.getInputType() });
	        }
	      }));
	      usages = newUsages;
	      this._variableUsages.set(node, usages);
	    }
	    return usages;
	  };
	
	  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
	    var usages = this._recursiveVariableUsages.get(operation);
	    if (!usages) {
	      usages = this.getVariableUsages(operation);
	      var fragments = this.getRecursivelyReferencedFragments(operation);
	      for (var i = 0; i < fragments.length; i++) {
	        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));
	      }
	      this._recursiveVariableUsages.set(operation, usages);
	    }
	    return usages;
	  };
	
	  ValidationContext.prototype.getType = function getType() {
	    return this._typeInfo.getType();
	  };
	
	  ValidationContext.prototype.getParentType = function getParentType() {
	    return this._typeInfo.getParentType();
	  };
	
	  ValidationContext.prototype.getInputType = function getInputType() {
	    return this._typeInfo.getInputType();
	  };
	
	  ValidationContext.prototype.getFieldDef = function getFieldDef() {
	    return this._typeInfo.getFieldDef();
	  };
	
	  ValidationContext.prototype.getDirective = function getDirective() {
	    return this._typeInfo.getDirective();
	  };
	
	  ValidationContext.prototype.getArgument = function getArgument() {
	    return this._typeInfo.getArgument();
	  };
	
	  return ValidationContext;
	}();

/***/ }),
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = alphabetical;
	
	/* Check if the given character code, or the character
	 * code at the first character, is alphabetical. */
	function alphabetical(character) {
	  var code = typeof character === 'string' ?
	    character.charCodeAt(0) : character;
	
	  return (code >= 97 && code <= 122) || /* a-z */
	    (code >= 65 && code <= 90); /* A-Z */
	}


/***/ }),
/* 296 */,
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
		// explicitly match decimal, hex, and named HTML entities 
	  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || (typeof window !== 'undefined' ? window : global);
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ES = __webpack_require__(488);
	var has = __webpack_require__(111);
	var bind = __webpack_require__(151);
	var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
	
	module.exports = function entries(O) {
		var obj = ES.RequireObjectCoercible(O);
		var entrys = [];
		for (var key in obj) {
			if (has(obj, key) && isEnumerable(obj, key)) {
				entrys.push([key, obj[key]]);
			}
		}
		return entrys;
	};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var implementation = __webpack_require__(298);
	
	module.exports = function getPolyfill() {
		return typeof Object.entries === 'function' ? Object.entries : implementation;
	};


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.assertNodeList = assertNodeList;
	exports.setElement = setElement;
	exports.tryForceFallback = tryForceFallback;
	exports.validateElement = validateElement;
	exports.hide = hide;
	exports.show = show;
	exports.documentNotReadyOrSSRTesting = documentNotReadyOrSSRTesting;
	exports.resetForTesting = resetForTesting;
	var globalElement = null;
	
	function assertNodeList(nodeList, selector) {
	  if (!nodeList || !nodeList.length) {
	    throw new Error("react-modal: No elements were found for selector " + selector + ".");
	  }
	}
	
	function setElement(element) {
	  var useElement = element;
	  if (typeof useElement === "string") {
	    var el = document.querySelectorAll(useElement);
	    assertNodeList(el, useElement);
	    useElement = "length" in el ? el[0] : el;
	  }
	  globalElement = useElement || globalElement;
	  return globalElement;
	}
	
	function tryForceFallback() {
	  if (document && document.body) {
	    // force fallback to document.body
	    setElement(document.body);
	    return true;
	  }
	  return false;
	}
	
	function validateElement(appElement) {
	  if (!appElement && !globalElement && !tryForceFallback()) {
	    throw new Error(["react-modal: Cannot fallback to `document.body`, because it is not", "ready or available. If you are doing server-side rendering, use this", "function to defined an element. `Modal.setAppElement(el)` to make", "this accessible"].join(" "));
	  }
	}
	
	function hide(appElement) {
	  validateElement(appElement);
	  (appElement || globalElement).setAttribute("aria-hidden", "true");
	}
	
	function show(appElement) {
	  validateElement(appElement);
	  (appElement || globalElement).removeAttribute("aria-hidden");
	}
	
	function documentNotReadyOrSSRTesting() {
	  globalElement = null;
	}
	
	function resetForTesting() {
	  globalElement = document.body;
	}

/***/ }),
/* 326 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.get = get;
	exports.add = add;
	exports.remove = remove;
	exports.totalCount = totalCount;
	var classListMap = {};
	
	function get() {
	  return classListMap;
	}
	
	function add(bodyClass) {
	  // Set variable and default if none
	  if (!classListMap[bodyClass]) {
	    classListMap[bodyClass] = 0;
	  }
	  classListMap[bodyClass] += 1;
	  return bodyClass;
	}
	
	function remove(bodyClass) {
	  if (classListMap[bodyClass]) {
	    classListMap[bodyClass] -= 1;
	  }
	  return bodyClass;
	}
	
	function totalCount() {
	  return Object.keys(classListMap).reduce(function (acc, curr) {
	    return acc + classListMap[curr];
	  }, 0);
	}

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.canUseDOM = undefined;
	
	var _exenv = __webpack_require__(148);
	
	var _exenv2 = _interopRequireDefault(_exenv);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EE = _exenv2.default;
	
	var SafeHTMLElement = EE.canUseDOM ? window.HTMLElement : {};
	
	var canUseDOM = exports.canUseDOM = EE.canUseDOM;
	
	exports.default = SafeHTMLElement;

/***/ }),
/* 328 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = findTabbableDescendants;
	/*!
	 * Adapted from jQuery UI core
	 *
	 * http://jqueryui.com
	 *
	 * Copyright 2014 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/ui-core/
	 */
	
	var tabbableNode = /input|select|textarea|button|object/;
	
	function hidesContents(element) {
	  var zeroSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;
	
	  // If the node is empty, this is good enough
	  if (zeroSize && !element.innerHTML) return true;
	
	  // Otherwise we need to check some styles
	  var style = window.getComputedStyle(element);
	  return zeroSize ? style.getPropertyValue("overflow") !== "visible" : style.getPropertyValue("display") == "none";
	}
	
	function visible(element) {
	  var parentElement = element;
	  while (parentElement) {
	    if (parentElement === document.body) break;
	    if (hidesContents(parentElement)) return false;
	    parentElement = parentElement.parentNode;
	  }
	  return true;
	}
	
	function focusable(element, isTabIndexNotNaN) {
	  var nodeName = element.nodeName.toLowerCase();
	  var res = tabbableNode.test(nodeName) && !element.disabled || (nodeName === "a" ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);
	  return res && visible(element);
	}
	
	function tabbable(element) {
	  var tabIndex = element.getAttribute("tabindex");
	  if (tabIndex === null) tabIndex = undefined;
	  var isTabIndexNaN = isNaN(tabIndex);
	  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
	}
	
	function findTabbableDescendants(element) {
	  return [].slice.call(element.querySelectorAll("*"), 0).filter(tabbable);
	}
	module.exports = exports["default"];

/***/ }),
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "black",
	        "background": "none",
	        "textShadow": "0 1px white",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "black",
	        "background": "#f5f2f0",
	        "textShadow": "0 1px white",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#b3d4fc"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#f5f2f0",
	        "padding": ".1em",
	        "borderRadius": ".3em",
	        "whiteSpace": "normal"
	    },
	    "comment": {
	        "color": "slategray"
	    },
	    "prolog": {
	        "color": "slategray"
	    },
	    "doctype": {
	        "color": "slategray"
	    },
	    "cdata": {
	        "color": "slategray"
	    },
	    "punctuation": {
	        "color": "#999"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "#905"
	    },
	    "tag": {
	        "color": "#905"
	    },
	    "boolean": {
	        "color": "#905"
	    },
	    "number": {
	        "color": "#905"
	    },
	    "constant": {
	        "color": "#905"
	    },
	    "symbol": {
	        "color": "#905"
	    },
	    "deleted": {
	        "color": "#905"
	    },
	    "selector": {
	        "color": "#690"
	    },
	    "attr-name": {
	        "color": "#690"
	    },
	    "string": {
	        "color": "#690"
	    },
	    "char": {
	        "color": "#690"
	    },
	    "builtin": {
	        "color": "#690"
	    },
	    "inserted": {
	        "color": "#690"
	    },
	    "operator": {
	        "color": "#a67f59",
	        "background": "hsla(0, 0%, 100%, .5)"
	    },
	    "entity": {
	        "color": "#a67f59",
	        "background": "hsla(0, 0%, 100%, .5)",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#a67f59",
	        "background": "hsla(0, 0%, 100%, .5)"
	    },
	    ".language-css .token.string": {
	        "color": "#a67f59",
	        "background": "hsla(0, 0%, 100%, .5)"
	    },
	    ".style .token.string": {
	        "color": "#a67f59",
	        "background": "hsla(0, 0%, 100%, .5)"
	    },
	    "atrule": {
	        "color": "#07a"
	    },
	    "attr-value": {
	        "color": "#07a"
	    },
	    "keyword": {
	        "color": "#07a"
	    },
	    "function": {
	        "color": "#DD4A68"
	    },
	    "regex": {
	        "color": "#e90"
	    },
	    "important": {
	        "color": "#e90",
	        "fontWeight": "bold"
	    },
	    "variable": {
	        "color": "#e90"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.nameShape = undefined;
	exports.transitionTimeout = transitionTimeout;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function transitionTimeout(transitionType) {
	  var timeoutPropName = 'transition' + transitionType + 'Timeout';
	  var enabledPropName = 'transition' + transitionType;
	
	  return function (props) {
	    // If the transition is enabled
	    if (props[enabledPropName]) {
	      // If no timeout duration is provided
	      if (props[timeoutPropName] == null) {
	        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');
	
	        // If the duration isn't a number
	      } else if (typeof props[timeoutPropName] !== 'number') {
	        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
	      }
	    }
	
	    return null;
	  };
	}
	
	var nameShape = exports.nameShape = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
	  enter: _propTypes2.default.string,
	  leave: _propTypes2.default.string,
	  active: _propTypes2.default.string
	}), _propTypes2.default.shape({
	  enter: _propTypes2.default.string,
	  enterActive: _propTypes2.default.string,
	  leave: _propTypes2.default.string,
	  leaveActive: _propTypes2.default.string,
	  appear: _propTypes2.default.string,
	  appearActive: _propTypes2.default.string
	})]);

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DEFAULT_HEIGHT = exports.DEFAULT_HEIGHT = 30;
	var DEFAULT_WIDTH = exports.DEFAULT_WIDTH = 100;
	
	// Enables more intelligent mapping of a given column and row index to an item ID.
	// This prevents a cell cache from being invalidated when its parent collection is modified.
	
	/**
	 * Caches measurements for a given cell.
	 */
	var CellMeasurerCache = function () {
	  function CellMeasurerCache() {
	    var _this = this;
	
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, CellMeasurerCache);
	
	    this._cellHeightCache = {};
	    this._cellWidthCache = {};
	    this._columnWidthCache = {};
	    this._rowHeightCache = {};
	    this._columnCount = 0;
	    this._rowCount = 0;
	
	    this.columnWidth = function (_ref) {
	      var index = _ref.index;
	
	      var key = _this._keyMapper(0, index);
	
	      return _this._columnWidthCache.hasOwnProperty(key) ? _this._columnWidthCache[key] : _this._defaultWidth;
	    };
	
	    this.rowHeight = function (_ref2) {
	      var index = _ref2.index;
	
	      var key = _this._keyMapper(index, 0);
	
	      return _this._rowHeightCache.hasOwnProperty(key) ? _this._rowHeightCache[key] : _this._defaultHeight;
	    };
	
	    var defaultHeight = params.defaultHeight,
	        defaultWidth = params.defaultWidth,
	        fixedHeight = params.fixedHeight,
	        fixedWidth = params.fixedWidth,
	        keyMapper = params.keyMapper,
	        minHeight = params.minHeight,
	        minWidth = params.minWidth;
	
	
	    this._hasFixedHeight = fixedHeight === true;
	    this._hasFixedWidth = fixedWidth === true;
	    this._minHeight = minHeight || 0;
	    this._minWidth = minWidth || 0;
	    this._keyMapper = keyMapper || defaultKeyMapper;
	
	    this._defaultHeight = Math.max(this._minHeight, typeof defaultHeight === 'number' ? defaultHeight : DEFAULT_HEIGHT);
	    this._defaultWidth = Math.max(this._minWidth, typeof defaultWidth === 'number' ? defaultWidth : DEFAULT_WIDTH);
	
	    if (false) {
	      if (this._hasFixedHeight === false && this._hasFixedWidth === false) {
	        console.warn("CellMeasurerCache should only measure a cell's width or height. " + 'You have configured CellMeasurerCache to measure both. ' + 'This will result in poor performance.');
	      }
	
	      if (this._hasFixedHeight === false && this._defaultHeight === 0) {
	        console.warn('Fixed height CellMeasurerCache should specify a :defaultHeight greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
	      }
	
	      if (this._hasFixedWidth === false && this._defaultWidth === 0) {
	        console.warn('Fixed width CellMeasurerCache should specify a :defaultWidth greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
	      }
	    }
	  }
	
	  _createClass(CellMeasurerCache, [{
	    key: 'clear',
	    value: function clear(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      var key = this._keyMapper(rowIndex, columnIndex);
	
	      delete this._cellHeightCache[key];
	      delete this._cellWidthCache[key];
	
	      this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
	    }
	  }, {
	    key: 'clearAll',
	    value: function clearAll() {
	      this._cellHeightCache = {};
	      this._cellWidthCache = {};
	      this._columnWidthCache = {};
	      this._rowHeightCache = {};
	      this._rowCount = 0;
	      this._columnCount = 0;
	    }
	  }, {
	    key: 'hasFixedHeight',
	    value: function hasFixedHeight() {
	      return this._hasFixedHeight;
	    }
	  }, {
	    key: 'hasFixedWidth',
	    value: function hasFixedWidth() {
	      return this._hasFixedWidth;
	    }
	  }, {
	    key: 'getHeight',
	    value: function getHeight(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      if (this._hasFixedHeight) {
	        return this._defaultHeight;
	      } else {
	        var _key = this._keyMapper(rowIndex, columnIndex);
	
	        return this._cellHeightCache.hasOwnProperty(_key) ? Math.max(this._minHeight, this._cellHeightCache[_key]) : this._defaultHeight;
	      }
	    }
	  }, {
	    key: 'getWidth',
	    value: function getWidth(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      if (this._hasFixedWidth) {
	        return this._defaultWidth;
	      } else {
	        var _key2 = this._keyMapper(rowIndex, columnIndex);
	
	        return this._cellWidthCache.hasOwnProperty(_key2) ? Math.max(this._minWidth, this._cellWidthCache[_key2]) : this._defaultWidth;
	      }
	    }
	  }, {
	    key: 'has',
	    value: function has(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      var key = this._keyMapper(rowIndex, columnIndex);
	
	      return this._cellHeightCache.hasOwnProperty(key);
	    }
	  }, {
	    key: 'set',
	    value: function set(rowIndex, columnIndex, width, height) {
	      var key = this._keyMapper(rowIndex, columnIndex);
	
	      if (columnIndex >= this._columnCount) {
	        this._columnCount = columnIndex + 1;
	      }
	      if (rowIndex >= this._rowCount) {
	        this._rowCount = rowIndex + 1;
	      }
	
	      // Size is cached per cell so we don't have to re-measure if cells are re-ordered.
	      this._cellHeightCache[key] = height;
	      this._cellWidthCache[key] = width;
	
	      this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
	    }
	  }, {
	    key: '_updateCachedColumnAndRowSizes',
	    value: function _updateCachedColumnAndRowSizes(rowIndex, columnIndex) {
	      // :columnWidth and :rowHeight are derived based on all cells in a column/row.
	      // Pre-cache these derived values for faster lookup later.
	      // Reads are expected to occur more frequently than writes in this case.
	      // Only update non-fixed dimensions though to avoid doing unnecessary work.
	      if (!this._hasFixedWidth) {
	        var columnWidth = 0;
	        for (var i = 0; i < this._rowCount; i++) {
	          columnWidth = Math.max(columnWidth, this.getWidth(i, columnIndex));
	        }
	        var columnKey = this._keyMapper(0, columnIndex);
	        this._columnWidthCache[columnKey] = columnWidth;
	      }
	      if (!this._hasFixedHeight) {
	        var rowHeight = 0;
	        for (var _i = 0; _i < this._columnCount; _i++) {
	          rowHeight = Math.max(rowHeight, this.getHeight(rowIndex, _i));
	        }
	        var rowKey = this._keyMapper(rowIndex, 0);
	        this._rowHeightCache[rowKey] = rowHeight;
	      }
	    }
	  }, {
	    key: 'defaultHeight',
	    get: function get() {
	      return this._defaultHeight;
	    }
	  }, {
	    key: 'defaultWidth',
	    get: function get() {
	      return this._defaultWidth;
	    }
	  }]);
	
	  return CellMeasurerCache;
	}();
	
	exports.default = CellMeasurerCache;
	
	
	function defaultKeyMapper(rowIndex, columnIndex) {
	  return rowIndex + '-' + columnIndex;
	}

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CellMeasurerCache = exports.CellMeasurer = undefined;
	
	var _CellMeasurer = __webpack_require__(811);
	
	var _CellMeasurer2 = _interopRequireDefault(_CellMeasurer);
	
	var _CellMeasurerCache = __webpack_require__(334);
	
	var _CellMeasurerCache2 = _interopRequireDefault(_CellMeasurerCache);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _CellMeasurer2.default;
	exports.CellMeasurer = _CellMeasurer2.default;
	exports.CellMeasurerCache = _CellMeasurerCache2.default;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultCellRangeRenderer;
	
	/**
	 * Default implementation of cellRangeRenderer used by Grid.
	 * This renderer supports cell-caching while the user is scrolling.
	 */
	
	var babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams || __webpack_require__(1).any;
	
	function defaultCellRangeRenderer(_ref) {
	  var cellCache = _ref.cellCache,
	      cellRenderer = _ref.cellRenderer,
	      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,
	      columnStartIndex = _ref.columnStartIndex,
	      columnStopIndex = _ref.columnStopIndex,
	      deferredMeasurementCache = _ref.deferredMeasurementCache,
	      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,
	      isScrolling = _ref.isScrolling,
	      parent = _ref.parent,
	      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,
	      rowStartIndex = _ref.rowStartIndex,
	      rowStopIndex = _ref.rowStopIndex,
	      styleCache = _ref.styleCache,
	      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,
	      visibleColumnIndices = _ref.visibleColumnIndices,
	      visibleRowIndices = _ref.visibleRowIndices;
	
	  var renderedCells = [];
	
	  // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).
	  // User cannot scroll beyond these size limitations.
	  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.
	  // We should never cache styles for compressed offsets though as this can lead to bugs.
	  // See issue #576 for more.
	  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();
	
	  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;
	
	  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
	    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);
	
	    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
	      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);
	      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;
	      var key = rowIndex + '-' + columnIndex;
	      var style = void 0;
	
	      // Cache style objects so shallow-compare doesn't re-render unnecessarily.
	      if (canCacheStyle && styleCache[key]) {
	        style = styleCache[key];
	      } else {
	        // In deferred mode, cells will be initially rendered before we know their size.
	        // Don't interfere with CellMeasurer's measurements by setting an invalid size.
	        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {
	          // Position not-yet-measured cells at top/left 0,0,
	          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.
	          // Positioning them further to the right/bottom influences their measured size.
	          style = {
	            height: 'auto',
	            left: 0,
	            position: 'absolute',
	            top: 0,
	            width: 'auto'
	          };
	        } else {
	          style = {
	            height: rowDatum.size,
	            left: columnDatum.offset + horizontalOffsetAdjustment,
	            position: 'absolute',
	            top: rowDatum.offset + verticalOffsetAdjustment,
	            width: columnDatum.size
	          };
	
	          styleCache[key] = style;
	        }
	      }
	
	      var cellRendererParams = {
	        columnIndex: columnIndex,
	        isScrolling: isScrolling,
	        isVisible: isVisible,
	        key: key,
	        parent: parent,
	        rowIndex: rowIndex,
	        style: style
	      };
	
	      var renderedCell = void 0;
	
	      // Avoid re-creating cells while scrolling.
	      // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
	      // If a scroll is in progress- cache and reuse cells.
	      // This cache will be thrown away once scrolling completes.
	      // However if we are scaling scroll positions and sizes, we should also avoid caching.
	      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
	      // For more info refer to issue #395
	      if (isScrolling && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {
	        if (!cellCache[key]) {
	          cellCache[key] = cellRenderer(cellRendererParams);
	        }
	
	        renderedCell = cellCache[key];
	
	        // If the user is no longer scrolling, don't cache cells.
	        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.
	      } else {
	        renderedCell = cellRenderer(cellRendererParams);
	      }
	
	      if (renderedCell == null || renderedCell === false) {
	        continue;
	      }
	
	      if (false) {
	        warnAboutMissingStyle(parent, renderedCell);
	      }
	
	      renderedCells.push(renderedCell);
	    }
	  }
	
	  return renderedCells;
	}
	
	function warnAboutMissingStyle(parent, renderedCell) {
	  if (false) {
	    if (renderedCell) {
	      // If the direct child is a CellMeasurer, then we should check its child
	      // See issue #611
	      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {
	        renderedCell = renderedCell.props.children;
	      }
	
	      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {
	        parent.__warnedAboutMissingStyle = true;
	
	        console.warn('Rendered cell should include style property for positioning.');
	      }
	    }
	  }
	}

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultOverscanIndicesGetter;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndices = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_OverscanIndices || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || __webpack_require__(1).any;
	
	var SCROLL_DIRECTION_BACKWARD = exports.SCROLL_DIRECTION_BACKWARD = -1;
	var SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_FORWARD = 1;
	
	var SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
	var SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_VERTICAL = 'vertical';
	
	/**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
	
	function defaultOverscanIndicesGetter(_ref) {
	  var cellCount = _ref.cellCount,
	      overscanCellsCount = _ref.overscanCellsCount,
	      scrollDirection = _ref.scrollDirection,
	      startIndex = _ref.startIndex,
	      stopIndex = _ref.stopIndex;
	
	  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
	    return {
	      overscanStartIndex: Math.max(0, startIndex),
	      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
	    };
	  } else {
	    return {
	      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
	      overscanStopIndex: Math.min(cellCount - 1, stopIndex)
	    };
	  }
	}

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _defaultHeaderRenderer = __webpack_require__(342);
	
	var _defaultHeaderRenderer2 = _interopRequireDefault(_defaultHeaderRenderer);
	
	var _defaultCellRenderer = __webpack_require__(341);
	
	var _defaultCellRenderer2 = _interopRequireDefault(_defaultCellRenderer);
	
	var _defaultCellDataGetter = __webpack_require__(340);
	
	var _defaultCellDataGetter2 = _interopRequireDefault(_defaultCellDataGetter);
	
	var _SortDirection = __webpack_require__(120);
	
	var _SortDirection2 = _interopRequireDefault(_SortDirection);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Describes the header and cell contents of a table column.
	 */
	var Column = function (_Component) {
	  _inherits(Column, _Component);
	
	  function Column() {
	    _classCallCheck(this, Column);
	
	    return _possibleConstructorReturn(this, (Column.__proto__ || Object.getPrototypeOf(Column)).apply(this, arguments));
	  }
	
	  return Column;
	}(_react.Component);
	
	Column.defaultProps = {
	  cellDataGetter: _defaultCellDataGetter2.default,
	  cellRenderer: _defaultCellRenderer2.default,
	  defaultSortDirection: _SortDirection2.default.ASC,
	  flexGrow: 0,
	  flexShrink: 1,
	  headerRenderer: _defaultHeaderRenderer2.default,
	  style: {}
	};
	exports.default = Column;
	Column.propTypes =  false ? {
	  /** Optional aria-label value to set on the column header */
	  'aria-label': _propTypes2.default.string,
	
	  /**
	   * Callback responsible for returning a cell's data, given its :dataKey
	   * ({ columnData: any, dataKey: string, rowData: any }): any
	   */
	  cellDataGetter: _propTypes2.default.func,
	
	  /**
	   * Callback responsible for rendering a cell's contents.
	   * ({ cellData: any, columnData: any, dataKey: string, rowData: any, rowIndex: number }): node
	   */
	  cellRenderer: _propTypes2.default.func,
	
	  /** Optional CSS class to apply to cell */
	  className: _propTypes2.default.string,
	
	  /** Optional additional data passed to this column's :cellDataGetter */
	  columnData: _propTypes2.default.object,
	
	  /** Uniquely identifies the row-data attribute corresponding to this cell */
	  dataKey: _propTypes2.default.any.isRequired,
	
	  /** Optional direction to be used when clicked the first time */
	  defaultSortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC]),
	
	  /** If sort is enabled for the table at large, disable it for this column */
	  disableSort: _propTypes2.default.bool,
	
	  /** Flex grow style; defaults to 0 */
	  flexGrow: _propTypes2.default.number,
	
	  /** Flex shrink style; defaults to 1 */
	  flexShrink: _propTypes2.default.number,
	
	  /** Optional CSS class to apply to this column's header */
	  headerClassName: _propTypes2.default.string,
	
	  /**
	   * Optional callback responsible for rendering a column header contents.
	   * ({ columnData: object, dataKey: string, disableSort: boolean, label: node, sortBy: string, sortDirection: string }): PropTypes.node
	   */
	  headerRenderer: _propTypes2.default.func.isRequired,
	
	  /** Optional inline style to apply to this column's header */
	  headerStyle: _propTypes2.default.object,
	
	  /** Optional id to set on the column header */
	  id: _propTypes2.default.string,
	
	  /** Header label for this column */
	  label: _propTypes2.default.node,
	
	  /** Maximum width of column; this property will only be used if :flexGrow is > 0. */
	  maxWidth: _propTypes2.default.number,
	
	  /** Minimum width of column. */
	  minWidth: _propTypes2.default.number,
	
	  /** Optional inline style to apply to cell */
	  style: _propTypes2.default.object,
	
	  /** Flex basis (width) for this column; This value can grow or shrink based on :flexGrow and :flexShrink properties. */
	  width: _propTypes2.default.number.isRequired
	} : {};

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SortIndicator;
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _SortDirection = __webpack_require__(120);
	
	var _SortDirection2 = _interopRequireDefault(_SortDirection);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Displayed beside a header to indicate that a Table is currently sorted by this column.
	 */
	function SortIndicator(_ref) {
	  var sortDirection = _ref.sortDirection;
	
	  var classNames = (0, _classnames2.default)('ReactVirtualized__Table__sortableHeaderIcon', {
	    'ReactVirtualized__Table__sortableHeaderIcon--ASC': sortDirection === _SortDirection2.default.ASC,
	    'ReactVirtualized__Table__sortableHeaderIcon--DESC': sortDirection === _SortDirection2.default.DESC
	  });
	
	  return _react2.default.createElement(
	    'svg',
	    { className: classNames, width: 18, height: 18, viewBox: '0 0 24 24' },
	    sortDirection === _SortDirection2.default.ASC ? _react2.default.createElement('path', { d: 'M7 14l5-5 5 5z' }) : _react2.default.createElement('path', { d: 'M7 10l5 5 5-5z' }),
	    _react2.default.createElement('path', { d: 'M0 0h24v24H0z', fill: 'none' })
	  );
	}
	
	SortIndicator.propTypes =  false ? {
	  sortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC])
	} : {};

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultCellDataGetter;
	
	/**
	 * Default accessor for returning a cell value for a given attribute.
	 * This function expects to operate on either a vanilla Object or an Immutable Map.
	 * You should override the column's cellDataGetter if your data is some other type of object.
	 */
	var babelPluginFlowReactPropTypes_proptype_CellDataGetterParams = __webpack_require__(86).babelPluginFlowReactPropTypes_proptype_CellDataGetterParams || __webpack_require__(1).any;
	
	function defaultCellDataGetter(_ref) {
	  var dataKey = _ref.dataKey,
	      rowData = _ref.rowData;
	
	  if (typeof rowData.get === 'function') {
	    return rowData.get(dataKey);
	  } else {
	    return rowData[dataKey];
	  }
	}

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultCellRenderer;
	
	/**
	 * Default cell renderer that displays an attribute as a simple string
	 * You should override the column's cellRenderer if your data is some other type of object.
	 */
	var babelPluginFlowReactPropTypes_proptype_CellRendererParams = __webpack_require__(86).babelPluginFlowReactPropTypes_proptype_CellRendererParams || __webpack_require__(1).any;
	
	function defaultCellRenderer(_ref) {
	  var cellData = _ref.cellData;
	
	  if (cellData == null) {
	    return '';
	  } else {
	    return String(cellData);
	  }
	}

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultHeaderRenderer;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _SortIndicator = __webpack_require__(339);
	
	var _SortIndicator2 = _interopRequireDefault(_SortIndicator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Default table header renderer.
	 */
	var babelPluginFlowReactPropTypes_proptype_HeaderRendererParams = __webpack_require__(86).babelPluginFlowReactPropTypes_proptype_HeaderRendererParams || __webpack_require__(1).any;
	
	function defaultHeaderRenderer(_ref) {
	  var dataKey = _ref.dataKey,
	      label = _ref.label,
	      sortBy = _ref.sortBy,
	      sortDirection = _ref.sortDirection;
	
	  var showSortIndicator = sortBy === dataKey;
	  var children = [_react2.default.createElement(
	    'span',
	    {
	      className: 'ReactVirtualized__Table__headerTruncatedText',
	      key: 'label',
	      title: label },
	    label
	  )];
	
	  if (showSortIndicator) {
	    children.push(_react2.default.createElement(_SortIndicator2.default, { key: 'SortIndicator', sortDirection: sortDirection }));
	  }
	
	  return children;
	}
	defaultHeaderRenderer.propTypes = babelPluginFlowReactPropTypes_proptype_HeaderRendererParams === __webpack_require__(1).any ? {} : babelPluginFlowReactPropTypes_proptype_HeaderRendererParams;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultHeaderRowRenderer;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams = __webpack_require__(86).babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams || __webpack_require__(1).any;
	
	function defaultHeaderRowRenderer(_ref) {
	  var className = _ref.className,
	      columns = _ref.columns,
	      style = _ref.style;
	
	  return _react2.default.createElement(
	    'div',
	    { className: className, role: 'row', style: style },
	    columns
	  );
	}
	defaultHeaderRowRenderer.propTypes = babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams === __webpack_require__(1).any ? {} : babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams;

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = defaultRowRenderer;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Default row renderer for Table.
	 */
	var babelPluginFlowReactPropTypes_proptype_RowRendererParams = __webpack_require__(86).babelPluginFlowReactPropTypes_proptype_RowRendererParams || __webpack_require__(1).any;
	
	function defaultRowRenderer(_ref) {
	  var className = _ref.className,
	      columns = _ref.columns,
	      index = _ref.index,
	      key = _ref.key,
	      onRowClick = _ref.onRowClick,
	      onRowDoubleClick = _ref.onRowDoubleClick,
	      onRowMouseOut = _ref.onRowMouseOut,
	      onRowMouseOver = _ref.onRowMouseOver,
	      onRowRightClick = _ref.onRowRightClick,
	      rowData = _ref.rowData,
	      style = _ref.style;
	
	  var a11yProps = {};
	
	  if (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) {
	    a11yProps['aria-label'] = 'row';
	    a11yProps.tabIndex = 0;
	
	    if (onRowClick) {
	      a11yProps.onClick = function (event) {
	        return onRowClick({ event: event, index: index, rowData: rowData });
	      };
	    }
	    if (onRowDoubleClick) {
	      a11yProps.onDoubleClick = function (event) {
	        return onRowDoubleClick({ event: event, index: index, rowData: rowData });
	      };
	    }
	    if (onRowMouseOut) {
	      a11yProps.onMouseOut = function (event) {
	        return onRowMouseOut({ event: event, index: index, rowData: rowData });
	      };
	    }
	    if (onRowMouseOver) {
	      a11yProps.onMouseOver = function (event) {
	        return onRowMouseOver({ event: event, index: index, rowData: rowData });
	      };
	    }
	    if (onRowRightClick) {
	      a11yProps.onContextMenu = function (event) {
	        return onRowRightClick({ event: event, index: index, rowData: rowData });
	      };
	    }
	  }
	
	  return _react2.default.createElement(
	    'div',
	    _extends({}, a11yProps, {
	      className: className,
	      key: key,
	      role: 'row',
	      style: style }),
	    columns
	  );
	}
	defaultRowRenderer.propTypes = babelPluginFlowReactPropTypes_proptype_RowRendererParams === __webpack_require__(1).any ? {} : babelPluginFlowReactPropTypes_proptype_RowRendererParams;

/***/ }),
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var c = __webpack_require__(68);
	module.exports = cpp;
	cpp.displayName = 'cpp';
	cpp.aliases = [];
	function cpp(Prism) {
	  Prism.register(c);
	  Prism.languages.cpp = Prism.languages.extend('c', {
	    keyword: /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
	    boolean: /\b(?:true|false)\b/,
	    operator: /--?|\+\+?|!=?|<{1,2}=?|>{1,2}=?|->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|\|?|\?|\*|\/|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
	  });
	  Prism.languages.insertBefore('cpp', 'keyword', {
	    'class-name': {
	      pattern: /(class\s+)\w+/i,
	      lookbehind: true
	    }
	  });
	}


/***/ }),
/* 351 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = java;
	java.displayName = 'java';
	java.aliases = [];
	function java(Prism) {
	  Prism.languages.java = Prism.languages.extend('clike', {
	    keyword: /\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
	    number: /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
	    operator: {
	      pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
	      lookbehind: true
	    }
	  });
	  Prism.languages.insertBefore('java', 'function', {
	    annotation: {
	      alias: 'punctuation',
	      pattern: /(^|[^.])@\w+/,
	      lookbehind: true
	    }
	  });
	}


/***/ }),
/* 352 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = ruby;
	ruby.displayName = 'ruby';
	ruby.aliases = [];
	function ruby(Prism) {
	  /**
	   * Original by Samuel Flores
	   *
	   * Adds the following new token classes:
	   *      constant, builtin, variable, symbol, regex
	   */
	  (function(Prism) {
	    Prism.languages.ruby = Prism.languages.extend('clike', {
	      comment: [
	        /#(?!\{[^\r\n]*?\}).*/,
	        /^=begin(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?=end/m
	      ],
	      keyword: /\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
	    });
	    var interpolation = {
	      pattern: /#\{[^}]+\}/,
	      inside: {
	        delimiter: {
	          pattern: /^#\{|\}$/,
	          alias: 'tag'
	        },
	        rest: Prism.util.clone(Prism.languages.ruby)
	      }
	    };
	    Prism.languages.insertBefore('ruby', 'keyword', {
	      regex: [
	        {
	          pattern: /%r([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1[gim]{0,3}/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        },
	        {
	          pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        },
	        {
	          // Here we need to specifically allow interpolation
	          pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        },
	        {
	          pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        },
	        {
	          pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        },
	        {
	          pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
	      symbol: /:[a-zA-Z_]\w*(?:[?!]|\b)/
	    });
	    Prism.languages.insertBefore('ruby', 'number', {
	      builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
	      constant: /\b[A-Z]\w*(?:[?!]|\b)/
	    });
	    Prism.languages.ruby.string = [
	      {
	        pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      },
	      {
	        pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      },
	      {
	        // Here we need to specifically allow interpolation
	        pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      },
	      {
	        pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      },
	      {
	        pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      },
	      {
	        pattern: /("|')(?:#\{[^}]+\}|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	        greedy: true,
	        inside: {
	          interpolation: interpolation
	        }
	      }
	    ];
	  })(Prism);
	}


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  position: true,
	  gfm: true,
	  commonmark: false,
	  footnotes: false,
	  pedantic: false,
	  blocks: __webpack_require__(662)
	};


/***/ }),
/* 354 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  var link = value.indexOf('[', fromIndex);
	  var image = value.indexOf('![', fromIndex);
	
	  if (image === -1) {
	    return link;
	  }
	
	  /* Link can never be `-1` if an image is found, so we don’t need
	   * to check for that :) */
	  return link < image ? link : image;
	}


/***/ }),
/* 355 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  return value.indexOf('<', fromIndex);
	}


/***/ }),
/* 356 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = indentation;
	
	/* Map of characters, and their column length,
	 * which can be used as indentation. */
	var characters = {' ': 1, '\t': 4};
	
	/* Gets indentation information for a line. */
	function indentation(value) {
	  var index = 0;
	  var indent = 0;
	  var character = value.charAt(index);
	  var stops = {};
	  var size;
	
	  while (character in characters) {
	    size = characters[character];
	
	    indent += size;
	
	    if (size > 1) {
	      indent = Math.floor(indent / size) * size;
	    }
	
	    stops[indent] = index;
	
	    character = value.charAt(++index);
	  }
	
	  return {indent: indent, stops: stops};
	}


/***/ }),
/* 357 */
/***/ (function(module, exports) {

	'use strict';
	
	var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
	var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
	var singleQuoted = '\'[^\']*\'';
	var doubleQuoted = '"[^"]*"';
	var attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';
	var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
	var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
	var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
	var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
	var processing = '<[?].*?[?]>';
	var declaration = '<![A-Za-z]+\\s+[^>]*>';
	var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
	
	exports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');
	
	exports.tag = new RegExp('^(?:' +
	  openTag + '|' +
	  closeTag + '|' +
	  comment + '|' +
	  processing + '|' +
	  declaration + '|' +
	  cdata +
	')');


/***/ }),
/* 358 */
/***/ (function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(203);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 360 */
/***/ (function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 361 */
/***/ (function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;(function() {
	  "use strict";
	
	function immutableInit(config) {
	
	  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L21
	  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element');
	  var REACT_ELEMENT_TYPE_FALLBACK = 0xeac7;
	
	  var globalConfig = {
	    use_static: false
	  };
	  if (isObject(config)) {
	      if (config.use_static !== undefined) {
	          globalConfig.use_static = Boolean(config.use_static);
	      }
	  }
	
	  function isObject(data) {
	    return (
	      typeof data === 'object' &&
	      !Array.isArray(data) &&
	      data !== null
	    );
	  }
	
	  function instantiateEmptyObject(obj) {
	      var prototype = Object.getPrototypeOf(obj);
	      if (!prototype) {
	          return {};
	      } else {
	          return Object.create(prototype);
	      }
	  }
	
	  function addPropertyTo(target, methodName, value) {
	    Object.defineProperty(target, methodName, {
	      enumerable: false,
	      configurable: false,
	      writable: false,
	      value: value
	    });
	  }
	
	  function banProperty(target, methodName) {
	    addPropertyTo(target, methodName, function() {
	      throw new ImmutableError("The " + methodName +
	        " method cannot be invoked on an Immutable data structure.");
	    });
	  }
	
	  var immutabilityTag = "__immutable_invariants_hold";
	
	  function addImmutabilityTag(target) {
	    addPropertyTo(target, immutabilityTag, true);
	  }
	
	  function isImmutable(target) {
	    if (typeof target === "object") {
	      return target === null || Boolean(
	        Object.getOwnPropertyDescriptor(target, immutabilityTag)
	      );
	    } else {
	      // In JavaScript, only objects are even potentially mutable.
	      // strings, numbers, null, and undefined are all naturally immutable.
	      return true;
	    }
	  }
	
	  function isEqual(a, b) {
	    // Avoid false positives due to (NaN !== NaN) evaluating to true
	    return (a === b || (a !== a && b !== b));
	  }
	
	  function isMergableObject(target) {
	    return target !== null && typeof target === "object" && !(Array.isArray(target)) && !(target instanceof Date);
	  }
	
	  var mutatingObjectMethods = [
	    "setPrototypeOf"
	  ];
	
	  var nonMutatingObjectMethods = [
	    "keys"
	  ];
	
	  var mutatingArrayMethods = mutatingObjectMethods.concat([
	    "push", "pop", "sort", "splice", "shift", "unshift", "reverse"
	  ]);
	
	  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([
	    "map", "filter", "slice", "concat", "reduce", "reduceRight"
	  ]);
	
	  var mutatingDateMethods = mutatingObjectMethods.concat([
	    "setDate", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setSeconds",
	    "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes",
	    "setUTCMonth", "setUTCSeconds", "setYear"
	  ]);
	
	  function ImmutableError(message) {
	    this.name = 'MyError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	  }
	  ImmutableError.prototype = new Error();
	  ImmutableError.prototype.constructor = Error;
	
	  function makeImmutable(obj, bannedMethods) {
	    // Tag it so we can quickly tell it's immutable later.
	    addImmutabilityTag(obj);
	
	    if (true) {
	      // Make all mutating methods throw exceptions.
	      for (var index in bannedMethods) {
	        if (bannedMethods.hasOwnProperty(index)) {
	          banProperty(obj, bannedMethods[index]);
	        }
	      }
	
	      // Freeze it and return it.
	      Object.freeze(obj);
	    }
	
	    return obj;
	  }
	
	  function makeMethodReturnImmutable(obj, methodName) {
	    var currentMethod = obj[methodName];
	
	    addPropertyTo(obj, methodName, function() {
	      return Immutable(currentMethod.apply(obj, arguments));
	    });
	  }
	
	  function arraySet(idx, value, config) {
	    var deep          = config && config.deep;
	
	    if (idx in this) {
	      if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {
	        value = Immutable.merge(this[idx], value, {deep: true, mode: 'replace'});
	      }
	      if (isEqual(this[idx], value)) {
	        return this;
	      }
	    }
	
	    var mutable = asMutableArray.call(this);
	    mutable[idx] = Immutable(value);
	    return makeImmutableArray(mutable);
	  }
	
	  var immutableEmptyArray = Immutable([]);
	
	  function arraySetIn(pth, value, config) {
	    var head = pth[0];
	
	    if (pth.length === 1) {
	      return arraySet.call(this, head, value, config);
	    } else {
	      var tail = pth.slice(1);
	      var thisHead = this[head];
	      var newValue;
	
	      if (typeof(thisHead) === "object" && thisHead !== null) {
	        // Might (validly) be object or array
	        newValue = Immutable.setIn(thisHead, tail, value);
	      } else {
	        var nextHead = tail[0];
	        // If the next path part is a number, then we are setting into an array, else an object.
	        if (nextHead !== '' && isFinite(nextHead)) {
	          newValue = arraySetIn.call(immutableEmptyArray, tail, value);
	        } else {
	          newValue = objectSetIn.call(immutableEmptyObject, tail, value);
	        }
	      }
	
	      if (head in this && thisHead === newValue) {
	        return this;
	      }
	
	      var mutable = asMutableArray.call(this);
	      mutable[head] = newValue;
	      return makeImmutableArray(mutable);
	    }
	  }
	
	  function makeImmutableArray(array) {
	    // Don't change their implementations, but wrap these functions to make sure
	    // they always return an immutable value.
	    for (var index in nonMutatingArrayMethods) {
	      if (nonMutatingArrayMethods.hasOwnProperty(index)) {
	        var methodName = nonMutatingArrayMethods[index];
	        makeMethodReturnImmutable(array, methodName);
	      }
	    }
	
	    if (!globalConfig.use_static) {
	      addPropertyTo(array, "flatMap",  flatMap);
	      addPropertyTo(array, "asObject", asObject);
	      addPropertyTo(array, "asMutable", asMutableArray);
	      addPropertyTo(array, "set", arraySet);
	      addPropertyTo(array, "setIn", arraySetIn);
	      addPropertyTo(array, "update", update);
	      addPropertyTo(array, "updateIn", updateIn);
	      addPropertyTo(array, "getIn", getIn);
	    }
	
	    for(var i = 0, length = array.length; i < length; i++) {
	      array[i] = Immutable(array[i]);
	    }
	
	    return makeImmutable(array, mutatingArrayMethods);
	  }
	
	  function makeImmutableDate(date) {
	    if (!globalConfig.use_static) {
	      addPropertyTo(date, "asMutable", asMutableDate);
	    }
	
	    return makeImmutable(date, mutatingDateMethods);
	  }
	
	  function asMutableDate() {
	    return new Date(this.getTime());
	  }
	
	  /**
	   * Effectively performs a map() over the elements in the array, using the
	   * provided iterator, except that whenever the iterator returns an array, that
	   * array's elements are added to the final result instead of the array itself.
	   *
	   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.
	   */
	  function flatMap(iterator) {
	    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.
	    if (arguments.length === 0) {
	      return this;
	    }
	
	    var result = [],
	        length = this.length,
	        index;
	
	    for (index = 0; index < length; index++) {
	      var iteratorResult = iterator(this[index], index, this);
	
	      if (Array.isArray(iteratorResult)) {
	        // Concatenate Array results into the return value we're building up.
	        result.push.apply(result, iteratorResult);
	      } else {
	        // Handle non-Array results the same way map() does.
	        result.push(iteratorResult);
	      }
	    }
	
	    return makeImmutableArray(result);
	  }
	
	  /**
	   * Returns an Immutable copy of the object without the given keys included.
	   *
	   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.
	   */
	  function without(remove) {
	    // Calling .without() with no arguments is a no-op. Don't bother cloning.
	    if (typeof remove === "undefined" && arguments.length === 0) {
	      return this;
	    }
	
	    if (typeof remove !== "function") {
	      // If we weren't given an array, use the arguments list.
	      var keysToRemoveArray = (Array.isArray(remove)) ?
	         remove.slice() : Array.prototype.slice.call(arguments);
	
	      // Convert numeric keys to strings since that's how they'll
	      // come from the enumeration of the object.
	      keysToRemoveArray.forEach(function(el, idx, arr) {
	        if(typeof(el) === "number") {
	          arr[idx] = el.toString();
	        }
	      });
	
	      remove = function(val, key) {
	        return keysToRemoveArray.indexOf(key) !== -1;
	      };
	    }
	
	    var result = instantiateEmptyObject(this);
	
	    for (var key in this) {
	      if (this.hasOwnProperty(key) && remove(this[key], key) === false) {
	        result[key] = this[key];
	      }
	    }
	
	    return makeImmutableObject(result);
	  }
	
	  function asMutableArray(opts) {
	    var result = [], i, length;
	
	    if(opts && opts.deep) {
	      for(i = 0, length = this.length; i < length; i++) {
	        result.push(asDeepMutable(this[i]));
	      }
	    } else {
	      for(i = 0, length = this.length; i < length; i++) {
	        result.push(this[i]);
	      }
	    }
	
	    return result;
	  }
	
	  /**
	   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function
	   * will return an array of two elements - the first representing a key, the other
	   * a value. Then returns an Immutable Object constructed of those keys and values.
	   *
	   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.
	   */
	  function asObject(iterator) {
	    // If no iterator was provided, assume the identity function
	    // (suggesting this array is already a list of key/value pairs.)
	    if (typeof iterator !== "function") {
	      iterator = function(value) { return value; };
	    }
	
	    var result = {},
	        length = this.length,
	        index;
	
	    for (index = 0; index < length; index++) {
	      var pair  = iterator(this[index], index, this),
	          key   = pair[0],
	          value = pair[1];
	
	      result[key] = value;
	    }
	
	    return makeImmutableObject(result);
	  }
	
	  function asDeepMutable(obj) {
	    if (
	      (!obj) ||
	      (typeof obj !== 'object') ||
	      (!Object.getOwnPropertyDescriptor(obj, immutabilityTag)) ||
	      (obj instanceof Date)
	    ) { return obj; }
	    return Immutable.asMutable(obj, {deep: true});
	  }
	
	  function quickCopy(src, dest) {
	    for (var key in src) {
	      if (Object.getOwnPropertyDescriptor(src, key)) {
	        dest[key] = src[key];
	      }
	    }
	
	    return dest;
	  }
	
	  /**
	   * Returns an Immutable Object containing the properties and values of both
	   * this object and the provided object, prioritizing the provided object's
	   * values whenever the same key is present in both objects.
	   *
	   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.
	   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function
	   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.
	   */
	  function merge(other, config) {
	    // Calling .merge() with no arguments is a no-op. Don't bother cloning.
	    if (arguments.length === 0) {
	      return this;
	    }
	
	    if (other === null || (typeof other !== "object")) {
	      throw new TypeError("Immutable#merge can only be invoked with objects or arrays, not " + JSON.stringify(other));
	    }
	
	    var receivedArray = (Array.isArray(other)),
	        deep          = config && config.deep,
	        mode          = config && config.mode || 'merge',
	        merger        = config && config.merger,
	        result;
	
	    // Use the given key to extract a value from the given object, then place
	    // that value in the result object under the same key. If that resulted
	    // in a change from this object's value at that key, set anyChanges = true.
	    function addToResult(currentObj, otherObj, key) {
	      var immutableValue = Immutable(otherObj[key]);
	      var mergerResult = merger && merger(currentObj[key], immutableValue, config);
	      var currentValue = currentObj[key];
	
	      if ((result !== undefined) ||
	        (mergerResult !== undefined) ||
	        (!currentObj.hasOwnProperty(key)) ||
	        !isEqual(immutableValue, currentValue)) {
	
	        var newValue;
	
	        if (mergerResult) {
	          newValue = mergerResult;
	        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {
	          newValue = Immutable.merge(currentValue, immutableValue, config);
	        } else {
	          newValue = immutableValue;
	        }
	
	        if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key)) {
	          if (result === undefined) {
	            // Make a shallow clone of the current object.
	            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
	          }
	
	          result[key] = newValue;
	        }
	      }
	    }
	
	    function clearDroppedKeys(currentObj, otherObj) {
	      for (var key in currentObj) {
	        if (!otherObj.hasOwnProperty(key)) {
	          if (result === undefined) {
	            // Make a shallow clone of the current object.
	            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
	          }
	          delete result[key];
	        }
	      }
	    }
	
	    var key;
	
	    // Achieve prioritization by overriding previous values that get in the way.
	    if (!receivedArray) {
	      // The most common use case: just merge one object into the existing one.
	      for (key in other) {
	        if (Object.getOwnPropertyDescriptor(other, key)) {
	          addToResult(this, other, key);
	        }
	      }
	      if (mode === 'replace') {
	        clearDroppedKeys(this, other);
	      }
	    } else {
	      // We also accept an Array
	      for (var index = 0, length = other.length; index < length; index++) {
	        var otherFromArray = other[index];
	
	        for (key in otherFromArray) {
	          if (otherFromArray.hasOwnProperty(key)) {
	            addToResult(result !== undefined ? result : this, otherFromArray, key);
	          }
	        }
	      }
	    }
	
	    if (result === undefined) {
	      return this;
	    } else {
	      return makeImmutableObject(result);
	    }
	  }
	
	  function objectReplace(value, config) {
	    var deep          = config && config.deep;
	
	    // Calling .replace() with no arguments is a no-op. Don't bother cloning.
	    if (arguments.length === 0) {
	      return this;
	    }
	
	    if (value === null || typeof value !== "object") {
	      throw new TypeError("Immutable#replace can only be invoked with objects or arrays, not " + JSON.stringify(value));
	    }
	
	    return Immutable.merge(this, value, {deep: deep, mode: 'replace'});
	  }
	
	  var immutableEmptyObject = Immutable({});
	
	  function objectSetIn(path, value, config) {
	    if (!(path instanceof Array) || path.length === 0) {
	      throw new TypeError("The first argument to Immutable#setIn must be an array containing at least one \"key\" string.");
	    }
	
	    var head = path[0];
	    if (path.length === 1) {
	      return objectSet.call(this, head, value, config);
	    }
	
	    var tail = path.slice(1);
	    var newValue;
	    var thisHead = this[head];
	
	    if (this.hasOwnProperty(head) && typeof(thisHead) === "object" && thisHead !== null) {
	      // Might (validly) be object or array
	      newValue = Immutable.setIn(thisHead, tail, value);
	    } else {
	      newValue = objectSetIn.call(immutableEmptyObject, tail, value);
	    }
	
	    if (this.hasOwnProperty(head) && thisHead === newValue) {
	      return this;
	    }
	
	    var mutable = quickCopy(this, instantiateEmptyObject(this));
	    mutable[head] = newValue;
	    return makeImmutableObject(mutable);
	  }
	
	  function objectSet(property, value, config) {
	    var deep          = config && config.deep;
	
	    if (this.hasOwnProperty(property)) {
	      if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {
	        value = Immutable.merge(this[property], value, {deep: true, mode: 'replace'});
	      }
	      if (isEqual(this[property], value)) {
	        return this;
	      }
	    }
	
	    var mutable = quickCopy(this, instantiateEmptyObject(this));
	    mutable[property] = Immutable(value);
	    return makeImmutableObject(mutable);
	  }
	
	  function update(property, updater) {
	    var restArgs = Array.prototype.slice.call(arguments, 2);
	    var initialVal = this[property];
	    return Immutable.set(this, property, updater.apply(initialVal, [initialVal].concat(restArgs)));
	  }
	
	  function getInPath(obj, path) {
	    /*jshint eqnull:true */
	    for (var i = 0, l = path.length; obj != null && i < l; i++) {
	      obj = obj[path[i]];
	    }
	
	    return (i && i == l) ? obj : undefined;
	  }
	
	  function updateIn(path, updater) {
	    var restArgs = Array.prototype.slice.call(arguments, 2);
	    var initialVal = getInPath(this, path);
	
	    return Immutable.setIn(this, path, updater.apply(initialVal, [initialVal].concat(restArgs)));
	  }
	
	  function getIn(path, defaultValue) {
	    var value = getInPath(this, path);
	    return value === undefined ? defaultValue : value;
	  }
	
	  function asMutableObject(opts) {
	    var result = instantiateEmptyObject(this), key;
	
	    if(opts && opts.deep) {
	      for (key in this) {
	        if (this.hasOwnProperty(key)) {
	          result[key] = asDeepMutable(this[key]);
	        }
	      }
	    } else {
	      for (key in this) {
	        if (this.hasOwnProperty(key)) {
	          result[key] = this[key];
	        }
	      }
	    }
	
	    return result;
	  }
	
	  // Creates plain object to be used for cloning
	  function instantiatePlainObject() {
	    return {};
	  }
	
	  // Finalizes an object with immutable methods, freezes it, and returns it.
	  function makeImmutableObject(obj) {
	    if (!globalConfig.use_static) {
	      addPropertyTo(obj, "merge", merge);
	      addPropertyTo(obj, "replace", objectReplace);
	      addPropertyTo(obj, "without", without);
	      addPropertyTo(obj, "asMutable", asMutableObject);
	      addPropertyTo(obj, "set", objectSet);
	      addPropertyTo(obj, "setIn", objectSetIn);
	      addPropertyTo(obj, "update", update);
	      addPropertyTo(obj, "updateIn", updateIn);
	      addPropertyTo(obj, "getIn", getIn);
	    }
	
	    return makeImmutable(obj, mutatingObjectMethods);
	  }
	
	  // Returns true if object is a valid react element
	  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L326
	  function isReactElement(obj) {
	    return typeof obj === 'object' &&
	           obj !== null &&
	           (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);
	  }
	
	  function isFileObject(obj) {
	    return typeof File !== 'undefined' &&
	           obj instanceof File;
	  }
	
	  function isPromise(obj) {
	    return typeof obj === 'object' &&
	           typeof obj.then === 'function';
	  }
	
	  function isError(obj) {
	    return obj instanceof Error;
	  }
	
	  function Immutable(obj, options, stackRemaining) {
	    if (isImmutable(obj) || isReactElement(obj) || isFileObject(obj) || isError(obj)) {
	      return obj;
	    } else if (isPromise(obj)) {
	      return obj.then(Immutable);
	    } else if (Array.isArray(obj)) {
	      return makeImmutableArray(obj.slice());
	    } else if (obj instanceof Date) {
	      return makeImmutableDate(new Date(obj.getTime()));
	    } else {
	      // Don't freeze the object we were given; make a clone and use that.
	      var prototype = options && options.prototype;
	      var instantiateEmptyObject =
	        (!prototype || prototype === Object.prototype) ?
	          instantiatePlainObject : (function() { return Object.create(prototype); });
	      var clone = instantiateEmptyObject();
	
	      if (true) {
	        /*jshint eqnull:true */
	        if (stackRemaining == null) {
	          stackRemaining = 64;
	        }
	        if (stackRemaining <= 0) {
	          throw new ImmutableError("Attempt to construct Immutable from a deeply nested object was detected." +
	            " Have you tried to wrap an object with circular references (e.g. React element)?" +
	            " See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.");
	        }
	        stackRemaining -= 1;
	      }
	
	      for (var key in obj) {
	        if (Object.getOwnPropertyDescriptor(obj, key)) {
	          clone[key] = Immutable(obj[key], undefined, stackRemaining);
	        }
	      }
	
	      return makeImmutableObject(clone);
	    }
	  }
	
	  // Wrapper to allow the use of object methods as static methods of Immutable.
	  function toStatic(fn) {
	    function staticWrapper() {
	      var args = [].slice.call(arguments);
	      var self = args.shift();
	      return fn.apply(self, args);
	    }
	
	    return staticWrapper;
	  }
	
	  // Wrapper to allow the use of object methods as static methods of Immutable.
	  // with the additional condition of choosing which function to call depending
	  // if argument is an array or an object.
	  function toStaticObjectOrArray(fnObject, fnArray) {
	    function staticWrapper() {
	      var args = [].slice.call(arguments);
	      var self = args.shift();
	      if (Array.isArray(self)) {
	          return fnArray.apply(self, args);
	      } else {
	          return fnObject.apply(self, args);
	      }
	    }
	
	    return staticWrapper;
	  }
	
	  // Wrapper to allow the use of object methods as static methods of Immutable.
	  // with the additional condition of choosing which function to call depending
	  // if argument is an array or an object or a date.
	  function toStaticObjectOrDateOrArray(fnObject, fnArray, fnDate) {
	    function staticWrapper() {
	      var args = [].slice.call(arguments);
	      var self = args.shift();
	      if (Array.isArray(self)) {
	          return fnArray.apply(self, args);
	      } else if (self instanceof Date) {
	          return fnDate.apply(self, args);
	      } else {
	          return fnObject.apply(self, args);
	      }
	    }
	
	    return staticWrapper;
	  }
	
	  // Export the library
	  Immutable.from           = Immutable;
	  Immutable.isImmutable    = isImmutable;
	  Immutable.ImmutableError = ImmutableError;
	  Immutable.merge          = toStatic(merge);
	  Immutable.replace        = toStatic(objectReplace);
	  Immutable.without        = toStatic(without);
	  Immutable.asMutable      = toStaticObjectOrDateOrArray(asMutableObject, asMutableArray, asMutableDate);
	  Immutable.set            = toStaticObjectOrArray(objectSet, arraySet);
	  Immutable.setIn          = toStaticObjectOrArray(objectSetIn, arraySetIn);
	  Immutable.update         = toStatic(update);
	  Immutable.updateIn       = toStatic(updateIn);
	  Immutable.getIn          = toStatic(getIn);
	  Immutable.flatMap        = toStatic(flatMap);
	  Immutable.asObject       = toStatic(asObject);
	  if (!globalConfig.use_static) {
	      Immutable.static = immutableInit({
	          use_static: true
	      });
	  }
	
	  Object.freeze(Immutable);
	
	  return Immutable;
	}
	
	  var Immutable = immutableInit();
	  /* istanbul ignore if */
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return Immutable;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof module === "object") {
	    module.exports = Immutable;
	  } else if (typeof exports === "object") {
	    exports.Immutable = Immutable;
	  } else if (typeof window === "object") {
	    window.Immutable = Immutable;
	  } else if (typeof global === "object") {
	    global.Immutable = Immutable;
	  }
	})();


/***/ }),
/* 363 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4IiB2aWV3Qm94PSIxMTggMTIgMTYgMTYiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8cG9seWdvbgogICAgICAgIHBvaW50cz0iMTI2IDI0IDEyMS4yOTc3MTggMjYuNDcyMTM2IDEyMi4xOTU3NzQgMjEuMjM2MDY4IDExOC4zOTE1NDggMTcuNTI3ODY0IDEyMy42NDg4NTkgMTYuNzYzOTMyIDEyNiAxMiAxMjguMzUxMTQxIDE2Ljc2MzkzMiAxMzMuNjA4NDUyIDE3LjUyNzg2NCAxMjkuODA0MjI2IDIxLjIzNjA2OCAxMzAuNzAyMjgyIDI2LjQ3MjEzNiIKICAgID48L3BvbHlnb24+Cjwvc3ZnPg=="

/***/ }),
/* 364 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjxzdmcgIHdpZHRoPSI1MHB4IiBoZWlnaHQ9IjUwcHgiIHZpZXdCb3g9IjAgMCA1MCA1MCIgPg0KCTxsaW5lIHgxPSIyNSIgeTE9IjEzLjEiIHgyPSIyNSIgeTI9IjM2LjkiLz4NCgk8bGluZSB4MT0iMzYuOSIgeTE9IjI1IiB4Mj0iMTMuMSIgeTI9IjI1Ii8+DQo8L3N2Zz4NCg=="

/***/ }),
/* 365 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjxzdmcgd2lkdGg9IjUwcHgiIGhlaWdodD0iNTBweCIgdmlld0JveD0iMCAwIDUwIDUwIj4NCgk8bGluZSB4MT0iNCIgeTE9IjQiIHgyPSI0NiIgeTI9IjQ2Ii8+DQoJPGxpbmUgeDE9IjQ2IiB5MT0iNCIgeDI9IjQiIHkyPSI0NiIvPg0KPC9zdmc+DQo="

/***/ }),
/* 366 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iNTBweCIgaGVpZ2h0PSI1MHB4IiB2aWV3Qm94PSIwIDAgNTAgNTAiPgo8cG9seWxpbmUgcG9pbnRzPSI0LjMzLDE5LjY0IDkuNywyNy42OSAxNS45NSwyMC41NCAiLz4KPHBhdGggZD0iTTkuNzEsMjcuNjlDOC4zNiwxNi44MSwxNi42OCw4LjM4LDI2LjA2LDguMDNjOS4zNy0wLjM1LDE3LjI1LDYuOTcsMTcuNiwxNi4zNQoJYzAuMzUsOS4zOC02Ljk3LDE3LjI2LTE2LjM1LDE3LjYiLz4KPHBvbHlsaW5lIHBvaW50cz0iMjYuNjgsMTYuMDYgMjYuNjgsMjUuODkgMzUuNjIsMjUuODkgIi8+Cjwvc3ZnPgo="

/***/ }),
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _prism = __webpack_require__(777);
	
	var _prism2 = _interopRequireDefault(_prism);
	
	var _prism3 = __webpack_require__(793);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (codeString) {
	  return _react2.default.createElement(
	    _prism2.default,
	    { language: 'javascript', style: _prism3.light },
	    codeString
	  );
	};
	
	module.exports = exports['default'];

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.query = undefined;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactMarkdown = __webpack_require__(748);
	
	var _reactMarkdown2 = _interopRequireDefault(_reactMarkdown);
	
	var _playground = __webpack_require__(380);
	
	var _playground2 = _interopRequireDefault(_playground);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (_ref) {
	  var data = _ref.data;
	
	  var post = data.markdownRemark;
	
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h1',
	      null,
	      post.frontmatter.title
	    ),
	    _react2.default.createElement(_reactMarkdown2.default, {
	      source: post.internal.content,
	      renderers: {
	        code: _playground2.default
	      },
	      allowNode: function allowNode(node, index, parent) {
	        if (!node.type === 'heading' || !node.value || !node.value.includes('title:')) {
	          // ensure not attribute
	          return true;
	        }
	      }
	    })
	  );
	};
	
	var query = exports.query = '** extracted graphql fragment **';

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _isomorphicFetch = __webpack_require__(173);
	
	var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);
	
	var _graphcoolGraphiql = __webpack_require__(587);
	
	var _frontMatter = __webpack_require__(515);
	
	var _frontMatter2 = _interopRequireDefault(_frontMatter);
	
	var _codeblock = __webpack_require__(378);
	
	var _codeblock2 = _interopRequireDefault(_codeblock);
	
	__webpack_require__(497);
	
	__webpack_require__(501);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function graphQLFetcher(graphQLParams) {
	  return (0, _isomorphicFetch2.default)(window.location.origin + '/___graphql', {
	    method: 'post',
	    headers: { 'Content-Type': 'application/json' },
	    body: JSON.stringify(graphQLParams)
	  }).then(function (response) {
	    return response.json();
	  });
	}
	
	function parseGraphqlStr(str) {
	  if (!str) return '';
	
	  var fm = (0, _frontMatter2.default)(str);
	
	  var _fm$body$split = fm.body.split('---'),
	      queryPart = _fm$body$split[0],
	      a = _fm$body$split[1],
	      b = _fm$body$split[2];
	
	  var dataPart = void 0;
	  var variablesPart = void 0;
	
	  if (b) {
	    dataPart = b;
	    variablesPart = a;
	  } else {
	    dataPart = a;
	  }
	
	  return {
	    data: dataPart.trim(),
	    disabled: fm.attributes.disabled || false,
	    endpoint: fm.attributes.endpoint,
	    query: queryPart.trim(),
	    variables: variablesPart ? variablesPart.trim() : null
	  };
	}
	
	var Playground = function (_React$Component) {
	  _inherits(Playground, _React$Component);
	
	  function Playground(props) {
	    _classCallCheck(this, Playground);
	
	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));
	
	    _this.handleEditQuery = function (query) {
	      return _this.setState({ query: query });
	    };
	
	    var isTypeGraphql = _this.props.language === 'graphql';
	
	    _this.state = {
	      // REQUIRED:
	      // `fetcher` must be provided in order for GraphiQL to operate
	      fetcher: graphQLFetcher,
	
	      // OPTIONAL PARAMETERS
	      // GraphQL artifacts
	      query: isTypeGraphql ? parseGraphqlStr(props.value).query : '',
	      variables: isTypeGraphql ? parseGraphqlStr(props.value).variables : '',
	      response: isTypeGraphql ? parseGraphqlStr(props.value).data : '',
	      defaultQuery: isTypeGraphql ? parseGraphqlStr(props.value).query : ''
	    };
	    return _this;
	  }
	
	  Playground.prototype.render = function render() {
	    if (this.props.language !== 'graphql') {
	      return (0, _codeblock2.default)(this.props.value);
	    }
	    return _react2.default.createElement(_graphcoolGraphiql.CustomGraphiQL, {
	      selectedEndpoint: this.props.selectedEndpoint || 'SIMPLE',
	      fetcher: graphQLFetcher,
	      query: this.state.query,
	      variables: this.state.variables,
	      onEditQuery: this.handleEditQuery,
	      disableAutofocus: true,
	      disableResize: true,
	      rerenderQuery: true
	    });
	  };
	
	  return Playground;
	}(_react2.default.Component);
	
	exports.default = Playground;
	module.exports = exports['default'];

/***/ }),
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */
/***/ (function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ }),
/* 388 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = bail;
	
	function bail(err) {
	  if (err) {
	    throw err;
	  }
	}


/***/ }),
/* 389 */
/***/ (function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return (b64.length * 3 / 4) - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr((len * 3 / 4) - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0; i < l; i += 4) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(389)
	var ieee754 = __webpack_require__(632)
	var isArray = __webpack_require__(296)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 391 */
/***/ (function(module, exports) {

	
	module.exports = function chain(){
	  var len = arguments.length
	  var args = [];
	
	  for (var i = 0; i < len; i++)
	    args[i] = arguments[i]
	
	  args = args.filter(function(fn){ return fn != null })
	
	  if (args.length === 0) return undefined
	  if (args.length === 1) return args[0]
	
	  return args.reduce(function(current, next){
	    return function chainedFunction() {
	      current.apply(this, arguments);
	      next.apply(this, arguments);
	    };
	  })
	}


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphqlLanguageServiceInterface = __webpack_require__(106);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Registers a "hint" helper for CodeMirror.
	 *
	 * Using CodeMirror's "hint" addon: https://codemirror.net/demo/complete.html
	 * Given an editor, this helper will take the token at the cursor and return a
	 * list of suggested tokens.
	 *
	 * Options:
	 *
	 *   - schema: GraphQLSchema provides the hinter with positionally relevant info
	 *
	 * Additional Events:
	 *
	 *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a
	 *     new list of completion suggestions.
	 *
	 */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	_codemirror2.default.registerHelper('hint', 'graphql', function (editor, options) {
	  var schema = options.schema;
	  if (!schema) {
	    return;
	  }
	
	  var cur = editor.getCursor();
	  var token = editor.getTokenAt(cur);
	  var rawResults = (0, _graphqlLanguageServiceInterface.getAutocompleteSuggestions)(schema, editor.getValue(), cur, token);
	  /**
	   * GraphQL language service responds to the autocompletion request with
	   * a different format:
	   * type CompletionItem = {
	   *   label: string,
	   *   kind?: number,
	   *   detail?: string,
	   *   documentation?: string,
	   *   // GraphQL Deprecation information
	   *   isDeprecated?: ?string,
	   *   deprecationReason?: ?string,
	   * };
	   *
	   * Switch to codemirror-compliant format before returning results.
	   */
	  var tokenStart = token.type !== null && /"|\w/.test(token.string[0]) ? token.start : token.end;
	  var results = {
	    list: rawResults.map(function (item) {
	      return {
	        text: item.label,
	        type: schema.getType(item.detail),
	        description: item.documentation,
	        isDeprecated: item.isDeprecated,
	        deprecationReason: item.deprecationReason
	      };
	    }),
	    from: { line: cur.line, column: tokenStart },
	    to: { line: cur.line, column: token.end }
	  };
	
	  if (results && results.list && results.list.length > 0) {
	    results.from = _codemirror2.default.Pos(results.from.line, results.from.column);
	    results.to = _codemirror2.default.Pos(results.to.line, results.to.column);
	    _codemirror2.default.signal(editor, 'hasCompletion', editor, results, token);
	  }
	
	  return results;
	});

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphqlLanguageServiceInterface = __webpack_require__(106);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	var SEVERITY = ['error', 'warning', 'information', 'hint'];
	var TYPE = {
	  'GraphQL: Validation': 'validation',
	  'GraphQL: Deprecation': 'deprecation',
	  'GraphQL: Syntax': 'syntax'
	};
	
	/**
	 * Registers a "lint" helper for CodeMirror.
	 *
	 * Using CodeMirror's "lint" addon: https://codemirror.net/demo/lint.html
	 * Given the text within an editor, this helper will take that text and return
	 * a list of linter issues, derived from GraphQL's parse and validate steps.
	 * Also, this uses `graphql-language-service-parser` to power the diagnostics
	 * service.
	 *
	 * Options:
	 *
	 *   - schema: GraphQLSchema provides the linter with positionally relevant info
	 *
	 */
	_codemirror2.default.registerHelper('lint', 'graphql', function (text, options) {
	  var schema = options.schema;
	  var rawResults = (0, _graphqlLanguageServiceInterface.getDiagnostics)(text, schema);
	
	  var results = rawResults.map(function (error) {
	    return {
	      message: error.message,
	      severity: SEVERITY[error.severity - 1],
	      type: TYPE[error.source],
	      from: _codemirror2.default.Pos(error.range.start.line, error.range.start.character),
	      to: _codemirror2.default.Pos(error.range.end.line, error.range.end.character)
	    };
	  });
	
	  return results;
	});

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphqlLanguageServiceParser = __webpack_require__(78);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The GraphQL mode is defined as a tokenizer along with a list of rules, each
	 * of which is either a function or an array.
	 *
	 *   * Function: Provided a token and the stream, returns an expected next step.
	 *   * Array: A list of steps to take in order.
	 *
	 * A step is either another rule, or a terminal description of a token. If it
	 * is a rule, that rule is pushed onto the stack and the parsing continues from
	 * that point.
	 *
	 * If it is a terminal description, the token is checked against it using a
	 * `match` function. If the match is successful, the token is colored and the
	 * rule is stepped forward. If the match is unsuccessful, the remainder of the
	 * rule is skipped and the previous rule is advanced.
	 *
	 * This parsing algorithm allows for incremental online parsing within various
	 * levels of the syntax tree and results in a structured `state` linked-list
	 * which contains the relevant information to produce valuable typeaheads.
	 */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	_codemirror2.default.defineMode('graphql', function (config) {
	  var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
	    eatWhitespace: function eatWhitespace(stream) {
	      return stream.eatWhile(_graphqlLanguageServiceParser.isIgnored);
	    },
	    lexRules: _graphqlLanguageServiceParser.LexRules,
	    parseRules: _graphqlLanguageServiceParser.ParseRules,
	    editorConfig: { tabSize: config.tabSize }
	  });
	
	  return {
	    config: config,
	    startState: parser.startState,
	    token: parser.token,
	    indent: indent,
	    electricInput: /^\s*[})\]]/,
	    fold: 'brace',
	    lineComment: '#',
	    closeBrackets: {
	      pairs: '()[]{}""',
	      explode: '()[]{}'
	    }
	  };
	});
	
	function indent(state, textAfter) {
	  var levels = state.levels;
	  // If there is no stack of levels, use the current level.
	  // Otherwise, use the top level, pre-emptively dedenting for close braces.
	  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);
	  return level * this.config.indentUnit;
	}

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphqlLanguageServiceParser = __webpack_require__(78);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This mode defines JSON, but provides a data-laden parser state to enable
	 * better code intelligence.
	 */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	_codemirror2.default.defineMode('graphql-results', function (config) {
	  var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
	    eatWhitespace: function eatWhitespace(stream) {
	      return stream.eatSpace();
	    },
	    lexRules: LexRules,
	    parseRules: ParseRules,
	    editorConfig: { tabSize: config.tabSize }
	  });
	
	  return {
	    config: config,
	    startState: parser.startState,
	    token: parser.token,
	    indent: indent,
	    electricInput: /^\s*[}\]]/,
	    fold: 'brace',
	    closeBrackets: {
	      pairs: '[]{}""',
	      explode: '[]{}'
	    }
	  };
	});
	
	function indent(state, textAfter) {
	  var levels = state.levels;
	  // If there is no stack of levels, use the current level.
	  // Otherwise, use the top level, pre-emptively dedenting for close braces.
	  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);
	  return level * this.config.indentUnit;
	}
	
	/**
	 * The lexer rules. These are exactly as described by the spec.
	 */
	var LexRules = {
	  // All Punctuation used in JSON.
	  Punctuation: /^\[|]|\{|\}|:|,/,
	
	  // JSON Number.
	  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
	
	  // JSON String.
	  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
	
	  // JSON literal keywords.
	  Keyword: /^true|false|null/
	};
	
	/**
	 * The parser rules for JSON.
	 */
	var ParseRules = {
	  Document: [(0, _graphqlLanguageServiceParser.p)('{'), (0, _graphqlLanguageServiceParser.list)('Entry', (0, _graphqlLanguageServiceParser.p)(',')), (0, _graphqlLanguageServiceParser.p)('}')],
	  Entry: [(0, _graphqlLanguageServiceParser.t)('String', 'def'), (0, _graphqlLanguageServiceParser.p)(':'), 'Value'],
	  Value: function Value(token) {
	    switch (token.kind) {
	      case 'Number':
	        return 'NumberValue';
	      case 'String':
	        return 'StringValue';
	      case 'Punctuation':
	        switch (token.value) {
	          case '[':
	            return 'ListValue';
	          case '{':
	            return 'ObjectValue';
	        }
	        return null;
	      case 'Keyword':
	        switch (token.value) {
	          case 'true':
	          case 'false':
	            return 'BooleanValue';
	          case 'null':
	            return 'NullValue';
	        }
	        return null;
	    }
	  },
	
	  NumberValue: [(0, _graphqlLanguageServiceParser.t)('Number', 'number')],
	  StringValue: [(0, _graphqlLanguageServiceParser.t)('String', 'string')],
	  BooleanValue: [(0, _graphqlLanguageServiceParser.t)('Keyword', 'builtin')],
	  NullValue: [(0, _graphqlLanguageServiceParser.t)('Keyword', 'keyword')],
	  ListValue: [(0, _graphqlLanguageServiceParser.p)('['), (0, _graphqlLanguageServiceParser.list)('Value', (0, _graphqlLanguageServiceParser.p)(',')), (0, _graphqlLanguageServiceParser.p)(']')],
	  ObjectValue: [(0, _graphqlLanguageServiceParser.p)('{'), (0, _graphqlLanguageServiceParser.list)('ObjectField', (0, _graphqlLanguageServiceParser.p)(',')), (0, _graphqlLanguageServiceParser.p)('}')],
	  ObjectField: [(0, _graphqlLanguageServiceParser.t)('String', 'property'), (0, _graphqlLanguageServiceParser.p)(':'), 'Value']
	};

/***/ }),
/* 396 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = forEachState;
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	// Utility for iterating through a CodeMirror parse state stack bottom-up.
	function forEachState(stack, fn) {
	  var reverseStateStack = [];
	  var state = stack;
	  while (state && state.kind) {
	    reverseStateStack.push(state);
	    state = state.prevState;
	  }
	  for (var i = reverseStateStack.length - 1; i >= 0; i--) {
	    fn(reverseStateStack[i]);
	  }
	}

/***/ }),
/* 397 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = hintList;
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	// Create the expected hint response given a possible list and a token
	function hintList(cursor, token, list) {
	  var hints = filterAndSortList(list, normalizeText(token.string));
	  if (!hints) {
	    return;
	  }
	
	  var tokenStart = token.type !== null && /"|\w/.test(token.string[0]) ? token.start : token.end;
	
	  return {
	    list: hints,
	    from: { line: cursor.line, column: tokenStart },
	    to: { line: cursor.line, column: token.end }
	  };
	}
	
	// Given a list of hint entries and currently typed text, sort and filter to
	// provide a concise list.
	function filterAndSortList(list, text) {
	  if (!text) {
	    return filterNonEmpty(list, function (entry) {
	      return !entry.isDeprecated;
	    });
	  }
	
	  var byProximity = list.map(function (entry) {
	    return {
	      proximity: getProximity(normalizeText(entry.text), text),
	      entry: entry
	    };
	  });
	
	  var conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, function (pair) {
	    return pair.proximity <= 2;
	  }), function (pair) {
	    return !pair.entry.isDeprecated;
	  });
	
	  var sortedMatches = conciseMatches.sort(function (a, b) {
	    return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;
	  });
	
	  return sortedMatches.map(function (pair) {
	    return pair.entry;
	  });
	}
	
	// Filters the array by the predicate, unless it results in an empty array,
	// in which case return the original array.
	function filterNonEmpty(array, predicate) {
	  var filtered = array.filter(predicate);
	  return filtered.length === 0 ? array : filtered;
	}
	
	function normalizeText(text) {
	  return text.toLowerCase().replace(/\W/g, '');
	}
	
	// Determine a numeric proximity for a suggestion based on current text.
	function getProximity(suggestion, text) {
	  // start with lexical distance
	  var proximity = lexicalDistance(text, suggestion);
	  if (suggestion.length > text.length) {
	    // do not penalize long suggestions.
	    proximity -= suggestion.length - text.length - 1;
	    // penalize suggestions not starting with this phrase
	    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
	  }
	  return proximity;
	}
	
	/**
	 * Computes the lexical distance between strings A and B.
	 *
	 * The "distance" between two strings is given by counting the minimum number
	 * of edits needed to transform string A into string B. An edit can be an
	 * insertion, deletion, or substitution of a single character, or a swap of two
	 * adjacent characters.
	 *
	 * This distance can be useful for detecting typos in input or sorting
	 *
	 * @param {string} a
	 * @param {string} b
	 * @return {int} distance in number of edits
	 */
	function lexicalDistance(a, b) {
	  var i = void 0;
	  var j = void 0;
	  var d = [];
	  var aLength = a.length;
	  var bLength = b.length;
	
	  for (i = 0; i <= aLength; i++) {
	    d[i] = [i];
	  }
	
	  for (j = 1; j <= bLength; j++) {
	    d[0][j] = j;
	  }
	
	  for (i = 1; i <= aLength; i++) {
	    for (j = 1; j <= bLength; j++) {
	      var cost = a[i - 1] === b[j - 1] ? 0 : 1;
	
	      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
	
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
	      }
	    }
	  }
	
	  return d[aLength][bLength];
	}

/***/ }),
/* 398 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = jsonParse;
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	/**
	 * This JSON parser simply walks the input, generating an AST. Use this in lieu
	 * of JSON.parse if you need character offset parse errors and an AST parse tree
	 * with location information.
	 *
	 * If an error is encountered, a SyntaxError will be thrown, with properties:
	 *
	 *   - message: string
	 *   - start: int - the start inclusive offset of the syntax error
	 *   - end: int - the end exclusive offset of the syntax error
	 *
	 */
	function jsonParse(str) {
	  string = str;
	  strLen = str.length;
	  start = end = lastEnd = -1;
	  ch();
	  lex();
	  var ast = parseObj();
	  expect('EOF');
	  return ast;
	}
	
	var string = void 0;
	var strLen = void 0;
	var start = void 0;
	var end = void 0;
	var lastEnd = void 0;
	var code = void 0;
	var kind = void 0;
	
	function parseObj() {
	  var nodeStart = start;
	  var members = [];
	  expect('{');
	  if (!skip('}')) {
	    do {
	      members.push(parseMember());
	    } while (skip(','));
	    expect('}');
	  }
	  return {
	    kind: 'Object',
	    start: nodeStart,
	    end: lastEnd,
	    members: members
	  };
	}
	
	function parseMember() {
	  var nodeStart = start;
	  var key = kind === 'String' ? curToken() : null;
	  expect('String');
	  expect(':');
	  var value = parseVal();
	  return {
	    kind: 'Member',
	    start: nodeStart,
	    end: lastEnd,
	    key: key,
	    value: value
	  };
	}
	
	function parseArr() {
	  var nodeStart = start;
	  var values = [];
	  expect('[');
	  if (!skip(']')) {
	    do {
	      values.push(parseVal());
	    } while (skip(','));
	    expect(']');
	  }
	  return {
	    kind: 'Array',
	    start: nodeStart,
	    end: lastEnd,
	    values: values
	  };
	}
	
	function parseVal() {
	  switch (kind) {
	    case '[':
	      return parseArr();
	    case '{':
	      return parseObj();
	    case 'String':
	    case 'Number':
	    case 'Boolean':
	    case 'Null':
	      var token = curToken();
	      lex();
	      return token;
	  }
	  return expect('Value');
	}
	
	function curToken() {
	  return { kind: kind, start: start, end: end, value: JSON.parse(string.slice(start, end)) };
	}
	
	function expect(str) {
	  if (kind === str) {
	    lex();
	    return;
	  }
	
	  var found = void 0;
	  if (kind === 'EOF') {
	    found = '[end of file]';
	  } else if (end - start > 1) {
	    found = '`' + string.slice(start, end) + '`';
	  } else {
	    var match = string.slice(start).match(/^.+?\b/);
	    found = '`' + (match ? match[0] : string[start]) + '`';
	  }
	
	  throw syntaxError('Expected ' + str + ' but found ' + found + '.');
	}
	
	function syntaxError(message) {
	  return { message: message, start: start, end: end };
	}
	
	function skip(k) {
	  if (kind === k) {
	    lex();
	    return true;
	  }
	}
	
	function ch() {
	  if (end < strLen) {
	    end++;
	    code = end === strLen ? 0 : string.charCodeAt(end);
	  }
	}
	
	function lex() {
	  lastEnd = end;
	
	  while (code === 9 || code === 10 || code === 13 || code === 32) {
	    ch();
	  }
	
	  if (code === 0) {
	    kind = 'EOF';
	    return;
	  }
	
	  start = end;
	
	  switch (code) {
	    // "
	    case 34:
	      kind = 'String';
	      return readString();
	    // -, 0-9
	    case 45:
	    case 48:
	    case 49:
	    case 50:
	    case 51:
	    case 52:
	    case 53:
	    case 54:
	    case 55:
	    case 56:
	    case 57:
	      kind = 'Number';
	      return readNumber();
	    // f
	    case 102:
	      if (string.slice(start, start + 5) !== 'false') {
	        break;
	      }
	      end += 4;
	      ch();
	
	      kind = 'Boolean';
	      return;
	    // n
	    case 110:
	      if (string.slice(start, start + 4) !== 'null') {
	        break;
	      }
	      end += 3;
	      ch();
	
	      kind = 'Null';
	      return;
	    // t
	    case 116:
	      if (string.slice(start, start + 4) !== 'true') {
	        break;
	      }
	      end += 3;
	      ch();
	
	      kind = 'Boolean';
	      return;
	  }
	
	  kind = string[start];
	  ch();
	}
	
	function readString() {
	  ch();
	  while (code !== 34 && code > 31) {
	    if (code === 92) {
	      // \
	      ch();
	      switch (code) {
	        case 34: // "
	        case 47: // /
	        case 92: // \
	        case 98: // b
	        case 102: // f
	        case 110: // n
	        case 114: // r
	        case 116:
	          // t
	          ch();
	          break;
	        case 117:
	          // u
	          ch();
	          readHex();
	          readHex();
	          readHex();
	          readHex();
	          break;
	        default:
	          throw syntaxError('Bad character escape sequence.');
	      }
	    } else if (end === strLen) {
	      throw syntaxError('Unterminated string.');
	    } else {
	      ch();
	    }
	  }
	
	  if (code === 34) {
	    ch();
	    return;
	  }
	
	  throw syntaxError('Unterminated string.');
	}
	
	function readHex() {
	  if (code >= 48 && code <= 57 || // 0-9
	  code >= 65 && code <= 70 || // A-F
	  code >= 97 && code <= 102 // a-f
	  ) {
	      return ch();
	    }
	  throw syntaxError('Expected hexadecimal digit.');
	}
	
	function readNumber() {
	  if (code === 45) {
	    // -
	    ch();
	  }
	
	  if (code === 48) {
	    // 0
	    ch();
	  } else {
	    readDigits();
	  }
	
	  if (code === 46) {
	    // .
	    ch();
	    readDigits();
	  }
	
	  if (code === 69 || code === 101) {
	    // E e
	    ch();
	    if (code === 43 || code === 45) {
	      // + -
	      ch();
	    }
	    readDigits();
	  }
	}
	
	function readDigits() {
	  if (code < 48 || code > 57) {
	    // 0 - 9
	    throw syntaxError('Expected decimal digit.');
	  }
	  do {
	    ch();
	  } while (code >= 48 && code <= 57); // 0 - 9
	}

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphql = __webpack_require__(12);
	
	var _forEachState = __webpack_require__(396);
	
	var _forEachState2 = _interopRequireDefault(_forEachState);
	
	var _hintList = __webpack_require__(397);
	
	var _hintList2 = _interopRequireDefault(_hintList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Registers a "hint" helper for CodeMirror.
	 *
	 * Using CodeMirror's "hint" addon: https://codemirror.net/demo/complete.html
	 * Given an editor, this helper will take the token at the cursor and return a
	 * list of suggested tokens.
	 *
	 * Options:
	 *
	 *   - variableToType: { [variable: string]: GraphQLInputType }
	 *
	 * Additional Events:
	 *
	 *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a
	 *     new list of completion suggestions.
	 *
	 */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	_codemirror2.default.registerHelper('hint', 'graphql-variables', function (editor, options) {
	  var cur = editor.getCursor();
	  var token = editor.getTokenAt(cur);
	
	  var results = getVariablesHint(cur, token, options);
	  if (results && results.list && results.list.length > 0) {
	    results.from = _codemirror2.default.Pos(results.from.line, results.from.column);
	    results.to = _codemirror2.default.Pos(results.to.line, results.to.column);
	    _codemirror2.default.signal(editor, 'hasCompletion', editor, results, token);
	  }
	
	  return results;
	});
	
	function getVariablesHint(cur, token, options) {
	  // If currently parsing an invalid state, attempt to hint to the prior state.
	  var state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;
	
	  var kind = state.kind;
	  var step = state.step;
	
	  // Variables can only be an object literal.
	  if (kind === 'Document' && step === 0) {
	    return (0, _hintList2.default)(cur, token, [{ text: '{' }]);
	  }
	
	  var variableToType = options.variableToType;
	  if (!variableToType) {
	    return;
	  }
	
	  var typeInfo = getTypeInfo(variableToType, token.state);
	
	  // Top level should typeahead possible variables.
	  if (kind === 'Document' || kind === 'Variable' && step === 0) {
	    var variableNames = Object.keys(variableToType);
	    return (0, _hintList2.default)(cur, token, variableNames.map(function (name) {
	      return {
	        text: '"' + name + '": ',
	        type: variableToType[name]
	      };
	    }));
	  }
	
	  // Input Object fields
	  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {
	    if (typeInfo.fields) {
	      var inputFields = Object.keys(typeInfo.fields).map(function (fieldName) {
	        return typeInfo.fields[fieldName];
	      });
	      return (0, _hintList2.default)(cur, token, inputFields.map(function (field) {
	        return {
	          text: '"' + field.name + '": ',
	          type: field.type,
	          description: field.description
	        };
	      }));
	    }
	  }
	
	  // Input values.
	  if (kind === 'StringValue' || kind === 'NumberValue' || kind === 'BooleanValue' || kind === 'NullValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Variable' && step === 2) {
	    var namedInputType = (0, _graphql.getNamedType)(typeInfo.type);
	    if (namedInputType instanceof _graphql.GraphQLInputObjectType) {
	      return (0, _hintList2.default)(cur, token, [{ text: '{' }]);
	    } else if (namedInputType instanceof _graphql.GraphQLEnumType) {
	      var valueMap = namedInputType.getValues();
	      var values = Object.keys(valueMap).map(function (name) {
	        return valueMap[name];
	      });
	      return (0, _hintList2.default)(cur, token, values.map(function (value) {
	        return {
	          text: '"' + value.name + '"',
	          type: namedInputType,
	          description: value.description
	        };
	      }));
	    } else if (namedInputType === _graphql.GraphQLBoolean) {
	      return (0, _hintList2.default)(cur, token, [{ text: 'true', type: _graphql.GraphQLBoolean, description: 'Not false.' }, { text: 'false', type: _graphql.GraphQLBoolean, description: 'Not true.' }]);
	    }
	  }
	}
	
	// Utility for collecting rich type information given any token's state
	// from the graphql-variables-mode parser.
	function getTypeInfo(variableToType, tokenState) {
	  var info = {
	    type: null,
	    fields: null
	  };
	
	  (0, _forEachState2.default)(tokenState, function (state) {
	    if (state.kind === 'Variable') {
	      info.type = variableToType[state.name];
	    } else if (state.kind === 'ListValue') {
	      var nullableType = (0, _graphql.getNullableType)(info.type);
	      info.type = nullableType instanceof _graphql.GraphQLList ? nullableType.ofType : null;
	    } else if (state.kind === 'ObjectValue') {
	      var objectType = (0, _graphql.getNamedType)(info.type);
	      info.fields = objectType instanceof _graphql.GraphQLInputObjectType ? objectType.getFields() : null;
	    } else if (state.kind === 'ObjectField') {
	      var objectField = state.name && info.fields ? info.fields[state.name] : null;
	      info.type = objectField && objectField.type;
	    }
	  });
	
	  return info;
	}

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphql = __webpack_require__(12);
	
	var _jsonParse = __webpack_require__(398);
	
	var _jsonParse2 = _interopRequireDefault(_jsonParse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Registers a "lint" helper for CodeMirror.
	 *
	 * Using CodeMirror's "lint" addon: https://codemirror.net/demo/lint.html
	 * Given the text within an editor, this helper will take that text and return
	 * a list of linter issues ensuring that correct variables were provided.
	 *
	 * Options:
	 *
	 *   - variableToType: { [variable: string]: GraphQLInputType }
	 *
	 */
	_codemirror2.default.registerHelper('lint', 'graphql-variables', function (text, options, editor) {
	  // If there's no text, do nothing.
	  if (!text) {
	    return [];
	  }
	
	  // First, linter needs to determine if there are any parsing errors.
	  var ast = void 0;
	  try {
	    ast = (0, _jsonParse2.default)(text);
	  } catch (syntaxError) {
	    if (syntaxError.stack) {
	      throw syntaxError;
	    }
	    return [lintError(editor, syntaxError, syntaxError.message)];
	  }
	
	  // If there are not yet known variables, do nothing.
	  var variableToType = options.variableToType;
	  if (!variableToType) {
	    return [];
	  }
	
	  // Then highlight any issues with the provided variables.
	  return validateVariables(editor, variableToType, ast);
	});
	
	// Given a variableToType object, a source text, and a JSON AST, produces a
	// list of CodeMirror annotations for any variable validation errors.
	/* eslint-disable max-len */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	function validateVariables(editor, variableToType, variablesAST) {
	  var errors = [];
	
	  variablesAST.members.forEach(function (member) {
	    var variableName = member.key.value;
	    var type = variableToType[variableName];
	    if (!type) {
	      errors.push(lintError(editor, member.key, 'Variable "$' + variableName + '" does not appear in any GraphQL query.'));
	    } else {
	      validateValue(type, member.value).forEach(function (_ref) {
	        var node = _ref[0],
	            message = _ref[1];
	
	        errors.push(lintError(editor, node, message));
	      });
	    }
	  });
	
	  return errors;
	}
	
	// Returns a list of validation errors in the form Array<[Node, String]>.
	function validateValue(type, valueAST) {
	  // Validate non-nullable values.
	  if (type instanceof _graphql.GraphQLNonNull) {
	    if (valueAST.kind === 'Null') {
	      return [[valueAST, 'Type "' + type + '" is non-nullable and cannot be null.']];
	    }
	    return validateValue(type.ofType, valueAST);
	  }
	
	  if (valueAST.kind === 'Null') {
	    return [];
	  }
	
	  // Validate lists of values, accepting a non-list as a list of one.
	  if (type instanceof _graphql.GraphQLList) {
	    var itemType = type.ofType;
	    if (valueAST.kind === 'Array') {
	      return mapCat(valueAST.values, function (item) {
	        return validateValue(itemType, item);
	      });
	    }
	    return validateValue(itemType, valueAST);
	  }
	
	  // Validate input objects.
	  if (type instanceof _graphql.GraphQLInputObjectType) {
	    if (valueAST.kind !== 'Object') {
	      return [[valueAST, 'Type "' + type + '" must be an Object.']];
	    }
	
	    // Validate each field in the input object.
	    var providedFields = Object.create(null);
	    var fieldErrors = mapCat(valueAST.members, function (member) {
	      var fieldName = member.key.value;
	      providedFields[fieldName] = true;
	      var inputField = type.getFields()[fieldName];
	      if (!inputField) {
	        return [[member.key, 'Type "' + type + '" does not have a field "' + fieldName + '".']];
	      }
	      var fieldType = inputField ? inputField.type : undefined;
	      return validateValue(fieldType, member.value);
	    });
	
	    // Look for missing non-nullable fields.
	    Object.keys(type.getFields()).forEach(function (fieldName) {
	      if (!providedFields[fieldName]) {
	        var fieldType = type.getFields()[fieldName].type;
	        if (fieldType instanceof _graphql.GraphQLNonNull) {
	          fieldErrors.push([valueAST, 'Object of type "' + type + '" is missing required field "' + fieldName + '".']);
	        }
	      }
	    });
	
	    return fieldErrors;
	  }
	
	  // Validate common scalars.
	  if (type.name === 'Boolean' && valueAST.kind !== 'Boolean' || type.name === 'String' && valueAST.kind !== 'String' || type.name === 'ID' && valueAST.kind !== 'Number' && valueAST.kind !== 'String' || type.name === 'Float' && valueAST.kind !== 'Number' || type.name === 'Int' && (valueAST.kind !== 'Number' || (valueAST.value | 0) !== valueAST.value)) {
	    return [[valueAST, 'Expected value of type "' + type + '".']];
	  }
	
	  // Validate enums and custom scalars.
	  if (type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLScalarType) {
	    if (valueAST.kind !== 'String' && valueAST.kind !== 'Number' && valueAST.kind !== 'Boolean' && valueAST.kind !== 'Null' || isNullish(type.parseValue(valueAST.value))) {
	      return [[valueAST, 'Expected value of type "' + type + '".']];
	    }
	  }
	
	  return [];
	}
	
	// Give a parent text, an AST node with location, and a message, produces a
	// CodeMirror annotation object.
	function lintError(editor, node, message) {
	  return {
	    message: message,
	    severity: 'error',
	    type: 'validation',
	    from: editor.posFromIndex(node.start),
	    to: editor.posFromIndex(node.end)
	  };
	}
	
	function isNullish(value) {
	  return value === null || value === undefined || value !== value;
	}
	
	function mapCat(array, mapper) {
	  return Array.prototype.concat.apply([], array.map(mapper));
	}

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _codemirror = __webpack_require__(5);
	
	var _codemirror2 = _interopRequireDefault(_codemirror);
	
	var _graphqlLanguageServiceParser = __webpack_require__(78);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This mode defines JSON, but provides a data-laden parser state to enable
	 * better code intelligence.
	 */
	/**
	 *  Copyright (c) 2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	_codemirror2.default.defineMode('graphql-variables', function (config) {
	  var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
	    eatWhitespace: function eatWhitespace(stream) {
	      return stream.eatSpace();
	    },
	    lexRules: LexRules,
	    parseRules: ParseRules,
	    editorConfig: { tabSize: config.tabSize }
	  });
	
	  return {
	    config: config,
	    startState: parser.startState,
	    token: parser.token,
	    indent: indent,
	    electricInput: /^\s*[}\]]/,
	    fold: 'brace',
	    closeBrackets: {
	      pairs: '[]{}""',
	      explode: '[]{}'
	    }
	  };
	});
	
	function indent(state, textAfter) {
	  var levels = state.levels;
	  // If there is no stack of levels, use the current level.
	  // Otherwise, use the top level, pre-emptively dedenting for close braces.
	  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (this.electricInput.test(textAfter) ? 1 : 0);
	  return level * this.config.indentUnit;
	}
	
	/**
	 * The lexer rules. These are exactly as described by the spec.
	 */
	var LexRules = {
	  // All Punctuation used in JSON.
	  Punctuation: /^\[|]|\{|\}|:|,/,
	
	  // JSON Number.
	  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
	
	  // JSON String.
	  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
	
	  // JSON literal keywords.
	  Keyword: /^true|false|null/
	};
	
	/**
	 * The parser rules for JSON.
	 */
	var ParseRules = {
	  Document: [(0, _graphqlLanguageServiceParser.p)('{'), (0, _graphqlLanguageServiceParser.list)('Variable', (0, _graphqlLanguageServiceParser.opt)((0, _graphqlLanguageServiceParser.p)(','))), (0, _graphqlLanguageServiceParser.p)('}')],
	  Variable: [namedKey('variable'), (0, _graphqlLanguageServiceParser.p)(':'), 'Value'],
	  Value: function Value(token) {
	    switch (token.kind) {
	      case 'Number':
	        return 'NumberValue';
	      case 'String':
	        return 'StringValue';
	      case 'Punctuation':
	        switch (token.value) {
	          case '[':
	            return 'ListValue';
	          case '{':
	            return 'ObjectValue';
	        }
	        return null;
	      case 'Keyword':
	        switch (token.value) {
	          case 'true':
	          case 'false':
	            return 'BooleanValue';
	          case 'null':
	            return 'NullValue';
	        }
	        return null;
	    }
	  },
	
	  NumberValue: [(0, _graphqlLanguageServiceParser.t)('Number', 'number')],
	  StringValue: [(0, _graphqlLanguageServiceParser.t)('String', 'string')],
	  BooleanValue: [(0, _graphqlLanguageServiceParser.t)('Keyword', 'builtin')],
	  NullValue: [(0, _graphqlLanguageServiceParser.t)('Keyword', 'keyword')],
	  ListValue: [(0, _graphqlLanguageServiceParser.p)('['), (0, _graphqlLanguageServiceParser.list)('Value', (0, _graphqlLanguageServiceParser.opt)((0, _graphqlLanguageServiceParser.p)(','))), (0, _graphqlLanguageServiceParser.p)(']')],
	  ObjectValue: [(0, _graphqlLanguageServiceParser.p)('{'), (0, _graphqlLanguageServiceParser.list)('ObjectField', (0, _graphqlLanguageServiceParser.opt)((0, _graphqlLanguageServiceParser.p)(','))), (0, _graphqlLanguageServiceParser.p)('}')],
	  ObjectField: [namedKey('attribute'), (0, _graphqlLanguageServiceParser.p)(':'), 'Value']
	};
	
	// A namedKey Token which will decorate the state with a `name`
	function namedKey(style) {
	  return {
	    style: style,
	    match: function match(token) {
	      return token.kind === 'String';
	    },
	    update: function update(state, token) {
	      state.name = token.value.slice(1, -1); // Remove quotes.
	    }
	  };
	}

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  var noOptions = {};
	  var nonWS = /[^\s\u00a0]/;
	  var Pos = CodeMirror.Pos;
	
	  function firstNonWS(str) {
	    var found = str.search(nonWS);
	    return found == -1 ? 0 : found;
	  }
	
	  CodeMirror.commands.toggleComment = function(cm) {
	    cm.toggleComment();
	  };
	
	  CodeMirror.defineExtension("toggleComment", function(options) {
	    if (!options) options = noOptions;
	    var cm = this;
	    var minLine = Infinity, ranges = this.listSelections(), mode = null;
	    for (var i = ranges.length - 1; i >= 0; i--) {
	      var from = ranges[i].from(), to = ranges[i].to();
	      if (from.line >= minLine) continue;
	      if (to.line >= minLine) to = Pos(minLine, 0);
	      minLine = from.line;
	      if (mode == null) {
	        if (cm.uncomment(from, to, options)) mode = "un";
	        else { cm.lineComment(from, to, options); mode = "line"; }
	      } else if (mode == "un") {
	        cm.uncomment(from, to, options);
	      } else {
	        cm.lineComment(from, to, options);
	      }
	    }
	  });
	
	  // Rough heuristic to try and detect lines that are part of multi-line string
	  function probablyInsideString(cm, pos, line) {
	    return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line)
	  }
	
	  function getMode(cm, pos) {
	    var mode = cm.getMode()
	    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)
	  }
	
	  CodeMirror.defineExtension("lineComment", function(from, to, options) {
	    if (!options) options = noOptions;
	    var self = this, mode = getMode(self, from);
	    var firstLine = self.getLine(from.line);
	    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;
	
	    var commentString = options.lineComment || mode.lineComment;
	    if (!commentString) {
	      if (options.blockCommentStart || mode.blockCommentStart) {
	        options.fullLines = true;
	        self.blockComment(from, to, options);
	      }
	      return;
	    }
	
	    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
	    var pad = options.padding == null ? " " : options.padding;
	    var blankLines = options.commentBlankLines || from.line == to.line;
	
	    self.operation(function() {
	      if (options.indent) {
	        var baseString = null;
	        for (var i = from.line; i < end; ++i) {
	          var line = self.getLine(i);
	          var whitespace = line.slice(0, firstNonWS(line));
	          if (baseString == null || baseString.length > whitespace.length) {
	            baseString = whitespace;
	          }
	        }
	        for (var i = from.line; i < end; ++i) {
	          var line = self.getLine(i), cut = baseString.length;
	          if (!blankLines && !nonWS.test(line)) continue;
	          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
	          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
	        }
	      } else {
	        for (var i = from.line; i < end; ++i) {
	          if (blankLines || nonWS.test(self.getLine(i)))
	            self.replaceRange(commentString + pad, Pos(i, 0));
	        }
	      }
	    });
	  });
	
	  CodeMirror.defineExtension("blockComment", function(from, to, options) {
	    if (!options) options = noOptions;
	    var self = this, mode = getMode(self, from);
	    var startString = options.blockCommentStart || mode.blockCommentStart;
	    var endString = options.blockCommentEnd || mode.blockCommentEnd;
	    if (!startString || !endString) {
	      if ((options.lineComment || mode.lineComment) && options.fullLines != false)
	        self.lineComment(from, to, options);
	      return;
	    }
	    if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return
	
	    var end = Math.min(to.line, self.lastLine());
	    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;
	
	    var pad = options.padding == null ? " " : options.padding;
	    if (from.line > end) return;
	
	    self.operation(function() {
	      if (options.fullLines != false) {
	        var lastLineHasText = nonWS.test(self.getLine(end));
	        self.replaceRange(pad + endString, Pos(end));
	        self.replaceRange(startString + pad, Pos(from.line, 0));
	        var lead = options.blockCommentLead || mode.blockCommentLead;
	        if (lead != null) for (var i = from.line + 1; i <= end; ++i)
	          if (i != end || lastLineHasText)
	            self.replaceRange(lead + pad, Pos(i, 0));
	      } else {
	        self.replaceRange(endString, to);
	        self.replaceRange(startString, from);
	      }
	    });
	  });
	
	  CodeMirror.defineExtension("uncomment", function(from, to, options) {
	    if (!options) options = noOptions;
	    var self = this, mode = getMode(self, from);
	    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);
	
	    // Try finding line comments
	    var lineString = options.lineComment || mode.lineComment, lines = [];
	    var pad = options.padding == null ? " " : options.padding, didSomething;
	    lineComment: {
	      if (!lineString) break lineComment;
	      for (var i = start; i <= end; ++i) {
	        var line = self.getLine(i);
	        var found = line.indexOf(lineString);
	        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
	        if (found == -1 && nonWS.test(line)) break lineComment;
	        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
	        lines.push(line);
	      }
	      self.operation(function() {
	        for (var i = start; i <= end; ++i) {
	          var line = lines[i - start];
	          var pos = line.indexOf(lineString), endPos = pos + lineString.length;
	          if (pos < 0) continue;
	          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
	          didSomething = true;
	          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
	        }
	      });
	      if (didSomething) return true;
	    }
	
	    // Try block comments
	    var startString = options.blockCommentStart || mode.blockCommentStart;
	    var endString = options.blockCommentEnd || mode.blockCommentEnd;
	    if (!startString || !endString) return false;
	    var lead = options.blockCommentLead || mode.blockCommentLead;
	    var startLine = self.getLine(start), open = startLine.indexOf(startString)
	    if (open == -1) return false
	    var endLine = end == start ? startLine : self.getLine(end)
	    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
	    if (close == -1 && start != end) {
	      endLine = self.getLine(--end);
	      close = endLine.indexOf(endString);
	    }
	    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)
	    if (close == -1 ||
	        !/comment/.test(self.getTokenTypeAt(insideStart)) ||
	        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||
	        self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
	      return false;
	
	    // Avoid killing block comments completely outside the selection.
	    // Positions of the last startString before the start of the selection, and the first endString after it.
	    var lastStart = startLine.lastIndexOf(startString, from.ch);
	    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
	    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
	    // Positions of the first endString after the end of the selection, and the last startString before it.
	    firstEnd = endLine.indexOf(endString, to.ch);
	    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
	    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;
	    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;
	
	    self.operation(function() {
	      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
	                        Pos(end, close + endString.length));
	      var openEnd = open + startString.length;
	      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
	      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
	      if (lead) for (var i = start + 1; i <= end; ++i) {
	        var line = self.getLine(i), found = line.indexOf(lead);
	        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
	        var foundEnd = found + lead.length;
	        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
	        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
	      }
	    });
	    return true;
	  });
	});


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
	    var prev = old && old != CodeMirror.Init;
	    if (val && !prev) {
	      cm.on("blur", onBlur);
	      cm.on("change", onChange);
	      cm.on("swapDoc", onChange);
	      onChange(cm);
	    } else if (!val && prev) {
	      cm.off("blur", onBlur);
	      cm.off("change", onChange);
	      cm.off("swapDoc", onChange);
	      clearPlaceholder(cm);
	      var wrapper = cm.getWrapperElement();
	      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
	    }
	
	    if (val && !cm.hasFocus()) onBlur(cm);
	  });
	
	  function clearPlaceholder(cm) {
	    if (cm.state.placeholder) {
	      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
	      cm.state.placeholder = null;
	    }
	  }
	  function setPlaceholder(cm) {
	    clearPlaceholder(cm);
	    var elt = cm.state.placeholder = document.createElement("pre");
	    elt.style.cssText = "height: 0; overflow: visible";
	    elt.className = "CodeMirror-placeholder";
	    var placeHolder = cm.getOption("placeholder")
	    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
	    elt.appendChild(placeHolder)
	    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
	  }
	
	  function onBlur(cm) {
	    if (isEmpty(cm)) setPlaceholder(cm);
	  }
	  function onChange(cm) {
	    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
	    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
	
	    if (empty) setPlaceholder(cm);
	    else clearPlaceholder(cm);
	  }
	
	  function isEmpty(cm) {
	    return (cm.lineCount() === 1) && (cm.getLine(0) === "");
	  }
	});


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  function doFold(cm, pos, options, force) {
	    if (options && options.call) {
	      var finder = options;
	      options = null;
	    } else {
	      var finder = getOption(cm, options, "rangeFinder");
	    }
	    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
	    var minSize = getOption(cm, options, "minFoldSize");
	
	    function getRange(allowFolded) {
	      var range = finder(cm, pos);
	      if (!range || range.to.line - range.from.line < minSize) return null;
	      var marks = cm.findMarksAt(range.from);
	      for (var i = 0; i < marks.length; ++i) {
	        if (marks[i].__isFold && force !== "fold") {
	          if (!allowFolded) return null;
	          range.cleared = true;
	          marks[i].clear();
	        }
	      }
	      return range;
	    }
	
	    var range = getRange(true);
	    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
	      pos = CodeMirror.Pos(pos.line - 1, 0);
	      range = getRange(false);
	    }
	    if (!range || range.cleared || force === "unfold") return;
	
	    var myWidget = makeWidget(cm, options);
	    CodeMirror.on(myWidget, "mousedown", function(e) {
	      myRange.clear();
	      CodeMirror.e_preventDefault(e);
	    });
	    var myRange = cm.markText(range.from, range.to, {
	      replacedWith: myWidget,
	      clearOnEnter: getOption(cm, options, "clearOnEnter"),
	      __isFold: true
	    });
	    myRange.on("clear", function(from, to) {
	      CodeMirror.signal(cm, "unfold", cm, from, to);
	    });
	    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
	  }
	
	  function makeWidget(cm, options) {
	    var widget = getOption(cm, options, "widget");
	    if (typeof widget == "string") {
	      var text = document.createTextNode(widget);
	      widget = document.createElement("span");
	      widget.appendChild(text);
	      widget.className = "CodeMirror-foldmarker";
	    } else if (widget) {
	      widget = widget.cloneNode(true)
	    }
	    return widget;
	  }
	
	  // Clumsy backwards-compatible interface
	  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
	    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
	  };
	
	  // New-style interface
	  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
	    doFold(this, pos, options, force);
	  });
	
	  CodeMirror.defineExtension("isFolded", function(pos) {
	    var marks = this.findMarksAt(pos);
	    for (var i = 0; i < marks.length; ++i)
	      if (marks[i].__isFold) return true;
	  });
	
	  CodeMirror.commands.toggleFold = function(cm) {
	    cm.foldCode(cm.getCursor());
	  };
	  CodeMirror.commands.fold = function(cm) {
	    cm.foldCode(cm.getCursor(), null, "fold");
	  };
	  CodeMirror.commands.unfold = function(cm) {
	    cm.foldCode(cm.getCursor(), null, "unfold");
	  };
	  CodeMirror.commands.foldAll = function(cm) {
	    cm.operation(function() {
	      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
	        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
	    });
	  };
	  CodeMirror.commands.unfoldAll = function(cm) {
	    cm.operation(function() {
	      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
	        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
	    });
	  };
	
	  CodeMirror.registerHelper("fold", "combine", function() {
	    var funcs = Array.prototype.slice.call(arguments, 0);
	    return function(cm, start) {
	      for (var i = 0; i < funcs.length; ++i) {
	        var found = funcs[i](cm, start);
	        if (found) return found;
	      }
	    };
	  });
	
	  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
	    var helpers = cm.getHelpers(start, "fold");
	    for (var i = 0; i < helpers.length; i++) {
	      var cur = helpers[i](cm, start);
	      if (cur) return cur;
	    }
	  });
	
	  var defaultOptions = {
	    rangeFinder: CodeMirror.fold.auto,
	    widget: "\u2194",
	    minFoldSize: 0,
	    scanUp: false,
	    clearOnEnter: true
	  };
	
	  CodeMirror.defineOption("foldOptions", null);
	
	  function getOption(cm, options, name) {
	    if (options && options[name] !== undefined)
	      return options[name];
	    var editorOptions = cm.options.foldOptions;
	    if (editorOptions && editorOptions[name] !== undefined)
	      return editorOptions[name];
	    return defaultOptions[name];
	  }
	
	  CodeMirror.defineExtension("foldOption", function(options, name) {
	    return getOption(this, options, name);
	  });
	});


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// Defines jumpToLine command. Uses dialog.js if present.
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5), __webpack_require__(91));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../dialog/dialog"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  function dialog(cm, text, shortText, deflt, f) {
	    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
	    else f(prompt(shortText, deflt));
	  }
	
	  var jumpDialog =
	      'Jump to line: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use line:column or scroll% syntax)</span>';
	
	  function interpretLine(cm, string) {
	    var num = Number(string)
	    if (/^[-+]/.test(string)) return cm.getCursor().line + num
	    else return num - 1
	  }
	
	  CodeMirror.commands.jumpToLine = function(cm) {
	    var cur = cm.getCursor();
	    dialog(cm, jumpDialog, "Jump to line:", (cur.line + 1) + ":" + cur.ch, function(posStr) {
	      if (!posStr) return;
	
	      var match;
	      if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
	        cm.setCursor(interpretLine(cm, match[1]), Number(match[2]))
	      } else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
	        var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
	        if (/^[-+]/.test(match[1])) line = cur.line + line + 1;
	        cm.setCursor(line - 1, cur.ch);
	      } else if (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
	        cm.setCursor(interpretLine(cm, match[1]), cur.ch);
	      }
	    });
	  };
	
	  CodeMirror.keyMap["default"]["Alt-G"] = "jumpToLine";
	});


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// Define search commands. Depends on dialog.js or another
	// implementation of the openDialog method.
	
	// Replace works a little oddly -- it will do the replace on the next
	// Ctrl-G (or whatever is bound to findNext) press. You prevent a
	// replace by making sure the match is no longer selected when hitting
	// Ctrl-G.
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5), __webpack_require__(130), __webpack_require__(91));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  function searchOverlay(query, caseInsensitive) {
	    if (typeof query == "string")
	      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
	    else if (!query.global)
	      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");
	
	    return {token: function(stream) {
	      query.lastIndex = stream.pos;
	      var match = query.exec(stream.string);
	      if (match && match.index == stream.pos) {
	        stream.pos += match[0].length || 1;
	        return "searching";
	      } else if (match) {
	        stream.pos = match.index;
	      } else {
	        stream.skipToEnd();
	      }
	    }};
	  }
	
	  function SearchState() {
	    this.posFrom = this.posTo = this.lastQuery = this.query = null;
	    this.overlay = null;
	  }
	
	  function getSearchState(cm) {
	    return cm.state.search || (cm.state.search = new SearchState());
	  }
	
	  function queryCaseInsensitive(query) {
	    return typeof query == "string" && query == query.toLowerCase();
	  }
	
	  function getSearchCursor(cm, query, pos) {
	    // Heuristic: if the query string is all lowercase, do a case insensitive search.
	    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});
	  }
	
	  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
	    cm.openDialog(text, onEnter, {
	      value: deflt,
	      selectValueOnOpen: true,
	      closeOnEnter: false,
	      onClose: function() { clearSearch(cm); },
	      onKeyDown: onKeyDown
	    });
	  }
	
	  function dialog(cm, text, shortText, deflt, f) {
	    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
	    else f(prompt(shortText, deflt));
	  }
	
	  function confirmDialog(cm, text, shortText, fs) {
	    if (cm.openConfirm) cm.openConfirm(text, fs);
	    else if (confirm(shortText)) fs[0]();
	  }
	
	  function parseString(string) {
	    return string.replace(/\\(.)/g, function(_, ch) {
	      if (ch == "n") return "\n"
	      if (ch == "r") return "\r"
	      return ch
	    })
	  }
	
	  function parseQuery(query) {
	    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
	    if (isRE) {
	      try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }
	      catch(e) {} // Not a regular expression after all, do a string search
	    } else {
	      query = parseString(query)
	    }
	    if (typeof query == "string" ? query == "" : query.test(""))
	      query = /x^/;
	    return query;
	  }
	
	  var queryDialog =
	    '<span class="CodeMirror-search-label">Search:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>';
	
	  function startSearch(cm, state, query) {
	    state.queryText = query;
	    state.query = parseQuery(query);
	    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
	    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
	    cm.addOverlay(state.overlay);
	    if (cm.showMatchesOnScrollbar) {
	      if (state.annotate) { state.annotate.clear(); state.annotate = null; }
	      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
	    }
	  }
	
	  function doSearch(cm, rev, persistent, immediate) {
	    var state = getSearchState(cm);
	    if (state.query) return findNext(cm, rev);
	    var q = cm.getSelection() || state.lastQuery;
	    if (q instanceof RegExp && q.source == "x^") q = null
	    if (persistent && cm.openDialog) {
	      var hiding = null
	      var searchNext = function(query, event) {
	        CodeMirror.e_stop(event);
	        if (!query) return;
	        if (query != state.queryText) {
	          startSearch(cm, state, query);
	          state.posFrom = state.posTo = cm.getCursor();
	        }
	        if (hiding) hiding.style.opacity = 1
	        findNext(cm, event.shiftKey, function(_, to) {
	          var dialog
	          if (to.line < 3 && document.querySelector &&
	              (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) &&
	              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
	            (hiding = dialog).style.opacity = .4
	        })
	      };
	      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {
	        var keyName = CodeMirror.keyName(event)
	        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption("keyMap")][keyName]
	        if (cmd == "findNext" || cmd == "findPrev" ||
	          cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
	          CodeMirror.e_stop(event);
	          startSearch(cm, getSearchState(cm), query);
	          cm.execCommand(cmd);
	        } else if (cmd == "find" || cmd == "findPersistent") {
	          CodeMirror.e_stop(event);
	          searchNext(query, event);
	        }
	      });
	      if (immediate && q) {
	        startSearch(cm, state, q);
	        findNext(cm, rev);
	      }
	    } else {
	      dialog(cm, queryDialog, "Search for:", q, function(query) {
	        if (query && !state.query) cm.operation(function() {
	          startSearch(cm, state, query);
	          state.posFrom = state.posTo = cm.getCursor();
	          findNext(cm, rev);
	        });
	      });
	    }
	  }
	
	  function findNext(cm, rev, callback) {cm.operation(function() {
	    var state = getSearchState(cm);
	    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
	    if (!cursor.find(rev)) {
	      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
	      if (!cursor.find(rev)) return;
	    }
	    cm.setSelection(cursor.from(), cursor.to());
	    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
	    state.posFrom = cursor.from(); state.posTo = cursor.to();
	    if (callback) callback(cursor.from(), cursor.to())
	  });}
	
	  function clearSearch(cm) {cm.operation(function() {
	    var state = getSearchState(cm);
	    state.lastQuery = state.query;
	    if (!state.query) return;
	    state.query = state.queryText = null;
	    cm.removeOverlay(state.overlay);
	    if (state.annotate) { state.annotate.clear(); state.annotate = null; }
	  });}
	
	  var replaceQueryDialog =
	    ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>';
	  var replacementQueryDialog = '<span class="CodeMirror-search-label">With:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';
	  var doReplaceConfirm = '<span class="CodeMirror-search-label">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';
	
	  function replaceAll(cm, query, text) {
	    cm.operation(function() {
	      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
	        if (typeof query != "string") {
	          var match = cm.getRange(cursor.from(), cursor.to()).match(query);
	          cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
	        } else cursor.replace(text);
	      }
	    });
	  }
	
	  function replace(cm, all) {
	    if (cm.getOption("readOnly")) return;
	    var query = cm.getSelection() || getSearchState(cm).lastQuery;
	    var dialogText = '<span class="CodeMirror-search-label">' + (all ? 'Replace all:' : 'Replace:') + '</span>';
	    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {
	      if (!query) return;
	      query = parseQuery(query);
	      dialog(cm, replacementQueryDialog, "Replace with:", "", function(text) {
	        text = parseString(text)
	        if (all) {
	          replaceAll(cm, query, text)
	        } else {
	          clearSearch(cm);
	          var cursor = getSearchCursor(cm, query, cm.getCursor("from"));
	          var advance = function() {
	            var start = cursor.from(), match;
	            if (!(match = cursor.findNext())) {
	              cursor = getSearchCursor(cm, query);
	              if (!(match = cursor.findNext()) ||
	                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
	            }
	            cm.setSelection(cursor.from(), cursor.to());
	            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
	            confirmDialog(cm, doReplaceConfirm, "Replace?",
	                          [function() {doReplace(match);}, advance,
	                           function() {replaceAll(cm, query, text)}]);
	          };
	          var doReplace = function(match) {
	            cursor.replace(typeof query == "string" ? text :
	                           text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
	            advance();
	          };
	          advance();
	        }
	      });
	    });
	  }
	
	  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
	  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};
	  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};
	  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};
	  CodeMirror.commands.findNext = doSearch;
	  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
	  CodeMirror.commands.clearSearch = clearSearch;
	  CodeMirror.commands.replace = replace;
	  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
	});


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
	
	  // Tokenizer
	
	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};
	
	    var jsKeywords = {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
	      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
	      "await": C
	    };
	
	    // Extend the 'normal' keywords with the TypeScript language extensions
	    if (isTS) {
	      var type = {type: "variable", style: "type"};
	      var tsKeywords = {
	        // object-like things
	        "interface": kw("class"),
	        "implements": C,
	        "namespace": C,
	        "module": kw("module"),
	        "enum": kw("module"),
	
	        // scope modifiers
	        "public": kw("modifier"),
	        "private": kw("modifier"),
	        "protected": kw("modifier"),
	        "abstract": kw("modifier"),
	        "readonly": kw("modifier"),
	
	        // types
	        "string": type, "number": type, "boolean": type, "any": type
	      };
	
	      for (var attr in tsKeywords) {
	        jsKeywords[attr] = tsKeywords[attr];
	      }
	    }
	
	    return jsKeywords;
	  }();
	
	  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
	
	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }
	
	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.eat(/x/i)) {
	      stream.eatWhile(/[\da-f]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/o/i)) {
	      stream.eatWhile(/[0-7]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/b/i)) {
	      stream.eatWhile(/[01]/i);
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (expressionAllowed(stream, state, 1)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eat("=");
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#") {
	      stream.skipToEnd();
	      return ret("error", "error");
	    } else if (isOperatorChar.test(ch)) {
	      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
	        if (stream.eat("=")) {
	          if (ch == "!" || ch == "=") stream.eat("=")
	        } else if (/[<>*+\-]/.test(ch)) {
	          stream.eat(ch)
	          if (ch == ">") stream.eat(ch)
	        }
	      }
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current()
	      if (state.lastType != ".") {
	        if (keywords.propertyIsEnumerable(word)) {
	          var kw = keywords[word]
	          return ret(kw.type, kw.style, word)
	        }
	        if (word == "async" && stream.match(/^\s*[\(\w]/, false))
	          return ret("async", "keyword", word)
	      }
	      return ret("variable", "variable", word)
	    }
	  }
	
	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }
	
	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }
	
	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }
	
	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;
	
	    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
	      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
	      if (m) arrow = m.index
	    }
	
	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/]/.test(ch)) {
	        return;
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }
	
	  // Parser
	
	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};
	
	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }
	
	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }
	
	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;
	
	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;
	
	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }
	
	  // Combinator utils
	
	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function register(varname) {
	    function inList(list) {
	      for (var v = list; v; v = v.next)
	        if (v.name == varname) return true;
	      return false;
	    }
	    var state = cx.state;
	    cx.marked = "def";
	    if (state.context) {
	      if (inList(state.localVars)) return;
	      state.localVars = {name: varname, next: state.localVars};
	    } else {
	      if (inList(state.globalVars)) return;
	      if (parserConfig.globalVars)
	        state.globalVars = {name: varname, next: state.globalVars};
	    }
	  }
	
	  // Combinators
	
	  var defaultVars = {name: "this", next: {name: "arguments"}};
	  function pushcontext() {
	    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
	    cx.state.localVars = defaultVars;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;
	
	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";") return pass();
	      else return cont(exp);
	    };
	    return exp;
	  }
	
	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
	    if (type == "debugger") return cont(expect(";"));
	    if (type == "{") return cont(pushlex("}"), block, poplex);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "variable") {
	      if (isTS && value == "type") {
	        cx.marked = "keyword"
	        return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
	      } if (isTS && value == "declare") {
	        cx.marked = "keyword"
	        return cont(statement)
	      } else {
	        return cont(pushlex("stat"), maybelabel);
	      }
	    }
	    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"),
	                                      block, poplex, poplex);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
	                                     statement, poplex, popcontext);
	    if (type == "class") return cont(pushlex("form"), className, poplex);
	    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	    if (type == "module") return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
	    if (type == "async") return cont(statement)
	    if (value == "@") return cont(expression, statement)
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function expression(type) {
	    return expressionInner(type, false);
	  }
	  function expressionNoComma(type) {
	    return expressionInner(type, true);
	  }
	  function parenExpr(type) {
	    if (type != "(") return pass()
	    return cont(pushlex(")"), expression, expect(")"), poplex)
	  }
	  function expressionInner(type, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }
	
	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "class") return cont(pushlex("form"), classExpression, poplex);
	    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") return pass(quasi, maybeop);
	    if (type == "new") return cont(maybeTarget(noComma));
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }
	
	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(expression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
	    if (type == "regexp") {
	      cx.state.lastType = cx.marked = "operator"
	      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
	      return cont(expr)
	    }
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybeTarget(noComma) {
	    return function(type) {
	      if (type == ".") return cont(noComma ? targetNoComma : target);
	      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
	      else return pass(noComma ? expressionNoComma : expression);
	    };
	  }
	  function target(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
	  }
	  function targetNoComma(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "async") {
	      cx.marked = "property";
	      return cont(objprop);
	    } else if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
	      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
	        cx.state.fatArrowAt = cx.stream.pos + m[0].length
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (type == "modifier") {
	      return cont(objprop)
	    } else if (type == "[") {
	      return cont(expression, expect("]"), afterprop);
	    } else if (type == "spread") {
	      return cont(expressionNoComma, afterprop);
	    } else if (value == "*") {
	      cx.marked = "keyword";
	      return cont(objprop);
	    } else if (type == ":") {
	      return pass(afterprop)
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end, sep) {
	    function proceed(type, value) {
	      if (sep ? sep.indexOf(type) > -1 : type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(function(type, value) {
	          if (type == end || value == end) return pass()
	          return pass(what)
	        }, proceed);
	      }
	      if (type == end || value == end) return cont();
	      return cont(expect(end));
	    }
	    return function(type, value) {
	      if (type == end || value == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type, value) {
	    if (isTS) {
	      if (type == ":") return cont(typeexpr);
	      if (value == "?") return cont(maybetype);
	    }
	  }
	  function typeexpr(type, value) {
	    if (type == "variable" || value == "void") {
	      if (value == "keyof") {
	        cx.marked = "keyword"
	        return cont(typeexpr)
	      } else {
	        cx.marked = "type"
	        return cont(afterType)
	      }
	    }
	    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
	    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
	    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
	    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
	  }
	  function maybeReturnType(type) {
	    if (type == "=>") return cont(typeexpr)
	  }
	  function typeprop(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property"
	      return cont(typeprop)
	    } else if (value == "?") {
	      return cont(typeprop)
	    } else if (type == ":") {
	      return cont(typeexpr)
	    } else if (type == "[") {
	      return cont(expression, maybetype, expect("]"), typeprop)
	    }
	  }
	  function typearg(type) {
	    if (type == "variable") return cont(typearg)
	    else if (type == ":") return cont(typeexpr)
	  }
	  function afterType(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	    if (value == "|" || type == ".") return cont(typeexpr)
	    if (type == "[") return cont(expect("]"), afterType)
	    if (value == "extends") return cont(typeexpr)
	  }
	  function maybeTypeArgs(_, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	  }
	  function vardef() {
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (type == "modifier") return cont(pattern)
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "spread") return cont(pattern);
	    if (type == "[") return contCommasep(pattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    if (type == "spread") return cont(pattern);
	    if (type == "}") return pass();
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type) {
	    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, expect(";"), forspec2);
	    if (type == ";") return cont(forspec2);
	    if (type == "variable") return cont(formaybeinof);
	    return pass(expression, expect(";"), forspec2);
	  }
	  function formaybeinof(_type, value) {
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return cont(maybeoperatorComma, forspec2);
	  }
	  function forspec2(type, value) {
	    if (type == ";") return cont(forspec3);
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return pass(expression, expect(";"), forspec3);
	  }
	  function forspec3(type) {
	    if (type != ")") cont(expression);
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
	    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, functiondef)
	  }
	  function funarg(type, value) {
	    if (value == "@") cont(expression, funarg)
	    if (type == "spread" || type == "modifier") return cont(funarg);
	    return pass(pattern, maybetype, maybeAssign);
	  }
	  function classExpression(type, value) {
	    // Class expressions may have an optional name.
	    if (type == "variable") return className(type, value);
	    return classNameAfter(type, value);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, classNameAfter)
	    if (value == "extends" || value == "implements" || (isTS && type == ","))
	      return cont(isTS ? typeexpr : expression, classNameAfter);
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "modifier" || type == "async" ||
	        (type == "variable" &&
	         (value == "static" || value == "get" || value == "set") &&
	         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      return cont(isTS ? classfield : functiondef, classBody);
	    }
	    if (type == "[")
	      return cont(expression, expect("]"), isTS ? classfield : functiondef, classBody)
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == ";") return cont(classBody);
	    if (type == "}") return cont();
	    if (value == "@") return cont(expression, classBody)
	  }
	  function classfield(type, value) {
	    if (value == "?") return cont(classfield)
	    if (type == ":") return cont(typeexpr, maybeAssign)
	    if (value == "=") return cont(expressionNoComma)
	    return pass(functiondef)
	  }
	  function afterExport(type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
	    return pass(statement);
	  }
	  function exportField(type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
	    if (type == "variable") return pass(expressionNoComma, exportField);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    return pass(importSpec, maybeMoreImports, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    if (value == "*") cx.marked = "keyword";
	    return cont(maybeAs);
	  }
	  function maybeMoreImports(type) {
	    if (type == ",") return cont(importSpec, maybeMoreImports)
	  }
	  function maybeAs(_type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(commasep(expressionNoComma, "]"));
	  }
	
	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }
	
	  function expressionAllowed(stream, state, backUp) {
	    return state.tokenize == tokenBase &&
	      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
	      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
	  }
	
	  // Interface
	
	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && {vars: parserConfig.localVars},
	        indented: basecolumn || 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },
	
	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },
	
	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      while ((lexical.type == "stat" || lexical.type == "form") &&
	             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
	                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
	                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
	        lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;
	
	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },
	
	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    blockCommentContinue: jsonMode ? null : " * ",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",
	    closeBrackets: "()[]{}''\"\"``",
	
	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode,
	
	    expressionAllowed: expressionAllowed,
	
	    skipExpression: function(state) {
	      var top = state.cc[state.cc.length - 1]
	      if (top == expression || top == expressionNoComma) state.cc.pop()
	    }
	  };
	});
	
	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
	
	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
	
	});


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(5));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.defineMode('shell', function() {
	
	  var words = {};
	  function define(style, string) {
	    var split = string.split(' ');
	    for(var i = 0; i < split.length; i++) {
	      words[split[i]] = style;
	    }
	  };
	
	  // Atoms
	  define('atom', 'true false');
	
	  // Keywords
	  define('keyword', 'if then do else elif while until for in esac fi fin ' +
	    'fil done exit set unset export function');
	
	  // Commands
	  define('builtin', 'ab awk bash beep cat cc cd chown chmod chroot clear cp ' +
	    'curl cut diff echo find gawk gcc get git grep hg kill killall ln ls make ' +
	    'mkdir openssl mv nc node npm ping ps restart rm rmdir sed service sh ' +
	    'shopt shred source sort sleep ssh start stop su sudo svn tee telnet top ' +
	    'touch vi vim wall wc wget who write yes zsh');
	
	  function tokenBase(stream, state) {
	    if (stream.eatSpace()) return null;
	
	    var sol = stream.sol();
	    var ch = stream.next();
	
	    if (ch === '\\') {
	      stream.next();
	      return null;
	    }
	    if (ch === '\'' || ch === '"' || ch === '`') {
	      state.tokens.unshift(tokenString(ch, ch === "`" ? "quote" : "string"));
	      return tokenize(stream, state);
	    }
	    if (ch === '#') {
	      if (sol && stream.eat('!')) {
	        stream.skipToEnd();
	        return 'meta'; // 'comment'?
	      }
	      stream.skipToEnd();
	      return 'comment';
	    }
	    if (ch === '$') {
	      state.tokens.unshift(tokenDollar);
	      return tokenize(stream, state);
	    }
	    if (ch === '+' || ch === '=') {
	      return 'operator';
	    }
	    if (ch === '-') {
	      stream.eat('-');
	      stream.eatWhile(/\w/);
	      return 'attribute';
	    }
	    if (/\d/.test(ch)) {
	      stream.eatWhile(/\d/);
	      if(stream.eol() || !/\w/.test(stream.peek())) {
	        return 'number';
	      }
	    }
	    stream.eatWhile(/[\w-]/);
	    var cur = stream.current();
	    if (stream.peek() === '=' && /\w+/.test(cur)) return 'def';
	    return words.hasOwnProperty(cur) ? words[cur] : null;
	  }
	
	  function tokenString(quote, style) {
	    var close = quote == "(" ? ")" : quote == "{" ? "}" : quote
	    return function(stream, state) {
	      var next, end = false, escaped = false;
	      while ((next = stream.next()) != null) {
	        if (next === close && !escaped) {
	          end = true;
	          break;
	        }
	        if (next === '$' && !escaped && quote !== "'") {
	          escaped = true;
	          stream.backUp(1);
	          state.tokens.unshift(tokenDollar);
	          break;
	        }
	        if (!escaped && next === quote && quote !== close) {
	          state.tokens.unshift(tokenString(quote, style))
	          return tokenize(stream, state)
	        }
	        escaped = !escaped && next === '\\';
	      }
	      if (end) state.tokens.shift();
	      return style;
	    };
	  };
	
	  var tokenDollar = function(stream, state) {
	    if (state.tokens.length > 1) stream.eat('$');
	    var ch = stream.next()
	    if (/['"({]/.test(ch)) {
	      state.tokens[0] = tokenString(ch, ch == "(" ? "quote" : ch == "{" ? "def" : "string");
	      return tokenize(stream, state);
	    }
	    if (!/\d/.test(ch)) stream.eatWhile(/\w/);
	    state.tokens.shift();
	    return 'def';
	  };
	
	  function tokenize(stream, state) {
	    return (state.tokens[0] || tokenBase) (stream, state);
	  };
	
	  return {
	    startState: function() {return {tokens:[]};},
	    token: function(stream, state) {
	      return tokenize(stream, state);
	    },
	    closeBrackets: "()[]{}''\"\"``",
	    lineComment: '#',
	    fold: "brace"
	  };
	});
	
	CodeMirror.defineMIME('text/x-sh', 'shell');
	// Apache uses a slightly different Media Type for Shell scripts
	// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
	CodeMirror.defineMIME('application/x-sh', 'shell');
	
	});


/***/ }),
/* 409 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = collapse;
	
	/* collapse(' \t\nbar \nbaz\t'); // ' bar baz ' */
	function collapse(value) {
	  return String(value).replace(/\s+/g, ' ');
	}


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.parse = parse;
	exports.stringify = stringify;
	
	var trim = __webpack_require__(43);
	
	var C_COMMA = ',';
	var C_SPACE = ' ';
	var EMPTY = '';
	
	/* Parse comma-separated tokens to an array. */
	function parse(value) {
	  var values = [];
	  var input = String(value || EMPTY);
	  var index = input.indexOf(C_COMMA);
	  var lastIndex = 0;
	  var end = false;
	  var val;
	
	  while (!end) {
	    if (index === -1) {
	      index = input.length;
	      end = true;
	    }
	
	    val = trim(input.slice(lastIndex, index));
	
	    if (val || !end) {
	      values.push(val);
	    }
	
	    lastIndex = index + 1;
	    index = input.indexOf(C_COMMA, lastIndex);
	  }
	
	  return values;
	}
	
	/* Compile an array to comma-separated tokens.
	 * `options.padLeft` (default: `true`) pads a space left of each
	 * token, and `options.padRight` (default: `false`) pads a space
	 * to the right of each token. */
	function stringify(values, options) {
	  var settings = options || {};
	  var left = settings.padLeft;
	
	  /* Ensure the last empty entry is seen. */
	  if (values[values.length - 1] === EMPTY) {
	    values = values.concat(EMPTY);
	  }
	
	  return trim(values.join(
	    (settings.padRight ? C_SPACE : EMPTY) +
	    C_COMMA +
	    (left || left === undefined || left === null ? C_SPACE : EMPTY)
	  ));
	}


/***/ }),
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */
	
	/*global window, navigator, document, require, process, module */
	(function (app) {
	  'use strict';
	  var namespace = 'cuid',
	    c = 0,
	    blockSize = 4,
	    base = 36,
	    discreteValues = Math.pow(base, blockSize),
	
	    pad = function pad(num, size) {
	      var s = "000000000" + num;
	      return s.substr(s.length-size);
	    },
	
	    randomBlock = function randomBlock() {
	      return pad((Math.random() *
	            discreteValues << 0)
	            .toString(base), blockSize);
	    },
	
	    safeCounter = function () {
	      c = (c < discreteValues) ? c : 0;
	      c++; // this is not subliminal
	      return c - 1;
	    },
	
	    api = function cuid() {
	      // Starting with a lowercase letter makes
	      // it HTML element ID friendly.
	      var letter = 'c', // hard-coded allows for sequential access
	
	        // timestamp
	        // warning: this exposes the exact date and time
	        // that the uid was created.
	        timestamp = (new Date().getTime()).toString(base),
	
	        // Prevent same-machine collisions.
	        counter,
	
	        // A few chars to generate distinct ids for different
	        // clients (so different computers are far less
	        // likely to generate the same id)
	        fingerprint = api.fingerprint(),
	
	        // Grab some more chars from Math.random()
	        random = randomBlock() + randomBlock();
	
	        counter = pad(safeCounter().toString(base), blockSize);
	
	      return  (letter + timestamp + counter + fingerprint + random);
	    };
	
	  api.slug = function slug() {
	    var date = new Date().getTime().toString(36),
	      counter,
	      print = api.fingerprint().slice(0,1) +
	        api.fingerprint().slice(-1),
	      random = randomBlock().slice(-2);
	
	      counter = safeCounter().toString(36).slice(-4);
	
	    return date.slice(-2) +
	      counter + print + random;
	  };
	
	  api.globalCount = function globalCount() {
	    // We want to cache the results of this
	    var cache = (function calc() {
	        var i,
	          count = 0;
	
	        for (i in window) {
	          count++;
	        }
	
	        return count;
	      }());
	
	    api.globalCount = function () { return cache; };
	    return cache;
	  };
	
	  api.fingerprint = function browserPrint() {
	    return pad((navigator.mimeTypes.length +
	      navigator.userAgent.length).toString(36) +
	      api.globalCount().toString(36), 4);
	  };
	
	  // don't change anything from here down.
	  if (app.register) {
	    app.register(namespace, api);
	  } else if (true) {
	    module.exports = api;
	  } else {
	    app[namespace] = api;
	  }
	
	}(this.applitude || this));


/***/ }),
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = __webpack_require__(111);
	var toPrimitive = __webpack_require__(491);
	
	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
	
	var $isNaN = __webpack_require__(242);
	var $isFinite = __webpack_require__(241);
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
	
	var assign = __webpack_require__(240);
	var sign = __webpack_require__(244);
	var mod = __webpack_require__(243);
	var isPrimitive = __webpack_require__(489);
	var parseInteger = parseInt;
	var bind = __webpack_require__(151);
	var arraySlice = bind.call(Function.call, Array.prototype.slice);
	var strSlice = bind.call(Function.call, String.prototype.slice);
	var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
	var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
	var regexExec = bind.call(Function.call, RegExp.prototype.exec);
	var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
	var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
	var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
	var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
	var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);
	
	// whitespace from: http://es5.github.io/#x15.5.4.20
	// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	var ws = [
		'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
		'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
		'\u2029\uFEFF'
	].join('');
	var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	var replace = bind.call(Function.call, String.prototype.replace);
	var trim = function (value) {
		return replace(value, trimRegex, '');
	};
	
	var ES5 = __webpack_require__(487);
	
	var hasRegExpMatcher = __webpack_require__(639);
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
	var ES6 = assign(assign({}, ES5), {
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
		Call: function Call(F, V) {
			var args = arguments.length > 2 ? arguments[2] : [];
			if (!this.IsCallable(F)) {
				throw new TypeError(F + ' is not a function');
			}
			return F.apply(V, args);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
		ToPrimitive: toPrimitive,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
		// ToBoolean: ES5.ToBoolean,
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
		ToNumber: function ToNumber(argument) {
			var value = isPrimitive(argument) ? argument : toPrimitive(argument, Number);
			if (typeof value === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a number');
			}
			if (typeof value === 'string') {
				if (isBinary(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 2));
				} else if (isOctal(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 8));
				} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
					return NaN;
				} else {
					var trimmed = trim(value);
					if (trimmed !== value) {
						return this.ToNumber(trimmed);
					}
				}
			}
			return Number(value);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
		// ToInteger: ES5.ToNumber,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
		// ToInt32: ES5.ToInt32,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
		// ToUint32: ES5.ToUint32,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
		ToInt16: function ToInt16(argument) {
			var int16bit = this.ToUint16(argument);
			return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
		// ToUint16: ES5.ToUint16,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
		ToInt8: function ToInt8(argument) {
			var int8bit = this.ToUint8(argument);
			return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
		ToUint8: function ToUint8(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x100);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
		ToUint8Clamp: function ToUint8Clamp(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number <= 0) { return 0; }
			if (number >= 0xFF) { return 0xFF; }
			var f = Math.floor(argument);
			if (f + 0.5 < number) { return f + 1; }
			if (number < f + 0.5) { return f; }
			if (f % 2 !== 0) { return f + 1; }
			return f;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
		ToString: function ToString(argument) {
			if (typeof argument === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a string');
			}
			return String(argument);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
		ToObject: function ToObject(value) {
			this.RequireObjectCoercible(value);
			return Object(value);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
		ToPropertyKey: function ToPropertyKey(argument) {
			var key = this.ToPrimitive(argument, String);
			return typeof key === 'symbol' ? key : this.ToString(key);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
		ToLength: function ToLength(argument) {
			var len = this.ToInteger(argument);
			if (len <= 0) { return 0; } // includes converting -0 to +0
			if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
			return len;
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
		CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
			if (toStr.call(argument) !== '[object String]') {
				throw new TypeError('must be a string');
			}
			if (argument === '-0') { return -0; }
			var n = this.ToNumber(argument);
			if (this.SameValue(this.ToString(n), argument)) { return n; }
			return void 0;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
		RequireObjectCoercible: ES5.CheckObjectCoercible,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
		IsArray: Array.isArray || function IsArray(argument) {
			return toStr.call(argument) === '[object Array]';
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
		// IsCallable: ES5.IsCallable,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
		IsConstructor: function IsConstructor(argument) {
			return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
		IsExtensible: function IsExtensible(obj) {
			if (!Object.preventExtensions) { return true; }
			if (isPrimitive(obj)) {
				return false;
			}
			return Object.isExtensible(obj);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
		IsInteger: function IsInteger(argument) {
			if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
				return false;
			}
			var abs = Math.abs(argument);
			return Math.floor(abs) === abs;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
		IsPropertyKey: function IsPropertyKey(argument) {
			return typeof argument === 'string' || typeof argument === 'symbol';
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
		IsRegExp: function IsRegExp(argument) {
			if (!argument || typeof argument !== 'object') {
				return false;
			}
			if (hasSymbols) {
				var isRegExp = argument[Symbol.match];
				if (typeof isRegExp !== 'undefined') {
					return ES5.ToBoolean(isRegExp);
				}
			}
			return hasRegExpMatcher(argument);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
		// SameValue: ES5.SameValue,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
		SameValueZero: function SameValueZero(x, y) {
			return (x === y) || ($isNaN(x) && $isNaN(y));
		},
	
		/**
		 * 7.3.2 GetV (V, P)
		 * 1. Assert: IsPropertyKey(P) is true.
		 * 2. Let O be ToObject(V).
		 * 3. ReturnIfAbrupt(O).
		 * 4. Return O.[[Get]](P, V).
		 */
		GetV: function GetV(V, P) {
			// 7.3.2.1
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
	
			// 7.3.2.2-3
			var O = this.ToObject(V);
	
			// 7.3.2.4
			return O[P];
		},
	
		/**
		 * 7.3.9 - http://www.ecma-international.org/ecma-262/6.0/#sec-getmethod
		 * 1. Assert: IsPropertyKey(P) is true.
		 * 2. Let func be GetV(O, P).
		 * 3. ReturnIfAbrupt(func).
		 * 4. If func is either undefined or null, return undefined.
		 * 5. If IsCallable(func) is false, throw a TypeError exception.
		 * 6. Return func.
		 */
		GetMethod: function GetMethod(O, P) {
			// 7.3.9.1
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
	
			// 7.3.9.2
			var func = this.GetV(O, P);
	
			// 7.3.9.4
			if (func == null) {
				return void 0;
			}
	
			// 7.3.9.5
			if (!this.IsCallable(func)) {
				throw new TypeError(P + 'is not a function');
			}
	
			// 7.3.9.6
			return func;
		},
	
		/**
		 * 7.3.1 Get (O, P) - http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p
		 * 1. Assert: Type(O) is Object.
		 * 2. Assert: IsPropertyKey(P) is true.
		 * 3. Return O.[[Get]](P, O).
		 */
		Get: function Get(O, P) {
			// 7.3.1.1
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			// 7.3.1.2
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
			// 7.3.1.3
			return O[P];
		},
	
		Type: function Type(x) {
			if (typeof x === 'symbol') {
				return 'Symbol';
			}
			return ES5.Type(x);
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
		SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			var C = O.constructor;
			if (typeof C === 'undefined') {
				return defaultConstructor;
			}
			if (this.Type(C) !== 'Object') {
				throw new TypeError('O.constructor is not an Object');
			}
			var S = hasSymbols && Symbol.species ? C[Symbol.species] : void 0;
			if (S == null) {
				return defaultConstructor;
			}
			if (this.IsConstructor(S)) {
				return S;
			}
			throw new TypeError('no constructor found');
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
		CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
			if (!this.IsPropertyDescriptor(Desc)) {
				throw new TypeError('Desc must be a Property Descriptor');
			}
	
			if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
				if (!has(Desc, '[[Value]]')) {
					Desc['[[Value]]'] = void 0;
				}
				if (!has(Desc, '[[Writable]]')) {
					Desc['[[Writable]]'] = false;
				}
			} else {
				if (!has(Desc, '[[Get]]')) {
					Desc['[[Get]]'] = void 0;
				}
				if (!has(Desc, '[[Set]]')) {
					Desc['[[Set]]'] = void 0;
				}
			}
			if (!has(Desc, '[[Enumerable]]')) {
				Desc['[[Enumerable]]'] = false;
			}
			if (!has(Desc, '[[Configurable]]')) {
				Desc['[[Configurable]]'] = false;
			}
			return Desc;
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
		Set: function Set(O, P, V, Throw) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('O must be an Object');
			}
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('P must be a Property Key');
			}
			if (this.Type(Throw) !== 'Boolean') {
				throw new TypeError('Throw must be a Boolean');
			}
			if (Throw) {
				O[P] = V;
				return true;
			} else {
				try {
					O[P] = V;
				} catch (e) {
					return false;
				}
			}
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
		HasOwnProperty: function HasOwnProperty(O, P) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('O must be an Object');
			}
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('P must be a Property Key');
			}
			return has(O, P);
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-hasproperty
		HasProperty: function HasProperty(O, P) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('O must be an Object');
			}
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('P must be a Property Key');
			}
			return P in O;
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
		IsConcatSpreadable: function IsConcatSpreadable(O) {
			if (this.Type(O) !== 'Object') {
				return false;
			}
			if (hasSymbols && typeof Symbol.isConcatSpreadable === 'symbol') {
				var spreadable = this.Get(O, Symbol.isConcatSpreadable);
				if (typeof spreadable !== 'undefined') {
					return this.ToBoolean(spreadable);
				}
			}
			return this.IsArray(O);
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-invoke
		Invoke: function Invoke(O, P) {
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('P must be a Property Key');
			}
			var argumentsList = arraySlice(arguments, 2);
			var func = this.GetV(O, P);
			return this.Call(func, O, argumentsList);
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
		CreateIterResultObject: function CreateIterResultObject(value, done) {
			if (this.Type(done) !== 'Boolean') {
				throw new TypeError('Assertion failed: Type(done) is not Boolean');
			}
			return {
				value: value,
				done: done
			};
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-regexpexec
		RegExpExec: function RegExpExec(R, S) {
			if (this.Type(R) !== 'Object') {
				throw new TypeError('R must be an Object');
			}
			if (this.Type(S) !== 'String') {
				throw new TypeError('S must be a String');
			}
			var exec = this.Get(R, 'exec');
			if (this.IsCallable(exec)) {
				var result = this.Call(exec, R, [S]);
				if (result === null || this.Type(result) === 'Object') {
					return result;
				}
				throw new TypeError('"exec" method must return `null` or an Object');
			}
			return regexExec(R, S);
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate
		ArraySpeciesCreate: function ArraySpeciesCreate(originalArray, length) {
			if (!this.IsInteger(length) || length < 0) {
				throw new TypeError('Assertion failed: length must be an integer >= 0');
			}
			var len = length === 0 ? 0 : length;
			var C;
			var isArray = this.IsArray(originalArray);
			if (isArray) {
				C = this.Get(originalArray, 'constructor');
				// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
				// if (this.IsConstructor(C)) {
				// 	if C is another realm's Array, C = undefined
				// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
				// }
				if (this.Type(C) === 'Object' && hasSymbols && Symbol.species) {
					C = this.Get(C, Symbol.species);
					if (C === null) {
						C = void 0;
					}
				}
			}
			if (typeof C === 'undefined') {
				return Array(len);
			}
			if (!this.IsConstructor(C)) {
				throw new TypeError('C must be a constructor');
			}
			return new C(len); // this.Construct(C, len);
		},
	
		CreateDataProperty: function CreateDataProperty(O, P, V) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
			var oldDesc = Object.getOwnPropertyDescriptor(O, P);
			var extensible = oldDesc || (typeof Object.isExtensible !== 'function' || Object.isExtensible(O));
			var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
			if (immutable || !extensible) {
				return false;
			}
			var newDesc = {
				configurable: true,
				enumerable: true,
				value: V,
				writable: true
			};
			Object.defineProperty(O, P, newDesc);
			return true;
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow
		CreateDataPropertyOrThrow: function CreateDataPropertyOrThrow(O, P, V) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
			var success = this.CreateDataProperty(O, P, V);
			if (!success) {
				throw new TypeError('unable to create data property');
			}
			return success;
		}
	});
	
	delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible
	
	module.exports = ES6;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ES2015 = __webpack_require__(485);
	var assign = __webpack_require__(240);
	
	var ES2016 = assign(assign({}, ES2015), {
		// https://github.com/tc39/ecma262/pull/60
		SameValueNonNumber: function SameValueNonNumber(x, y) {
			if (typeof x === 'number' || typeof x !== typeof y) {
				throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
			}
			return this.SameValue(x, y);
		}
	});
	
	module.exports = ES2016;


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $isNaN = __webpack_require__(242);
	var $isFinite = __webpack_require__(241);
	
	var sign = __webpack_require__(244);
	var mod = __webpack_require__(243);
	
	var IsCallable = __webpack_require__(172);
	var toPrimitive = __webpack_require__(490);
	
	var has = __webpack_require__(111);
	
	// https://es5.github.io/#x9
	var ES5 = {
		ToPrimitive: toPrimitive,
	
		ToBoolean: function ToBoolean(value) {
			return !!value;
		},
		ToNumber: function ToNumber(value) {
			return Number(value);
		},
		ToInteger: function ToInteger(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number)) { return 0; }
			if (number === 0 || !$isFinite(number)) { return number; }
			return sign(number) * Math.floor(Math.abs(number));
		},
		ToInt32: function ToInt32(x) {
			return this.ToNumber(x) >> 0;
		},
		ToUint32: function ToUint32(x) {
			return this.ToNumber(x) >>> 0;
		},
		ToUint16: function ToUint16(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x10000);
		},
		ToString: function ToString(value) {
			return String(value);
		},
		ToObject: function ToObject(value) {
			this.CheckObjectCoercible(value);
			return Object(value);
		},
		CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
			/* jshint eqnull:true */
			if (value == null) {
				throw new TypeError(optMessage || 'Cannot call method on ' + value);
			}
			return value;
		},
		IsCallable: IsCallable,
		SameValue: function SameValue(x, y) {
			if (x === y) { // 0 === -0, but they are not identical.
				if (x === 0) { return 1 / x === 1 / y; }
				return true;
			}
			return $isNaN(x) && $isNaN(y);
		},
	
		// http://www.ecma-international.org/ecma-262/5.1/#sec-8
		Type: function Type(x) {
			if (x === null) {
				return 'Null';
			}
			if (typeof x === 'undefined') {
				return 'Undefined';
			}
			if (typeof x === 'function' || typeof x === 'object') {
				return 'Object';
			}
			if (typeof x === 'number') {
				return 'Number';
			}
			if (typeof x === 'boolean') {
				return 'Boolean';
			}
			if (typeof x === 'string') {
				return 'String';
			}
		},
	
		// http://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
		IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
			if (this.Type(Desc) !== 'Object') {
				return false;
			}
			var allowed = {
				'[[Configurable]]': true,
				'[[Enumerable]]': true,
				'[[Get]]': true,
				'[[Set]]': true,
				'[[Value]]': true,
				'[[Writable]]': true
			};
			// jscs:disable
			for (var key in Desc) { // eslint-disable-line
				if (has(Desc, key) && !allowed[key]) {
					return false;
				}
			}
			// jscs:enable
			var isData = has(Desc, '[[Value]]');
			var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
			if (isData && IsAccessor) {
				throw new TypeError('Property Descriptors may not be both accessor and data descriptors');
			}
			return true;
		},
	
		// http://ecma-international.org/ecma-262/5.1/#sec-8.10.1
		IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
			if (typeof Desc === 'undefined') {
				return false;
			}
	
			if (!this.IsPropertyDescriptor(Desc)) {
				throw new TypeError('Desc must be a Property Descriptor');
			}
	
			if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
				return false;
			}
	
			return true;
		},
	
		// http://ecma-international.org/ecma-262/5.1/#sec-8.10.2
		IsDataDescriptor: function IsDataDescriptor(Desc) {
			if (typeof Desc === 'undefined') {
				return false;
			}
	
			if (!this.IsPropertyDescriptor(Desc)) {
				throw new TypeError('Desc must be a Property Descriptor');
			}
	
			if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
				return false;
			}
	
			return true;
		},
	
		// http://ecma-international.org/ecma-262/5.1/#sec-8.10.3
		IsGenericDescriptor: function IsGenericDescriptor(Desc) {
			if (typeof Desc === 'undefined') {
				return false;
			}
	
			if (!this.IsPropertyDescriptor(Desc)) {
				throw new TypeError('Desc must be a Property Descriptor');
			}
	
			if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
				return true;
			}
	
			return false;
		},
	
		// http://ecma-international.org/ecma-262/5.1/#sec-8.10.4
		FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
			if (typeof Desc === 'undefined') {
				return Desc;
			}
	
			if (!this.IsPropertyDescriptor(Desc)) {
				throw new TypeError('Desc must be a Property Descriptor');
			}
	
			if (this.IsDataDescriptor(Desc)) {
				return {
					value: Desc['[[Value]]'],
					writable: !!Desc['[[Writable]]'],
					enumerable: !!Desc['[[Enumerable]]'],
					configurable: !!Desc['[[Configurable]]']
				};
			} else if (this.IsAccessorDescriptor(Desc)) {
				return {
					get: Desc['[[Get]]'],
					set: Desc['[[Set]]'],
					enumerable: !!Desc['[[Enumerable]]'],
					configurable: !!Desc['[[Configurable]]']
				};
			} else {
				throw new TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
			}
		},
	
		// http://ecma-international.org/ecma-262/5.1/#sec-8.10.5
		ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
			if (this.Type(Obj) !== 'Object') {
				throw new TypeError('ToPropertyDescriptor requires an object');
			}
	
			var desc = {};
			if (has(Obj, 'enumerable')) {
				desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
			}
			if (has(Obj, 'configurable')) {
				desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
			}
			if (has(Obj, 'value')) {
				desc['[[Value]]'] = Obj.value;
			}
			if (has(Obj, 'writable')) {
				desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
			}
			if (has(Obj, 'get')) {
				var getter = Obj.get;
				if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
					throw new TypeError('getter must be a function');
				}
				desc['[[Get]]'] = getter;
			}
			if (has(Obj, 'set')) {
				var setter = Obj.set;
				if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
					throw new TypeError('setter must be a function');
				}
				desc['[[Set]]'] = setter;
			}
	
			if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
				throw new TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
			}
			return desc;
		}
	};
	
	module.exports = ES5;


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(486);


/***/ }),
/* 489 */
/***/ (function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var toStr = Object.prototype.toString;
	
	var isPrimitive = __webpack_require__(245);
	
	var isCallable = __webpack_require__(172);
	
	// https://es5.github.io/#x8.12
	var ES5internalSlots = {
		'[[DefaultValue]]': function (O, hint) {
			var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);
	
			if (actualHint === String || actualHint === Number) {
				var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
				var value, i;
				for (i = 0; i < methods.length; ++i) {
					if (isCallable(O[methods[i]])) {
						value = O[methods[i]]();
						if (isPrimitive(value)) {
							return value;
						}
					}
				}
				throw new TypeError('No default value');
			}
			throw new TypeError('invalid [[DefaultValue]] hint supplied');
		}
	};
	
	// https://es5.github.io/#x9
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
	};


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
	
	var isPrimitive = __webpack_require__(245);
	var isCallable = __webpack_require__(172);
	var isDate = __webpack_require__(636);
	var isSymbol = __webpack_require__(640);
	
	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
		if (typeof O === 'undefined' || O === null) {
			throw new TypeError('Cannot call method on ' + O);
		}
		if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
			throw new TypeError('hint must be "string" or "number"');
		}
		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
		var method, result, i;
		for (i = 0; i < methodNames.length; ++i) {
			method = O[methodNames[i]];
			if (isCallable(method)) {
				result = method.call(O);
				if (isPrimitive(result)) {
					return result;
				}
			}
		}
		throw new TypeError('No default value');
	};
	
	var GetMethod = function GetMethod(O, P) {
		var func = O[P];
		if (func !== null && typeof func !== 'undefined') {
			if (!isCallable(func)) {
				throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
			}
			return func;
		}
	};
	
	// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		var hint = 'default';
		if (arguments.length > 1) {
			if (PreferredType === String) {
				hint = 'string';
			} else if (PreferredType === Number) {
				hint = 'number';
			}
		}
	
		var exoticToPrim;
		if (hasSymbols) {
			if (Symbol.toPrimitive) {
				exoticToPrim = GetMethod(input, Symbol.toPrimitive);
			} else if (isSymbol(input)) {
				exoticToPrim = Symbol.prototype.valueOf;
			}
		}
		if (typeof exoticToPrim !== 'undefined') {
			var result = exoticToPrim.call(input, hint);
			if (isPrimitive(result)) {
				return result;
			}
			throw new TypeError('unable to convert exotic object to primitive');
		}
		if (hint === 'default' && (isDate(input) || isSymbol(input))) {
			hint = 'string';
		}
		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
	};


/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	(function (root, factory) {
	    'use strict';
	
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.
	
	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';
	
	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PlaceHolders,
	        Messages,
	        Regex,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        hasLineTerminator,
	        lastIndex,
	        lastLineNumber,
	        lastLineStart,
	        startIndex,
	        startLineNumber,
	        startLineStart,
	        scanning,
	        length,
	        lookahead,
	        state,
	        extra,
	        isBindingElement,
	        isAssignmentTarget,
	        firstCoverInitializedNameError;
	
	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };
	
	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';
	
	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];
	
	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForOfStatement: 'ForOfStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };
	
	    PlaceHolders = {
	        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
	    };
	
	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	        DefaultRestParameter: 'Unexpected token =',
	        ObjectPatternAsRestParameter: 'Unexpected token {',
	        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	        DuplicateConstructor: 'A class may only have one constructor',
	        StaticPrototype: 'Classes may not have static property named prototype',
	        MissingFromClause: 'Unexpected token',
	        NoAsAfterImportNamespace: 'Unexpected token',
	        InvalidModuleSpecifier: 'Unexpected token',
	        IllegalImportDeclaration: 'Unexpected token',
	        IllegalExportDeclaration: 'Unexpected token',
	        DuplicateBinding: 'Duplicate binding %0'
	    };
	
	    // See also tools/generate-unicode-regex.js.
	    Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };
	
	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.
	
	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }
	
	    function isDecimalDigit(ch) {
	        return (ch >= 0x30 && ch <= 0x39);   // 0..9
	    }
	
	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }
	
	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }
	
	    function octalToDecimal(ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);
	
	        if (index < length && isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + '01234567'.indexOf(source[index++]);
	
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 &&
	                    index < length &&
	                    isOctalDigit(source[index])) {
	                code = code * 8 + '01234567'.indexOf(source[index++]);
	            }
	        }
	
	        return {
	            code: code,
	            octal: octal
	        };
	    }
	
	    // ECMA-262 11.2 White Space
	
	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }
	
	    // ECMA-262 11.3 Line Terminators
	
	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }
	
	    // ECMA-262 11.6 Identifier Names and Identifiers
	
	    function fromCodePoint(cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    }
	
	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
	    }
	
	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
	    }
	
	    // ECMA-262 11.6.2.2 Future Reserved Words
	
	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'enum':
	        case 'export':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }
	
	    // ECMA-262 11.6.2.1 Keywords
	
	    function isKeyword(id) {
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }
	
	    // ECMA-262 11.4 Comments
	
	    function addComment(type, value, start, end, loc) {
	        var comment;
	
	        assert(typeof start === 'number', 'Comment must have valid position');
	
	        state.lastCommentStart = start;
	
	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	        if (extra.tokenize) {
	            comment.type = comment.type + 'Comment';
	            if (extra.delegate) {
	                comment = extra.delegate(comment);
	            }
	            extra.tokens.push(comment);
	        }
	    }
	
	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;
	
	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };
	
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }
	
	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }
	
	    function skipMultiLineComment() {
	        var start, loc, ch, comment;
	
	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }
	
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                hasLineTerminator = true;
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }
	
	        // Ran off the end of the file - the whole thing is a comment
	        if (extra.comments) {
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            comment = source.slice(start + 2, index);
	            addComment('Block', comment, start, index, loc);
	        }
	        tolerateUnexpectedToken();
	    }
	
	    function skipComment() {
	        var ch, start;
	        hasLineTerminator = false;
	
	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);
	
	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }
	
	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;
	
	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }
	
	    function scanUnicodeCodePointEscape() {
	        var ch, code;
	
	        ch = source[index];
	        code = 0;
	
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwUnexpectedToken();
	        }
	
	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }
	
	        if (code > 0x10FFFF || ch !== '}') {
	            throwUnexpectedToken();
	        }
	
	        return fromCodePoint(code);
	    }
	
	    function codePointAt(i) {
	        var cp, first, second;
	
	        cp = source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            second = source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	
	        return cp;
	    }
	
	    function getComplexIdentifier() {
	        var cp, ch, id;
	
	        cp = codePointAt(index);
	        id = fromCodePoint(cp);
	        index += id.length;
	
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (cp === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwUnexpectedToken();
	            }
	            ++index;
	            if (source[index] === '{') {
	                ++index;
	                ch = scanUnicodeCodePointEscape();
	            } else {
	                ch = scanHexEscape('u');
	                cp = ch.charCodeAt(0);
	                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
	                    throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	
	        while (index < length) {
	            cp = codePointAt(index);
	            if (!isIdentifierPart(cp)) {
	                break;
	            }
	            ch = fromCodePoint(cp);
	            id += ch;
	            index += ch.length;
	
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwUnexpectedToken();
	                }
	                ++index;
	                if (source[index] === '{') {
	                    ++index;
	                    ch = scanUnicodeCodePointEscape();
	                } else {
	                    ch = scanHexEscape('u');
	                    cp = ch.charCodeAt(0);
	                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
	                        throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	
	        return id;
	    }
	
	    function getIdentifier() {
	        var start, ch;
	
	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getComplexIdentifier();
	            } else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                index = start;
	                return getComplexIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }
	
	        return source.slice(start, index);
	    }
	
	    function scanIdentifier() {
	        var start, id, type;
	
	        start = index;
	
	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();
	
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }
	
	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	
	    // ECMA-262 11.7 Punctuators
	
	    function scanPunctuator() {
	        var token, str;
	
	        token = {
	            type: Token.Punctuator,
	            value: '',
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: index,
	            end: index
	        };
	
	        // Check for most common single-character punctuators.
	        str = source[index];
	        switch (str) {
	
	        case '(':
	            if (extra.tokenize) {
	                extra.openParenToken = extra.tokenValues.length;
	            }
	            ++index;
	            break;
	
	        case '{':
	            if (extra.tokenize) {
	                extra.openCurlyToken = extra.tokenValues.length;
	            }
	            state.curlyStack.push('{');
	            ++index;
	            break;
	
	        case '.':
	            ++index;
	            if (source[index] === '.' && source[index + 1] === '.') {
	                // Spread operator: ...
	                index += 2;
	                str = '...';
	            }
	            break;
	
	        case '}':
	            ++index;
	            state.curlyStack.pop();
	            break;
	        case ')':
	        case ';':
	        case ',':
	        case '[':
	        case ']':
	        case ':':
	        case '?':
	        case '~':
	            ++index;
	            break;
	
	        default:
	            // 4-character punctuator.
	            str = source.substr(index, 4);
	            if (str === '>>>=') {
	                index += 4;
	            } else {
	
	                // 3-character punctuators.
	                str = str.substr(0, 3);
	                if (str === '===' || str === '!==' || str === '>>>' ||
	                    str === '<<=' || str === '>>=') {
	                    index += 3;
	                } else {
	
	                    // 2-character punctuators.
	                    str = str.substr(0, 2);
	                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                        str === '<=' || str === '>=' || str === '=>') {
	                        index += 2;
	                    } else {
	
	                        // 1-character punctuators.
	                        str = source[index];
	                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                            ++index;
	                        }
	                    }
	                }
	            }
	        }
	
	        if (index === token.start) {
	            throwUnexpectedToken();
	        }
	
	        token.end = index;
	        token.value = str;
	        return token;
	    }
	
	    // ECMA-262 11.8.3 Numeric Literals
	
	    function scanHexLiteral(start) {
	        var number = '';
	
	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (number.length === 0) {
	            throwUnexpectedToken();
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function scanBinaryLiteral(start) {
	        var ch, number;
	
	        number = '';
	
	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (number.length === 0) {
	            // only 0b or 0B
	            throwUnexpectedToken();
	        }
	
	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwUnexpectedToken();
	            }
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function scanOctalLiteral(prefix, start) {
	        var number, octal;
	
	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }
	
	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwUnexpectedToken();
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function isImplicitOctalLiteral() {
	        var i, ch;
	
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }
	
	        return true;
	    }
	
	    function scanNumericLiteral() {
	        var number, start, ch;
	
	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');
	
	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];
	
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return scanOctalLiteral(ch, start);
	                }
	
	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }
	
	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }
	
	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];
	
	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwUnexpectedToken();
	            }
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.4 String Literals
	
	    function scanStringLiteral() {
	        var str = '', quote, start, ch, unescaped, octToDec, octal = false;
	
	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');
	
	        start = index;
	        ++index;
	
	        while (index < length) {
	            ch = source[index++];
	
	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            unescaped = scanHexEscape(ch);
	                            if (!unescaped) {
	                                throw throwUnexpectedToken();
	                            }
	                            str += unescaped;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;
	                    case '8':
	                    case '9':
	                        str += ch;
	                        tolerateUnexpectedToken();
	                        break;
	
	                    default:
	                        if (isOctalDigit(ch)) {
	                            octToDec = octalToDecimal(ch);
	
	                            octal = octToDec.octal || octal;
	                            str += String.fromCharCode(octToDec.code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }
	
	        if (quote !== '') {
	            index = start;
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: startLineNumber,
	            lineStart: startLineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.6 Template Literal Lexical Components
	
	    function scanTemplate() {
	        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;
	
	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');
	        rawOffset = 2;
	
	        ++index;
	
	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    state.curlyStack.push('${');
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;
	
	                    default:
	                        if (ch === '0') {
	                            if (isDecimalDigit(source.charCodeAt(index))) {
	                                // Illegal: \01 \02 and so on
	                                throwError(Messages.TemplateOctalLiteral);
	                            }
	                            cooked += '\0';
	                        } else if (isOctalDigit(ch)) {
	                            // Illegal: \1 \2
	                            throwError(Messages.TemplateOctalLiteral);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }
	
	        if (!terminated) {
	            throwUnexpectedToken();
	        }
	
	        if (!head) {
	            state.curlyStack.pop();
	        }
	
	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - rawOffset)
	            },
	            head: head,
	            tail: tail,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.5 Regular Expression Literals
	
	    function testRegExp(pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF',
	            tmp = pattern;
	
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                // Replace every Unicode escape sequence with the equivalent
	                // BMP character or a constant ASCII code point in the case of
	                // astral symbols. (See the above note on `astralSubstitute`
	                // for more information.)
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                    var codePoint = parseInt($1 || $2, 16);
	                    if (codePoint > 0x10FFFF) {
	                        throwUnexpectedToken(null, Messages.InvalidRegExp);
	                    }
	                    if (codePoint <= 0xFFFF) {
	                        return String.fromCharCode(codePoint);
	                    }
	                    return astralSubstitute;
	                })
	                // Replace each paired surrogate with a single ASCII symbol to
	                // avoid throwing on regular expressions that are only valid in
	                // combination with the "u" flag.
	                .replace(
	                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	                    astralSubstitute
	                );
	        }
	
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        } catch (e) {
	            throwUnexpectedToken(null, Messages.InvalidRegExp);
	        }
	
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    }
	
	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;
	
	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];
	
	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	
	        if (!terminated) {
	            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	        }
	
	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }
	
	    function scanRegExpFlags() {
	        var ch, str, flags, restore;
	
	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	
	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    tolerateUnexpectedToken();
	                } else {
	                    str += '\\';
	                    tolerateUnexpectedToken();
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }
	
	        return {
	            value: flags,
	            literal: str
	        };
	    }
	
	    function scanRegExp() {
	        var start, body, flags, value;
	        scanning = true;
	
	        lookahead = null;
	        skipComment();
	        start = index;
	
	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);
	        scanning = false;
	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }
	
	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            start: start,
	            end: index
	        };
	    }
	
	    function collectRegex() {
	        var pos, loc, regex, token;
	
	        skipComment();
	
	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };
	
	        regex = scanRegExp();
	
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };
	
	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }
	
	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }
	
	        return regex;
	    }
	
	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }
	
	    // Using the following algorithm:
	    // https://github.com/mozilla/sweet.js/wiki/design
	
	    function advanceSlash() {
	        var regex, previous, check;
	
	        function testKeyword(value) {
	            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
	        }
	
	        previous = extra.tokenValues[extra.tokenValues.length - 1];
	        regex = (previous !== null);
	
	        switch (previous) {
	        case 'this':
	        case ']':
	            regex = false;
	            break;
	
	        case ')':
	            check = extra.tokenValues[extra.openParenToken - 1];
	            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
	            break;
	
	        case '}':
	            // Dividing a function by anything makes little sense,
	            // but we have to check for that.
	            regex = false;
	            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
	                // Anonymous function, e.g. function(){} /42
	                check = extra.tokenValues[extra.openCurlyToken - 4];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
	            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
	                // Named function, e.g. function f(){} /42/
	                check = extra.tokenValues[extra.openCurlyToken - 5];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
	            }
	        }
	
	        return regex ? collectRegex() : scanPunctuator();
	    }
	
	    function advance() {
	        var cp, token;
	
	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }
	
	        cp = source.charCodeAt(index);
	
	        if (isIdentifierStart(cp)) {
	            token = scanIdentifier();
	            if (strict && isStrictModeReservedWord(token.value)) {
	                token.type = Token.Keyword;
	            }
	            return token;
	        }
	
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return scanPunctuator();
	        }
	
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return scanStringLiteral();
	        }
	
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }
	
	        if (isDecimalDigit(cp)) {
	            return scanNumericLiteral();
	        }
	
	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && cp === 0x2F) {
	            return advanceSlash();
	        }
	
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
	            return scanTemplate();
	        }
	
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            cp = codePointAt(index);
	            if (isIdentifierStart(cp)) {
	                return scanIdentifier();
	            }
	        }
	
	        return scanPunctuator();
	    }
	
	    function collectToken() {
	        var loc, token, value, entry;
	
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };
	
	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };
	
	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            if (extra.tokenValues) {
	                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
	            }
	            if (extra.tokenize) {
	                if (!extra.range) {
	                    delete entry.range;
	                }
	                if (!extra.loc) {
	                    delete entry.loc;
	                }
	                if (extra.delegate) {
	                    entry = extra.delegate(entry);
	                }
	            }
	            extra.tokens.push(entry);
	        }
	
	        return token;
	    }
	
	    function lex() {
	        var token;
	        scanning = true;
	
	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;
	
	        skipComment();
	
	        token = lookahead;
	
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	        return token;
	    }
	
	    function peek() {
	        scanning = true;
	
	        skipComment();
	
	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;
	
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	    }
	
	    function Position() {
	        this.line = startLineNumber;
	        this.column = startIndex - startLineStart;
	    }
	
	    function SourceLocation() {
	        this.start = new Position();
	        this.end = null;
	    }
	
	    function WrappingSourceLocation(startToken) {
	        this.start = {
	            line: startToken.lineNumber,
	            column: startToken.start - startToken.lineStart
	        };
	        this.end = null;
	    }
	
	    function Node() {
	        if (extra.range) {
	            this.range = [startIndex, 0];
	        }
	        if (extra.loc) {
	            this.loc = new SourceLocation();
	        }
	    }
	
	    function WrappingNode(startToken) {
	        if (extra.range) {
	            this.range = [startToken.start, 0];
	        }
	        if (extra.loc) {
	            this.loc = new WrappingSourceLocation(startToken);
	        }
	    }
	
	    WrappingNode.prototype = Node.prototype = {
	
	        processComment: function () {
	            var lastChild,
	                innerComments,
	                leadingComments,
	                trailingComments,
	                bottomRight = extra.bottomRightStack,
	                i,
	                comment,
	                last = bottomRight[bottomRight.length - 1];
	
	            if (this.type === Syntax.Program) {
	                if (this.body.length > 0) {
	                    return;
	                }
	            }
	            /**
	             * patch innnerComments for properties empty block
	             * `function a() {/** comments **\/}`
	             */
	
	            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
	                innerComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (this.range[1] >= comment.range[1]) {
	                        innerComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                if (innerComments.length) {
	                    this.innerComments = innerComments;
	                    //bottomRight.push(this);
	                    return;
	                }
	            }
	
	            if (extra.trailingComments.length > 0) {
	                trailingComments = [];
	                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
	                    comment = extra.trailingComments[i];
	                    if (comment.range[0] >= this.range[1]) {
	                        trailingComments.unshift(comment);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                extra.trailingComments = [];
	            } else {
	                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
	                    trailingComments = last.trailingComments;
	                    delete last.trailingComments;
	                }
	            }
	
	            // Eating the stack.
	            while (last && last.range[0] >= this.range[0]) {
	                lastChild = bottomRight.pop();
	                last = bottomRight[bottomRight.length - 1];
	            }
	
	            if (lastChild) {
	                if (lastChild.leadingComments) {
	                    leadingComments = [];
	                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
	                        comment = lastChild.leadingComments[i];
	                        if (comment.range[1] <= this.range[0]) {
	                            leadingComments.unshift(comment);
	                            lastChild.leadingComments.splice(i, 1);
	                        }
	                    }
	
	                    if (!lastChild.leadingComments.length) {
	                        lastChild.leadingComments = undefined;
	                    }
	                }
	            } else if (extra.leadingComments.length > 0) {
	                leadingComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (comment.range[1] <= this.range[0]) {
	                        leadingComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                    }
	                }
	            }
	
	
	            if (leadingComments && leadingComments.length > 0) {
	                this.leadingComments = leadingComments;
	            }
	            if (trailingComments && trailingComments.length > 0) {
	                this.trailingComments = trailingComments;
	            }
	
	            bottomRight.push(this);
	        },
	
	        finish: function () {
	            if (extra.range) {
	                this.range[1] = lastIndex;
	            }
	            if (extra.loc) {
	                this.loc.end = {
	                    line: lastLineNumber,
	                    column: lastIndex - lastLineStart
	                };
	                if (extra.source) {
	                    this.loc.source = extra.source;
	                }
	            }
	
	            if (extra.attachComment) {
	                this.processComment();
	            }
	        },
	
	        finishArrayExpression: function (elements) {
	            this.type = Syntax.ArrayExpression;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },
	
	        finishArrayPattern: function (elements) {
	            this.type = Syntax.ArrayPattern;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },
	
	        finishArrowFunctionExpression: function (params, defaults, body, expression) {
	            this.type = Syntax.ArrowFunctionExpression;
	            this.id = null;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },
	
	        finishAssignmentExpression: function (operator, left, right) {
	            this.type = Syntax.AssignmentExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishAssignmentPattern: function (left, right) {
	            this.type = Syntax.AssignmentPattern;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishBinaryExpression: function (operator, left, right) {
	            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishBlockStatement: function (body) {
	            this.type = Syntax.BlockStatement;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishBreakStatement: function (label) {
	            this.type = Syntax.BreakStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },
	
	        finishCallExpression: function (callee, args) {
	            this.type = Syntax.CallExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },
	
	        finishCatchClause: function (param, body) {
	            this.type = Syntax.CatchClause;
	            this.param = param;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassBody: function (body) {
	            this.type = Syntax.ClassBody;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassDeclaration: function (id, superClass, body) {
	            this.type = Syntax.ClassDeclaration;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassExpression: function (id, superClass, body) {
	            this.type = Syntax.ClassExpression;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishConditionalExpression: function (test, consequent, alternate) {
	            this.type = Syntax.ConditionalExpression;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },
	
	        finishContinueStatement: function (label) {
	            this.type = Syntax.ContinueStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },
	
	        finishDebuggerStatement: function () {
	            this.type = Syntax.DebuggerStatement;
	            this.finish();
	            return this;
	        },
	
	        finishDoWhileStatement: function (body, test) {
	            this.type = Syntax.DoWhileStatement;
	            this.body = body;
	            this.test = test;
	            this.finish();
	            return this;
	        },
	
	        finishEmptyStatement: function () {
	            this.type = Syntax.EmptyStatement;
	            this.finish();
	            return this;
	        },
	
	        finishExpressionStatement: function (expression) {
	            this.type = Syntax.ExpressionStatement;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },
	
	        finishForStatement: function (init, test, update, body) {
	            this.type = Syntax.ForStatement;
	            this.init = init;
	            this.test = test;
	            this.update = update;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishForOfStatement: function (left, right, body) {
	            this.type = Syntax.ForOfStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishForInStatement: function (left, right, body) {
	            this.type = Syntax.ForInStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.each = false;
	            this.finish();
	            return this;
	        },
	
	        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionDeclaration;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },
	
	        finishFunctionExpression: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionExpression;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },
	
	        finishIdentifier: function (name) {
	            this.type = Syntax.Identifier;
	            this.name = name;
	            this.finish();
	            return this;
	        },
	
	        finishIfStatement: function (test, consequent, alternate) {
	            this.type = Syntax.IfStatement;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },
	
	        finishLabeledStatement: function (label, body) {
	            this.type = Syntax.LabeledStatement;
	            this.label = label;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishLiteral: function (token) {
	            this.type = Syntax.Literal;
	            this.value = token.value;
	            this.raw = source.slice(token.start, token.end);
	            if (token.regex) {
	                this.regex = token.regex;
	            }
	            this.finish();
	            return this;
	        },
	
	        finishMemberExpression: function (accessor, object, property) {
	            this.type = Syntax.MemberExpression;
	            this.computed = accessor === '[';
	            this.object = object;
	            this.property = property;
	            this.finish();
	            return this;
	        },
	
	        finishMetaProperty: function (meta, property) {
	            this.type = Syntax.MetaProperty;
	            this.meta = meta;
	            this.property = property;
	            this.finish();
	            return this;
	        },
	
	        finishNewExpression: function (callee, args) {
	            this.type = Syntax.NewExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },
	
	        finishObjectExpression: function (properties) {
	            this.type = Syntax.ObjectExpression;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },
	
	        finishObjectPattern: function (properties) {
	            this.type = Syntax.ObjectPattern;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },
	
	        finishPostfixExpression: function (operator, argument) {
	            this.type = Syntax.UpdateExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = false;
	            this.finish();
	            return this;
	        },
	
	        finishProgram: function (body, sourceType) {
	            this.type = Syntax.Program;
	            this.body = body;
	            this.sourceType = sourceType;
	            this.finish();
	            return this;
	        },
	
	        finishProperty: function (kind, key, computed, value, method, shorthand) {
	            this.type = Syntax.Property;
	            this.key = key;
	            this.computed = computed;
	            this.value = value;
	            this.kind = kind;
	            this.method = method;
	            this.shorthand = shorthand;
	            this.finish();
	            return this;
	        },
	
	        finishRestElement: function (argument) {
	            this.type = Syntax.RestElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishReturnStatement: function (argument) {
	            this.type = Syntax.ReturnStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishSequenceExpression: function (expressions) {
	            this.type = Syntax.SequenceExpression;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },
	
	        finishSpreadElement: function (argument) {
	            this.type = Syntax.SpreadElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishSwitchCase: function (test, consequent) {
	            this.type = Syntax.SwitchCase;
	            this.test = test;
	            this.consequent = consequent;
	            this.finish();
	            return this;
	        },
	
	        finishSuper: function () {
	            this.type = Syntax.Super;
	            this.finish();
	            return this;
	        },
	
	        finishSwitchStatement: function (discriminant, cases) {
	            this.type = Syntax.SwitchStatement;
	            this.discriminant = discriminant;
	            this.cases = cases;
	            this.finish();
	            return this;
	        },
	
	        finishTaggedTemplateExpression: function (tag, quasi) {
	            this.type = Syntax.TaggedTemplateExpression;
	            this.tag = tag;
	            this.quasi = quasi;
	            this.finish();
	            return this;
	        },
	
	        finishTemplateElement: function (value, tail) {
	            this.type = Syntax.TemplateElement;
	            this.value = value;
	            this.tail = tail;
	            this.finish();
	            return this;
	        },
	
	        finishTemplateLiteral: function (quasis, expressions) {
	            this.type = Syntax.TemplateLiteral;
	            this.quasis = quasis;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },
	
	        finishThisExpression: function () {
	            this.type = Syntax.ThisExpression;
	            this.finish();
	            return this;
	        },
	
	        finishThrowStatement: function (argument) {
	            this.type = Syntax.ThrowStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishTryStatement: function (block, handler, finalizer) {
	            this.type = Syntax.TryStatement;
	            this.block = block;
	            this.guardedHandlers = [];
	            this.handlers = handler ? [handler] : [];
	            this.handler = handler;
	            this.finalizer = finalizer;
	            this.finish();
	            return this;
	        },
	
	        finishUnaryExpression: function (operator, argument) {
	            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = true;
	            this.finish();
	            return this;
	        },
	
	        finishVariableDeclaration: function (declarations) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = 'var';
	            this.finish();
	            return this;
	        },
	
	        finishLexicalDeclaration: function (declarations, kind) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = kind;
	            this.finish();
	            return this;
	        },
	
	        finishVariableDeclarator: function (id, init) {
	            this.type = Syntax.VariableDeclarator;
	            this.id = id;
	            this.init = init;
	            this.finish();
	            return this;
	        },
	
	        finishWhileStatement: function (test, body) {
	            this.type = Syntax.WhileStatement;
	            this.test = test;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishWithStatement: function (object, body) {
	            this.type = Syntax.WithStatement;
	            this.object = object;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishExportSpecifier: function (local, exported) {
	            this.type = Syntax.ExportSpecifier;
	            this.exported = exported || local;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishImportDefaultSpecifier: function (local) {
	            this.type = Syntax.ImportDefaultSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishImportNamespaceSpecifier: function (local) {
	            this.type = Syntax.ImportNamespaceSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishExportNamedDeclaration: function (declaration, specifiers, src) {
	            this.type = Syntax.ExportNamedDeclaration;
	            this.declaration = declaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishExportDefaultDeclaration: function (declaration) {
	            this.type = Syntax.ExportDefaultDeclaration;
	            this.declaration = declaration;
	            this.finish();
	            return this;
	        },
	
	        finishExportAllDeclaration: function (src) {
	            this.type = Syntax.ExportAllDeclaration;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishImportSpecifier: function (local, imported) {
	            this.type = Syntax.ImportSpecifier;
	            this.local = local || imported;
	            this.imported = imported;
	            this.finish();
	            return this;
	        },
	
	        finishImportDeclaration: function (specifiers, src) {
	            this.type = Syntax.ImportDeclaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishYieldExpression: function (argument, delegate) {
	            this.type = Syntax.YieldExpression;
	            this.argument = argument;
	            this.delegate = delegate;
	            this.finish();
	            return this;
	        }
	    };
	
	
	    function recordError(error) {
	        var e, existing;
	
	        for (e = 0; e < extra.errors.length; e++) {
	            existing = extra.errors[e];
	            // Prevent duplicated error.
	            /* istanbul ignore next */
	            if (existing.index === error.index && existing.message === error.message) {
	                return;
	            }
	        }
	
	        extra.errors.push(error);
	    }
	
	    function constructError(msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        } catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        } finally {
	            return error;
	        }
	    }
	
	    function createError(line, pos, description) {
	        var msg, column, error;
	
	        msg = 'Line ' + line + ': ' + description;
	        column = pos - (scanning ? lineStart : lastLineStart) + 1;
	        error = constructError(msg, column);
	        error.lineNumber = line;
	        error.description = description;
	        error.index = pos;
	        return error;
	    }
	
	    // Throw an exception
	
	    function throwError(messageFormat) {
	        var args, msg;
	
	        args = Array.prototype.slice.call(arguments, 1);
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );
	
	        throw createError(lastLineNumber, lastIndex, msg);
	    }
	
	    function tolerateError(messageFormat) {
	        var args, msg, error;
	
	        args = Array.prototype.slice.call(arguments, 1);
	        /* istanbul ignore next */
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );
	
	        error = createError(lineNumber, lastIndex, msg);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }
	
	    // Throw an exception because of the token.
	
	    function unexpectedTokenError(token, message) {
	        var value, msg = message || Messages.UnexpectedToken;
	
	        if (token) {
	            if (!message) {
	                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
	                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
	                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
	                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
	                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
	                    Messages.UnexpectedToken;
	
	                if (token.type === Token.Keyword) {
	                    if (isFutureReservedWord(token.value)) {
	                        msg = Messages.UnexpectedReserved;
	                    } else if (strict && isStrictModeReservedWord(token.value)) {
	                        msg = Messages.StrictReservedWord;
	                    }
	                }
	            }
	
	            value = (token.type === Token.Template) ? token.value.raw : token.value;
	        } else {
	            value = 'ILLEGAL';
	        }
	
	        msg = msg.replace('%0', value);
	
	        return (token && typeof token.lineNumber === 'number') ?
	            createError(token.lineNumber, token.start, msg) :
	            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
	    }
	
	    function throwUnexpectedToken(token, message) {
	        throw unexpectedTokenError(token, message);
	    }
	
	    function tolerateUnexpectedToken(token, message) {
	        var error = unexpectedTokenError(token, message);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }
	
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	
	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpectedToken(token);
	        }
	    }
	
	    /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */
	    function expectCommaSeparator() {
	        var token;
	
	        if (extra.errors) {
	            token = lookahead;
	            if (token.type === Token.Punctuator && token.value === ',') {
	                lex();
	            } else if (token.type === Token.Punctuator && token.value === ';') {
	                lex();
	                tolerateUnexpectedToken(token);
	            } else {
	                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
	            }
	        } else {
	            expect(',');
	        }
	    }
	
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	
	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpectedToken(token);
	        }
	    }
	
	    // Return true if the next token matches the specified punctuator.
	
	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }
	
	    // Return true if the next token matches the specified keyword
	
	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }
	
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	
	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }
	
	    // Return true if the next token is an assignment operator
	
	    function matchAssign() {
	        var op;
	
	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }
	
	    function consumeSemicolon() {
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
	            lex();
	            return;
	        }
	
	        if (hasLineTerminator) {
	            return;
	        }
	
	        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	        lastIndex = startIndex;
	        lastLineNumber = startLineNumber;
	        lastLineStart = startLineStart;
	
	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpectedToken(lookahead);
	        }
	    }
	
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    function isolateCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        if (firstCoverInitializedNameError !== null) {
	            throwUnexpectedToken(firstCoverInitializedNameError);
	        }
	        isBindingElement = oldIsBindingElement;
	        isAssignmentTarget = oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
	        return result;
	    }
	
	    function inheritCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        isBindingElement = isBindingElement && oldIsBindingElement;
	        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
	        return result;
	    }
	
	    // ECMA-262 13.3.3 Destructuring Binding Patterns
	
	    function parseArrayPattern(params, kind) {
	        var node = new Node(), elements = [], rest, restNode;
	        expect('[');
	
	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                if (match('...')) {
	                    restNode = new Node();
	                    lex();
	                    params.push(lookahead);
	                    rest = parseVariableIdentifier(kind);
	                    elements.push(restNode.finishRestElement(rest));
	                    break;
	                } else {
	                    elements.push(parsePatternWithDefault(params, kind));
	                }
	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	
	        }
	
	        expect(']');
	
	        return node.finishArrayPattern(elements);
	    }
	
	    function parsePropertyPattern(params, kind) {
	        var node = new Node(), key, keyToken, computed = match('['), init;
	        if (lookahead.type === Token.Identifier) {
	            keyToken = lookahead;
	            key = parseVariableIdentifier();
	            if (match('=')) {
	                params.push(keyToken);
	                lex();
	                init = parseAssignmentExpression();
	
	                return node.finishProperty(
	                    'init', key, false,
	                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);
	            } else if (!match(':')) {
	                params.push(keyToken);
	                return node.finishProperty('init', key, false, key, false, true);
	            }
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        expect(':');
	        init = parsePatternWithDefault(params, kind);
	        return node.finishProperty('init', key, computed, init, false, false);
	    }
	
	    function parseObjectPattern(params, kind) {
	        var node = new Node(), properties = [];
	
	        expect('{');
	
	        while (!match('}')) {
	            properties.push(parsePropertyPattern(params, kind));
	            if (!match('}')) {
	                expect(',');
	            }
	        }
	
	        lex();
	
	        return node.finishObjectPattern(properties);
	    }
	
	    function parsePattern(params, kind) {
	        if (match('[')) {
	            return parseArrayPattern(params, kind);
	        } else if (match('{')) {
	            return parseObjectPattern(params, kind);
	        } else if (matchKeyword('let')) {
	            if (kind === 'const' || kind === 'let') {
	                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
	            }
	        }
	
	        params.push(lookahead);
	        return parseVariableIdentifier(kind);
	    }
	
	    function parsePatternWithDefault(params, kind) {
	        var startToken = lookahead, pattern, previousAllowYield, right;
	        pattern = parsePattern(params, kind);
	        if (match('=')) {
	            lex();
	            previousAllowYield = state.allowYield;
	            state.allowYield = true;
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowYield = previousAllowYield;
	            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
	        }
	        return pattern;
	    }
	
	    // ECMA-262 12.2.5 Array Initializer
	
	    function parseArrayInitializer() {
	        var elements = [], node = new Node(), restSpread;
	
	        expect('[');
	
	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else if (match('...')) {
	                restSpread = new Node();
	                lex();
	                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));
	
	                if (!match(']')) {
	                    isAssignmentTarget = isBindingElement = false;
	                    expect(',');
	                }
	                elements.push(restSpread);
	            } else {
	                elements.push(inheritCoverGrammar(parseAssignmentExpression));
	
	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }
	
	        lex();
	
	        return node.finishArrayExpression(elements);
	    }
	
	    // ECMA-262 12.2.6 Object Initializer
	
	    function parsePropertyFunction(node, paramInfo, isGenerator) {
	        var previousStrict, body;
	
	        isAssignmentTarget = isBindingElement = false;
	
	        previousStrict = strict;
	        body = isolateCoverGrammar(parseFunctionSourceElements);
	
	        if (strict && paramInfo.firstRestricted) {
	            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
	        }
	        if (strict && paramInfo.stricted) {
	            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
	        }
	
	        strict = previousStrict;
	        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
	    }
	
	    function parsePropertyMethodFunction() {
	        var params, method, node = new Node(),
	            previousAllowYield = state.allowYield;
	
	        state.allowYield = false;
	        params = parseParams();
	        state.allowYield = previousAllowYield;
	
	        state.allowYield = false;
	        method = parsePropertyFunction(node, params, false);
	        state.allowYield = previousAllowYield;
	
	        return method;
	    }
	
	    function parseObjectPropertyKey() {
	        var token, node = new Node(), expr;
	
	        token = lex();
	
	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.
	
	        switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
	            }
	            return node.finishLiteral(token);
	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return node.finishIdentifier(token.value);
	        case Token.Punctuator:
	            if (token.value === '[') {
	                expr = isolateCoverGrammar(parseAssignmentExpression);
	                expect(']');
	                return expr;
	            }
	            break;
	        }
	        throwUnexpectedToken(token);
	    }
	
	    function lookaheadPropertyName() {
	        switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === '[';
	        }
	        return false;
	    }
	
	    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	    // This can only be determined after we consumed up to the left parentheses.
	    //
	    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	    // is responsible to visit other options.
	    function tryParseMethodDefinition(token, key, computed, node) {
	        var value, options, methodNode, params,
	            previousAllowYield = state.allowYield;
	
	        if (token.type === Token.Identifier) {
	            // check for `get` and `set`;
	
	            if (token.value === 'get' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	                expect(')');
	
	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, {
	                    params: [],
	                    defaults: [],
	                    stricted: null,
	                    firstRestricted: null,
	                    message: null
	                }, false);
	                state.allowYield = previousAllowYield;
	
	                return node.finishProperty('get', key, computed, value, false, false);
	            } else if (token.value === 'set' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	
	                options = {
	                    params: [],
	                    defaultCount: 0,
	                    defaults: [],
	                    firstRestricted: null,
	                    paramSet: {}
	                };
	                if (match(')')) {
	                    tolerateUnexpectedToken(lookahead);
	                } else {
	                    state.allowYield = false;
	                    parseParam(options);
	                    state.allowYield = previousAllowYield;
	                    if (options.defaultCount === 0) {
	                        options.defaults = [];
	                    }
	                }
	                expect(')');
	
	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, options, false);
	                state.allowYield = previousAllowYield;
	
	                return node.finishProperty('set', key, computed, value, false, false);
	            }
	        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
	            computed = match('[');
	            key = parseObjectPropertyKey();
	            methodNode = new Node();
	
	            state.allowYield = true;
	            params = parseParams();
	            state.allowYield = previousAllowYield;
	
	            state.allowYield = false;
	            value = parsePropertyFunction(methodNode, params, true);
	            state.allowYield = previousAllowYield;
	
	            return node.finishProperty('init', key, computed, value, true, false);
	        }
	
	        if (key && match('(')) {
	            value = parsePropertyMethodFunction();
	            return node.finishProperty('init', key, computed, value, true, false);
	        }
	
	        // Not a MethodDefinition.
	        return null;
	    }
	
	    function parseObjectProperty(hasProto) {
	        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;
	
	        computed = match('[');
	        if (match('*')) {
	            lex();
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
	        if (maybeMethod) {
	            return maybeMethod;
	        }
	
	        if (!key) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        // Check for duplicated __proto__
	        if (!computed) {
	            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
	                (key.type === Syntax.Literal && key.value === '__proto__');
	            if (hasProto.value && proto) {
	                tolerateError(Messages.DuplicateProtoProperty);
	            }
	            hasProto.value |= proto;
	        }
	
	        if (match(':')) {
	            lex();
	            value = inheritCoverGrammar(parseAssignmentExpression);
	            return node.finishProperty('init', key, computed, value, false, false);
	        }
	
	        if (token.type === Token.Identifier) {
	            if (match('=')) {
	                firstCoverInitializedNameError = lookahead;
	                lex();
	                value = isolateCoverGrammar(parseAssignmentExpression);
	                return node.finishProperty('init', key, computed,
	                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
	            }
	            return node.finishProperty('init', key, computed, key, false, true);
	        }
	
	        throwUnexpectedToken(lookahead);
	    }
	
	    function parseObjectInitializer() {
	        var properties = [], hasProto = {value: false}, node = new Node();
	
	        expect('{');
	
	        while (!match('}')) {
	            properties.push(parseObjectProperty(hasProto));
	
	            if (!match('}')) {
	                expectCommaSeparator();
	            }
	        }
	
	        expect('}');
	
	        return node.finishObjectExpression(properties);
	    }
	
	    function reinterpretExpressionAsPattern(expr) {
	        var i;
	        switch (expr.type) {
	        case Syntax.Identifier:
	        case Syntax.MemberExpression:
	        case Syntax.RestElement:
	        case Syntax.AssignmentPattern:
	            break;
	        case Syntax.SpreadElement:
	            expr.type = Syntax.RestElement;
	            reinterpretExpressionAsPattern(expr.argument);
	            break;
	        case Syntax.ArrayExpression:
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0; i < expr.elements.length; i++) {
	                if (expr.elements[i] !== null) {
	                    reinterpretExpressionAsPattern(expr.elements[i]);
	                }
	            }
	            break;
	        case Syntax.ObjectExpression:
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0; i < expr.properties.length; i++) {
	                reinterpretExpressionAsPattern(expr.properties[i].value);
	            }
	            break;
	        case Syntax.AssignmentExpression:
	            expr.type = Syntax.AssignmentPattern;
	            reinterpretExpressionAsPattern(expr.left);
	            break;
	        default:
	            // Allow other node type for tolerant parsing.
	            break;
	        }
	    }
	
	    // ECMA-262 12.2.9 Template Literals
	
	    function parseTemplateElement(option) {
	        var node, token;
	
	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwUnexpectedToken();
	        }
	
	        node = new Node();
	        token = lex();
	
	        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
	    }
	
	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, node = new Node();
	
	        quasi = parseTemplateElement({ head: true });
	        quasis = [quasi];
	        expressions = [];
	
	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }
	
	        return node.finishTemplateLiteral(quasis, expressions);
	    }
	
	    // ECMA-262 12.2.10 The Grouping Operator
	
	    function parseGroupExpression() {
	        var expr, expressions, startToken, i, params = [];
	
	        expect('(');
	
	        if (match(')')) {
	            lex();
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [],
	                rawParams: []
	            };
	        }
	
	        startToken = lookahead;
	        if (match('...')) {
	            expr = parseRestElement(params);
	            expect(')');
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [expr]
	            };
	        }
	
	        isBindingElement = true;
	        expr = inheritCoverGrammar(parseAssignmentExpression);
	
	        if (match(',')) {
	            isAssignmentTarget = false;
	            expressions = [expr];
	
	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	
	                if (match('...')) {
	                    if (!isBindingElement) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    expressions.push(parseRestElement(params));
	                    expect(')');
	                    if (!match('=>')) {
	                        expect('=>');
	                    }
	                    isBindingElement = false;
	                    for (i = 0; i < expressions.length; i++) {
	                        reinterpretExpressionAsPattern(expressions[i]);
	                    }
	                    return {
	                        type: PlaceHolders.ArrowParameterPlaceHolder,
	                        params: expressions
	                    };
	                }
	
	                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
	            }
	
	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }
	
	
	        expect(')');
	
	        if (match('=>')) {
	            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
	                return {
	                    type: PlaceHolders.ArrowParameterPlaceHolder,
	                    params: [expr]
	                };
	            }
	
	            if (!isBindingElement) {
	                throwUnexpectedToken(lookahead);
	            }
	
	            if (expr.type === Syntax.SequenceExpression) {
	                for (i = 0; i < expr.expressions.length; i++) {
	                    reinterpretExpressionAsPattern(expr.expressions[i]);
	                }
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }
	
	            expr = {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
	            };
	        }
	        isBindingElement = false;
	        return expr;
	    }
	
	
	    // ECMA-262 12.2 Primary Expressions
	
	    function parsePrimaryExpression() {
	        var type, token, expr, node;
	
	        if (match('(')) {
	            isBindingElement = false;
	            return inheritCoverGrammar(parseGroupExpression);
	        }
	
	        if (match('[')) {
	            return inheritCoverGrammar(parseArrayInitializer);
	        }
	
	        if (match('{')) {
	            return inheritCoverGrammar(parseObjectInitializer);
	        }
	
	        type = lookahead.type;
	        node = new Node();
	
	        if (type === Token.Identifier) {
	            if (state.sourceType === 'module' && lookahead.value === 'await') {
	                tolerateUnexpectedToken(lookahead);
	            }
	            expr = node.finishIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            if (strict && lookahead.octal) {
	                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = node.finishLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (!strict && state.allowYield && matchKeyword('yield')) {
	                return parseNonComputedProperty();
	            }
	            if (!strict && matchKeyword('let')) {
	                return node.finishIdentifier(lex().value);
	            }
	            isAssignmentTarget = isBindingElement = false;
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                return node.finishThisExpression();
	            }
	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }
	            throwUnexpectedToken(lex());
	        } else if (type === Token.BooleanLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = node.finishLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = null;
	            expr = node.finishLiteral(token);
	        } else if (match('/') || match('/=')) {
	            isAssignmentTarget = isBindingElement = false;
	            index = startIndex;
	
	            if (typeof extra.tokens !== 'undefined') {
	                token = collectRegex();
	            } else {
	                token = scanRegExp();
	            }
	            lex();
	            expr = node.finishLiteral(token);
	        } else if (type === Token.Template) {
	            expr = parseTemplateLiteral();
	        } else {
	            throwUnexpectedToken(lex());
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.3 Left-Hand-Side Expressions
	
	    function parseArguments() {
	        var args = [], expr;
	
	        expect('(');
	
	        if (!match(')')) {
	            while (startIndex < length) {
	                if (match('...')) {
	                    expr = new Node();
	                    lex();
	                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
	                } else {
	                    expr = isolateCoverGrammar(parseAssignmentExpression);
	                }
	                args.push(expr);
	                if (match(')')) {
	                    break;
	                }
	                expectCommaSeparator();
	            }
	        }
	
	        expect(')');
	
	        return args;
	    }
	
	    function parseNonComputedProperty() {
	        var token, node = new Node();
	
	        token = lex();
	
	        if (!isIdentifierName(token)) {
	            throwUnexpectedToken(token);
	        }
	
	        return node.finishIdentifier(token.value);
	    }
	
	    function parseNonComputedMember() {
	        expect('.');
	
	        return parseNonComputedProperty();
	    }
	
	    function parseComputedMember() {
	        var expr;
	
	        expect('[');
	
	        expr = isolateCoverGrammar(parseExpression);
	
	        expect(']');
	
	        return expr;
	    }
	
	    // ECMA-262 12.3.3 The new Operator
	
	    function parseNewExpression() {
	        var callee, args, node = new Node();
	
	        expectKeyword('new');
	
	        if (match('.')) {
	            lex();
	            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
	                if (state.inFunctionBody) {
	                    lex();
	                    return node.finishMetaProperty('new', 'target');
	                }
	            }
	            throwUnexpectedToken(lookahead);
	        }
	
	        callee = isolateCoverGrammar(parseLeftHandSideExpression);
	        args = match('(') ? parseArguments() : [];
	
	        isAssignmentTarget = isBindingElement = false;
	
	        return node.finishNewExpression(callee, args);
	    }
	
	    // ECMA-262 12.3.4 Function Calls
	
	    function parseLeftHandSideExpressionAllowCall() {
	        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;
	
	        startToken = lookahead;
	        state.allowIn = true;
	
	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('(') && !match('.') && !match('[')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }
	
	        for (;;) {
	            if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                isBindingElement = false;
	                isAssignmentTarget = false;
	                args = parseArguments();
	                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	            } else if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        state.allowIn = previousAllowIn;
	
	        return expr;
	    }
	
	    // ECMA-262 12.3 Left-Hand-Side Expressions
	
	    function parseLeftHandSideExpression() {
	        var quasi, expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');
	
	        startToken = lookahead;
	
	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('[') && !match('.')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }
	
	        for (;;) {
	            if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        return expr;
	    }
	
	    // ECMA-262 12.4 Postfix Expressions
	
	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;
	
	        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);
	
	        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
	            if (match('++') || match('--')) {
	                // ECMA-262 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    tolerateError(Messages.StrictLHSPostfix);
	                }
	
	                if (!isAssignmentTarget) {
	                    tolerateError(Messages.InvalidLHSInAssignment);
	                }
	
	                isAssignmentTarget = isBindingElement = false;
	
	                token = lex();
	                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
	            }
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.5 Unary Operators
	
	    function parseUnaryExpression() {
	        var token, expr, startToken;
	
	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            // ECMA-262 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateError(Messages.StrictLHSPrefix);
	            }
	
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                tolerateError(Messages.StrictDelete);
	            }
	            isAssignmentTarget = isBindingElement = false;
	        } else {
	            expr = parsePostfixExpression();
	        }
	
	        return expr;
	    }
	
	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;
	
	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }
	
	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;
	
	        case '&&':
	            prec = 2;
	            break;
	
	        case '|':
	            prec = 3;
	            break;
	
	        case '^':
	            prec = 4;
	            break;
	
	        case '&':
	            prec = 5;
	            break;
	
	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;
	
	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;
	
	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;
	
	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;
	
	        case '+':
	        case '-':
	            prec = 9;
	            break;
	
	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;
	
	        default:
	            break;
	        }
	
	        return prec;
	    }
	
	    // ECMA-262 12.6 Multiplicative Operators
	    // ECMA-262 12.7 Additive Operators
	    // ECMA-262 12.8 Bitwise Shift Operators
	    // ECMA-262 12.9 Relational Operators
	    // ECMA-262 12.10 Equality Operators
	    // ECMA-262 12.11 Binary Bitwise Operators
	    // ECMA-262 12.12 Binary Logical Operators
	
	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;
	
	        marker = lookahead;
	        left = inheritCoverGrammar(parseUnaryExpression);
	
	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        isAssignmentTarget = isBindingElement = false;
	        token.prec = prec;
	        lex();
	
	        markers = [marker, lookahead];
	        right = isolateCoverGrammar(parseUnaryExpression);
	
	        stack = [left, token, right];
	
	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
	
	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                markers.pop();
	                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	                stack.push(expr);
	            }
	
	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = isolateCoverGrammar(parseUnaryExpression);
	            stack.push(expr);
	        }
	
	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	        }
	
	        return expr;
	    }
	
	
	    // ECMA-262 12.13 Conditional Operator
	
	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;
	
	        startToken = lookahead;
	
	        expr = inheritCoverGrammar(parseBinaryExpression);
	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = isolateCoverGrammar(parseAssignmentExpression);
	
	            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	            isAssignmentTarget = isBindingElement = false;
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 14.2 Arrow Function Definitions
	
	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return isolateCoverGrammar(parseAssignmentExpression);
	    }
	
	    function checkPatternParam(options, param) {
	        var i;
	        switch (param.type) {
	        case Syntax.Identifier:
	            validateParam(options, param, param.name);
	            break;
	        case Syntax.RestElement:
	            checkPatternParam(options, param.argument);
	            break;
	        case Syntax.AssignmentPattern:
	            checkPatternParam(options, param.left);
	            break;
	        case Syntax.ArrayPattern:
	            for (i = 0; i < param.elements.length; i++) {
	                if (param.elements[i] !== null) {
	                    checkPatternParam(options, param.elements[i]);
	                }
	            }
	            break;
	        case Syntax.YieldExpression:
	            break;
	        default:
	            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
	            for (i = 0; i < param.properties.length; i++) {
	                checkPatternParam(options, param.properties[i].value);
	            }
	            break;
	        }
	    }
	    function reinterpretAsCoverFormalsList(expr) {
	        var i, len, param, params, defaults, defaultCount, options, token;
	
	        defaults = [];
	        defaultCount = 0;
	        params = [expr];
	
	        switch (expr.type) {
	        case Syntax.Identifier:
	            break;
	        case PlaceHolders.ArrowParameterPlaceHolder:
	            params = expr.params;
	            break;
	        default:
	            return null;
	        }
	
	        options = {
	            paramSet: {}
	        };
	
	        for (i = 0, len = params.length; i < len; i += 1) {
	            param = params[i];
	            switch (param.type) {
	            case Syntax.AssignmentPattern:
	                params[i] = param.left;
	                if (param.right.type === Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    param.right.type = Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	                defaults.push(param.right);
	                ++defaultCount;
	                checkPatternParam(options, param.left);
	                break;
	            default:
	                checkPatternParam(options, param);
	                params[i] = param;
	                defaults.push(null);
	                break;
	            }
	        }
	
	        if (strict || !state.allowYield) {
	            for (i = 0, len = params.length; i < len; i += 1) {
	                param = params[i];
	                if (param.type === Syntax.YieldExpression) {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	
	        if (options.message === Messages.StrictParamDupe) {
	            token = strict ? options.stricted : options.firstRestricted;
	            throwUnexpectedToken(token, options.message);
	        }
	
	        if (defaultCount === 0) {
	            defaults = [];
	        }
	
	        return {
	            params: params,
	            defaults: defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }
	
	    function parseArrowFunctionExpression(options, node) {
	        var previousStrict, previousAllowYield, body;
	
	        if (hasLineTerminator) {
	            tolerateUnexpectedToken(lookahead);
	        }
	        expect('=>');
	
	        previousStrict = strict;
	        previousAllowYield = state.allowYield;
	        state.allowYield = true;
	
	        body = parseConciseBody();
	
	        if (strict && options.firstRestricted) {
	            throwUnexpectedToken(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            tolerateUnexpectedToken(options.stricted, options.message);
	        }
	
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
	    }
	
	    // ECMA-262 14.4 Yield expression
	
	    function parseYieldExpression() {
	        var argument, expr, delegate, previousAllowYield;
	
	        argument = null;
	        expr = new Node();
	        delegate = false;
	
	        expectKeyword('yield');
	
	        if (!hasLineTerminator) {
	            previousAllowYield = state.allowYield;
	            state.allowYield = false;
	            delegate = match('*');
	            if (delegate) {
	                lex();
	                argument = parseAssignmentExpression();
	            } else {
	                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
	                    argument = parseAssignmentExpression();
	                }
	            }
	            state.allowYield = previousAllowYield;
	        }
	
	        return expr.finishYieldExpression(argument, delegate);
	    }
	
	    // ECMA-262 12.14 Assignment Operators
	
	    function parseAssignmentExpression() {
	        var token, expr, right, list, startToken;
	
	        startToken = lookahead;
	        token = lookahead;
	
	        if (!state.allowYield && matchKeyword('yield')) {
	            return parseYieldExpression();
	        }
	
	        expr = parseConditionalExpression();
	
	        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
	            isAssignmentTarget = isBindingElement = false;
	            list = reinterpretAsCoverFormalsList(expr);
	
	            if (list) {
	                firstCoverInitializedNameError = null;
	                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
	            }
	
	            return expr;
	        }
	
	        if (matchAssign()) {
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	
	            // ECMA-262 12.1.1
	            if (strict && expr.type === Syntax.Identifier) {
	                if (isRestrictedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
	                }
	                if (isStrictModeReservedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	                }
	            }
	
	            if (!match('=')) {
	                isAssignmentTarget = isBindingElement = false;
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }
	
	            token = lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
	            firstCoverInitializedNameError = null;
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.15 Comma Operator
	
	    function parseExpression() {
	        var expr, startToken = lookahead, expressions;
	
	        expr = isolateCoverGrammar(parseAssignmentExpression);
	
	        if (match(',')) {
	            expressions = [expr];
	
	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
	            }
	
	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 13.2 Block
	
	    function parseStatementListItem() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case 'import':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case 'const':
	                return parseLexicalDeclaration({inFor: false});
	            case 'function':
	                return parseFunctionDeclaration(new Node());
	            case 'class':
	                return parseClassDeclaration();
	            }
	        }
	
	        if (matchKeyword('let') && isLexicalDeclaration()) {
	            return parseLexicalDeclaration({inFor: false});
	        }
	
	        return parseStatement();
	    }
	
	    function parseStatementList() {
	        var list = [];
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            list.push(parseStatementListItem());
	        }
	
	        return list;
	    }
	
	    function parseBlock() {
	        var block, node = new Node();
	
	        expect('{');
	
	        block = parseStatementList();
	
	        expect('}');
	
	        return node.finishBlockStatement(block);
	    }
	
	    // ECMA-262 13.3.2 Variable Statement
	
	    function parseVariableIdentifier(kind) {
	        var token, node = new Node();
	
	        token = lex();
	
	        if (token.type === Token.Keyword && token.value === 'yield') {
	            if (strict) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } if (!state.allowYield) {
	                throwUnexpectedToken(token);
	            }
	        } else if (token.type !== Token.Identifier) {
	            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } else {
	                if (strict || token.value !== 'let' || kind !== 'var') {
	                    throwUnexpectedToken(token);
	                }
	            }
	        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
	            tolerateUnexpectedToken(token);
	        }
	
	        return node.finishIdentifier(token.value);
	    }
	
	    function parseVariableDeclaration(options) {
	        var init = null, id, node = new Node(), params = [];
	
	        id = parsePattern(params, 'var');
	
	        // ECMA-262 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }
	
	        if (match('=')) {
	            lex();
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        } else if (id.type !== Syntax.Identifier && !options.inFor) {
	            expect('=');
	        }
	
	        return node.finishVariableDeclarator(id, init);
	    }
	
	    function parseVariableDeclarationList(options) {
	        var opt, list;
	
	        opt = { inFor: options.inFor };
	        list = [parseVariableDeclaration(opt)];
	
	        while (match(',')) {
	            lex();
	            list.push(parseVariableDeclaration(opt));
	        }
	
	        return list;
	    }
	
	    function parseVariableStatement(node) {
	        var declarations;
	
	        expectKeyword('var');
	
	        declarations = parseVariableDeclarationList({ inFor: false });
	
	        consumeSemicolon();
	
	        return node.finishVariableDeclaration(declarations);
	    }
	
	    // ECMA-262 13.3.1 Let and Const Declarations
	
	    function parseLexicalBinding(kind, options) {
	        var init = null, id, node = new Node(), params = [];
	
	        id = parsePattern(params, kind);
	
	        // ECMA-262 12.2.1
	        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }
	
	        if (kind === 'const') {
	            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
	                expect('=');
	                init = isolateCoverGrammar(parseAssignmentExpression);
	            }
	        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
	            expect('=');
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        }
	
	        return node.finishVariableDeclarator(id, init);
	    }
	
	    function parseBindingList(kind, options) {
	        var list = [parseLexicalBinding(kind, options)];
	
	        while (match(',')) {
	            lex();
	            list.push(parseLexicalBinding(kind, options));
	        }
	
	        return list;
	    }
	
	
	    function tokenizerState() {
	        return {
	            index: index,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            hasLineTerminator: hasLineTerminator,
	            lastIndex: lastIndex,
	            lastLineNumber: lastLineNumber,
	            lastLineStart: lastLineStart,
	            startIndex: startIndex,
	            startLineNumber: startLineNumber,
	            startLineStart: startLineStart,
	            lookahead: lookahead,
	            tokenCount: extra.tokens ? extra.tokens.length : 0
	        };
	    }
	
	    function resetTokenizerState(ts) {
	        index = ts.index;
	        lineNumber = ts.lineNumber;
	        lineStart = ts.lineStart;
	        hasLineTerminator = ts.hasLineTerminator;
	        lastIndex = ts.lastIndex;
	        lastLineNumber = ts.lastLineNumber;
	        lastLineStart = ts.lastLineStart;
	        startIndex = ts.startIndex;
	        startLineNumber = ts.startLineNumber;
	        startLineStart = ts.startLineStart;
	        lookahead = ts.lookahead;
	        if (extra.tokens) {
	            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
	        }
	    }
	
	    function isLexicalDeclaration() {
	        var lexical, ts;
	
	        ts = tokenizerState();
	
	        lex();
	        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
	            matchKeyword('let') || matchKeyword('yield');
	
	        resetTokenizerState(ts);
	
	        return lexical;
	    }
	
	    function parseLexicalDeclaration(options) {
	        var kind, declarations, node = new Node();
	
	        kind = lex().value;
	        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	
	        declarations = parseBindingList(kind, options);
	
	        consumeSemicolon();
	
	        return node.finishLexicalDeclaration(declarations, kind);
	    }
	
	    function parseRestElement(params) {
	        var param, node = new Node();
	
	        lex();
	
	        if (match('{')) {
	            throwError(Messages.ObjectPatternAsRestParameter);
	        }
	
	        params.push(lookahead);
	
	        param = parseVariableIdentifier();
	
	        if (match('=')) {
	            throwError(Messages.DefaultRestParameter);
	        }
	
	        if (!match(')')) {
	            throwError(Messages.ParameterAfterRestParameter);
	        }
	
	        return node.finishRestElement(param);
	    }
	
	    // ECMA-262 13.4 Empty Statement
	
	    function parseEmptyStatement(node) {
	        expect(';');
	        return node.finishEmptyStatement();
	    }
	
	    // ECMA-262 12.4 Expression Statement
	
	    function parseExpressionStatement(node) {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return node.finishExpressionStatement(expr);
	    }
	
	    // ECMA-262 13.6 If statement
	
	    function parseIfStatement(node) {
	        var test, consequent, alternate;
	
	        expectKeyword('if');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        consequent = parseStatement();
	
	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }
	
	        return node.finishIfStatement(test, consequent, alternate);
	    }
	
	    // ECMA-262 13.7 Iteration Statements
	
	    function parseDoWhileStatement(node) {
	        var body, test, oldInIteration;
	
	        expectKeyword('do');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = parseStatement();
	
	        state.inIteration = oldInIteration;
	
	        expectKeyword('while');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        if (match(';')) {
	            lex();
	        }
	
	        return node.finishDoWhileStatement(body, test);
	    }
	
	    function parseWhileStatement(node) {
	        var test, body, oldInIteration;
	
	        expectKeyword('while');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = parseStatement();
	
	        state.inIteration = oldInIteration;
	
	        return node.finishWhileStatement(test, body);
	    }
	
	    function parseForStatement(node) {
	        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
	            body, oldInIteration, previousAllowIn = state.allowIn;
	
	        init = test = update = null;
	        forIn = true;
	
	        expectKeyword('for');
	
	        expect('(');
	
	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var')) {
	                init = new Node();
	                lex();
	
	                state.allowIn = false;
	                declarations = parseVariableDeclarationList({ inFor: true });
	                state.allowIn = previousAllowIn;
	
	                if (declarations.length === 1 && matchKeyword('in')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    init = init.finishVariableDeclaration(declarations);
	                    expect(';');
	                }
	            } else if (matchKeyword('const') || matchKeyword('let')) {
	                init = new Node();
	                kind = lex().value;
	
	                if (!strict && lookahead.value === 'in') {
	                    init = init.finishIdentifier(kind);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    state.allowIn = false;
	                    declarations = parseBindingList(kind, {inFor: true});
	                    state.allowIn = previousAllowIn;
	
	                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseExpression();
	                        init = null;
	                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    } else {
	                        consumeSemicolon();
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                    }
	                }
	            } else {
	                initStartToken = lookahead;
	                state.allowIn = false;
	                init = inheritCoverGrammar(parseAssignmentExpression);
	                state.allowIn = previousAllowIn;
	
	                if (matchKeyword('in')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForIn);
	                    }
	
	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (matchContextualKeyword('of')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForLoop);
	                    }
	
	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    if (match(',')) {
	                        initSeq = [init];
	                        while (match(',')) {
	                            lex();
	                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
	                        }
	                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
	                    }
	                    expect(';');
	                }
	            }
	        }
	
	        if (typeof left === 'undefined') {
	
	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');
	
	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }
	
	        expect(')');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = isolateCoverGrammar(parseStatement);
	
	        state.inIteration = oldInIteration;
	
	        return (typeof left === 'undefined') ?
	                node.finishForStatement(init, test, update, body) :
	                forIn ? node.finishForInStatement(left, right, body) :
	                    node.finishForOfStatement(left, right, body);
	    }
	
	    // ECMA-262 13.8 The continue statement
	
	    function parseContinueStatement(node) {
	        var label = null, key;
	
	        expectKeyword('continue');
	
	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(startIndex) === 0x3B) {
	            lex();
	
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }
	
	            return node.finishContinueStatement(null);
	        }
	
	        if (hasLineTerminator) {
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }
	
	            return node.finishContinueStatement(null);
	        }
	
	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();
	
	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }
	
	        consumeSemicolon();
	
	        if (label === null && !state.inIteration) {
	            throwError(Messages.IllegalContinue);
	        }
	
	        return node.finishContinueStatement(label);
	    }
	
	    // ECMA-262 13.9 The break statement
	
	    function parseBreakStatement(node) {
	        var label = null, key;
	
	        expectKeyword('break');
	
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(lastIndex) === 0x3B) {
	            lex();
	
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	
	            return node.finishBreakStatement(null);
	        }
	
	        if (hasLineTerminator) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	        } else if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();
	
	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }
	
	        consumeSemicolon();
	
	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError(Messages.IllegalBreak);
	        }
	
	        return node.finishBreakStatement(label);
	    }
	
	    // ECMA-262 13.10 The return statement
	
	    function parseReturnStatement(node) {
	        var argument = null;
	
	        expectKeyword('return');
	
	        if (!state.inFunctionBody) {
	            tolerateError(Messages.IllegalReturn);
	        }
	
	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(lastIndex) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return node.finishReturnStatement(argument);
	            }
	        }
	
	        if (hasLineTerminator) {
	            // HACK
	            return node.finishReturnStatement(null);
	        }
	
	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }
	
	        consumeSemicolon();
	
	        return node.finishReturnStatement(argument);
	    }
	
	    // ECMA-262 13.11 The with statement
	
	    function parseWithStatement(node) {
	        var object, body;
	
	        if (strict) {
	            tolerateError(Messages.StrictModeWith);
	        }
	
	        expectKeyword('with');
	
	        expect('(');
	
	        object = parseExpression();
	
	        expect(')');
	
	        body = parseStatement();
	
	        return node.finishWithStatement(object, body);
	    }
	
	    // ECMA-262 13.12 The switch statement
	
	    function parseSwitchCase() {
	        var test, consequent = [], statement, node = new Node();
	
	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');
	
	        while (startIndex < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatementListItem();
	            consequent.push(statement);
	        }
	
	        return node.finishSwitchCase(test, consequent);
	    }
	
	    function parseSwitchStatement(node) {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;
	
	        expectKeyword('switch');
	
	        expect('(');
	
	        discriminant = parseExpression();
	
	        expect(')');
	
	        expect('{');
	
	        cases = [];
	
	        if (match('}')) {
	            lex();
	            return node.finishSwitchStatement(discriminant, cases);
	        }
	
	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;
	
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError(Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	
	        state.inSwitch = oldInSwitch;
	
	        expect('}');
	
	        return node.finishSwitchStatement(discriminant, cases);
	    }
	
	    // ECMA-262 13.14 The throw statement
	
	    function parseThrowStatement(node) {
	        var argument;
	
	        expectKeyword('throw');
	
	        if (hasLineTerminator) {
	            throwError(Messages.NewlineAfterThrow);
	        }
	
	        argument = parseExpression();
	
	        consumeSemicolon();
	
	        return node.finishThrowStatement(argument);
	    }
	
	    // ECMA-262 13.15 The try statement
	
	    function parseCatchClause() {
	        var param, params = [], paramMap = {}, key, i, body, node = new Node();
	
	        expectKeyword('catch');
	
	        expect('(');
	        if (match(')')) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        param = parsePattern(params);
	        for (i = 0; i < params.length; i++) {
	            key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                tolerateError(Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	
	        // ECMA-262 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            tolerateError(Messages.StrictCatchVariable);
	        }
	
	        expect(')');
	        body = parseBlock();
	        return node.finishCatchClause(param, body);
	    }
	
	    function parseTryStatement(node) {
	        var block, handler = null, finalizer = null;
	
	        expectKeyword('try');
	
	        block = parseBlock();
	
	        if (matchKeyword('catch')) {
	            handler = parseCatchClause();
	        }
	
	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }
	
	        if (!handler && !finalizer) {
	            throwError(Messages.NoCatchOrFinally);
	        }
	
	        return node.finishTryStatement(block, handler, finalizer);
	    }
	
	    // ECMA-262 13.16 The debugger statement
	
	    function parseDebuggerStatement(node) {
	        expectKeyword('debugger');
	
	        consumeSemicolon();
	
	        return node.finishDebuggerStatement();
	    }
	
	    // 13 Statements
	
	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            node;
	
	        if (type === Token.EOF) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }
	        isAssignmentTarget = isBindingElement = true;
	        node = new Node();
	
	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement(node);
	            case '(':
	                return parseExpressionStatement(node);
	            default:
	                break;
	            }
	        } else if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement(node);
	            case 'continue':
	                return parseContinueStatement(node);
	            case 'debugger':
	                return parseDebuggerStatement(node);
	            case 'do':
	                return parseDoWhileStatement(node);
	            case 'for':
	                return parseForStatement(node);
	            case 'function':
	                return parseFunctionDeclaration(node);
	            case 'if':
	                return parseIfStatement(node);
	            case 'return':
	                return parseReturnStatement(node);
	            case 'switch':
	                return parseSwitchStatement(node);
	            case 'throw':
	                return parseThrowStatement(node);
	            case 'try':
	                return parseTryStatement(node);
	            case 'var':
	                return parseVariableStatement(node);
	            case 'while':
	                return parseWhileStatement(node);
	            case 'with':
	                return parseWithStatement(node);
	            default:
	                break;
	            }
	        }
	
	        expr = parseExpression();
	
	        // ECMA-262 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();
	
	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.Redeclaration, 'Label', expr.name);
	            }
	
	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return node.finishLabeledStatement(expr, labeledBody);
	        }
	
	        consumeSemicolon();
	
	        return node.finishExpressionStatement(expr);
	    }
	
	    // ECMA-262 14.1 Function Definition
	
	    function parseFunctionSourceElements() {
	        var statement, body = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
	            node = new Node();
	
	        expect('{');
	
	        while (startIndex < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;
	
	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	
	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;
	
	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;
	
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            body.push(parseStatementListItem());
	        }
	
	        expect('}');
	
	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;
	
	        return node.finishBlockStatement(body);
	    }
	
	    function validateParam(options, param, name) {
	        var key = '$' + name;
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet[key] = true;
	    }
	
	    function parseParam(options) {
	        var token, param, params = [], i, def;
	
	        token = lookahead;
	        if (token.value === '...') {
	            param = parseRestElement(params);
	            validateParam(options, param.argument, param.argument.name);
	            options.params.push(param);
	            options.defaults.push(null);
	            return false;
	        }
	
	        param = parsePatternWithDefault(params);
	        for (i = 0; i < params.length; i++) {
	            validateParam(options, params[i], params[i].value);
	        }
	
	        if (param.type === Syntax.AssignmentPattern) {
	            def = param.right;
	            param = param.left;
	            ++options.defaultCount;
	        }
	
	        options.params.push(param);
	        options.defaults.push(def);
	
	        return !match(')');
	    }
	
	    function parseParams(firstRestricted) {
	        var options;
	
	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            firstRestricted: firstRestricted
	        };
	
	        expect('(');
	
	        if (!match(')')) {
	            options.paramSet = {};
	            while (startIndex < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }
	
	        expect(')');
	
	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }
	
	        return {
	            params: options.params,
	            defaults: options.defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }
	
	    function parseFunctionDeclaration(node, identifierIsOptional) {
	        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
	            isGenerator, previousAllowYield;
	
	        previousAllowYield = state.allowYield;
	
	        expectKeyword('function');
	
	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }
	
	        if (!identifierIsOptional || !match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }
	
	        state.allowYield = !isGenerator;
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }
	
	
	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
	    }
	
	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp,
	            params = [], defaults = [], body, previousStrict, node = new Node(),
	            isGenerator, previousAllowYield;
	
	        previousAllowYield = state.allowYield;
	
	        expectKeyword('function');
	
	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }
	
	        state.allowYield = !isGenerator;
	        if (!match('(')) {
	            token = lookahead;
	            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }
	
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }
	
	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
	    }
	
	    // ECMA-262 14.5 Class Definitions
	
	    function parseClassBody() {
	        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;
	
	        classBody = new Node();
	
	        expect('{');
	        body = [];
	        while (!match('}')) {
	            if (match(';')) {
	                lex();
	            } else {
	                method = new Node();
	                token = lookahead;
	                isStatic = false;
	                computed = match('[');
	                if (match('*')) {
	                    lex();
	                } else {
	                    key = parseObjectPropertyKey();
	                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
	                        token = lookahead;
	                        isStatic = true;
	                        computed = match('[');
	                        if (match('*')) {
	                            lex();
	                        } else {
	                            key = parseObjectPropertyKey();
	                        }
	                    }
	                }
	                method = tryParseMethodDefinition(token, key, computed, method);
	                if (method) {
	                    method['static'] = isStatic; // jscs:ignore requireDotNotation
	                    if (method.kind === 'init') {
	                        method.kind = 'method';
	                    }
	                    if (!isStatic) {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
	                            if (method.kind !== 'method' || !method.method || method.value.generator) {
	                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
	                            }
	                            if (hasConstructor) {
	                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
	                            } else {
	                                hasConstructor = true;
	                            }
	                            method.kind = 'constructor';
	                        }
	                    } else {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
	                            throwUnexpectedToken(token, Messages.StaticPrototype);
	                        }
	                    }
	                    method.type = Syntax.MethodDefinition;
	                    delete method.method;
	                    delete method.shorthand;
	                    body.push(method);
	                } else {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	        lex();
	        return classBody.finishClassBody(body);
	    }
	
	    function parseClassDeclaration(identifierIsOptional) {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;
	
	        expectKeyword('class');
	
	        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }
	
	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;
	
	        return classNode.finishClassDeclaration(id, superClass, classBody);
	    }
	
	    function parseClassExpression() {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;
	
	        expectKeyword('class');
	
	        if (lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }
	
	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;
	
	        return classNode.finishClassExpression(id, superClass, classBody);
	    }
	
	    // ECMA-262 15.2 Modules
	
	    function parseModuleSpecifier() {
	        var node = new Node();
	
	        if (lookahead.type !== Token.StringLiteral) {
	            throwError(Messages.InvalidModuleSpecifier);
	        }
	        return node.finishLiteral(lex());
	    }
	
	    // ECMA-262 15.2.3 Exports
	
	    function parseExportSpecifier() {
	        var exported, local, node = new Node(), def;
	        if (matchKeyword('default')) {
	            // export {default} from 'something';
	            def = new Node();
	            lex();
	            local = def.finishIdentifier('default');
	        } else {
	            local = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            exported = parseNonComputedProperty();
	        }
	        return node.finishExportSpecifier(local, exported);
	    }
	
	    function parseExportNamedDeclaration(node) {
	        var declaration = null,
	            isExportFromIdentifier,
	            src = null, specifiers = [];
	
	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = parseLexicalDeclaration({inFor: false});
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = parseStatementListItem();
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	            }
	        }
	
	        expect('{');
	        while (!match('}')) {
	            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	            specifiers.push(parseExportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	
	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from 'foo';
	            // export {foo} from 'foo';
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return node.finishExportNamedDeclaration(declaration, specifiers, src);
	    }
	
	    function parseExportDefaultDeclaration(node) {
	        var declaration = null,
	            expression = null;
	
	        // covers:
	        // export default ...
	        expectKeyword('default');
	
	        if (matchKeyword('function')) {
	            // covers:
	            // export default function foo () {}
	            // export default function () {}
	            declaration = parseFunctionDeclaration(new Node(), true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	        if (matchKeyword('class')) {
	            declaration = parseClassDeclaration(true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	
	        if (matchContextualKeyword('from')) {
	            throwError(Messages.UnexpectedToken, lookahead.value);
	        }
	
	        // covers:
	        // export default {};
	        // export default [];
	        // export default (1 + 2);
	        if (match('{')) {
	            expression = parseObjectInitializer();
	        } else if (match('[')) {
	            expression = parseArrayInitializer();
	        } else {
	            expression = parseAssignmentExpression();
	        }
	        consumeSemicolon();
	        return node.finishExportDefaultDeclaration(expression);
	    }
	
	    function parseExportAllDeclaration(node) {
	        var src;
	
	        // covers:
	        // export * from 'foo';
	        expect('*');
	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();
	
	        return node.finishExportAllDeclaration(src);
	    }
	
	    function parseExportDeclaration() {
	        var node = new Node();
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalExportDeclaration);
	        }
	
	        expectKeyword('export');
	
	        if (matchKeyword('default')) {
	            return parseExportDefaultDeclaration(node);
	        }
	        if (match('*')) {
	            return parseExportAllDeclaration(node);
	        }
	        return parseExportNamedDeclaration(node);
	    }
	
	    // ECMA-262 15.2.2 Imports
	
	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var local, imported, node = new Node();
	
	        imported = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            local = parseVariableIdentifier();
	        }
	
	        return node.finishImportSpecifier(local, imported);
	    }
	
	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        while (!match('}')) {
	            specifiers.push(parseImportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	        return specifiers;
	    }
	
	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var local, node = new Node();
	
	        local = parseNonComputedProperty();
	
	        return node.finishImportDefaultSpecifier(local);
	    }
	
	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var local, node = new Node();
	
	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError(Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        local = parseNonComputedProperty();
	
	        return node.finishImportNamespaceSpecifier(local);
	    }
	
	    function parseImportDeclaration() {
	        var specifiers = [], src, node = new Node();
	
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalImportDeclaration);
	        }
	
	        expectKeyword('import');
	
	        if (lookahead.type === Token.StringLiteral) {
	            // import 'foo';
	            src = parseModuleSpecifier();
	        } else {
	
	            if (match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(parseNamedImports());
	            } else if (match('*')) {
	                // import * as foo
	                specifiers.push(parseImportNamespaceSpecifier());
	            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
	                // import foo
	                specifiers.push(parseImportDefaultSpecifier());
	                if (match(',')) {
	                    lex();
	                    if (match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(parseImportNamespaceSpecifier());
	                    } else if (match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(parseNamedImports());
	                    } else {
	                        throwUnexpectedToken(lookahead);
	                    }
	                }
	            } else {
	                throwUnexpectedToken(lex());
	            }
	
	            if (!matchContextualKeyword('from')) {
	                throwError(lookahead.value ?
	                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	            }
	            lex();
	            src = parseModuleSpecifier();
	        }
	
	        consumeSemicolon();
	        return node.finishImportDeclaration(specifiers, src);
	    }
	
	    // ECMA-262 15.1 Scripts
	
	    function parseScriptBody() {
	        var statement, body = [], token, directive, firstRestricted;
	
	        while (startIndex < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }
	
	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	
	        while (startIndex < length) {
	            statement = parseStatementListItem();
	            /* istanbul ignore if */
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            body.push(statement);
	        }
	        return body;
	    }
	
	    function parseProgram() {
	        var body, node;
	
	        peek();
	        node = new Node();
	
	        body = parseScriptBody();
	        return node.finishProgram(body, state.sourceType);
	    }
	
	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];
	
	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }
	
	        extra.tokens = tokens;
	    }
	
	    function tokenize(code, options, delegate) {
	        var toString,
	            tokens;
	
	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }
	
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };
	
	        extra = {};
	
	        // Options matching.
	        options = options || {};
	
	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenValues = [];
	        extra.tokenize = true;
	        extra.delegate = delegate;
	
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;
	
	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;
	
	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }
	
	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }
	
	            lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    lex();
	                } catch (lexError) {
	                    if (extra.errors) {
	                        recordError(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }
	
	            tokens = extra.tokens;
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }
	
	    function parse(code, options) {
	        var program, toString;
	
	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }
	
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: [],
	            sourceType: 'script'
	        };
	        strict = false;
	
	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
	
	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }
	
	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	            if (options.sourceType === 'module') {
	                // very restrictive condition for now
	                state.sourceType = options.sourceType;
	                strict = true;
	            }
	        }
	
	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	
	        return program;
	    }
	
	    // Sync with *.json manifests.
	    exports.version = '2.7.3';
	
	    exports.tokenize = tokenize;
	
	    exports.parse = parse;
	
	    // Deep copy.
	    /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};
	
	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }
	
	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }
	
	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }
	
	        return types;
	    }());
	
	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;
	
	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} [once=false] Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }
	
	/**
	 * Hold the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;
	
	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var events = this._events
	    , names = []
	    , name;
	
	  if (!events) return names;
	
	  for (name in events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }
	
	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }
	
	  return names;
	};
	
	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return this;
	
	  var listeners = this._events[evt]
	    , events = [];
	
	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }
	
	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;
	
	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ }),
/* 494 */
/***/ (function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	
	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}
	
		return toStr.call(arr) === '[object Array]';
	};
	
	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}
	
		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}
	
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) { /**/ }
	
		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};
	
	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;
	
		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
			target = {};
		}
	
		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];
	
					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}
	
							// Never move original objects, clone them
							target[name] = extend(deep, clone, copy);
	
						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							target[name] = copy;
						}
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};


/***/ }),
/* 495 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 496 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 497 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */
/***/ (function(module, exports) {

	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach (obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};
	


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var parser = __webpack_require__(516)
	var optionalByteOrderMark = '\\ufeff?'
	var pattern = '^(' +
	  optionalByteOrderMark +
	  '(= yaml =|---)' +
	  '$([\\s\\S]*?)' +
	  '^(?:\\2|\\.\\.\\.)' +
	  '$' +
	  (process.platform === 'win32' ? '\\r?' : '') +
	  '(?:\\n)?)'
	// NOTE: If this pattern uses the 'g' flag the `regex` variable definition will
	// need to be moved down into the functions that use it.
	var regex = new RegExp(pattern, 'm')
	
	module.exports = extractor
	module.exports.test = test
	
	function extractor (string) {
	  string = string || ''
	
	  var lines = string.split(/(\r?\n)/)
	  if (lines[0] && /= yaml =|---/.test(lines[0])) {
	    return parse(string)
	  } else {
	    return { attributes: {}, body: string }
	  }
	}
	
	function parse (string) {
	  var match = regex.exec(string)
	
	  if (!match) {
	    return {
	      attributes: {},
	      body: string
	    }
	  }
	
	  var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, '')
	  var attributes = parser.load(yaml) || {}
	  var body = string.replace(match[0], '')
	
	  return { attributes: attributes, body: body, frontmatter: yaml }
	}
	
	function test (string) {
	  string = string || ''
	
	  return regex.test(string)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var yaml = __webpack_require__(517);
	
	
	module.exports = yaml;


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var loader = __webpack_require__(519);
	var dumper = __webpack_require__(518);
	
	
	function deprecated(name) {
	  return function () {
	    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	  };
	}
	
	
	module.exports.Type                = __webpack_require__(18);
	module.exports.Schema              = __webpack_require__(56);
	module.exports.FAILSAFE_SCHEMA     = __webpack_require__(150);
	module.exports.JSON_SCHEMA         = __webpack_require__(250);
	module.exports.CORE_SCHEMA         = __webpack_require__(249);
	module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(76);
	module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(100);
	module.exports.load                = loader.load;
	module.exports.loadAll             = loader.loadAll;
	module.exports.safeLoad            = loader.safeLoad;
	module.exports.safeLoadAll         = loader.safeLoadAll;
	module.exports.dump                = dumper.dump;
	module.exports.safeDump            = dumper.safeDump;
	module.exports.YAMLException       = __webpack_require__(75);
	
	// Deprecated schema names from JS-YAML 2.0.x
	module.exports.MINIMAL_SCHEMA = __webpack_require__(150);
	module.exports.SAFE_SCHEMA    = __webpack_require__(76);
	module.exports.DEFAULT_SCHEMA = __webpack_require__(100);
	
	// Deprecated functions from JS-YAML 1.x.x
	module.exports.scan           = deprecated('scan');
	module.exports.parse          = deprecated('parse');
	module.exports.compose        = deprecated('compose');
	module.exports.addConstructor = deprecated('addConstructor');


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*eslint-disable no-use-before-define*/
	
	var common              = __webpack_require__(55);
	var YAMLException       = __webpack_require__(75);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(100);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(76);
	
	var _toString       = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var CHAR_TAB                  = 0x09; /* Tab */
	var CHAR_LINE_FEED            = 0x0A; /* LF */
	var CHAR_SPACE                = 0x20; /* Space */
	var CHAR_EXCLAMATION          = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
	var CHAR_SHARP                = 0x23; /* # */
	var CHAR_PERCENT              = 0x25; /* % */
	var CHAR_AMPERSAND            = 0x26; /* & */
	var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
	var CHAR_ASTERISK             = 0x2A; /* * */
	var CHAR_COMMA                = 0x2C; /* , */
	var CHAR_MINUS                = 0x2D; /* - */
	var CHAR_COLON                = 0x3A; /* : */
	var CHAR_GREATER_THAN         = 0x3E; /* > */
	var CHAR_QUESTION             = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
	var CHAR_VERTICAL_LINE        = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */
	
	var ESCAPE_SEQUENCES = {};
	
	ESCAPE_SEQUENCES[0x00]   = '\\0';
	ESCAPE_SEQUENCES[0x07]   = '\\a';
	ESCAPE_SEQUENCES[0x08]   = '\\b';
	ESCAPE_SEQUENCES[0x09]   = '\\t';
	ESCAPE_SEQUENCES[0x0A]   = '\\n';
	ESCAPE_SEQUENCES[0x0B]   = '\\v';
	ESCAPE_SEQUENCES[0x0C]   = '\\f';
	ESCAPE_SEQUENCES[0x0D]   = '\\r';
	ESCAPE_SEQUENCES[0x1B]   = '\\e';
	ESCAPE_SEQUENCES[0x22]   = '\\"';
	ESCAPE_SEQUENCES[0x5C]   = '\\\\';
	ESCAPE_SEQUENCES[0x85]   = '\\N';
	ESCAPE_SEQUENCES[0xA0]   = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';
	
	var DEPRECATED_BOOLEANS_SYNTAX = [
	  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
	  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
	];
	
	function compileStyleMap(schema, map) {
	  var result, keys, index, length, tag, style, type;
	
	  if (map === null) return {};
	
	  result = {};
	  keys = Object.keys(map);
	
	  for (index = 0, length = keys.length; index < length; index += 1) {
	    tag = keys[index];
	    style = String(map[tag]);
	
	    if (tag.slice(0, 2) === '!!') {
	      tag = 'tag:yaml.org,2002:' + tag.slice(2);
	    }
	    type = schema.compiledTypeMap['fallback'][tag];
	
	    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	      style = type.styleAliases[style];
	    }
	
	    result[tag] = style;
	  }
	
	  return result;
	}
	
	function encodeHex(character) {
	  var string, handle, length;
	
	  string = character.toString(16).toUpperCase();
	
	  if (character <= 0xFF) {
	    handle = 'x';
	    length = 2;
	  } else if (character <= 0xFFFF) {
	    handle = 'u';
	    length = 4;
	  } else if (character <= 0xFFFFFFFF) {
	    handle = 'U';
	    length = 8;
	  } else {
	    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	  }
	
	  return '\\' + handle + common.repeat('0', length - string.length) + string;
	}
	
	function State(options) {
	  this.schema       = options['schema'] || DEFAULT_FULL_SCHEMA;
	  this.indent       = Math.max(1, (options['indent'] || 2));
	  this.skipInvalid  = options['skipInvalid'] || false;
	  this.flowLevel    = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	  this.styleMap     = compileStyleMap(this.schema, options['styles'] || null);
	  this.sortKeys     = options['sortKeys'] || false;
	  this.lineWidth    = options['lineWidth'] || 80;
	  this.noRefs       = options['noRefs'] || false;
	  this.noCompatMode = options['noCompatMode'] || false;
	  this.condenseFlow = options['condenseFlow'] || false;
	
	  this.implicitTypes = this.schema.compiledImplicit;
	  this.explicitTypes = this.schema.compiledExplicit;
	
	  this.tag = null;
	  this.result = '';
	
	  this.duplicates = [];
	  this.usedDuplicates = null;
	}
	
	// Indents every line in a string. Empty lines (\n only) are not indented.
	function indentString(string, spaces) {
	  var ind = common.repeat(' ', spaces),
	      position = 0,
	      next = -1,
	      result = '',
	      line,
	      length = string.length;
	
	  while (position < length) {
	    next = string.indexOf('\n', position);
	    if (next === -1) {
	      line = string.slice(position);
	      position = length;
	    } else {
	      line = string.slice(position, next + 1);
	      position = next + 1;
	    }
	
	    if (line.length && line !== '\n') result += ind;
	
	    result += line;
	  }
	
	  return result;
	}
	
	function generateNextLine(state, level) {
	  return '\n' + common.repeat(' ', state.indent * level);
	}
	
	function testImplicitResolving(state, str) {
	  var index, length, type;
	
	  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	    type = state.implicitTypes[index];
	
	    if (type.resolve(str)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	// [33] s-white ::= s-space | s-tab
	function isWhitespace(c) {
	  return c === CHAR_SPACE || c === CHAR_TAB;
	}
	
	// Returns true if the character can be printed without escaping.
	// From YAML 1.2: "any allowed characters known to be non-printable
	// should also be escaped. [However,] This isn’t mandatory"
	// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
	function isPrintable(c) {
	  return  (0x00020 <= c && c <= 0x00007E)
	      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
	      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
	      ||  (0x10000 <= c && c <= 0x10FFFF);
	}
	
	// Simplified test for values allowed after the first character in plain style.
	function isPlainSafe(c) {
	  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
	  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
	  return isPrintable(c) && c !== 0xFEFF
	    // - c-flow-indicator
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // - ":" - "#"
	    && c !== CHAR_COLON
	    && c !== CHAR_SHARP;
	}
	
	// Simplified test for values allowed as the first character in plain style.
	function isPlainSafeFirst(c) {
	  // Uses a subset of ns-char - c-indicator
	  // where ns-char = nb-char - s-white.
	  return isPrintable(c) && c !== 0xFEFF
	    && !isWhitespace(c) // - s-white
	    // - (c-indicator ::=
	    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
	    && c !== CHAR_MINUS
	    && c !== CHAR_QUESTION
	    && c !== CHAR_COLON
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
	    && c !== CHAR_SHARP
	    && c !== CHAR_AMPERSAND
	    && c !== CHAR_ASTERISK
	    && c !== CHAR_EXCLAMATION
	    && c !== CHAR_VERTICAL_LINE
	    && c !== CHAR_GREATER_THAN
	    && c !== CHAR_SINGLE_QUOTE
	    && c !== CHAR_DOUBLE_QUOTE
	    // | “%” | “@” | “`”)
	    && c !== CHAR_PERCENT
	    && c !== CHAR_COMMERCIAL_AT
	    && c !== CHAR_GRAVE_ACCENT;
	}
	
	var STYLE_PLAIN   = 1,
	    STYLE_SINGLE  = 2,
	    STYLE_LITERAL = 3,
	    STYLE_FOLDED  = 4,
	    STYLE_DOUBLE  = 5;
	
	// Determines which scalar styles are possible and returns the preferred style.
	// lineWidth = -1 => no limit.
	// Pre-conditions: str.length > 0.
	// Post-conditions:
	//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
	//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
	//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
	function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
	  var i;
	  var char;
	  var hasLineBreak = false;
	  var hasFoldableLine = false; // only checked if shouldTrackWidth
	  var shouldTrackWidth = lineWidth !== -1;
	  var previousLineBreak = -1; // count the first line correctly
	  var plain = isPlainSafeFirst(string.charCodeAt(0))
	          && !isWhitespace(string.charCodeAt(string.length - 1));
	
	  if (singleLineOnly) {
	    // Case: no block styles.
	    // Check for disallowed characters to rule out plain and single.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char);
	    }
	  } else {
	    // Case: block styles permitted.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (char === CHAR_LINE_FEED) {
	        hasLineBreak = true;
	        // Check if any line can be folded.
	        if (shouldTrackWidth) {
	          hasFoldableLine = hasFoldableLine ||
	            // Foldable line = too long, and not more-indented.
	            (i - previousLineBreak - 1 > lineWidth &&
	             string[previousLineBreak + 1] !== ' ');
	          previousLineBreak = i;
	        }
	      } else if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char);
	    }
	    // in case the end is missing a \n
	    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
	      (i - previousLineBreak - 1 > lineWidth &&
	       string[previousLineBreak + 1] !== ' '));
	  }
	  // Although every style can represent \n without escaping, prefer block styles
	  // for multiline, since they're more readable and they don't add empty lines.
	  // Also prefer folding a super-long line.
	  if (!hasLineBreak && !hasFoldableLine) {
	    // Strings interpretable as another type have to be quoted;
	    // e.g. the string 'true' vs. the boolean true.
	    return plain && !testAmbiguousType(string)
	      ? STYLE_PLAIN : STYLE_SINGLE;
	  }
	  // Edge case: block indentation indicator can only have one digit.
	  if (string[0] === ' ' && indentPerLevel > 9) {
	    return STYLE_DOUBLE;
	  }
	  // At this point we know block styles are valid.
	  // Prefer literal style unless we want to fold.
	  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	}
	
	// Note: line breaking/folding is implemented for only the folded style.
	// NB. We drop the last trailing newline (if any) of a returned block scalar
	//  since the dumper adds its own newline. This always works:
	//    • No ending newline => unaffected; already using strip "-" chomping.
	//    • Ending newline    => removed then restored.
	//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
	function writeScalar(state, string, level, iskey) {
	  state.dump = (function () {
	    if (string.length === 0) {
	      return "''";
	    }
	    if (!state.noCompatMode &&
	        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
	      return "'" + string + "'";
	    }
	
	    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
	    // As indentation gets deeper, let the width decrease monotonically
	    // to the lower bound min(state.lineWidth, 40).
	    // Note that this implies
	    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
	    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
	    // This behaves better than a constant minimum width which disallows narrower options,
	    // or an indent threshold which causes the width to suddenly increase.
	    var lineWidth = state.lineWidth === -1
	      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
	
	    // Without knowing if keys are implicit/explicit, assume implicit for safety.
	    var singleLineOnly = iskey
	      // No block styles in flow mode.
	      || (state.flowLevel > -1 && level >= state.flowLevel);
	    function testAmbiguity(string) {
	      return testImplicitResolving(state, string);
	    }
	
	    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
	      case STYLE_PLAIN:
	        return string;
	      case STYLE_SINGLE:
	        return "'" + string.replace(/'/g, "''") + "'";
	      case STYLE_LITERAL:
	        return '|' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(string, indent));
	      case STYLE_FOLDED:
	        return '>' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
	      case STYLE_DOUBLE:
	        return '"' + escapeString(string, lineWidth) + '"';
	      default:
	        throw new YAMLException('impossible error: invalid scalar style');
	    }
	  }());
	}
	
	// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
	function blockHeader(string, indentPerLevel) {
	  var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';
	
	  // note the special case: the string '\n' counts as a "trailing" empty line.
	  var clip =          string[string.length - 1] === '\n';
	  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
	  var chomp = keep ? '+' : (clip ? '' : '-');
	
	  return indentIndicator + chomp + '\n';
	}
	
	// (See the note for writeScalar.)
	function dropEndingNewline(string) {
	  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
	}
	
	// Note: a long line without a suitable break point will exceed the width limit.
	// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
	function foldString(string, width) {
	  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
	  // unless they're before or after a more-indented line, or at the very
	  // beginning or end, in which case $k$ maps to $k$.
	  // Therefore, parse each chunk as newline(s) followed by a content line.
	  var lineRe = /(\n+)([^\n]*)/g;
	
	  // first line (possibly an empty line)
	  var result = (function () {
	    var nextLF = string.indexOf('\n');
	    nextLF = nextLF !== -1 ? nextLF : string.length;
	    lineRe.lastIndex = nextLF;
	    return foldLine(string.slice(0, nextLF), width);
	  }());
	  // If we haven't reached the first content line yet, don't add an extra \n.
	  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
	  var moreIndented;
	
	  // rest of the lines
	  var match;
	  while ((match = lineRe.exec(string))) {
	    var prefix = match[1], line = match[2];
	    moreIndented = (line[0] === ' ');
	    result += prefix
	      + (!prevMoreIndented && !moreIndented && line !== ''
	        ? '\n' : '')
	      + foldLine(line, width);
	    prevMoreIndented = moreIndented;
	  }
	
	  return result;
	}
	
	// Greedy line breaking.
	// Picks the longest line under the limit each time,
	// otherwise settles for the shortest line over the limit.
	// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
	function foldLine(line, width) {
	  if (line === '' || line[0] === ' ') return line;
	
	  // Since a more-indented line adds a \n, breaks can't be followed by a space.
	  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
	  var match;
	  // start is an inclusive index. end, curr, and next are exclusive.
	  var start = 0, end, curr = 0, next = 0;
	  var result = '';
	
	  // Invariants: 0 <= start <= length-1.
	  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
	  // Inside the loop:
	  //   A match implies length >= 2, so curr and next are <= length-2.
	  while ((match = breakRe.exec(line))) {
	    next = match.index;
	    // maintain invariant: curr - start <= width
	    if (next - start > width) {
	      end = (curr > start) ? curr : next; // derive end <= length-2
	      result += '\n' + line.slice(start, end);
	      // skip the space that was output as \n
	      start = end + 1;                    // derive start <= length-1
	    }
	    curr = next;
	  }
	
	  // By the invariants, start <= length-1, so there is something left over.
	  // It is either the whole string or a part starting from non-whitespace.
	  result += '\n';
	  // Insert a break if the remainder is too long and there is a break available.
	  if (line.length - start > width && curr > start) {
	    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
	  } else {
	    result += line.slice(start);
	  }
	
	  return result.slice(1); // drop extra \n joiner
	}
	
	// Escapes a double-quoted string.
	function escapeString(string) {
	  var result = '';
	  var char, nextChar;
	  var escapeSeq;
	
	  for (var i = 0; i < string.length; i++) {
	    char = string.charCodeAt(i);
	    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
	    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
	      nextChar = string.charCodeAt(i + 1);
	      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
	        // Combine the surrogate pair and store it escaped.
	        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
	        // Advance index one extra since we already used that char here.
	        i++; continue;
	      }
	    }
	    escapeSeq = ESCAPE_SEQUENCES[char];
	    result += !escapeSeq && isPrintable(char)
	      ? string[i]
	      : escapeSeq || encodeHex(char);
	  }
	
	  return result;
	}
	
	function writeFlowSequence(state, level, object) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;
	
	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level, object[index], false, false)) {
	      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
	      _result += state.dump;
	    }
	  }
	
	  state.tag = _tag;
	  state.dump = '[' + _result + ']';
	}
	
	function writeBlockSequence(state, level, object, compact) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;
	
	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level + 1, object[index], true, true)) {
	      if (!compact || index !== 0) {
	        _result += generateNextLine(state, level);
	      }
	
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        _result += '-';
	      } else {
	        _result += '- ';
	      }
	
	      _result += state.dump;
	    }
	  }
	
	  state.tag = _tag;
	  state.dump = _result || '[]'; // Empty sequence if no valid values.
	}
	
	function writeFlowMapping(state, level, object) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      pairBuffer;
	
	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = state.condenseFlow ? '"' : '';
	
	    if (index !== 0) pairBuffer += ', ';
	
	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];
	
	    if (!writeNode(state, level, objectKey, false, false)) {
	      continue; // Skip this pair because of invalid key;
	    }
	
	    if (state.dump.length > 1024) pairBuffer += '? ';
	
	    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
	
	    if (!writeNode(state, level, objectValue, false, false)) {
	      continue; // Skip this pair because of invalid value.
	    }
	
	    pairBuffer += state.dump;
	
	    // Both key and value are valid.
	    _result += pairBuffer;
	  }
	
	  state.tag = _tag;
	  state.dump = '{' + _result + '}';
	}
	
	function writeBlockMapping(state, level, object, compact) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      explicitPair,
	      pairBuffer;
	
	  // Allow sorting keys so that the output file is deterministic
	  if (state.sortKeys === true) {
	    // Default sorting
	    objectKeyList.sort();
	  } else if (typeof state.sortKeys === 'function') {
	    // Custom sort function
	    objectKeyList.sort(state.sortKeys);
	  } else if (state.sortKeys) {
	    // Something is wrong
	    throw new YAMLException('sortKeys must be a boolean or a function');
	  }
	
	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';
	
	    if (!compact || index !== 0) {
	      pairBuffer += generateNextLine(state, level);
	    }
	
	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];
	
	    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
	      continue; // Skip this pair because of invalid key.
	    }
	
	    explicitPair = (state.tag !== null && state.tag !== '?') ||
	                   (state.dump && state.dump.length > 1024);
	
	    if (explicitPair) {
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        pairBuffer += '?';
	      } else {
	        pairBuffer += '? ';
	      }
	    }
	
	    pairBuffer += state.dump;
	
	    if (explicitPair) {
	      pairBuffer += generateNextLine(state, level);
	    }
	
	    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	      continue; // Skip this pair because of invalid value.
	    }
	
	    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	      pairBuffer += ':';
	    } else {
	      pairBuffer += ': ';
	    }
	
	    pairBuffer += state.dump;
	
	    // Both key and value are valid.
	    _result += pairBuffer;
	  }
	
	  state.tag = _tag;
	  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}
	
	function detectType(state, object, explicit) {
	  var _result, typeList, index, length, type, style;
	
	  typeList = explicit ? state.explicitTypes : state.implicitTypes;
	
	  for (index = 0, length = typeList.length; index < length; index += 1) {
	    type = typeList[index];
	
	    if ((type.instanceOf  || type.predicate) &&
	        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
	        (!type.predicate  || type.predicate(object))) {
	
	      state.tag = explicit ? type.tag : '?';
	
	      if (type.represent) {
	        style = state.styleMap[type.tag] || type.defaultStyle;
	
	        if (_toString.call(type.represent) === '[object Function]') {
	          _result = type.represent(object, style);
	        } else if (_hasOwnProperty.call(type.represent, style)) {
	          _result = type.represent[style](object, style);
	        } else {
	          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	        }
	
	        state.dump = _result;
	      }
	
	      return true;
	    }
	  }
	
	  return false;
	}
	
	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact, iskey) {
	  state.tag = null;
	  state.dump = object;
	
	  if (!detectType(state, object, false)) {
	    detectType(state, object, true);
	  }
	
	  var type = _toString.call(state.dump);
	
	  if (block) {
	    block = (state.flowLevel < 0 || state.flowLevel > level);
	  }
	
	  var objectOrArray = type === '[object Object]' || type === '[object Array]',
	      duplicateIndex,
	      duplicate;
	
	  if (objectOrArray) {
	    duplicateIndex = state.duplicates.indexOf(object);
	    duplicate = duplicateIndex !== -1;
	  }
	
	  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
	    compact = false;
	  }
	
	  if (duplicate && state.usedDuplicates[duplicateIndex]) {
	    state.dump = '*ref_' + duplicateIndex;
	  } else {
	    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	      state.usedDuplicates[duplicateIndex] = true;
	    }
	    if (type === '[object Object]') {
	      if (block && (Object.keys(state.dump).length !== 0)) {
	        writeBlockMapping(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowMapping(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object Array]') {
	      if (block && (state.dump.length !== 0)) {
	        writeBlockSequence(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowSequence(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object String]') {
	      if (state.tag !== '?') {
	        writeScalar(state, state.dump, level, iskey);
	      }
	    } else {
	      if (state.skipInvalid) return false;
	      throw new YAMLException('unacceptable kind of an object to dump ' + type);
	    }
	
	    if (state.tag !== null && state.tag !== '?') {
	      state.dump = '!<' + state.tag + '> ' + state.dump;
	    }
	  }
	
	  return true;
	}
	
	function getDuplicateReferences(object, state) {
	  var objects = [],
	      duplicatesIndexes = [],
	      index,
	      length;
	
	  inspectNode(object, objects, duplicatesIndexes);
	
	  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	    state.duplicates.push(objects[duplicatesIndexes[index]]);
	  }
	  state.usedDuplicates = new Array(length);
	}
	
	function inspectNode(object, objects, duplicatesIndexes) {
	  var objectKeyList,
	      index,
	      length;
	
	  if (object !== null && typeof object === 'object') {
	    index = objects.indexOf(object);
	    if (index !== -1) {
	      if (duplicatesIndexes.indexOf(index) === -1) {
	        duplicatesIndexes.push(index);
	      }
	    } else {
	      objects.push(object);
	
	      if (Array.isArray(object)) {
	        for (index = 0, length = object.length; index < length; index += 1) {
	          inspectNode(object[index], objects, duplicatesIndexes);
	        }
	      } else {
	        objectKeyList = Object.keys(object);
	
	        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	        }
	      }
	    }
	  }
	}
	
	function dump(input, options) {
	  options = options || {};
	
	  var state = new State(options);
	
	  if (!state.noRefs) getDuplicateReferences(input, state);
	
	  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
	
	  return '';
	}
	
	function safeDump(input, options) {
	  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	
	module.exports.dump     = dump;
	module.exports.safeDump = safeDump;


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*eslint-disable max-len,no-use-before-define*/
	
	var common              = __webpack_require__(55);
	var YAMLException       = __webpack_require__(75);
	var Mark                = __webpack_require__(520);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(76);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(100);
	
	
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	
	
	var CONTEXT_FLOW_IN   = 1;
	var CONTEXT_FLOW_OUT  = 2;
	var CONTEXT_BLOCK_IN  = 3;
	var CONTEXT_BLOCK_OUT = 4;
	
	
	var CHOMPING_CLIP  = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP  = 3;
	
	
	var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	
	
	function is_EOL(c) {
	  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
	}
	
	function is_WHITE_SPACE(c) {
	  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
	}
	
	function is_WS_OR_EOL(c) {
	  return (c === 0x09/* Tab */) ||
	         (c === 0x20/* Space */) ||
	         (c === 0x0A/* LF */) ||
	         (c === 0x0D/* CR */);
	}
	
	function is_FLOW_INDICATOR(c) {
	  return c === 0x2C/* , */ ||
	         c === 0x5B/* [ */ ||
	         c === 0x5D/* ] */ ||
	         c === 0x7B/* { */ ||
	         c === 0x7D/* } */;
	}
	
	function fromHexCode(c) {
	  var lc;
	
	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }
	
	  /*eslint-disable no-bitwise*/
	  lc = c | 0x20;
	
	  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
	    return lc - 0x61 + 10;
	  }
	
	  return -1;
	}
	
	function escapedHexLen(c) {
	  if (c === 0x78/* x */) { return 2; }
	  if (c === 0x75/* u */) { return 4; }
	  if (c === 0x55/* U */) { return 8; }
	  return 0;
	}
	
	function fromDecimalCode(c) {
	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }
	
	  return -1;
	}
	
	function simpleEscapeSequence(c) {
	  /* eslint-disable indent */
	  return (c === 0x30/* 0 */) ? '\x00' :
	        (c === 0x61/* a */) ? '\x07' :
	        (c === 0x62/* b */) ? '\x08' :
	        (c === 0x74/* t */) ? '\x09' :
	        (c === 0x09/* Tab */) ? '\x09' :
	        (c === 0x6E/* n */) ? '\x0A' :
	        (c === 0x76/* v */) ? '\x0B' :
	        (c === 0x66/* f */) ? '\x0C' :
	        (c === 0x72/* r */) ? '\x0D' :
	        (c === 0x65/* e */) ? '\x1B' :
	        (c === 0x20/* Space */) ? ' ' :
	        (c === 0x22/* " */) ? '\x22' :
	        (c === 0x2F/* / */) ? '/' :
	        (c === 0x5C/* \ */) ? '\x5C' :
	        (c === 0x4E/* N */) ? '\x85' :
	        (c === 0x5F/* _ */) ? '\xA0' :
	        (c === 0x4C/* L */) ? '\u2028' :
	        (c === 0x50/* P */) ? '\u2029' : '';
	}
	
	function charFromCodepoint(c) {
	  if (c <= 0xFFFF) {
	    return String.fromCharCode(c);
	  }
	  // Encode UTF-16 surrogate pair
	  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	  return String.fromCharCode(
	    ((c - 0x010000) >> 10) + 0xD800,
	    ((c - 0x010000) & 0x03FF) + 0xDC00
	  );
	}
	
	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	  simpleEscapeMap[i] = simpleEscapeSequence(i);
	}
	
	
	function State(input, options) {
	  this.input = input;
	
	  this.filename  = options['filename']  || null;
	  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
	  this.onWarning = options['onWarning'] || null;
	  this.legacy    = options['legacy']    || false;
	  this.json      = options['json']      || false;
	  this.listener  = options['listener']  || null;
	
	  this.implicitTypes = this.schema.compiledImplicit;
	  this.typeMap       = this.schema.compiledTypeMap;
	
	  this.length     = input.length;
	  this.position   = 0;
	  this.line       = 0;
	  this.lineStart  = 0;
	  this.lineIndent = 0;
	
	  this.documents = [];
	
	  /*
	  this.version;
	  this.checkLineBreaks;
	  this.tagMap;
	  this.anchorMap;
	  this.tag;
	  this.anchor;
	  this.kind;
	  this.result;*/
	
	}
	
	
	function generateError(state, message) {
	  return new YAMLException(
	    message,
	    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
	}
	
	function throwError(state, message) {
	  throw generateError(state, message);
	}
	
	function throwWarning(state, message) {
	  if (state.onWarning) {
	    state.onWarning.call(null, generateError(state, message));
	  }
	}
	
	
	var directiveHandlers = {
	
	  YAML: function handleYamlDirective(state, name, args) {
	
	    var match, major, minor;
	
	    if (state.version !== null) {
	      throwError(state, 'duplication of %YAML directive');
	    }
	
	    if (args.length !== 1) {
	      throwError(state, 'YAML directive accepts exactly one argument');
	    }
	
	    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
	
	    if (match === null) {
	      throwError(state, 'ill-formed argument of the YAML directive');
	    }
	
	    major = parseInt(match[1], 10);
	    minor = parseInt(match[2], 10);
	
	    if (major !== 1) {
	      throwError(state, 'unacceptable YAML version of the document');
	    }
	
	    state.version = args[0];
	    state.checkLineBreaks = (minor < 2);
	
	    if (minor !== 1 && minor !== 2) {
	      throwWarning(state, 'unsupported YAML version of the document');
	    }
	  },
	
	  TAG: function handleTagDirective(state, name, args) {
	
	    var handle, prefix;
	
	    if (args.length !== 2) {
	      throwError(state, 'TAG directive accepts exactly two arguments');
	    }
	
	    handle = args[0];
	    prefix = args[1];
	
	    if (!PATTERN_TAG_HANDLE.test(handle)) {
	      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	    }
	
	    if (_hasOwnProperty.call(state.tagMap, handle)) {
	      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	    }
	
	    if (!PATTERN_TAG_URI.test(prefix)) {
	      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	    }
	
	    state.tagMap[handle] = prefix;
	  }
	};
	
	
	function captureSegment(state, start, end, checkJson) {
	  var _position, _length, _character, _result;
	
	  if (start < end) {
	    _result = state.input.slice(start, end);
	
	    if (checkJson) {
	      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	        _character = _result.charCodeAt(_position);
	        if (!(_character === 0x09 ||
	              (0x20 <= _character && _character <= 0x10FFFF))) {
	          throwError(state, 'expected valid JSON character');
	        }
	      }
	    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
	      throwError(state, 'the stream contains non-printable characters');
	    }
	
	    state.result += _result;
	  }
	}
	
	function mergeMappings(state, destination, source, overridableKeys) {
	  var sourceKeys, key, index, quantity;
	
	  if (!common.isObject(source)) {
	    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	  }
	
	  sourceKeys = Object.keys(source);
	
	  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	    key = sourceKeys[index];
	
	    if (!_hasOwnProperty.call(destination, key)) {
	      destination[key] = source[key];
	      overridableKeys[key] = true;
	    }
	  }
	}
	
	function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
	  var index, quantity;
	
	  keyNode = String(keyNode);
	
	  if (_result === null) {
	    _result = {};
	  }
	
	  if (keyTag === 'tag:yaml.org,2002:merge') {
	    if (Array.isArray(valueNode)) {
	      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
	        mergeMappings(state, _result, valueNode[index], overridableKeys);
	      }
	    } else {
	      mergeMappings(state, _result, valueNode, overridableKeys);
	    }
	  } else {
	    if (!state.json &&
	        !_hasOwnProperty.call(overridableKeys, keyNode) &&
	        _hasOwnProperty.call(_result, keyNode)) {
	      state.line = startLine || state.line;
	      state.position = startPos || state.position;
	      throwError(state, 'duplicated mapping key');
	    }
	    _result[keyNode] = valueNode;
	    delete overridableKeys[keyNode];
	  }
	
	  return _result;
	}
	
	function readLineBreak(state) {
	  var ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch === 0x0A/* LF */) {
	    state.position++;
	  } else if (ch === 0x0D/* CR */) {
	    state.position++;
	    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
	      state.position++;
	    }
	  } else {
	    throwError(state, 'a line break is expected');
	  }
	
	  state.line += 1;
	  state.lineStart = state.position;
	}
	
	function skipSeparationSpace(state, allowComments, checkIndent) {
	  var lineBreaks = 0,
	      ch = state.input.charCodeAt(state.position);
	
	  while (ch !== 0) {
	    while (is_WHITE_SPACE(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }
	
	    if (allowComments && ch === 0x23/* # */) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
	    }
	
	    if (is_EOL(ch)) {
	      readLineBreak(state);
	
	      ch = state.input.charCodeAt(state.position);
	      lineBreaks++;
	      state.lineIndent = 0;
	
	      while (ch === 0x20/* Space */) {
	        state.lineIndent++;
	        ch = state.input.charCodeAt(++state.position);
	      }
	    } else {
	      break;
	    }
	  }
	
	  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
	    throwWarning(state, 'deficient indentation');
	  }
	
	  return lineBreaks;
	}
	
	function testDocumentSeparator(state) {
	  var _position = state.position,
	      ch;
	
	  ch = state.input.charCodeAt(_position);
	
	  // Condition state.position === state.lineStart is tested
	  // in parent on each call, for efficiency. No needs to test here again.
	  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
	      ch === state.input.charCodeAt(_position + 1) &&
	      ch === state.input.charCodeAt(_position + 2)) {
	
	    _position += 3;
	
	    ch = state.input.charCodeAt(_position);
	
	    if (ch === 0 || is_WS_OR_EOL(ch)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	function writeFoldedLines(state, count) {
	  if (count === 1) {
	    state.result += ' ';
	  } else if (count > 1) {
	    state.result += common.repeat('\n', count - 1);
	  }
	}
	
	
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	  var preceding,
	      following,
	      captureStart,
	      captureEnd,
	      hasPendingContent,
	      _line,
	      _lineStart,
	      _lineIndent,
	      _kind = state.kind,
	      _result = state.result,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (is_WS_OR_EOL(ch)      ||
	      is_FLOW_INDICATOR(ch) ||
	      ch === 0x23/* # */    ||
	      ch === 0x26/* & */    ||
	      ch === 0x2A/* * */    ||
	      ch === 0x21/* ! */    ||
	      ch === 0x7C/* | */    ||
	      ch === 0x3E/* > */    ||
	      ch === 0x27/* ' */    ||
	      ch === 0x22/* " */    ||
	      ch === 0x25/* % */    ||
	      ch === 0x40/* @ */    ||
	      ch === 0x60/* ` */) {
	    return false;
	  }
	
	  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
	    following = state.input.charCodeAt(state.position + 1);
	
	    if (is_WS_OR_EOL(following) ||
	        withinFlowCollection && is_FLOW_INDICATOR(following)) {
	      return false;
	    }
	  }
	
	  state.kind = 'scalar';
	  state.result = '';
	  captureStart = captureEnd = state.position;
	  hasPendingContent = false;
	
	  while (ch !== 0) {
	    if (ch === 0x3A/* : */) {
	      following = state.input.charCodeAt(state.position + 1);
	
	      if (is_WS_OR_EOL(following) ||
	          withinFlowCollection && is_FLOW_INDICATOR(following)) {
	        break;
	      }
	
	    } else if (ch === 0x23/* # */) {
	      preceding = state.input.charCodeAt(state.position - 1);
	
	      if (is_WS_OR_EOL(preceding)) {
	        break;
	      }
	
	    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
	               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	      break;
	
	    } else if (is_EOL(ch)) {
	      _line = state.line;
	      _lineStart = state.lineStart;
	      _lineIndent = state.lineIndent;
	      skipSeparationSpace(state, false, -1);
	
	      if (state.lineIndent >= nodeIndent) {
	        hasPendingContent = true;
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      } else {
	        state.position = captureEnd;
	        state.line = _line;
	        state.lineStart = _lineStart;
	        state.lineIndent = _lineIndent;
	        break;
	      }
	    }
	
	    if (hasPendingContent) {
	      captureSegment(state, captureStart, captureEnd, false);
	      writeFoldedLines(state, state.line - _line);
	      captureStart = captureEnd = state.position;
	      hasPendingContent = false;
	    }
	
	    if (!is_WHITE_SPACE(ch)) {
	      captureEnd = state.position + 1;
	    }
	
	    ch = state.input.charCodeAt(++state.position);
	  }
	
	  captureSegment(state, captureStart, captureEnd, false);
	
	  if (state.result) {
	    return true;
	  }
	
	  state.kind = _kind;
	  state.result = _result;
	  return false;
	}
	
	function readSingleQuotedScalar(state, nodeIndent) {
	  var ch,
	      captureStart, captureEnd;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch !== 0x27/* ' */) {
	    return false;
	  }
	
	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;
	
	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x27/* ' */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);
	
	      if (ch === 0x27/* ' */) {
	        captureStart = state.position;
	        state.position++;
	        captureEnd = state.position;
	      } else {
	        return true;
	      }
	
	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;
	
	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a single quoted scalar');
	
	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }
	
	  throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}
	
	function readDoubleQuotedScalar(state, nodeIndent) {
	  var captureStart,
	      captureEnd,
	      hexLength,
	      hexResult,
	      tmp,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch !== 0x22/* " */) {
	    return false;
	  }
	
	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;
	
	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x22/* " */) {
	      captureSegment(state, captureStart, state.position, true);
	      state.position++;
	      return true;
	
	    } else if (ch === 0x5C/* \ */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);
	
	      if (is_EOL(ch)) {
	        skipSeparationSpace(state, false, nodeIndent);
	
	        // TODO: rework to inline fn with no type cast?
	      } else if (ch < 256 && simpleEscapeCheck[ch]) {
	        state.result += simpleEscapeMap[ch];
	        state.position++;
	
	      } else if ((tmp = escapedHexLen(ch)) > 0) {
	        hexLength = tmp;
	        hexResult = 0;
	
	        for (; hexLength > 0; hexLength--) {
	          ch = state.input.charCodeAt(++state.position);
	
	          if ((tmp = fromHexCode(ch)) >= 0) {
	            hexResult = (hexResult << 4) + tmp;
	
	          } else {
	            throwError(state, 'expected hexadecimal character');
	          }
	        }
	
	        state.result += charFromCodepoint(hexResult);
	
	        state.position++;
	
	      } else {
	        throwError(state, 'unknown escape sequence');
	      }
	
	      captureStart = captureEnd = state.position;
	
	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;
	
	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a double quoted scalar');
	
	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }
	
	  throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}
	
	function readFlowCollection(state, nodeIndent) {
	  var readNext = true,
	      _line,
	      _tag     = state.tag,
	      _result,
	      _anchor  = state.anchor,
	      following,
	      terminator,
	      isPair,
	      isExplicitPair,
	      isMapping,
	      overridableKeys = {},
	      keyNode,
	      keyTag,
	      valueNode,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch === 0x5B/* [ */) {
	    terminator = 0x5D;/* ] */
	    isMapping = false;
	    _result = [];
	  } else if (ch === 0x7B/* { */) {
	    terminator = 0x7D;/* } */
	    isMapping = true;
	    _result = {};
	  } else {
	    return false;
	  }
	
	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }
	
	  ch = state.input.charCodeAt(++state.position);
	
	  while (ch !== 0) {
	    skipSeparationSpace(state, true, nodeIndent);
	
	    ch = state.input.charCodeAt(state.position);
	
	    if (ch === terminator) {
	      state.position++;
	      state.tag = _tag;
	      state.anchor = _anchor;
	      state.kind = isMapping ? 'mapping' : 'sequence';
	      state.result = _result;
	      return true;
	    } else if (!readNext) {
	      throwError(state, 'missed comma between flow collection entries');
	    }
	
	    keyTag = keyNode = valueNode = null;
	    isPair = isExplicitPair = false;
	
	    if (ch === 0x3F/* ? */) {
	      following = state.input.charCodeAt(state.position + 1);
	
	      if (is_WS_OR_EOL(following)) {
	        isPair = isExplicitPair = true;
	        state.position++;
	        skipSeparationSpace(state, true, nodeIndent);
	      }
	    }
	
	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	    keyTag = state.tag;
	    keyNode = state.result;
	    skipSeparationSpace(state, true, nodeIndent);
	
	    ch = state.input.charCodeAt(state.position);
	
	    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
	      isPair = true;
	      ch = state.input.charCodeAt(++state.position);
	      skipSeparationSpace(state, true, nodeIndent);
	      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	      valueNode = state.result;
	    }
	
	    if (isMapping) {
	      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
	    } else if (isPair) {
	      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
	    } else {
	      _result.push(keyNode);
	    }
	
	    skipSeparationSpace(state, true, nodeIndent);
	
	    ch = state.input.charCodeAt(state.position);
	
	    if (ch === 0x2C/* , */) {
	      readNext = true;
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      readNext = false;
	    }
	  }
	
	  throwError(state, 'unexpected end of the stream within a flow collection');
	}
	
	function readBlockScalar(state, nodeIndent) {
	  var captureStart,
	      folding,
	      chomping       = CHOMPING_CLIP,
	      didReadContent = false,
	      detectedIndent = false,
	      textIndent     = nodeIndent,
	      emptyLines     = 0,
	      atMoreIndented = false,
	      tmp,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch === 0x7C/* | */) {
	    folding = false;
	  } else if (ch === 0x3E/* > */) {
	    folding = true;
	  } else {
	    return false;
	  }
	
	  state.kind = 'scalar';
	  state.result = '';
	
	  while (ch !== 0) {
	    ch = state.input.charCodeAt(++state.position);
	
	    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
	      if (CHOMPING_CLIP === chomping) {
	        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
	      } else {
	        throwError(state, 'repeat of a chomping mode identifier');
	      }
	
	    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
	      if (tmp === 0) {
	        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	      } else if (!detectedIndent) {
	        textIndent = nodeIndent + tmp - 1;
	        detectedIndent = true;
	      } else {
	        throwError(state, 'repeat of an indentation width identifier');
	      }
	
	    } else {
	      break;
	    }
	  }
	
	  if (is_WHITE_SPACE(ch)) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (is_WHITE_SPACE(ch));
	
	    if (ch === 0x23/* # */) {
	      do { ch = state.input.charCodeAt(++state.position); }
	      while (!is_EOL(ch) && (ch !== 0));
	    }
	  }
	
	  while (ch !== 0) {
	    readLineBreak(state);
	    state.lineIndent = 0;
	
	    ch = state.input.charCodeAt(state.position);
	
	    while ((!detectedIndent || state.lineIndent < textIndent) &&
	           (ch === 0x20/* Space */)) {
	      state.lineIndent++;
	      ch = state.input.charCodeAt(++state.position);
	    }
	
	    if (!detectedIndent && state.lineIndent > textIndent) {
	      textIndent = state.lineIndent;
	    }
	
	    if (is_EOL(ch)) {
	      emptyLines++;
	      continue;
	    }
	
	    // End of the scalar.
	    if (state.lineIndent < textIndent) {
	
	      // Perform the chomping.
	      if (chomping === CHOMPING_KEEP) {
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	      } else if (chomping === CHOMPING_CLIP) {
	        if (didReadContent) { // i.e. only if the scalar is not empty.
	          state.result += '\n';
	        }
	      }
	
	      // Break this `while` cycle and go to the funciton's epilogue.
	      break;
	    }
	
	    // Folded style: use fancy rules to handle line breaks.
	    if (folding) {
	
	      // Lines starting with white space characters (more-indented lines) are not folded.
	      if (is_WHITE_SPACE(ch)) {
	        atMoreIndented = true;
	        // except for the first content line (cf. Example 8.1)
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	
	      // End of more-indented block.
	      } else if (atMoreIndented) {
	        atMoreIndented = false;
	        state.result += common.repeat('\n', emptyLines + 1);
	
	      // Just one line break - perceive as the same line.
	      } else if (emptyLines === 0) {
	        if (didReadContent) { // i.e. only if we have already read some scalar content.
	          state.result += ' ';
	        }
	
	      // Several line breaks - perceive as different lines.
	      } else {
	        state.result += common.repeat('\n', emptyLines);
	      }
	
	    // Literal style: just add exact number of line breaks between content lines.
	    } else {
	      // Keep all line breaks except the header line break.
	      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	    }
	
	    didReadContent = true;
	    detectedIndent = true;
	    emptyLines = 0;
	    captureStart = state.position;
	
	    while (!is_EOL(ch) && (ch !== 0)) {
	      ch = state.input.charCodeAt(++state.position);
	    }
	
	    captureSegment(state, captureStart, state.position, false);
	  }
	
	  return true;
	}
	
	function readBlockSequence(state, nodeIndent) {
	  var _line,
	      _tag      = state.tag,
	      _anchor   = state.anchor,
	      _result   = [],
	      following,
	      detected  = false,
	      ch;
	
	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }
	
	  ch = state.input.charCodeAt(state.position);
	
	  while (ch !== 0) {
	
	    if (ch !== 0x2D/* - */) {
	      break;
	    }
	
	    following = state.input.charCodeAt(state.position + 1);
	
	    if (!is_WS_OR_EOL(following)) {
	      break;
	    }
	
	    detected = true;
	    state.position++;
	
	    if (skipSeparationSpace(state, true, -1)) {
	      if (state.lineIndent <= nodeIndent) {
	        _result.push(null);
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      }
	    }
	
	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	    _result.push(state.result);
	    skipSeparationSpace(state, true, -1);
	
	    ch = state.input.charCodeAt(state.position);
	
	    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
	      throwError(state, 'bad indentation of a sequence entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }
	
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'sequence';
	    state.result = _result;
	    return true;
	  }
	  return false;
	}
	
	function readBlockMapping(state, nodeIndent, flowIndent) {
	  var following,
	      allowCompact,
	      _line,
	      _pos,
	      _tag          = state.tag,
	      _anchor       = state.anchor,
	      _result       = {},
	      overridableKeys = {},
	      keyTag        = null,
	      keyNode       = null,
	      valueNode     = null,
	      atExplicitKey = false,
	      detected      = false,
	      ch;
	
	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }
	
	  ch = state.input.charCodeAt(state.position);
	
	  while (ch !== 0) {
	    following = state.input.charCodeAt(state.position + 1);
	    _line = state.line; // Save the current line.
	    _pos = state.position;
	
	    //
	    // Explicit notation case. There are two separate blocks:
	    // first for the key (denoted by "?") and second for the value (denoted by ":")
	    //
	    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {
	
	      if (ch === 0x3F/* ? */) {
	        if (atExplicitKey) {
	          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	          keyTag = keyNode = valueNode = null;
	        }
	
	        detected = true;
	        atExplicitKey = true;
	        allowCompact = true;
	
	      } else if (atExplicitKey) {
	        // i.e. 0x3A/* : */ === character after the explicit key.
	        atExplicitKey = false;
	        allowCompact = true;
	
	      } else {
	        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
	      }
	
	      state.position += 1;
	      ch = following;
	
	    //
	    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
	    //
	    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
	
	      if (state.line === _line) {
	        ch = state.input.charCodeAt(state.position);
	
	        while (is_WHITE_SPACE(ch)) {
	          ch = state.input.charCodeAt(++state.position);
	        }
	
	        if (ch === 0x3A/* : */) {
	          ch = state.input.charCodeAt(++state.position);
	
	          if (!is_WS_OR_EOL(ch)) {
	            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	          }
	
	          if (atExplicitKey) {
	            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	            keyTag = keyNode = valueNode = null;
	          }
	
	          detected = true;
	          atExplicitKey = false;
	          allowCompact = false;
	          keyTag = state.tag;
	          keyNode = state.result;
	
	        } else if (detected) {
	          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
	
	        } else {
	          state.tag = _tag;
	          state.anchor = _anchor;
	          return true; // Keep the result of `composeNode`.
	        }
	
	      } else if (detected) {
	        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
	
	      } else {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        return true; // Keep the result of `composeNode`.
	      }
	
	    } else {
	      break; // Reading is done. Go to the epilogue.
	    }
	
	    //
	    // Common reading code for both explicit and implicit notations.
	    //
	    if (state.line === _line || state.lineIndent > nodeIndent) {
	      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	        if (atExplicitKey) {
	          keyNode = state.result;
	        } else {
	          valueNode = state.result;
	        }
	      }
	
	      if (!atExplicitKey) {
	        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
	        keyTag = keyNode = valueNode = null;
	      }
	
	      skipSeparationSpace(state, true, -1);
	      ch = state.input.charCodeAt(state.position);
	    }
	
	    if (state.lineIndent > nodeIndent && (ch !== 0)) {
	      throwError(state, 'bad indentation of a mapping entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }
	
	  //
	  // Epilogue.
	  //
	
	  // Special case: last mapping's node contains only the key in explicit notation.
	  if (atExplicitKey) {
	    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	  }
	
	  // Expose the resulting mapping.
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'mapping';
	    state.result = _result;
	  }
	
	  return detected;
	}
	
	function readTagProperty(state) {
	  var _position,
	      isVerbatim = false,
	      isNamed    = false,
	      tagHandle,
	      tagName,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch !== 0x21/* ! */) return false;
	
	  if (state.tag !== null) {
	    throwError(state, 'duplication of a tag property');
	  }
	
	  ch = state.input.charCodeAt(++state.position);
	
	  if (ch === 0x3C/* < */) {
	    isVerbatim = true;
	    ch = state.input.charCodeAt(++state.position);
	
	  } else if (ch === 0x21/* ! */) {
	    isNamed = true;
	    tagHandle = '!!';
	    ch = state.input.charCodeAt(++state.position);
	
	  } else {
	    tagHandle = '!';
	  }
	
	  _position = state.position;
	
	  if (isVerbatim) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (ch !== 0 && ch !== 0x3E/* > */);
	
	    if (state.position < state.length) {
	      tagName = state.input.slice(_position, state.position);
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      throwError(state, 'unexpected end of the stream within a verbatim tag');
	    }
	  } else {
	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	
	      if (ch === 0x21/* ! */) {
	        if (!isNamed) {
	          tagHandle = state.input.slice(_position - 1, state.position + 1);
	
	          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	            throwError(state, 'named tag handle cannot contain such characters');
	          }
	
	          isNamed = true;
	          _position = state.position + 1;
	        } else {
	          throwError(state, 'tag suffix cannot contain exclamation marks');
	        }
	      }
	
	      ch = state.input.charCodeAt(++state.position);
	    }
	
	    tagName = state.input.slice(_position, state.position);
	
	    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	      throwError(state, 'tag suffix cannot contain flow indicator characters');
	    }
	  }
	
	  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	    throwError(state, 'tag name cannot contain such characters: ' + tagName);
	  }
	
	  if (isVerbatim) {
	    state.tag = tagName;
	
	  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	    state.tag = state.tagMap[tagHandle] + tagName;
	
	  } else if (tagHandle === '!') {
	    state.tag = '!' + tagName;
	
	  } else if (tagHandle === '!!') {
	    state.tag = 'tag:yaml.org,2002:' + tagName;
	
	  } else {
	    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	  }
	
	  return true;
	}
	
	function readAnchorProperty(state) {
	  var _position,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch !== 0x26/* & */) return false;
	
	  if (state.anchor !== null) {
	    throwError(state, 'duplication of an anchor property');
	  }
	
	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;
	
	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }
	
	  if (state.position === _position) {
	    throwError(state, 'name of an anchor node must contain at least one character');
	  }
	
	  state.anchor = state.input.slice(_position, state.position);
	  return true;
	}
	
	function readAlias(state) {
	  var _position, alias,
	      ch;
	
	  ch = state.input.charCodeAt(state.position);
	
	  if (ch !== 0x2A/* * */) return false;
	
	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;
	
	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }
	
	  if (state.position === _position) {
	    throwError(state, 'name of an alias node must contain at least one character');
	  }
	
	  alias = state.input.slice(_position, state.position);
	
	  if (!state.anchorMap.hasOwnProperty(alias)) {
	    throwError(state, 'unidentified alias "' + alias + '"');
	  }
	
	  state.result = state.anchorMap[alias];
	  skipSeparationSpace(state, true, -1);
	  return true;
	}
	
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	  var allowBlockStyles,
	      allowBlockScalars,
	      allowBlockCollections,
	      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
	      atNewLine  = false,
	      hasContent = false,
	      typeIndex,
	      typeQuantity,
	      type,
	      flowIndent,
	      blockIndent;
	
	  if (state.listener !== null) {
	    state.listener('open', state);
	  }
	
	  state.tag    = null;
	  state.anchor = null;
	  state.kind   = null;
	  state.result = null;
	
	  allowBlockStyles = allowBlockScalars = allowBlockCollections =
	    CONTEXT_BLOCK_OUT === nodeContext ||
	    CONTEXT_BLOCK_IN  === nodeContext;
	
	  if (allowToSeek) {
	    if (skipSeparationSpace(state, true, -1)) {
	      atNewLine = true;
	
	      if (state.lineIndent > parentIndent) {
	        indentStatus = 1;
	      } else if (state.lineIndent === parentIndent) {
	        indentStatus = 0;
	      } else if (state.lineIndent < parentIndent) {
	        indentStatus = -1;
	      }
	    }
	  }
	
	  if (indentStatus === 1) {
	    while (readTagProperty(state) || readAnchorProperty(state)) {
	      if (skipSeparationSpace(state, true, -1)) {
	        atNewLine = true;
	        allowBlockCollections = allowBlockStyles;
	
	        if (state.lineIndent > parentIndent) {
	          indentStatus = 1;
	        } else if (state.lineIndent === parentIndent) {
	          indentStatus = 0;
	        } else if (state.lineIndent < parentIndent) {
	          indentStatus = -1;
	        }
	      } else {
	        allowBlockCollections = false;
	      }
	    }
	  }
	
	  if (allowBlockCollections) {
	    allowBlockCollections = atNewLine || allowCompact;
	  }
	
	  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
	    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	      flowIndent = parentIndent;
	    } else {
	      flowIndent = parentIndent + 1;
	    }
	
	    blockIndent = state.position - state.lineStart;
	
	    if (indentStatus === 1) {
	      if (allowBlockCollections &&
	          (readBlockSequence(state, blockIndent) ||
	           readBlockMapping(state, blockIndent, flowIndent)) ||
	          readFlowCollection(state, flowIndent)) {
	        hasContent = true;
	      } else {
	        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
	            readSingleQuotedScalar(state, flowIndent) ||
	            readDoubleQuotedScalar(state, flowIndent)) {
	          hasContent = true;
	
	        } else if (readAlias(state)) {
	          hasContent = true;
	
	          if (state.tag !== null || state.anchor !== null) {
	            throwError(state, 'alias node should not have any properties');
	          }
	
	        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	          hasContent = true;
	
	          if (state.tag === null) {
	            state.tag = '?';
	          }
	        }
	
	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else if (indentStatus === 0) {
	      // Special case: block sequences are allowed to have same indentation level as the parent.
	      // http://www.yaml.org/spec/1.2/spec.html#id2799784
	      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	    }
	  }
	
	  if (state.tag !== null && state.tag !== '!') {
	    if (state.tag === '?') {
	      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	        type = state.implicitTypes[typeIndex];
	
	        // Implicit resolving is not allowed for non-scalar types, and '?'
	        // non-specific tag is only assigned to plain scalars. So, it isn't
	        // needed to check for 'kind' conformity.
	
	        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
	          state.result = type.construct(state.result);
	          state.tag = type.tag;
	          if (state.anchor !== null) {
	            state.anchorMap[state.anchor] = state.result;
	          }
	          break;
	        }
	      }
	    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
	      type = state.typeMap[state.kind || 'fallback'][state.tag];
	
	      if (state.result !== null && type.kind !== state.kind) {
	        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	      }
	
	      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
	        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	      } else {
	        state.result = type.construct(state.result);
	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else {
	      throwError(state, 'unknown tag !<' + state.tag + '>');
	    }
	  }
	
	  if (state.listener !== null) {
	    state.listener('close', state);
	  }
	  return state.tag !== null ||  state.anchor !== null || hasContent;
	}
	
	function readDocument(state) {
	  var documentStart = state.position,
	      _position,
	      directiveName,
	      directiveArgs,
	      hasDirectives = false,
	      ch;
	
	  state.version = null;
	  state.checkLineBreaks = state.legacy;
	  state.tagMap = {};
	  state.anchorMap = {};
	
	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    skipSeparationSpace(state, true, -1);
	
	    ch = state.input.charCodeAt(state.position);
	
	    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
	      break;
	    }
	
	    hasDirectives = true;
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	
	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }
	
	    directiveName = state.input.slice(_position, state.position);
	    directiveArgs = [];
	
	    if (directiveName.length < 1) {
	      throwError(state, 'directive name must not be less than one character in length');
	    }
	
	    while (ch !== 0) {
	      while (is_WHITE_SPACE(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }
	
	      if (ch === 0x23/* # */) {
	        do { ch = state.input.charCodeAt(++state.position); }
	        while (ch !== 0 && !is_EOL(ch));
	        break;
	      }
	
	      if (is_EOL(ch)) break;
	
	      _position = state.position;
	
	      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }
	
	      directiveArgs.push(state.input.slice(_position, state.position));
	    }
	
	    if (ch !== 0) readLineBreak(state);
	
	    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	      directiveHandlers[directiveName](state, directiveName, directiveArgs);
	    } else {
	      throwWarning(state, 'unknown document directive "' + directiveName + '"');
	    }
	  }
	
	  skipSeparationSpace(state, true, -1);
	
	  if (state.lineIndent === 0 &&
	      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
	    state.position += 3;
	    skipSeparationSpace(state, true, -1);
	
	  } else if (hasDirectives) {
	    throwError(state, 'directives end mark is expected');
	  }
	
	  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	  skipSeparationSpace(state, true, -1);
	
	  if (state.checkLineBreaks &&
	      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	  }
	
	  state.documents.push(state.result);
	
	  if (state.position === state.lineStart && testDocumentSeparator(state)) {
	
	    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
	      state.position += 3;
	      skipSeparationSpace(state, true, -1);
	    }
	    return;
	  }
	
	  if (state.position < (state.length - 1)) {
	    throwError(state, 'end of the stream or a document separator is expected');
	  } else {
	    return;
	  }
	}
	
	
	function loadDocuments(input, options) {
	  input = String(input);
	  options = options || {};
	
	  if (input.length !== 0) {
	
	    // Add tailing `\n` if not exists
	    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
	        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
	      input += '\n';
	    }
	
	    // Strip BOM
	    if (input.charCodeAt(0) === 0xFEFF) {
	      input = input.slice(1);
	    }
	  }
	
	  var state = new State(input, options);
	
	  // Use 0 as string terminator. That significantly simplifies bounds check.
	  state.input += '\0';
	
	  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
	    state.lineIndent += 1;
	    state.position += 1;
	  }
	
	  while (state.position < (state.length - 1)) {
	    readDocument(state);
	  }
	
	  return state.documents;
	}
	
	
	function loadAll(input, iterator, options) {
	  var documents = loadDocuments(input, options), index, length;
	
	  if (typeof iterator !== 'function') {
	    return documents;
	  }
	
	  for (index = 0, length = documents.length; index < length; index += 1) {
	    iterator(documents[index]);
	  }
	}
	
	
	function load(input, options) {
	  var documents = loadDocuments(input, options);
	
	  if (documents.length === 0) {
	    /*eslint-disable no-undefined*/
	    return undefined;
	  } else if (documents.length === 1) {
	    return documents[0];
	  }
	  throw new YAMLException('expected a single document in the stream, but found more');
	}
	
	
	function safeLoadAll(input, output, options) {
	  if (typeof output === 'function') {
	    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	  } else {
	    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	  }
	}
	
	
	function safeLoad(input, options) {
	  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	
	
	module.exports.loadAll     = loadAll;
	module.exports.load        = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad    = safeLoad;


/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var common = __webpack_require__(55);
	
	
	function Mark(name, buffer, position, line, column) {
	  this.name     = name;
	  this.buffer   = buffer;
	  this.position = position;
	  this.line     = line;
	  this.column   = column;
	}
	
	
	Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
	  var head, start, tail, end, snippet;
	
	  if (!this.buffer) return null;
	
	  indent = indent || 4;
	  maxLength = maxLength || 75;
	
	  head = '';
	  start = this.position;
	
	  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
	    start -= 1;
	    if (this.position - start > (maxLength / 2 - 1)) {
	      head = ' ... ';
	      start += 5;
	      break;
	    }
	  }
	
	  tail = '';
	  end = this.position;
	
	  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
	    end += 1;
	    if (end - this.position > (maxLength / 2 - 1)) {
	      tail = ' ... ';
	      end -= 5;
	      break;
	    }
	  }
	
	  snippet = this.buffer.slice(start, end);
	
	  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
	         common.repeat(' ', indent + this.position - start + head.length) + '^';
	};
	
	
	Mark.prototype.toString = function toString(compact) {
	  var snippet, where = '';
	
	  if (this.name) {
	    where += 'in "' + this.name + '" ';
	  }
	
	  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
	
	  if (!compact) {
	    snippet = this.getSnippet();
	
	    if (snippet) {
	      where += ':\n' + snippet;
	    }
	  }
	
	  return where;
	};
	
	
	module.exports = Mark;


/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

	var require;'use strict';
	
	/*eslint-disable no-bitwise*/
	
	var NodeBuffer;
	
	try {
	  // A trick for browserified version, to not include `Buffer` shim
	  var _require = require;
	  NodeBuffer = __webpack_require__(390).Buffer;
	} catch (__) {}
	
	var Type       = __webpack_require__(18);
	
	
	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
	
	
	function resolveYamlBinary(data) {
	  if (data === null) return false;
	
	  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
	
	  // Convert one by one.
	  for (idx = 0; idx < max; idx++) {
	    code = map.indexOf(data.charAt(idx));
	
	    // Skip CR/LF
	    if (code > 64) continue;
	
	    // Fail on illegal characters
	    if (code < 0) return false;
	
	    bitlen += 6;
	  }
	
	  // If there are any bits left, source was corrupted
	  return (bitlen % 8) === 0;
	}
	
	function constructYamlBinary(data) {
	  var idx, tailbits,
	      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
	      max = input.length,
	      map = BASE64_MAP,
	      bits = 0,
	      result = [];
	
	  // Collect by 6*4 bits (3 bytes)
	
	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 4 === 0) && idx) {
	      result.push((bits >> 16) & 0xFF);
	      result.push((bits >> 8) & 0xFF);
	      result.push(bits & 0xFF);
	    }
	
	    bits = (bits << 6) | map.indexOf(input.charAt(idx));
	  }
	
	  // Dump tail
	
	  tailbits = (max % 4) * 6;
	
	  if (tailbits === 0) {
	    result.push((bits >> 16) & 0xFF);
	    result.push((bits >> 8) & 0xFF);
	    result.push(bits & 0xFF);
	  } else if (tailbits === 18) {
	    result.push((bits >> 10) & 0xFF);
	    result.push((bits >> 2) & 0xFF);
	  } else if (tailbits === 12) {
	    result.push((bits >> 4) & 0xFF);
	  }
	
	  // Wrap into Buffer for NodeJS and leave Array for browser
	  if (NodeBuffer) {
	    // Support node 6.+ Buffer API when available
	    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
	  }
	
	  return result;
	}
	
	function representYamlBinary(object /*, style*/) {
	  var result = '', bits = 0, idx, tail,
	      max = object.length,
	      map = BASE64_MAP;
	
	  // Convert every three bytes to 4 ASCII characters.
	
	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 3 === 0) && idx) {
	      result += map[(bits >> 18) & 0x3F];
	      result += map[(bits >> 12) & 0x3F];
	      result += map[(bits >> 6) & 0x3F];
	      result += map[bits & 0x3F];
	    }
	
	    bits = (bits << 8) + object[idx];
	  }
	
	  // Dump tail
	
	  tail = max % 3;
	
	  if (tail === 0) {
	    result += map[(bits >> 18) & 0x3F];
	    result += map[(bits >> 12) & 0x3F];
	    result += map[(bits >> 6) & 0x3F];
	    result += map[bits & 0x3F];
	  } else if (tail === 2) {
	    result += map[(bits >> 10) & 0x3F];
	    result += map[(bits >> 4) & 0x3F];
	    result += map[(bits << 2) & 0x3F];
	    result += map[64];
	  } else if (tail === 1) {
	    result += map[(bits >> 2) & 0x3F];
	    result += map[(bits << 4) & 0x3F];
	    result += map[64];
	    result += map[64];
	  }
	
	  return result;
	}
	
	function isBinary(object) {
	  return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	
	module.exports = new Type('tag:yaml.org,2002:binary', {
	  kind: 'scalar',
	  resolve: resolveYamlBinary,
	  construct: constructYamlBinary,
	  predicate: isBinary,
	  represent: representYamlBinary
	});


/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	function resolveYamlBoolean(data) {
	  if (data === null) return false;
	
	  var max = data.length;
	
	  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
	         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}
	
	function constructYamlBoolean(data) {
	  return data === 'true' ||
	         data === 'True' ||
	         data === 'TRUE';
	}
	
	function isBoolean(object) {
	  return Object.prototype.toString.call(object) === '[object Boolean]';
	}
	
	module.exports = new Type('tag:yaml.org,2002:bool', {
	  kind: 'scalar',
	  resolve: resolveYamlBoolean,
	  construct: constructYamlBoolean,
	  predicate: isBoolean,
	  represent: {
	    lowercase: function (object) { return object ? 'true' : 'false'; },
	    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
	    camelcase: function (object) { return object ? 'True' : 'False'; }
	  },
	  defaultStyle: 'lowercase'
	});


/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var common = __webpack_require__(55);
	var Type   = __webpack_require__(18);
	
	var YAML_FLOAT_PATTERN = new RegExp(
	  // 2.5e4, 2.5 and integers
	  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
	  // .2e4, .2
	  // special case, seems not from spec
	  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
	  // 20:59
	  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
	  // .inf
	  '|[-+]?\\.(?:inf|Inf|INF)' +
	  // .nan
	  '|\\.(?:nan|NaN|NAN))$');
	
	function resolveYamlFloat(data) {
	  if (data === null) return false;
	
	  if (!YAML_FLOAT_PATTERN.test(data) ||
	      // Quick hack to not allow integers end with `_`
	      // Probably should update regexp & check speed
	      data[data.length - 1] === '_') {
	    return false;
	  }
	
	  return true;
	}
	
	function constructYamlFloat(data) {
	  var value, sign, base, digits;
	
	  value  = data.replace(/_/g, '').toLowerCase();
	  sign   = value[0] === '-' ? -1 : 1;
	  digits = [];
	
	  if ('+-'.indexOf(value[0]) >= 0) {
	    value = value.slice(1);
	  }
	
	  if (value === '.inf') {
	    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	
	  } else if (value === '.nan') {
	    return NaN;
	
	  } else if (value.indexOf(':') >= 0) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseFloat(v, 10));
	    });
	
	    value = 0.0;
	    base = 1;
	
	    digits.forEach(function (d) {
	      value += d * base;
	      base *= 60;
	    });
	
	    return sign * value;
	
	  }
	  return sign * parseFloat(value, 10);
	}
	
	
	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
	
	function representYamlFloat(object, style) {
	  var res;
	
	  if (isNaN(object)) {
	    switch (style) {
	      case 'lowercase': return '.nan';
	      case 'uppercase': return '.NAN';
	      case 'camelcase': return '.NaN';
	    }
	  } else if (Number.POSITIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '.inf';
	      case 'uppercase': return '.INF';
	      case 'camelcase': return '.Inf';
	    }
	  } else if (Number.NEGATIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '-.inf';
	      case 'uppercase': return '-.INF';
	      case 'camelcase': return '-.Inf';
	    }
	  } else if (common.isNegativeZero(object)) {
	    return '-0.0';
	  }
	
	  res = object.toString(10);
	
	  // JS stringifier can build scientific format without dots: 5e-100,
	  // while YAML requres dot: 5.e-100. Fix it with simple hack
	
	  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
	}
	
	function isFloat(object) {
	  return (Object.prototype.toString.call(object) === '[object Number]') &&
	         (object % 1 !== 0 || common.isNegativeZero(object));
	}
	
	module.exports = new Type('tag:yaml.org,2002:float', {
	  kind: 'scalar',
	  resolve: resolveYamlFloat,
	  construct: constructYamlFloat,
	  predicate: isFloat,
	  represent: representYamlFloat,
	  defaultStyle: 'lowercase'
	});


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var common = __webpack_require__(55);
	var Type   = __webpack_require__(18);
	
	function isHexCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
	         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
	         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
	}
	
	function isOctCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
	}
	
	function isDecCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
	}
	
	function resolveYamlInteger(data) {
	  if (data === null) return false;
	
	  var max = data.length,
	      index = 0,
	      hasDigits = false,
	      ch;
	
	  if (!max) return false;
	
	  ch = data[index];
	
	  // sign
	  if (ch === '-' || ch === '+') {
	    ch = data[++index];
	  }
	
	  if (ch === '0') {
	    // 0
	    if (index + 1 === max) return true;
	    ch = data[++index];
	
	    // base 2, base 8, base 16
	
	    if (ch === 'b') {
	      // base 2
	      index++;
	
	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (ch !== '0' && ch !== '1') return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }
	
	
	    if (ch === 'x') {
	      // base 16
	      index++;
	
	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (!isHexCode(data.charCodeAt(index))) return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }
	
	    // base 8
	    for (; index < max; index++) {
	      ch = data[index];
	      if (ch === '_') continue;
	      if (!isOctCode(data.charCodeAt(index))) return false;
	      hasDigits = true;
	    }
	    return hasDigits && ch !== '_';
	  }
	
	  // base 10 (except 0) or base 60
	
	  // value should not start with `_`;
	  if (ch === '_') return false;
	
	  for (; index < max; index++) {
	    ch = data[index];
	    if (ch === '_') continue;
	    if (ch === ':') break;
	    if (!isDecCode(data.charCodeAt(index))) {
	      return false;
	    }
	    hasDigits = true;
	  }
	
	  // Should have digits and should not end with `_`
	  if (!hasDigits || ch === '_') return false;
	
	  // if !base60 - done;
	  if (ch !== ':') return true;
	
	  // base60 almost not used, no needs to optimize
	  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}
	
	function constructYamlInteger(data) {
	  var value = data, sign = 1, ch, base, digits = [];
	
	  if (value.indexOf('_') !== -1) {
	    value = value.replace(/_/g, '');
	  }
	
	  ch = value[0];
	
	  if (ch === '-' || ch === '+') {
	    if (ch === '-') sign = -1;
	    value = value.slice(1);
	    ch = value[0];
	  }
	
	  if (value === '0') return 0;
	
	  if (ch === '0') {
	    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
	    if (value[1] === 'x') return sign * parseInt(value, 16);
	    return sign * parseInt(value, 8);
	  }
	
	  if (value.indexOf(':') !== -1) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseInt(v, 10));
	    });
	
	    value = 0;
	    base = 1;
	
	    digits.forEach(function (d) {
	      value += (d * base);
	      base *= 60;
	    });
	
	    return sign * value;
	
	  }
	
	  return sign * parseInt(value, 10);
	}
	
	function isInteger(object) {
	  return (Object.prototype.toString.call(object)) === '[object Number]' &&
	         (object % 1 === 0 && !common.isNegativeZero(object));
	}
	
	module.exports = new Type('tag:yaml.org,2002:int', {
	  kind: 'scalar',
	  resolve: resolveYamlInteger,
	  construct: constructYamlInteger,
	  predicate: isInteger,
	  represent: {
	    binary:      function (object) { return '0b' + object.toString(2); },
	    octal:       function (object) { return '0'  + object.toString(8); },
	    decimal:     function (object) { return        object.toString(10); },
	    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
	  },
	  defaultStyle: 'decimal',
	  styleAliases: {
	    binary:      [ 2,  'bin' ],
	    octal:       [ 8,  'oct' ],
	    decimal:     [ 10, 'dec' ],
	    hexadecimal: [ 16, 'hex' ]
	  }
	});


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

	var require;'use strict';
	
	var esprima;
	
	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	try {
	  // workaround to exclude package from browserify list.
	  var _require = require;
	  esprima = __webpack_require__(492);
	} catch (_) {
	  /*global window */
	  if (typeof window !== 'undefined') esprima = window.esprima;
	}
	
	var Type = __webpack_require__(18);
	
	function resolveJavascriptFunction(data) {
	  if (data === null) return false;
	
	  try {
	    var source = '(' + data + ')',
	        ast    = esprima.parse(source, { range: true });
	
	    if (ast.type                    !== 'Program'             ||
	        ast.body.length             !== 1                     ||
	        ast.body[0].type            !== 'ExpressionStatement' ||
	        ast.body[0].expression.type !== 'FunctionExpression') {
	      return false;
	    }
	
	    return true;
	  } catch (err) {
	    return false;
	  }
	}
	
	function constructJavascriptFunction(data) {
	  /*jslint evil:true*/
	
	  var source = '(' + data + ')',
	      ast    = esprima.parse(source, { range: true }),
	      params = [],
	      body;
	
	  if (ast.type                    !== 'Program'             ||
	      ast.body.length             !== 1                     ||
	      ast.body[0].type            !== 'ExpressionStatement' ||
	      ast.body[0].expression.type !== 'FunctionExpression') {
	    throw new Error('Failed to resolve function');
	  }
	
	  ast.body[0].expression.params.forEach(function (param) {
	    params.push(param.name);
	  });
	
	  body = ast.body[0].expression.body.range;
	
	  // Esprima's ranges include the first '{' and the last '}' characters on
	  // function expressions. So cut them out.
	  /*eslint-disable no-new-func*/
	  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	}
	
	function representJavascriptFunction(object /*, style*/) {
	  return object.toString();
	}
	
	function isFunction(object) {
	  return Object.prototype.toString.call(object) === '[object Function]';
	}
	
	module.exports = new Type('tag:yaml.org,2002:js/function', {
	  kind: 'scalar',
	  resolve: resolveJavascriptFunction,
	  construct: constructJavascriptFunction,
	  predicate: isFunction,
	  represent: representJavascriptFunction
	});


/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	function resolveJavascriptRegExp(data) {
	  if (data === null) return false;
	  if (data.length === 0) return false;
	
	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';
	
	  // if regexp starts with '/' it can have modifiers and must be properly closed
	  // `/foo/gim` - modifiers tail can be maximum 3 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];
	
	    if (modifiers.length > 3) return false;
	    // if expression starts with /, is should be properly terminated
	    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
	  }
	
	  return true;
	}
	
	function constructJavascriptRegExp(data) {
	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';
	
	  // `/foo/gim` - tail can be maximum 4 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];
	    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	  }
	
	  return new RegExp(regexp, modifiers);
	}
	
	function representJavascriptRegExp(object /*, style*/) {
	  var result = '/' + object.source + '/';
	
	  if (object.global) result += 'g';
	  if (object.multiline) result += 'm';
	  if (object.ignoreCase) result += 'i';
	
	  return result;
	}
	
	function isRegExp(object) {
	  return Object.prototype.toString.call(object) === '[object RegExp]';
	}
	
	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	  kind: 'scalar',
	  resolve: resolveJavascriptRegExp,
	  construct: constructJavascriptRegExp,
	  predicate: isRegExp,
	  represent: representJavascriptRegExp
	});


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	function resolveJavascriptUndefined() {
	  return true;
	}
	
	function constructJavascriptUndefined() {
	  /*eslint-disable no-undefined*/
	  return undefined;
	}
	
	function representJavascriptUndefined() {
	  return '';
	}
	
	function isUndefined(object) {
	  return typeof object === 'undefined';
	}
	
	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	  kind: 'scalar',
	  resolve: resolveJavascriptUndefined,
	  construct: constructJavascriptUndefined,
	  predicate: isUndefined,
	  represent: representJavascriptUndefined
	});


/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	module.exports = new Type('tag:yaml.org,2002:map', {
	  kind: 'mapping',
	  construct: function (data) { return data !== null ? data : {}; }
	});


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	function resolveYamlMerge(data) {
	  return data === '<<' || data === null;
	}
	
	module.exports = new Type('tag:yaml.org,2002:merge', {
	  kind: 'scalar',
	  resolve: resolveYamlMerge
	});


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	function resolveYamlNull(data) {
	  if (data === null) return true;
	
	  var max = data.length;
	
	  return (max === 1 && data === '~') ||
	         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}
	
	function constructYamlNull() {
	  return null;
	}
	
	function isNull(object) {
	  return object === null;
	}
	
	module.exports = new Type('tag:yaml.org,2002:null', {
	  kind: 'scalar',
	  resolve: resolveYamlNull,
	  construct: constructYamlNull,
	  predicate: isNull,
	  represent: {
	    canonical: function () { return '~';    },
	    lowercase: function () { return 'null'; },
	    uppercase: function () { return 'NULL'; },
	    camelcase: function () { return 'Null'; }
	  },
	  defaultStyle: 'lowercase'
	});


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString       = Object.prototype.toString;
	
	function resolveYamlOmap(data) {
	  if (data === null) return true;
	
	  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
	      object = data;
	
	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	    pairHasKey = false;
	
	    if (_toString.call(pair) !== '[object Object]') return false;
	
	    for (pairKey in pair) {
	      if (_hasOwnProperty.call(pair, pairKey)) {
	        if (!pairHasKey) pairHasKey = true;
	        else return false;
	      }
	    }
	
	    if (!pairHasKey) return false;
	
	    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
	    else return false;
	  }
	
	  return true;
	}
	
	function constructYamlOmap(data) {
	  return data !== null ? data : [];
	}
	
	module.exports = new Type('tag:yaml.org,2002:omap', {
	  kind: 'sequence',
	  resolve: resolveYamlOmap,
	  construct: constructYamlOmap
	});


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	var _toString = Object.prototype.toString;
	
	function resolveYamlPairs(data) {
	  if (data === null) return true;
	
	  var index, length, pair, keys, result,
	      object = data;
	
	  result = new Array(object.length);
	
	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	
	    if (_toString.call(pair) !== '[object Object]') return false;
	
	    keys = Object.keys(pair);
	
	    if (keys.length !== 1) return false;
	
	    result[index] = [ keys[0], pair[keys[0]] ];
	  }
	
	  return true;
	}
	
	function constructYamlPairs(data) {
	  if (data === null) return [];
	
	  var index, length, pair, keys, result,
	      object = data;
	
	  result = new Array(object.length);
	
	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	
	    keys = Object.keys(pair);
	
	    result[index] = [ keys[0], pair[keys[0]] ];
	  }
	
	  return result;
	}
	
	module.exports = new Type('tag:yaml.org,2002:pairs', {
	  kind: 'sequence',
	  resolve: resolveYamlPairs,
	  construct: constructYamlPairs
	});


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	module.exports = new Type('tag:yaml.org,2002:seq', {
	  kind: 'sequence',
	  construct: function (data) { return data !== null ? data : []; }
	});


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function resolveYamlSet(data) {
	  if (data === null) return true;
	
	  var key, object = data;
	
	  for (key in object) {
	    if (_hasOwnProperty.call(object, key)) {
	      if (object[key] !== null) return false;
	    }
	  }
	
	  return true;
	}
	
	function constructYamlSet(data) {
	  return data !== null ? data : {};
	}
	
	module.exports = new Type('tag:yaml.org,2002:set', {
	  kind: 'mapping',
	  resolve: resolveYamlSet,
	  construct: constructYamlSet
	});


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	module.exports = new Type('tag:yaml.org,2002:str', {
	  kind: 'scalar',
	  construct: function (data) { return data !== null ? data : ''; }
	});


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Type = __webpack_require__(18);
	
	var YAML_DATE_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9])'                    + // [2] month
	  '-([0-9][0-9])$');                   // [3] day
	
	var YAML_TIMESTAMP_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9]?)'                   + // [2] month
	  '-([0-9][0-9]?)'                   + // [3] day
	  '(?:[Tt]|[ \\t]+)'                 + // ...
	  '([0-9][0-9]?)'                    + // [4] hour
	  ':([0-9][0-9])'                    + // [5] minute
	  ':([0-9][0-9])'                    + // [6] second
	  '(?:\\.([0-9]*))?'                 + // [7] fraction
	  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
	  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute
	
	function resolveYamlTimestamp(data) {
	  if (data === null) return false;
	  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	  return false;
	}
	
	function constructYamlTimestamp(data) {
	  var match, year, month, day, hour, minute, second, fraction = 0,
	      delta = null, tz_hour, tz_minute, date;
	
	  match = YAML_DATE_REGEXP.exec(data);
	  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
	
	  if (match === null) throw new Error('Date resolve error');
	
	  // match: [1] year [2] month [3] day
	
	  year = +(match[1]);
	  month = +(match[2]) - 1; // JS month starts with 0
	  day = +(match[3]);
	
	  if (!match[4]) { // no hour
	    return new Date(Date.UTC(year, month, day));
	  }
	
	  // match: [4] hour [5] minute [6] second [7] fraction
	
	  hour = +(match[4]);
	  minute = +(match[5]);
	  second = +(match[6]);
	
	  if (match[7]) {
	    fraction = match[7].slice(0, 3);
	    while (fraction.length < 3) { // milli-seconds
	      fraction += '0';
	    }
	    fraction = +fraction;
	  }
	
	  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
	
	  if (match[9]) {
	    tz_hour = +(match[10]);
	    tz_minute = +(match[11] || 0);
	    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	    if (match[9] === '-') delta = -delta;
	  }
	
	  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	
	  if (delta) date.setTime(date.getTime() - delta);
	
	  return date;
	}
	
	function representYamlTimestamp(object /*, style*/) {
	  return object.toISOString();
	}
	
	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	  kind: 'scalar',
	  resolve: resolveYamlTimestamp,
	  construct: constructYamlTimestamp,
	  instanceOf: Date,
	  represent: representYamlTimestamp
	});


/***/ }),
/* 537 */
/***/ (function(module, exports) {

	'use strict';
	
	/* eslint no-invalid-this: 1 */
	
	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';
	
	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);
	
	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };
	
	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }
	
	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
	
	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }
	
	    return bound;
	};


/***/ }),
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var CodeGenerationPopupCode_1 = __webpack_require__(563);
	var CodeGenerationPopupHeader_1 = __webpack_require__(565);
	var CodeGenerationPopupEnvironmentChooser_1 = __webpack_require__(564);
	var CodeGenerationPopupClientChooser_1 = __webpack_require__(562);
	var constants_1 = __webpack_require__(101);
	var Modal = __webpack_require__(192);
	var CodeGenerationPopup = function (_super) {
	    __extends(CodeGenerationPopup, _super);
	    function CodeGenerationPopup(props) {
	        var _this = _super.call(this, props) || this;
	        _this.handleSetClient = function (client) {
	            _this.setState({ selectedClient: client });
	        };
	        _this.handleSetEnvironment = function (env) {
	            _this.setState({ selectedEnv: env });
	        };
	        _this.state = {
	            selectedEnv: 'Browser',
	            selectedClient: 'lokka'
	        };
	        return _this;
	    }
	    CodeGenerationPopup.prototype.render = function () {
	        var _a = this.props,
	            query = _a.query,
	            endpointUrl = _a.endpointUrl;
	        var queryActive = Boolean(query) && query.length > 0;
	        return React.createElement(
	            Modal,
	            { isOpen: this.props.isOpen, onRequestClose: this.props.onRequestClose, contentLabel: "Code Generation", style: constants_1.modalStyle },
	            React.createElement(_style2.default, {
	                styleId: 2190860931,
	                css: ".code-generation-popup-wrapper[data-jsx=\"2190860931\"] {max-height: calc(100vh - 50px);}.overflowScroll,\n.code-generation-popup-wrapper[data-jsx=\"2190860931\"] {overflow: scroll;}.buttonShadow,\n.code-generation-popup-wrapper[data-jsx=\"2190860931\"] {box-shadow: 0 1px 3px 0 rgba(0,0,0,.2);}.bgWhite,\n.code-generation-popup[data-jsx=\"2190860931\"] {background-color: #fff;}.br2,\n.code-generation-popup[data-jsx=\"2190860931\"] {border-radius: 2px;}.flex,\n.code-generation-popup[data-jsx=\"2190860931\"],\n.choosers[data-jsx=\"2190860931\"] {display: -ms-flexbox;display: flex;}.flexColumn,\n.code-generation-popup[data-jsx=\"2190860931\"] {-ms-flex-direction: column;flex-direction: column;}.overflowXHidden,\n.code-generation-popup[data-jsx=\"2190860931\"] {overflow-x: hidden;}.flex,\n.code-generation-popup[data-jsx=\"2190860931\"],\n.choosers[data-jsx=\"2190860931\"] {display: -ms-flexbox;display: flex;}.w100,\n.choosers[data-jsx=\"2190860931\"] {width: 100%;}"
	            }),
	            React.createElement(
	                "div",
	                { className: "code-generation-popup-wrapper", "data-jsx": 2190860931
	                },
	                React.createElement(
	                    "div",
	                    { className: "code-generation-popup", "data-jsx": 2190860931
	                    },
	                    React.createElement(CodeGenerationPopupHeader_1.default, { queryActive: queryActive }),
	                    React.createElement(
	                        "div",
	                        { className: "choosers", "data-jsx": 2190860931
	                        },
	                        React.createElement(CodeGenerationPopupEnvironmentChooser_1.default, { environment: this.state.selectedEnv, setEnvironment: this.handleSetEnvironment }),
	                        React.createElement(CodeGenerationPopupClientChooser_1.default, { client: this.state.selectedClient, setClient: this.handleSetClient })
	                    ),
	                    React.createElement(CodeGenerationPopupCode_1.default, { endpointUrl: endpointUrl, query: query, client: this.state.selectedClient, environment: this.state.selectedEnv })
	                )
	            )
	        );
	    };
	    return CodeGenerationPopup;
	}(React.Component);
	exports.CodeGenerationPopup = CodeGenerationPopup;

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2); // tslint:disable-line
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	var calculate_size_1 = __webpack_require__(126);
	var clients = ['lokka', 'fetch'];
	var Chooser = function Chooser(props) {
	  return React.createElement(
	    "div",
	    { className: cx(graphcool_styles_1.$p.bb, graphcool_styles_1.$p.bt, graphcool_styles_1.$p.bl, graphcool_styles_1.$p.bBlack10, graphcool_styles_1.$p.flex1), "data-jsx": 1042326032
	    },
	    React.createElement(_style2.default, {
	      styleId: 1042326032,
	      css: ".condition-button[data-jsx=\"1042326032\"]:not(.bgGreen):hover {background-color: rgba(0, 0, 0, .1);}"
	    }),
	    React.createElement(
	      "div",
	      { className: cx(graphcool_styles_1.$p.pa38, graphcool_styles_1.$p.pt16, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexColumn, graphcool_styles_1.$p.itemsCenter), "data-jsx": 1042326032
	      },
	      React.createElement(
	        "h2",
	        { className: cx(graphcool_styles_1.$p.fw3, graphcool_styles_1.$p.mb10, graphcool_styles_1.$p.tc), "data-jsx": 1042326032
	        },
	        "Client"
	      ),
	      React.createElement(
	        "div",
	        { className: cx(graphcool_styles_1.$p.dib, graphcool_styles_1.$p.mt25), "data-jsx": 1042326032
	        },
	        React.createElement(
	          "div",
	          { className: cx(graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexRow, graphcool_styles_1.$p.justifyAround, graphcool_styles_1.$p.ph16, graphcool_styles_1.$p.pv6, graphcool_styles_1.$p.relative, graphcool_styles_1.$p.itemsCenter), "data-jsx": 1042326032
	          },
	          clients.map(function (env) {
	            var width = calculate_size_1.default(env.toUpperCase(), {
	              fontSize: '14px',
	              fontWeight: '600'
	            }).width;
	            return React.createElement(
	              "div",
	              { className: cx(graphcool_styles_1.$p.relative, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.itemsCenter, graphcool_styles_1.$p.justifyCenter, graphcool_styles_1.$p.pointer), onClick: function onClick() {
	                  return props.setClient(env);
	                }, style: { width: width + 15 }, key: env, "data-jsx": 1042326032
	              },
	              React.createElement(
	                "div",
	                { className: cx('condition-button', graphcool_styles_1.$p.nowrap, graphcool_styles_1.$p.absolute, graphcool_styles_1.$p.ph10, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexRow, graphcool_styles_1.$p.itemsCenter, (_a = {}, _a[cx(graphcool_styles_1.$p.pv6, graphcool_styles_1.$p.bgBlack04)] = props.client !== env, _a[cx(graphcool_styles_1.$p.bgGreen, graphcool_styles_1.$p.br2, graphcool_styles_1.$p.pv8, graphcool_styles_1.$p.z1)] = props.client === env, _a)), "data-jsx": 1042326032
	                },
	                React.createElement(
	                  "div",
	                  { className: cx(graphcool_styles_1.$p.ttu, graphcool_styles_1.$p.fw6, graphcool_styles_1.$p.f14, (_b = {}, _b[graphcool_styles_1.$p.black30] = props.client !== env, _b[graphcool_styles_1.$p.white] = props.client === env, _b)), "data-jsx": 1042326032
	                  },
	                  env
	                )
	              )
	            );
	            var _a, _b;
	          })
	        )
	      )
	    )
	  );
	};
	exports.default = Chooser;

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var cx = __webpack_require__(13);
	var graphcool_styles_1 = __webpack_require__(26);
	var codeGeneration_1 = __webpack_require__(567);
	var Codemirror = __webpack_require__(566);
	var CodeGenerationPopupCode = function (_super) {
	    __extends(CodeGenerationPopupCode, _super);
	    function CodeGenerationPopupCode() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    CodeGenerationPopupCode.prototype.componentWillMount = function () {
	        __webpack_require__(495);
	        __webpack_require__(496);
	        __webpack_require__(407);
	        __webpack_require__(408);
	    };
	    CodeGenerationPopupCode.prototype.render = function () {
	        var _a = this.props,
	            client = _a.client,
	            environment = _a.environment,
	            endpointUrl = _a.endpointUrl,
	            query = _a.query;
	        var generator = new codeGeneration_1.CodeGenerator(client, environment, endpointUrl);
	        var projectSetup = generator.getSetup();
	        var code = generator.getCode(query);
	        return React.createElement(
	            "div",
	            { className: cx(graphcool_styles_1.$p.pa38, graphcool_styles_1.$p.pt16, 'code-generation-popup'), "data-jsx": 636455752
	            },
	            React.createElement(_style2.default, {
	                styleId: 1204972749,
	                css: ".fw3,\nh3[data-jsx=\"636455752\"] {\n    font-weight: 300\n}\n.f25,\nh3[data-jsx=\"636455752\"] {\n    font-size: 25px\n}\n.mv16,\nh3[data-jsx=\"636455752\"] {\n    margin-top: 16px;\n    margin-bottom: 16px\n}"
	            }),
	            React.createElement(_style2.default, {
	                styleId: 266628640,
	                css: "\n          .code-generation-popup .CodeMirror {\n            height: auto;\n          }\n.pa6,\n.code-generation-popup .CodeMirror {\n            padding: 6px;\n}\n        "
	            }),
	            React.createElement(
	                "h3",
	                {
	                    "data-jsx": 636455752
	                },
	                "Project Setup"
	            ),
	            React.createElement(Codemirror, { key: projectSetup, value: projectSetup, options: {
	                    height: 'auto',
	                    mode: 'shell',
	                    viewportMargin: Infinity,
	                    theme: 'dracula'
	                }, onFocusChange: function onFocusChange(focused) {
	                    if (focused) {
	                        // TODO track
	                    }
	                } }),
	            React.createElement(
	                "h3",
	                {
	                    "data-jsx": 636455752
	                },
	                "Code"
	            ),
	            React.createElement(Codemirror, { key: code, value: code, options: {
	                    height: 'auto',
	                    viewportMargin: Infinity,
	                    mode: 'javascript',
	                    theme: 'dracula'
	                }, onFocusChange: function onFocusChange(focused) {
	                    if (focused) {
	                        // TODO track
	                    }
	                } })
	        );
	    };
	    return CodeGenerationPopupCode;
	}(React.Component);
	exports.default = CodeGenerationPopupCode;

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2); // tslint:disable-line
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	var calculate_size_1 = __webpack_require__(126);
	var environments = ['Node', 'Browser'];
	var Chooser = function Chooser(props) {
	  return React.createElement(
	    "div",
	    { className: cx(graphcool_styles_1.$p.bt, graphcool_styles_1.$p.bb, graphcool_styles_1.$p.bBlack10, graphcool_styles_1.$p.flex1), "data-jsx": 1042326032
	    },
	    React.createElement(_style2.default, {
	      styleId: 1042326032,
	      css: ".condition-button[data-jsx=\"1042326032\"]:not(.bgGreen):hover {background-color: rgba(0, 0, 0, .1);}"
	    }),
	    React.createElement(
	      "div",
	      { className: cx(graphcool_styles_1.$p.pa38, graphcool_styles_1.$p.pt16, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexColumn, graphcool_styles_1.$p.itemsCenter), "data-jsx": 1042326032
	      },
	      React.createElement(
	        "h2",
	        { className: cx(graphcool_styles_1.$p.fw3, graphcool_styles_1.$p.mb10, graphcool_styles_1.$p.tc), "data-jsx": 1042326032
	        },
	        "Environment"
	      ),
	      React.createElement(
	        "div",
	        { className: cx(graphcool_styles_1.$p.dib, graphcool_styles_1.$p.mt25), "data-jsx": 1042326032
	        },
	        React.createElement(
	          "div",
	          { className: cx(graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexRow, graphcool_styles_1.$p.justifyAround, graphcool_styles_1.$p.ph16, graphcool_styles_1.$p.pv6, graphcool_styles_1.$p.relative, graphcool_styles_1.$p.itemsCenter), "data-jsx": 1042326032
	          },
	          environments.map(function (env) {
	            var width = calculate_size_1.default(env.toUpperCase(), {
	              fontSize: '14px',
	              fontWeight: '600'
	            }).width;
	            return React.createElement(
	              "div",
	              { className: cx(graphcool_styles_1.$p.relative, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.itemsCenter, graphcool_styles_1.$p.justifyCenter, graphcool_styles_1.$p.pointer), onClick: function onClick() {
	                  return props.setEnvironment(env);
	                }, style: { width: width + 15 }, key: env, "data-jsx": 1042326032
	              },
	              React.createElement(
	                "div",
	                { className: cx('condition-button', graphcool_styles_1.$p.nowrap, graphcool_styles_1.$p.absolute, graphcool_styles_1.$p.ph10, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexRow, graphcool_styles_1.$p.itemsCenter, (_a = {}, _a[cx(graphcool_styles_1.$p.pv6, graphcool_styles_1.$p.bgBlack04)] = props.environment !== env, _a[cx(graphcool_styles_1.$p.bgGreen, graphcool_styles_1.$p.br2, graphcool_styles_1.$p.pv8, graphcool_styles_1.$p.z1)] = props.environment === env, _a)), "data-jsx": 1042326032
	                },
	                React.createElement(
	                  "div",
	                  { className: cx(graphcool_styles_1.$p.ttu, graphcool_styles_1.$p.fw6, graphcool_styles_1.$p.f14, (_b = {}, _b[graphcool_styles_1.$p.black30] = props.environment !== env, _b[graphcool_styles_1.$p.white] = props.environment === env, _b)), "data-jsx": 1042326032
	                  },
	                  env
	                )
	              )
	            );
	            var _a, _b;
	          })
	        )
	      )
	    )
	  );
	};
	exports.default = Chooser;

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2); // tslint:disable-line
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	exports.default = function (props) {
	  return React.createElement(
	    "div",
	    { className: cx(graphcool_styles_1.$p.flex, graphcool_styles_1.$p.justifyCenter, graphcool_styles_1.$p.black, graphcool_styles_1.$p.itemsCenter, graphcool_styles_1.$p.w100, 'container'), "data-jsx": 3419975726
	    },
	    React.createElement(_style2.default, {
	      styleId: 3419975726,
	      css: ".container[data-jsx=\"3419975726\"] {height: 103px;}"
	    }),
	    React.createElement(
	      "div",
	      { className: cx(graphcool_styles_1.$p.f25, graphcool_styles_1.$p.fw3, graphcool_styles_1.$p.flex, graphcool_styles_1.$p.flexRow, graphcool_styles_1.$p.itemsCenter), "data-jsx": 3419975726
	      },
	      "Generate Code for your",
	      React.createElement(
	        "div",
	        { className: cx(graphcool_styles_1.$p.fw6, graphcool_styles_1.$p.ml6), "data-jsx": 3419975726
	        },
	        props.queryActive ? 'Query' : 'Mutation'
	      )
	    )
	  );
	};

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(36);
	var className = __webpack_require__(13);
	var debounce = __webpack_require__(664);
	
	function normalizeLineEndings(str) {
	  if (!str) return str;
	  return str.replace(/\r\n|\r/g, '\n');
	}
	
	var CodeMirror = React.createClass({
	  displayName: 'CodeMirror',
	
	  propTypes: {
	    className: React.PropTypes.any,
	    codeMirrorInstance: React.PropTypes.func,
	    defaultValue: React.PropTypes.string,
	    onChange: React.PropTypes.func,
	    onFocusChange: React.PropTypes.func,
	    onScroll: React.PropTypes.func,
	    options: React.PropTypes.object,
	    path: React.PropTypes.string,
	    value: React.PropTypes.string,
	    preserveScrollPosition: React.PropTypes.bool
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      preserveScrollPosition: false
	    };
	  },
	  getCodeMirrorInstance: function getCodeMirrorInstance() {
	    return this.props.codeMirrorInstance || __webpack_require__(5);
	  },
	  getInitialState: function getInitialState() {
	    return {
	      isFocused: false
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    this.componentWillReceiveProps = debounce(this.componentWillReceiveProps, 0);
	  },
	  componentDidMount: function componentDidMount() {
	    var textareaNode = this._textarea;
	    var codeMirrorInstance = this.getCodeMirrorInstance();
	    this.codeMirror = codeMirrorInstance.fromTextArea(textareaNode, this.props.options);
	    this.codeMirror.on('change', this.codemirrorValueChanged);
	    this.codeMirror.on('focus', this.focusChanged.bind(this, true));
	    this.codeMirror.on('blur', this.focusChanged.bind(this, false));
	    this.codeMirror.on('scroll', this.scrollChanged);
	    this.codeMirror.setValue(this.props.defaultValue || this.props.value || '');
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    // is there a lighter-weight way to remove the cm instance?
	    if (this.codeMirror) {
	      this.codeMirror.toTextArea();
	    }
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if (this.codeMirror && nextProps.value !== undefined && normalizeLineEndings(this.codeMirror.getValue()) !== normalizeLineEndings(nextProps.value)) {
	      if (this.props.preserveScrollPosition) {
	        var prevScrollPosition = this.codeMirror.getScrollInfo();
	        this.codeMirror.setValue(nextProps.value);
	        this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
	      } else {
	        this.codeMirror.setValue(nextProps.value);
	      }
	    }
	    if (typeof nextProps.options === 'object') {
	      for (var optionName in nextProps.options) {
	        if (nextProps.options.hasOwnProperty(optionName)) {
	          this.codeMirror.setOption(optionName, nextProps.options[optionName]);
	        }
	      }
	    }
	  },
	  getCodeMirror: function getCodeMirror() {
	    return this.codeMirror;
	  },
	  focus: function focus() {
	    if (this.codeMirror) {
	      this.codeMirror.focus();
	    }
	  },
	  focusChanged: function focusChanged(focused) {
	    this.setState({
	      isFocused: focused
	    });
	    this.props.onFocusChange && this.props.onFocusChange(focused);
	  },
	  scrollChanged: function scrollChanged(cm) {
	    this.props.onScroll && this.props.onScroll(cm.getScrollInfo());
	  },
	  codemirrorValueChanged: function codemirrorValueChanged(doc, change) {
	    if (this.props.onChange && change.origin !== 'setValue') {
	      this.props.onChange(doc.getValue(), change);
	    }
	  },
	  render: function render() {
	    var _this = this;
	
	    var editorClassName = className('ReactCodeMirror', this.state.isFocused ? 'ReactCodeMirror--focused' : null, this.props.className);
	    return React.createElement(
	      'div',
	      { className: editorClassName },
	      React.createElement('textarea', {
	        ref: function (textarea) {
	          return _this._textarea = textarea;
	        },
	        name: this.props.path,
	        defaultValue: this.props.value,
	        autoComplete: 'off'
	      })
	    );
	  }
	});
	
	module.exports = CodeMirror;


/***/ }),
/* 567 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var CodeGenerator = function () {
	    function CodeGenerator(client, environment, endpointUrl) {
	        this.client = client;
	        this.environment = environment;
	        this.endpointUrl = endpointUrl;
	    }
	    CodeGenerator.prototype.getSetup = function () {
	        var template = "$ npm install ";
	        if (this.client === 'lokka') {
	            return template + "lokka lokka-transport-http";
	        } else if (this.client === 'fetch') {
	            return template + "isomorphic-fetch es6-promise";
	        }
	        return '';
	    };
	    CodeGenerator.prototype.getCode = function (query) {
	        return this.getImports() + this.getTransport() + '\n' + this.getQueryCode(query);
	    };
	    CodeGenerator.prototype.getTransport = function () {
	        if (this.client === 'lokka') {
	            return "\nconst headers = {\n  Authorization: 'Bearer YOUR_AUTH_TOKEN'\n}\n\nconst client = new Lokka({\n  transport: new Transport('" + this.endpointUrl + "', {headers})\n});\n";
	        }
	        return '';
	    };
	    CodeGenerator.prototype.getImports = function () {
	        if (this.client === 'lokka' && this.environment === 'Node') {
	            return "const Lokka = require('lokka').Lokka;\nconst Transport = require('lokka-transport-http').Transport;\n";
	        } else if (this.client === 'lokka' && this.environment === 'Browser') {
	            return "import {Lokka} from 'lokka'\nimport {Transport} from 'lokka-transport-http'\n";
	        } else if (this.client === 'fetch') {
	            return "require('es6-promise').polyfill()\nrequire('isomorphic-fetch')\n";
	        }
	        return '';
	    };
	    CodeGenerator.prototype.getQueryCode = function (query) {
	        if (query.includes('mutation')) {
	            return this.getMutation(query);
	        } else {
	            return this.getQuery(query);
	        }
	    };
	    CodeGenerator.prototype.getQuery = function (query) {
	        if (this.client === 'lokka') {
	            return "function getItems() {\n  return client.query(`\n  " + query.split('\n').map(function (line, i) {
	                return '    ' + line;
	            }).join('\n') + "\n  `)\n}";
	        }
	        if (this.client === 'fetch') {
	            return "function getItems() {" + this.getFetchBody(query) + "}";
	        }
	        return '';
	    };
	    CodeGenerator.prototype.getFetchBody = function (query) {
	        var jsonQuery = JSON.stringify({
	            query: query
	        });
	        return "\n    return fetch('" + this.endpointUrl + "', {\n      method: 'post',\n      headers: {\n        'Content-Type': 'application/json',\n      //   'Authorization': 'Bearer YOUR_AUTH_TOKEN'\n      },\n      body: '" + jsonQuery + "',\n    })\n";
	    };
	    CodeGenerator.prototype.getMutation = function (query) {
	        var curlyIndex = query.indexOf('{');
	        var strippedQuery = query.slice(curlyIndex, query.length);
	        if (this.client === 'lokka') {
	            return "function setItem() {\nreturn client.mutate(`\n" + strippedQuery.split('\n').map(function (line, i) {
	                return '    ' + line;
	            }).join('\n') + "\n  `)\n}";
	        }
	        if (this.client === 'fetch') {
	            return "function setItem() {" + this.getFetchBody(query) + "}";
	        }
	        return '';
	    };
	    return CodeGenerator;
	}();
	exports.CodeGenerator = CodeGenerator;

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var graphql_1 = __webpack_require__(12);
	var cx = __webpack_require__(13);
	var FieldDoc_1 = __webpack_require__(592);
	var SchemaDoc_1 = __webpack_require__(569);
	var SearchBox_1 = __webpack_require__(153);
	var SearchResults_1 = __webpack_require__(593);
	var TypeDoc_1 = __webpack_require__(594);
	var DocExplorer = function (_super) {
	    __extends(DocExplorer, _super);
	    function DocExplorer(props) {
	        var _this = _super.call(this, props) || this;
	        _this.handleNavBackClick = function () {
	            _this.setState({ navStack: _this.state.navStack.slice(0, -1) });
	        };
	        _this.handleClickTypeOrField = function (typeOrField) {
	            _this.showDoc(typeOrField);
	        };
	        _this.handleSearch = function (value) {
	            _this.showSearch({
	                name: 'Search Results',
	                searchValue: value
	            });
	        };
	        _this.state = { navStack: [], searchValue: undefined };
	        return _this;
	    }
	    DocExplorer.prototype.shouldComponentUpdate = function (nextProps, nextState) {
	        return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack || this.state.searchValue !== nextState.searchValue;
	    };
	    DocExplorer.prototype.render = function () {
	        var schema = this.props.schema;
	        var navStack = this.state.navStack;
	        var navItem;
	        if (navStack.length > 0) {
	            navItem = navStack[navStack.length - 1];
	        }
	        var title = 'Documentation Explorer';
	        var content;
	        if (schema === undefined) {
	            // Schema is undefined when it is being loaded via introspection.
	            content = React.createElement(
	                "div",
	                { className: "spinner-container" },
	                React.createElement("div", { className: "spinner" })
	            );
	        } else if (schema === null) {
	            // Schema is null when it explicitly does not exist, typically due to
	            // an error during introspection.
	            content = React.createElement(
	                "div",
	                { className: "error-container" },
	                'No Schema Available'
	            );
	        } else if (navItem) {
	            if (navItem.name === 'Search Results') {
	                title = navItem.name;
	                content = React.createElement(SearchResults_1.default, { searchValue: navItem.searchValue, schema: schema, onClickType: this.handleClickTypeOrField, onClickField: this.handleClickTypeOrField });
	            } else {
	                title = navItem.name;
	                if (graphql_1.isType(navItem)) {
	                    content = React.createElement(TypeDoc_1.default, { key: navItem.name, schema: schema, type: navItem, onClickType: this.handleClickTypeOrField, onClickField: this.handleClickTypeOrField });
	                } else {
	                    content = React.createElement(FieldDoc_1.default, { key: navItem.name, field: navItem, onClickType: this.handleClickTypeOrField });
	                }
	            }
	        } else if (schema) {
	            content = React.createElement(SchemaDoc_1.default, { schema: schema, onClickType: this.handleClickTypeOrField });
	        }
	        var prevName;
	        if (navStack.length === 1) {
	            prevName = 'Schema';
	        } else if (navStack.length > 1) {
	            prevName = navStack[navStack.length - 2].name;
	        }
	        var shouldSearchBoxAppear = content && (content.type === SearchResults_1.default || content.type === SchemaDoc_1.default);
	        return React.createElement(
	            "div",
	            { className: cx('doc-explorer', {
	                    'show-title': Boolean(prevName)
	                }), "data-jsx": 1799508982
	            },
	            React.createElement(_style2.default, {
	                styleId: 1799508982,
	                css: ".doc-explorer[data-jsx=\"1799508982\"] {border-left: 6px solid rgba(39, 174, 96, 1);}.doc-explorer-contents[data-jsx=\"1799508982\"] {top: 0;box-shadow: none;height: calc(100% - 57px);}.doc-explorer-title-bar[data-jsx=\"1799508982\"] {z-index: 2;}.relative,\n.doc-explorer[data-jsx=\"1799508982\"],\n.doc-explorer-contents[data-jsx=\"1799508982\"] {position: relative;}.h100,\n.doc-explorer[data-jsx=\"1799508982\"] {height: 100%;}.pa0,\n.doc-explorer-contents[data-jsx=\"1799508982\"] {padding: 0;}.overflowYScroll,\n.doc-explorer-contents[data-jsx=\"1799508982\"] {overflow-y: scroll;}.nosb,\n.doc-explorer-contents[data-jsx=\"1799508982\"] {-ms-overflow-style: none;}.nosb::-webkit-scrollbar,\n.doc-explorer-contents[data-jsx=\"1799508982\"]::-webkit-scrollbar {display: none;}.relative,\n.doc-explorer[data-jsx=\"1799508982\"],\n.doc-explorer-contents[data-jsx=\"1799508982\"] {position: relative;}"
	            }),
	            prevName && React.createElement(
	                "div",
	                { className: 'doc-explorer-title-bar', "data-jsx": 1799508982
	                },
	                React.createElement(
	                    "div",
	                    { className: "doc-explorer-back", onClick: this.handleNavBackClick, "data-jsx": 1799508982
	                    },
	                    prevName
	                ),
	                React.createElement(
	                    "div",
	                    { className: "doc-explorer-title", "data-jsx": 1799508982
	                    },
	                    title
	                )
	            ),
	            React.createElement(
	                "div",
	                { className: "doc-explorer-contents", "data-jsx": 1799508982
	                },
	                React.createElement(
	                    "div",
	                    { className: "header", "data-jsx": 1799508982
	                    },
	                    React.createElement(SearchBox_1.default, { isShown: shouldSearchBoxAppear, onSearch: this.handleSearch })
	                ),
	                content
	            )
	        );
	    };
	    // Public API
	    DocExplorer.prototype.showDoc = function (typeOrField) {
	        var navStack = this.state.navStack;
	        var isCurrentlyShown = navStack.length > 0 && navStack[navStack.length - 1] === typeOrField;
	        if (!isCurrentlyShown) {
	            navStack = navStack.concat([typeOrField]);
	        }
	        this.setState({ navStack: navStack });
	    };
	    // Public API
	    DocExplorer.prototype.showSearch = function (searchItem) {
	        var navStack = this.state.navStack;
	        var lastEntry = navStack.length > 0 && navStack[navStack.length - 1];
	        if (!lastEntry) {
	            navStack = navStack.concat([searchItem]);
	        } else if (lastEntry.searchValue !== searchItem.searchValue) {
	            navStack = navStack.slice(0, -1).concat([searchItem]);
	        }
	        this.setState({ navStack: navStack });
	    };
	    return DocExplorer;
	}(React.Component);
	exports.DocExplorer = DocExplorer;

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var TypeLink_1 = __webpack_require__(77);
	var MarkdownContent_1 = __webpack_require__(155);
	// Render the top level Schema
	var SchemaDoc = function (_super) {
	    __extends(SchemaDoc, _super);
	    function SchemaDoc() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    SchemaDoc.prototype.shouldComponentUpdate = function (nextProps) {
	        return this.props.schema !== nextProps.schema;
	    };
	    SchemaDoc.prototype.render = function () {
	        var schema = this.props.schema;
	        var queryType = schema.getQueryType();
	        var mutationType = schema.getMutationType && schema.getMutationType();
	        var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();
	        return React.createElement(
	            "div",
	            { className: "root" },
	            React.createElement(MarkdownContent_1.default, { className: "doc-type-description", markdown: 'A GraphQL schema provides a root type for each kind of operation.' }),
	            React.createElement(
	                "div",
	                { className: "doc-category" },
	                React.createElement(
	                    "div",
	                    { className: "doc-category-title" },
	                    'root types'
	                ),
	                React.createElement(
	                    "div",
	                    { className: "doc-category-item" },
	                    React.createElement(
	                        "span",
	                        { className: "keyword" },
	                        'query'
	                    ),
	                    ': ',
	                    React.createElement(TypeLink_1.default, { type: queryType, onClick: this.props.onClickType })
	                ),
	                mutationType && React.createElement(
	                    "div",
	                    { className: "doc-category-item" },
	                    React.createElement(
	                        "span",
	                        { className: "keyword" },
	                        'mutation'
	                    ),
	                    ': ',
	                    React.createElement(TypeLink_1.default, { type: mutationType, onClick: this.props.onClickType })
	                ),
	                subscriptionType && React.createElement(
	                    "div",
	                    { className: "doc-category-item" },
	                    React.createElement(
	                        "span",
	                        { className: "keyword" },
	                        'subscription'
	                    ),
	                    ': ',
	                    React.createElement(TypeLink_1.default, { type: subscriptionType, onClick: this.props.onClickType })
	                )
	            )
	        );
	    };
	    return SchemaDoc;
	}(React.Component);
	exports.default = SchemaDoc;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var cx = __webpack_require__(13);
	var firstTime = true;
	/**
	 * ExecuteButton
	 *
	 * What a nice round shiny button. Shows a drop-down when there are multiple
	 * queries to run.
	 */
	var ExecuteButton = function (_super) {
	    __extends(ExecuteButton, _super);
	    function ExecuteButton(props) {
	        var _this = _super.call(this, props) || this;
	        _this._onClick = function () {
	            if (_this.props.isRunning) {
	                _this.props.onStop();
	            } else {
	                _this.props.onRun();
	            }
	        };
	        _this._onOptionSelected = function (operation) {
	            _this.setState({ optionsOpen: false });
	            _this.props.onRun(operation.name && operation.name.value);
	        };
	        _this._onOptionsOpen = function (downEvent) {
	            var initialPress = true;
	            var downTarget = downEvent.target;
	            _this.setState({ highlight: null, optionsOpen: true });
	            var _onMouseUp = function onMouseUp(upEvent) {
	                if (initialPress && upEvent.target === downTarget) {
	                    initialPress = false;
	                } else {
	                    document.removeEventListener('mouseup', _onMouseUp);
	                    _onMouseUp = null;
	                    var isOptionsMenuClicked = downTarget.parentNode.compareDocumentPosition(upEvent.target) & Node.DOCUMENT_POSITION_CONTAINED_BY;
	                    if (!isOptionsMenuClicked) {
	                        _this.setState({ optionsOpen: false });
	                    }
	                    if (firstTime) {
	                        _this._onOptionSelected(_this.props.operations.find(function (op) {
	                            return op.name.value === upEvent.target.textContent;
	                        }));
	                        firstTime = false;
	                    }
	                }
	            };
	            document.addEventListener('mouseup', _onMouseUp);
	        };
	        _this.state = {
	            optionsOpen: false,
	            highlight: null
	        };
	        return _this;
	    }
	    ExecuteButton.prototype.render = function () {
	        var _this = this;
	        var operations = this.props.operations;
	        var optionsOpen = this.state.optionsOpen;
	        var hasOptions = operations && operations.length > 1;
	        var options = null;
	        if (hasOptions && optionsOpen) {
	            var highlight_1 = this.state.highlight;
	            options = React.createElement(
	                "ul",
	                { className: "execute-options" },
	                operations.map(function (operation) {
	                    return React.createElement(
	                        "li",
	                        { key: operation.name ? operation.name.value : '*', className: operation === highlight_1 ? 'selected' : '', onMouseOver: function onMouseOver() {
	                                return _this.setState({ highlight: operation });
	                            }, onMouseOut: function onMouseOut() {
	                                return _this.setState({ highlight: null });
	                            }, onMouseUp: function onMouseUp() {
	                                return _this._onOptionSelected(operation);
	                            } },
	                        operation.name ? operation.name.value : '<Unnamed>'
	                    );
	                })
	            );
	        }
	        // Allow click event if there is a running query or if there are not options
	        // for which operation to run.
	        var onClick;
	        if (this.props.isRunning || !hasOptions) {
	            onClick = this._onClick;
	        }
	        // Allow mouse down if there is no running query, there are options for
	        // which operation to run, and the dropdown is currently closed.
	        var onMouseDown;
	        if (!this.props.isRunning && hasOptions && !optionsOpen) {
	            onMouseDown = this._onOptionsOpen;
	        }
	        var pathJSX = this.props.isRunning ? React.createElement("rect", { fill: "#FFFFFF", x: "10", y: "10", width: "13", height: "13", rx: "1" }) : React.createElement("path", { d: "M0.02,2.23v32.54c0,1.47,1.52,2.42,2.81,1.76l32.08-16.27c1.43-0.73,1.43-2.8,0-3.53L2.83,0.47\n\tC2.54,0.32,2.25,0.25,1.96,0.25C0.94,0.25,0.02,1.09,0.02,2.23z" });
	        var width = this.props.isRunning ? 35 : 20;
	        return React.createElement(
	            "div",
	            { className: "execute-button-wrap", "data-jsx": 1087431325
	            },
	            React.createElement(_style2.default, {
	                styleId: 1087431325,
	                css: ".execute-button-wrap[data-jsx=\"1087431325\"] {position: absolute !important;left: -62px;z-index: 5;top: 15px;}.graphcool-execute-button[data-jsx=\"1087431325\"] {background-color: rgb(185, 191, 196);border: 6px solid rgb(11, 20, 28);width: 71px;height: 71px;}.graphcool-execute-button[data-jsx=\"1087431325\"]:not(.running) svg[data-jsx=\"1087431325\"] {top: -1px;left: 2px;}.br100,\n.graphcool-execute-button[data-jsx=\"1087431325\"] {border-radius: 100%;}.flex,\n.graphcool-execute-button[data-jsx=\"1087431325\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.graphcool-execute-button[data-jsx=\"1087431325\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyCenter,\n.graphcool-execute-button[data-jsx=\"1087431325\"] {-ms-flex-pack: center;justify-content: center;}.pointer:hover,\n.graphcool-execute-button[data-jsx=\"1087431325\"]:hover {cursor: pointer;}.bgrRed,\n.running[data-jsx=\"1087431325\"] {background-color: #f25c54;}.relative,\n.graphcool-execute-button[data-jsx=\"1087431325\"]:not(.running) svg[data-jsx=\"1087431325\"] {position: relative;}"
	            }),
	            React.createElement(
	                "div",
	                { className: cx('graphcool-execute-button', {
	                        'running': this.props.isRunning
	                    }), onMouseDown: onMouseDown, onClick: onClick, title: "Execute Query (Ctrl-Enter)", "data-jsx": 1087431325
	                },
	                React.createElement(
	                    "svg",
	                    { width: width, height: width, viewBox: this.props.isRunning ? "4.5,4.5,24,24" : "0 0 36 37", "data-jsx": 1087431325
	                    },
	                    pathJSX
	                )
	            ),
	            options
	        );
	    };
	    return ExecuteButton;
	}(React.Component);
	exports.ExecuteButton = ExecuteButton;

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var EndpointChooser_1 = __webpack_require__(572);
	var QueryHeader = function QueryHeader(_a) {
	    var selectedEndpoint = _a.selectedEndpoint,
	        onChangeEndpoint = _a.onChangeEndpoint,
	        onPrettify = _a.onPrettify,
	        showEndpoints = _a.showEndpoints,
	        showQueryTitle = _a.showQueryTitle;
	    return React.createElement(
	        "div",
	        { className: "query-header", "data-jsx": 2288579073
	        },
	        React.createElement(_style2.default, {
	            styleId: 2288579073,
	            css: ".graphiql-button[data-jsx=\"2288579073\"] {margin-right: 33px;padding: 5px 9px 6px 9px;letter-spacing: 0.53px;}.bgDarkerBlue,\n.query-header[data-jsx=\"2288579073\"] {background-color: #0f202e;}.pa25,\n.query-header[data-jsx=\"2288579073\"] {padding: 25px;}.flex,\n.query-header[data-jsx=\"2288579073\"] {display: -ms-flexbox;display: flex;}.justifyBetween,\n.query-header[data-jsx=\"2288579073\"] {-ms-flex-pack: justify;justify-content: space-between;}.itemsCenter,\n.query-header[data-jsx=\"2288579073\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.white50,\n.graphiql-button[data-jsx=\"2288579073\"] {color: hsla(0,0%,100%,.5);}.bgDarkBlue,\n.graphiql-button[data-jsx=\"2288579073\"] {background-color: #172a3a;}.ttu,\n.graphiql-button[data-jsx=\"2288579073\"] {text-transform: uppercase;}.f14,\n.graphiql-button[data-jsx=\"2288579073\"] {font-size: 14px;}.fw6,\n.graphiql-button[data-jsx=\"2288579073\"] {font-weight: 600;}.br2,\n.graphiql-button[data-jsx=\"2288579073\"] {border-radius: 2px;}.pointer:hover,\n.graphiql-button[data-jsx=\"2288579073\"]:hover {cursor: pointer;}"
	        }),
	        showQueryTitle && React.createElement(
	            "div",
	            { className: "editor-title", "data-jsx": 2288579073
	            },
	            "Query"
	        ),
	        showEndpoints && selectedEndpoint && onChangeEndpoint && React.createElement(EndpointChooser_1.default, { selectedEndpoint: selectedEndpoint, onChangeEndpoint: onChangeEndpoint }),
	        React.createElement(
	            "div",
	            { className: "graphiql-button", onClick: onPrettify, "data-jsx": 2288579073
	            },
	            "Prettify"
	        )
	    );
	};
	exports.default = QueryHeader;

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var cx = __webpack_require__(13);
	var Info_1 = __webpack_require__(573);
	var EndpointChooser = function EndpointChooser(_a) {
	  var selectedEndpoint = _a.selectedEndpoint,
	      onChangeEndpoint = _a.onChangeEndpoint;
	  return React.createElement(
	    "div",
	    { className: "root", "data-jsx": 3949980999
	    },
	    React.createElement(_style2.default, {
	      styleId: 3949980999,
	      css: ".root[data-jsx=\"3949980999\"] {color: rgba(255, 255, 255, .25);}.endpoint[data-jsx=\"3949980999\"] {padding: 5px 12px 6px 12px}.endpoint[data-jsx=\"3949980999\"].active[data-jsx=\"3949980999\"] {padding: 7px 9px 8px 9px;margin: 0 -2px;z-index: 2;}.fw6,\n.root[data-jsx=\"3949980999\"] {font-weight: 600;}.flex,\n.root[data-jsx=\"3949980999\"],\n.chooser[data-jsx=\"3949980999\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.root[data-jsx=\"3949980999\"],\n.chooser[data-jsx=\"3949980999\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.ml16,\n.chooser[data-jsx=\"3949980999\"] {margin-left: 16px;}.flex,\n.root[data-jsx=\"3949980999\"],\n.chooser[data-jsx=\"3949980999\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.root[data-jsx=\"3949980999\"],\n.chooser[data-jsx=\"3949980999\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.bgBlack50,\n.endpoint[data-jsx=\"3949980999\"] {background-color: rgba(0,0,0,.5);}.br2,\n.endpoint[data-jsx=\"3949980999\"] {border-radius: 2px;}.relative,\n.endpoint[data-jsx=\"3949980999\"] {position: relative;}.pointer:hover,\n.endpoint[data-jsx=\"3949980999\"]:hover {cursor: pointer;}.ttu,\n.endpoint[data-jsx=\"3949980999\"] {text-transform: uppercase;}.darkerBlue,\n.endpoint[data-jsx=\"3949980999\"].active[data-jsx=\"3949980999\"] {color: #0f202e;}.bgLightGray,\n.endpoint[data-jsx=\"3949980999\"].active[data-jsx=\"3949980999\"] {background-color: #c3bfc4;}.mt6,\na[data-jsx=\"3949980999\"] {margin-top: 6px;}.dib,\na[data-jsx=\"3949980999\"] {display: inline-block;}"
	    }),
	    React.createElement(
	      "div",
	      {
	        "data-jsx": 3949980999
	      },
	      "API"
	    ),
	    React.createElement(
	      "div",
	      { className: "chooser", "data-jsx": 3949980999
	      },
	      React.createElement(
	        "div",
	        { className: cx('endpoint', {
	            'active': selectedEndpoint === 'RELAY'
	          }), onClick: function onClick() {
	            return onChangeEndpoint('RELAY');
	          }, "data-jsx": 3949980999
	        },
	        "Relay"
	      ),
	      React.createElement(
	        "div",
	        { className: cx('endpoint', {
	            'active': selectedEndpoint === 'SIMPLE'
	          }), onClick: function onClick() {
	            return onChangeEndpoint('SIMPLE');
	          }, "data-jsx": 3949980999
	        },
	        "Simple"
	      )
	    ),
	    React.createElement(
	      Info_1.default,
	      null,
	      selectedEndpoint === 'SIMPLE' ? React.createElement(
	        "div",
	        {
	          "data-jsx": 3949980999
	        },
	        React.createElement(
	          "div",
	          {
	            "data-jsx": 3949980999
	          },
	          "The Simple API is our most simplistic GraphQL API. It is highly recommended in use with Apollo, as it is much simpler than the Relay API."
	        ),
	        React.createElement(
	          "a",
	          { href: "https://www.graph.cool/docs/reference/simple-api/overview-heshoov3ai", target: "_blank", "data-jsx": 3949980999
	          },
	          "Simple API Docs"
	        )
	      ) : React.createElement(
	        "div",
	        {
	          "data-jsx": 3949980999
	        },
	        React.createElement(
	          "div",
	          {
	            "data-jsx": 3949980999
	          },
	          "In order to use Relay, the backend must implement a spec that Relay needs. The Relay API fully supports this spec, so you can implement fully-fledged Relay Apps with Graphcool."
	        ),
	        React.createElement(
	          "a",
	          { href: "https://www.graph.cool/docs/reference/relay-api/overview-aizoong9ah", target: "_blank", "data-jsx": 3949980999
	          },
	          "Relay API Docs"
	        )
	      )
	    )
	  );
	};
	exports.default = EndpointChooser;

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var Info = function Info(props) {
	  return React.createElement(
	    "div",
	    { className: "info", "data-jsx": 2331235822
	    },
	    React.createElement(_style2.default, {
	      styleId: 2331235822,
	      css: ".question-mark[data-jsx=\"2331235822\"] {width: 18px;height: 18px;}.tooltip[data-jsx=\"2331235822\"] {z-index: 20;width: 250px;padding-top: 5px;left: -50px;}.tooltip-content[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:before {content: \"\";top: -4px;left: 55px;-webkit-transform: rotate(45deg);transform: rotate(45deg);width: 8px;height: 8px;}.bgWhite10,\n.question-mark[data-jsx=\"2331235822\"] {background-color: hsla(0,0%,100%,.1);}.flex,\n.question-mark[data-jsx=\"2331235822\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.question-mark[data-jsx=\"2331235822\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyCenter,\n.question-mark[data-jsx=\"2331235822\"] {-ms-flex-pack: center;justify-content: center;}.white40,\n.question-mark[data-jsx=\"2331235822\"] {color: hsla(0,0%,100%,.4);}.f12,\n.question-mark[data-jsx=\"2331235822\"] {font-size: 12px;}.fw6,\n.question-mark[data-jsx=\"2331235822\"] {font-weight: 600;}.br100,\n.question-mark[data-jsx=\"2331235822\"] {border-radius: 100%;}.pointer:hover,\n.question-mark[data-jsx=\"2331235822\"]:hover {cursor: pointer;}.dn,\n.tooltip[data-jsx=\"2331235822\"] {display: none;}.absolute,\n.tooltip[data-jsx=\"2331235822\"],\n.tooltip-content[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:before {position: absolute;}.br2,\n.tooltip-content[data-jsx=\"2331235822\"] {border-radius: 2px;}.bgWhite,\n.tooltip-content[data-jsx=\"2331235822\"],\n.tooltip-content[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:before {background-color: #fff;}.pa16,\n.tooltip-content[data-jsx=\"2331235822\"] {padding: 16px;}.black50,\n.tooltip-content[data-jsx=\"2331235822\"] {color: rgba(0,0,0,.5);}.f14,\n.tooltip-content[data-jsx=\"2331235822\"] {font-size: 14px;}.fw4,\n.tooltip-content[data-jsx=\"2331235822\"] {font-weight: 400;}.relative,\n.tooltip-content[data-jsx=\"2331235822\"],\n.info[data-jsx=\"2331235822\"] {position: relative;}.absolute,\n.tooltip[data-jsx=\"2331235822\"],\n.tooltip-content[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:before {position: absolute;}.bgWhite,\n.tooltip-content[data-jsx=\"2331235822\"],\n.tooltip-content[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:before {background-color: #fff;}.ml10,\n.info[data-jsx=\"2331235822\"] {margin-left: 10px;}.relative,\n.tooltip-content[data-jsx=\"2331235822\"],\n.info[data-jsx=\"2331235822\"] {position: relative;}.db,\n.info[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:hover .tooltip[data-jsx=\"2331235822\"] {display: block;}.bgBlue,\n.info[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:hover .question-mark[data-jsx=\"2331235822\"] {background-color: #2a7ed2;}.white,\n.info[data-jsx=\"2331235822\"][data-jsx=\"2331235822\"]:hover .question-mark[data-jsx=\"2331235822\"] {color: #fff;}"
	    }),
	    React.createElement(
	      "div",
	      { className: "question-mark", "data-jsx": 2331235822
	      },
	      "?"
	    ),
	    React.createElement(
	      "div",
	      { className: "tooltip", "data-jsx": 2331235822
	      },
	      React.createElement(
	        "div",
	        { className: "tooltip-content", "data-jsx": 2331235822
	        },
	        props.children
	      )
	    )
	  );
	};
	exports.default = Info;

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var ViewerChooser_1 = __webpack_require__(575);
	var cx = __webpack_require__(13);
	var ResultHeader = function ResultHeader(_a) {
	  var selectedViewer = _a.selectedViewer,
	      onChangeViewer = _a.onChangeViewer,
	      showViewAs = _a.showViewAs,
	      showResponseTitle = _a.showResponseTitle,
	      showSelectUser = _a.showSelectUser;
	  return React.createElement(
	    "div",
	    { className: cx('result-header subscription'), "data-jsx": 3076978164
	    },
	    React.createElement(_style2.default, {
	      styleId: 3076978164,
	      css: ".result-header[data-jsx=\"3076978164\"] {height: 75px}.result-header[data-jsx=\"3076978164\"].subscription[data-jsx=\"3076978164\"] {}.result-header[data-jsx=\"3076978164\"].subscription[data-jsx=\"3076978164\"][data-jsx=\"3076978164\"]:after {content: \"\";position: absolute;bottom: -25px;left: 0;right: 0;height: 25px;background: -webkit-linear-gradient(top, rgba(23, 42, 58, 1) 0%,rgba(23, 42, 58, 0) 100%);background: linear-gradient(to bottom, rgba(23, 42, 58, 1) 0%,rgba(23, 42, 58, 0) 100%);z-index: 4}.bgDarkBlue,\n.result-header[data-jsx=\"3076978164\"] {background-color: #172a3a}.flex,\n.result-header[data-jsx=\"3076978164\"] {display: -ms-flexbox;display: flex}.justifyBetween,\n.result-header[data-jsx=\"3076978164\"] {-ms-flex-pack: justify;justify-content: space-between}.itemsCenter,\n.result-header[data-jsx=\"3076978164\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center}.relative,\n.result-header[data-jsx=\"3076978164\"] {position: relative}.pt25,\n.result-header[data-jsx=\"3076978164\"] {padding-top: 25px}.mh25,\n.result-header[data-jsx=\"3076978164\"] {margin-left: 25px;margin-right: 25px}.pl16,\n.result-header[data-jsx=\"3076978164\"] {padding-left: 16px}.absolute,\n.inner[data-jsx=\"3076978164\"] {position: absolute}"
	    }),
	    React.createElement(
	      "div",
	      { className: "inner", "data-jsx": 3076978164
	      },
	      React.createElement(
	        "div",
	        {
	          "data-jsx": 3076978164
	        },
	        showResponseTitle && React.createElement(
	          "div",
	          { className: "editor-title", "data-jsx": 3076978164
	          },
	          "Response"
	        )
	      ),
	      showViewAs && selectedViewer && onChangeViewer && React.createElement(ViewerChooser_1.default, { showSelectUser: showSelectUser, selectedViewer: selectedViewer, onChangeViewer: onChangeViewer })
	    )
	  );
	};
	exports.default = ResultHeader;

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var cx = __webpack_require__(13);
	var graphcool_styles_1 = __webpack_require__(26);
	var ViewAs = function ViewAs(_a) {
	  var selectedViewer = _a.selectedViewer,
	      onChangeViewer = _a.onChangeViewer,
	      showSelectUser = _a.showSelectUser;
	  return React.createElement(
	    "div",
	    { className: "root", "data-jsx": 2745537961
	    },
	    React.createElement(_style2.default, {
	      styleId: 2745537961,
	      css: ".root[data-jsx=\"2745537961\"] {color: rgba(255, 255, 255, .25);}.viewer[data-jsx=\"2745537961\"] {padding: 5px 13px 6px 13px;margin: 0 -2px;background-color: #08131B}.viewer[data-jsx=\"2745537961\"].active[data-jsx=\"2745537961\"] {padding: 7px 9px 8px 9px;z-index: 2;}.fw6,\n.root[data-jsx=\"2745537961\"] {font-weight: 600;}.flex,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.ml16,\n.chooser[data-jsx=\"2745537961\"] {margin-left: 16px;}.flex,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.br2,\n.viewer[data-jsx=\"2745537961\"] {border-radius: 2px;}.relative,\n.viewer[data-jsx=\"2745537961\"] {position: relative;}.pointer:hover,\n.viewer[data-jsx=\"2745537961\"]:hover {cursor: pointer;}.ttu,\n.viewer[data-jsx=\"2745537961\"] {text-transform: uppercase;}.flex,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.root[data-jsx=\"2745537961\"],\n.chooser[data-jsx=\"2745537961\"],\n.viewer[data-jsx=\"2745537961\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.bgLightGray,\n.viewer[data-jsx=\"2745537961\"].active[data-jsx=\"2745537961\"] {background-color: #c3bfc4;}.darkerBlue,\n.viewer[data-jsx=\"2745537961\"].active[data-jsx=\"2745537961\"] {color: #0f202e;}.ml6,\n.viewer-text[data-jsx=\"2745537961\"] {margin-left: 6px;}.nowrap,\n.viewer-text[data-jsx=\"2745537961\"] {white-space: nowrap;}"
	    }),
	    React.createElement(
	      "div",
	      { className: "nowrap", "data-jsx": 2745537961
	      },
	      "View As"
	    ),
	    React.createElement(
	      "div",
	      { className: "chooser", "data-jsx": 2745537961
	      },
	      React.createElement(
	        "div",
	        { className: cx('viewer', {
	            'active': selectedViewer === 'ADMIN'
	          }), onClick: function onClick() {
	            return onChangeViewer('ADMIN');
	          }, "data-jsx": 2745537961
	        },
	        "Admin"
	      ),
	      React.createElement(
	        "div",
	        { className: cx('viewer', {
	            'active': selectedViewer === 'EVERYONE'
	          }), onClick: function onClick() {
	            return onChangeViewer('EVERYONE');
	          }, "data-jsx": 2745537961
	        },
	        React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(206), color: selectedViewer === 'EVERYONE' ? graphcool_styles_1.$v.darkerBlue : graphcool_styles_1.$v.white30, width: 14, height: 14 }),
	        React.createElement(
	          "div",
	          { className: "viewer-text", "data-jsx": 2745537961
	          },
	          "Everyone"
	        )
	      ),
	      showSelectUser && React.createElement(
	        "div",
	        { className: cx('viewer', {
	            'active': selectedViewer === 'USER'
	          }), onClick: function onClick() {
	            return onChangeViewer('USER');
	          }, "data-jsx": 2745537961
	        },
	        React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(205), color: selectedViewer === 'USER' ? graphcool_styles_1.$v.darkerBlue : graphcool_styles_1.$v.white30, width: 14, height: 14 }),
	        React.createElement(
	          "div",
	          { className: "viewer-text", "data-jsx": 2745537961
	          },
	          "Select User"
	        )
	      )
	    )
	  );
	};
	exports.default = ViewAs;

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	/**
	 * ResultViewer
	 *
	 * Maintains an instance of CodeMirror for viewing a GraphQL response.
	 *
	 * Props:
	 *
	 *   - value: The text of the editor.
	 *
	 */
	var ResultViewer = function (_super) {
	    __extends(ResultViewer, _super);
	    function ResultViewer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ResultViewer.prototype.componentDidMount = function () {
	        // Lazily require to ensure requiring GraphiQL outside of a Browser context
	        // does not produce an error.
	        var CodeMirror = __webpack_require__(5);
	        __webpack_require__(129);
	        __webpack_require__(128);
	        __webpack_require__(91);
	        __webpack_require__(406);
	        __webpack_require__(131);
	        __webpack_require__(395);
	        var gutters = [];
	        if (!this.props.hideGutters) {
	            gutters.push('CodeMirror-foldgutter');
	        }
	        var foldGutter = {};
	        if (!this.props.hideGutters) {
	            foldGutter = {
	                minFoldSize: 4
	            };
	        }
	        this.viewer = CodeMirror(this._node, {
	            lineWrapping: true,
	            value: this.props.value || '',
	            readOnly: true,
	            theme: 'graphiql',
	            mode: 'graphql-results',
	            keyMap: 'sublime',
	            foldGutter: foldGutter,
	            gutters: gutters,
	            extraKeys: {
	                // Editor improvements
	                'Ctrl-Left': 'goSubwordLeft',
	                'Ctrl-Right': 'goSubwordRight',
	                'Alt-Left': 'goGroupLeft',
	                'Alt-Right': 'goGroupRight'
	            },
	            viewportMargin: Infinity
	        });
	    };
	    ResultViewer.prototype.shouldComponentUpdate = function (nextProps) {
	        return this.props.value !== nextProps.value;
	    };
	    ResultViewer.prototype.componentDidUpdate = function () {
	        this.viewer.setValue(this.props.value || '');
	    };
	    ResultViewer.prototype.componentWillUnmount = function () {
	        this.viewer = null;
	    };
	    ResultViewer.prototype.render = function () {
	        var _this = this;
	        return React.createElement("div", { className: "result-codemirror", ref: function ref(node) {
	                _this._node = node;
	            } });
	    };
	    /**
	     * Public API for retrieving the CodeMirror instance from this
	     * React component.
	     */
	    ResultViewer.prototype.getCodeMirror = function () {
	        return this.viewer;
	    };
	    /**
	     * Public API for retrieving the DOM client height for this component.
	     */
	    ResultViewer.prototype.getClientHeight = function () {
	        return this._node && this._node.clientHeight;
	    };
	    return ResultViewer;
	}(React.Component);
	exports.ResultViewer = ResultViewer;

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var QueryEditor_1 = __webpack_require__(252);
	function SchemaExplorer(_a) {
	  var idl = _a.idl,
	      modelName = _a.modelName;
	  return React.createElement(
	    "div",
	    { className: "schema-explorer", "data-jsx": 3889923712
	    },
	    React.createElement(_style2.default, {
	      styleId: 3889923712,
	      css: ".header[data-jsx=\"3889923712\"] {letter-spacing: 0.6px;}.h100,\n.schema-explorer[data-jsx=\"3889923712\"] {height: 100%;}.flex,\n.schema-explorer[data-jsx=\"3889923712\"] {display: -ms-flexbox;display: flex;}.flexColumn,\n.schema-explorer[data-jsx=\"3889923712\"] {-ms-flex-direction: column;flex-direction: column;}.bgDarkerBlue,\n.schema-explorer[data-jsx=\"3889923712\"] {background-color: #0f202e;}.flexFixed,\n.header[data-jsx=\"3889923712\"] {-ms-flex: 0 0 auto;flex: 0 0 auto;}.f16,\n.header[data-jsx=\"3889923712\"] {font-size: 16px;}.fw6,\n.header[data-jsx=\"3889923712\"] {font-weight: 600;}.pt16,\n.header[data-jsx=\"3889923712\"] {padding-top: 16px;}.pl16,\n.header[data-jsx=\"3889923712\"] {padding-left: 16px;}.pr16,\n.header[data-jsx=\"3889923712\"] {padding-right: 16px;}.white40,\n.header[data-jsx=\"3889923712\"] {color: hsla(0,0%,100%,.4);}.ttu,\n.header[data-jsx=\"3889923712\"] {text-transform: uppercase;}.dn,\n.schema-explorer[data-jsx=\"3889923712\"] .CodeMirror-cursor {display: none;}"
	    }),
	    React.createElement(
	      "div",
	      { className: "header", "data-jsx": 3889923712
	      },
	      "Schema for \u201E",
	      modelName,
	      "\u201C"
	    ),
	    React.createElement(QueryEditor_1.QueryEditor, { schema: null, value: idl || '', readOnly: true, hideLineNumbers: true })
	  );
	}
	exports.default = SchemaExplorer;

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var graphcool_styles_1 = __webpack_require__(26);
	exports.TabBar = function (_a) {
	  var sessions = _a.sessions,
	      selectedSessionIndex = _a.selectedSessionIndex,
	      onNewSession = _a.onNewSession,
	      onSelectSession = _a.onSelectSession,
	      onOpenHistory = _a.onOpenHistory,
	      onCloseSession = _a.onCloseSession,
	      onboardingStep = _a.onboardingStep,
	      tether = _a.tether,
	      nextStep = _a.nextStep;
	  var Tether = tether;
	  return React.createElement(
	    "div",
	    { className: "root", "data-jsx": 2613608420
	    },
	    React.createElement(_style2.default, {
	      styleId: 2613608420,
	      css: ".root[data-jsx=\"2613608420\"] {height: 57px;background-color: rgba(9, 20, 28, 1);path[data-jsx=\"2613608420\"] {stroke: white;}}.tabs[data-jsx=\"2613608420\"] {height: 41px;}.tab[data-jsx=\"2613608420\"] {height: 43px;padding: 10px;padding-top: 9px}.red-dot[data-jsx=\"2613608420\"] {width: 7px;height: 7px;}.query-types[data-jsx=\"2613608420\"] {margin-right: 2px;}.query-type[data-jsx=\"2613608420\"] {height: 21px;width: 21px;}.plus[data-jsx=\"2613608420\"] {width: 43px;}.white,\n.root[data-jsx=\"2613608420\"] {color: #fff;}.z4,\n.root[data-jsx=\"2613608420\"] {z-index: 4;}.mt16,\n.tabs[data-jsx=\"2613608420\"] {margin-top: 16px;}.ml16,\n.tabs[data-jsx=\"2613608420\"] {margin-left: 16px;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.bgDarkerBlue,\n.tab[data-jsx=\"2613608420\"] {background-color: #0f202e;}.br2,\n.tab[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"] {border-radius: 2px;}.brTop,\n.tab[data-jsx=\"2613608420\"] {border-bottom-right-radius: 0;}.brRight,\n.brTop,\n.tab[data-jsx=\"2613608420\"] {border-bottom-left-radius: 0;}.ml10,\n.tab[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"] {margin-left: 10px;}.bbox,\n.tab[data-jsx=\"2613608420\"] {box-sizing: border-box;}.pointer:hover,\n.tab[data-jsx=\"2613608420\"]:hover,\n.history[data-jsx=\"2613608420\"]:hover {cursor: pointer;}.bgDarkBlue,\n.tab[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"] {background-color: #172a3a;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.o50,\n.icons[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"] {opacity: .5;}.o100,\n.icons[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"] {opacity: 1;}.br100,\n.red-dot[data-jsx=\"2613608420\"] {border-radius: 100%;}.bgrRed,\n.red-dot[data-jsx=\"2613608420\"] {background-color: #f25c54;}.mr10,\n.red-dot[data-jsx=\"2613608420\"],\n.viewer[data-jsx=\"2613608420\"] {margin-right: 10px;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.br2,\n.tab[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"] {border-radius: 2px;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyCenter,\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-ms-flex-pack: center;justify-content: center;}.mr4,\n.query-type[data-jsx=\"2613608420\"] {margin-right: 4px;}.fw7,\n.query-type[data-jsx=\"2613608420\"] {font-weight: 700;}.f12,\n.query-type[data-jsx=\"2613608420\"] {font-size: 12px;}.bgPurple,\n.subscription[data-jsx=\"2613608420\"] {background-color: #a4036f;}.bgBlue,\n.query[data-jsx=\"2613608420\"] {background-color: #2a7ed2;}.bgLightOrange,\n.mutation[data-jsx=\"2613608420\"] {background-color: #f18f01;}.mr10,\n.red-dot[data-jsx=\"2613608420\"],\n.viewer[data-jsx=\"2613608420\"] {margin-right: 10px;}.o50,\n.icons[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"] {opacity: .5;}.o100,\n.icons[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"] {opacity: 1;}.ml10,\n.tab[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"] {margin-left: 10px;}.o50,\n.icons[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"] {opacity: .5;}.o100,\n.icons[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.operation-name[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"],\n.close[data-jsx=\"2613608420\"].active[data-jsx=\"2613608420\"] {opacity: 1;}.flex,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {display: -ms-flexbox;display: flex;}.justifyCenter,\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-ms-flex-pack: center;justify-content: center;}.itemsCenter,\n.tabs[data-jsx=\"2613608420\"],\n.tab[data-jsx=\"2613608420\"],\n.icons[data-jsx=\"2613608420\"],\n.query-types[data-jsx=\"2613608420\"],\n.query-type[data-jsx=\"2613608420\"],\n.plus[data-jsx=\"2613608420\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.pointer:hover,\n.tab[data-jsx=\"2613608420\"]:hover,\n.history[data-jsx=\"2613608420\"]:hover {cursor: pointer;}"
	    }),
	    React.createElement(
	      "div",
	      { className: "tabs", "data-jsx": 2613608420
	      },
	      React.createElement(
	        "div",
	        { className: "history", "data-jsx": 2613608420
	        },
	        React.createElement(graphcool_styles_1.Icon, { className: "icon", src: __webpack_require__(366), stroke: true, strokeWidth: 3, width: 25, height: 25, color: graphcool_styles_1.$v.white40, onClick: onOpenHistory })
	      ),
	      sessions.map(function (session, index) {
	        var queryTypes = session.queryTypes;
	        return React.createElement(
	          "div",
	          { key: session.id, className: "tab " + (index === selectedSessionIndex && 'active'), onClick: function onClick() {
	              return onSelectSession(session);
	            }, "data-jsx": 2613608420
	          },
	          React.createElement(
	            "div",
	            { className: "icons " + (index === selectedSessionIndex && 'active'), "data-jsx": 2613608420
	            },
	            session.subscriptionActive && React.createElement("div", { className: "red-dot", "data-jsx": 2613608420
	            }),
	            React.createElement(
	              "div",
	              { className: "query-types", "data-jsx": 2613608420
	              },
	              queryTypes.query && React.createElement(
	                "div",
	                { className: "query-type query", "data-jsx": 2613608420
	                },
	                "Q"
	              ),
	              queryTypes.mutation && React.createElement(
	                "div",
	                { className: "query-type mutation", "data-jsx": 2613608420
	                },
	                "M"
	              ),
	              queryTypes.subscription && React.createElement(
	                "div",
	                { className: "query-type subscription", "data-jsx": 2613608420
	                },
	                "S"
	              )
	            ),
	            session.selectedViewer !== 'ADMIN' && React.createElement(
	              "div",
	              { className: "viewer", "data-jsx": 2613608420
	              },
	              session.selectedViewer === 'EVERYONE' && React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(206), color: graphcool_styles_1.$v.white40, width: 14, height: 14 }),
	              session.selectedViewer === 'USER' && React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(205), color: graphcool_styles_1.$v.white40, width: 14, height: 14 })
	            )
	          ),
	          tether && onboardingStep === 'STEP3_SELECT_QUERY_TAB' && index === 0 ? React.createElement(
	            Tether,
	            { steps: [{
	                step: 'STEP3_SELECT_QUERY_TAB',
	                title: 'Back to the query',
	                description: 'After creating the data with our mutations, let\'s see what we got'
	              }] },
	            React.createElement(
	              "div",
	              { className: "operation-name " + (index === selectedSessionIndex && 'active'), "data-jsx": 2613608420
	              },
	              session.operationName || queryTypes.firstOperationName || 'New Session'
	            )
	          ) : React.createElement(
	            "div",
	            { className: "operation-name " + (index === selectedSessionIndex && 'active'), "data-jsx": 2613608420
	            },
	            session.operationName || queryTypes.firstOperationName || 'New Session'
	          ),
	          React.createElement(
	            "div",
	            { className: "close " + (index === selectedSessionIndex && 'active'), onClick: function onClick(e) {
	                // we don't want selectIndex to be executed
	                e.stopPropagation();
	                onCloseSession(session);
	              }, "data-jsx": 2613608420
	            },
	            React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(365), stroke: true, color: graphcool_styles_1.$v.white40, width: 11, height: 10, strokeWidth: 8 })
	          )
	        );
	      }),
	      tether && onboardingStep === 'STEP3_CREATE_MUTATION_TAB' ? React.createElement(
	        Tether,
	        { offsetY: -7, steps: [{
	            step: 'STEP3_CREATE_MUTATION_TAB',
	            title: 'Apparently, there is no data yet',
	            description: 'Click here to create new data'
	          }] },
	        React.createElement(
	          "div",
	          { className: "tab plus", onClick: onNewSession, "data-jsx": 2613608420
	          },
	          React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(364), color: "rgba(255,255,255,.15)", width: 34, height: 34, stroke: true, strokeWidth: 4 })
	        )
	      ) : React.createElement(
	        "div",
	        { className: "tab plus", onClick: onNewSession, "data-jsx": 2613608420
	        },
	        React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(364), color: "rgba(255,255,255,.15)", width: 34, height: 34, stroke: true, strokeWidth: 4 })
	      )
	    )
	  );
	};

/***/ }),
/* 579 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	function ageOfDate(date) {
	    var now = new Date();
	    var diffMs = Math.abs(date.getTime() - now.getTime());
	    var diffDays = Math.floor(diffMs / 86400000);
	    var diffHrs = Math.floor(diffMs % 86400000 / 3600000);
	    var diffMins = Math.round(diffMs % 86400000 % 3600000 / 60000);
	    if (diffDays > 0) {
	        return diffDays + " days ago";
	    }
	    if (diffHrs > 0) {
	        return diffHrs + " h ago";
	    }
	    if (diffMins > 0) {
	        return diffMins + " min ago";
	    }
	    var sec = Math.round(diffMs / 1000);
	    return sec + " sec" + (sec > 1 ? 's' : '') + " ago";
	}
	exports.default = ageOfDate;

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var graphql_1 = __webpack_require__(12);
	var getQueryTypes = function getQueryTypes(query) {
	    var ast = null;
	    // takes around 0.02ms -  1ms
	    try {
	        ast = graphql_1.parse(query);
	    } catch (e) {
	        //
	    }
	    var hasSubscription = false;
	    var hasQuery = false;
	    var hasMutation = false;
	    var firstOperationName = null;
	    // let operations: OperationDefinition[] = []
	    if (ast) {
	        ast.definitions.forEach(function (definition) {
	            if (!firstOperationName) {
	                firstOperationName = definition.selectionSet && definition.selectionSet.selections && definition.selectionSet.selections.length > 0 && definition.selectionSet.selections[0].name.value;
	            }
	            if (definition.operation === 'subscription') {
	                hasSubscription = true;
	            }
	            if (definition.operation === 'query') {
	                hasQuery = true;
	            }
	            if (definition.operation === 'mutation') {
	                hasMutation = true;
	            }
	            // if (definition.name) {
	            //   operations.push({
	            //     name: definition.name.value,
	            //     startLine: definition.loc.startToken.line,
	            //     endLine: definition.loc.endToken.line,
	            //   })
	            // }
	        });
	    }
	    return {
	        firstOperationName: firstOperationName,
	        subscription: hasSubscription,
	        query: hasQuery,
	        mutation: hasMutation
	    };
	};
	exports.default = getQueryTypes;

/***/ }),
/* 581 */
/***/ (function(module, exports) {

	"use strict";
	
	//download.js v3.0, by dandavis; 2008-2014. [CCBY2] see http://danml.com/download.html for tests/usage
	// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
	// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
	// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support
	// data can be a string, Blob, File, or dataURL
	module.exports = {
	    download: download
	};
	function download(data, strFileName, strMimeType) {
	    var self = typeof window !== 'undefined' ? window : {},
	        // this script is only for browsers anyway...
	    u = "application/octet-stream",
	        // this default mime also triggers iframe downloads
	    m = strMimeType || u,
	        x = data,
	        D = document,
	        a = D.createElement("a"),
	        z = function z(a) {
	        return String(a);
	    },
	        B = self.Blob || self.MozBlob || self.WebKitBlob || z,
	        BB = self.MSBlobBuilder || self.WebKitBlobBuilder || self.BlobBuilder,
	        fn = strFileName || "download",
	        blob,
	        b,
	        ua,
	        fr;
	    //if(typeof B.bind === 'function' ){ B=B.bind(self); }
	    if (String(this) === "true") {
	        x = [x, m];
	        m = x[0];
	        x = x[1];
	    }
	    //go ahead and download dataURLs right away
	    if (String(x).match(/^data\:[\w+\-]+\/[\w+\-]+[,;]/)) {
	        return navigator.msSaveBlob ? navigator.msSaveBlob(d2b(x), fn) : saver(x); // everyone else can save dataURLs un-processed
	    } //end if dataURL passed?
	    try {
	        blob = x instanceof B ? x : new B([x], { type: m });
	    } catch (y) {
	        if (BB) {
	            b = new BB();
	            b.append([x]);
	            blob = b.getBlob(m); // the blob
	        }
	    }
	    function d2b(u) {
	        var p = u.split(/[:;,]/),
	            t = p[1],
	            dec = p[2] == "base64" ? atob : decodeURIComponent,
	            bin = dec(p.pop()),
	            mx = bin.length,
	            i = 0,
	            uia = new Uint8Array(mx);
	        for (i; i < mx; ++i) {
	            uia[i] = bin.charCodeAt(i);
	        }return new B([uia], { type: t });
	    }
	    function saver(url, winMode) {
	        if ('download' in a) {
	            a.href = url;
	            a.setAttribute("download", fn);
	            a.innerHTML = "downloading...";
	            D.body.appendChild(a);
	            setTimeout(function () {
	                a.click();
	                D.body.removeChild(a);
	                if (winMode === true) {
	                    setTimeout(function () {
	                        self.URL.revokeObjectURL(a.href);
	                    }, 250);
	                }
	            }, 66);
	            return true;
	        }
	        //do iframe dataURL download (old ch+FF):
	        var f = D.createElement("iframe");
	        D.body.appendChild(f);
	        if (!winMode) {
	            url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, u);
	        }
	        f.src = url;
	        setTimeout(function () {
	            D.body.removeChild(f);
	        }, 333);
	    } //end saver
	    if (navigator.msSaveBlob) {
	        return navigator.msSaveBlob(blob, fn);
	    }
	    if (self.URL) {
	        saver(self.URL.createObjectURL(blob), true);
	    } else {
	        // handle non-Blob()+non-URL browsers:
	        if (typeof blob === "string" || blob.constructor === z) {
	            try {
	                return saver("data:" + m + ";base64," + self.btoa(blob));
	            } catch (y) {
	                return saver("data:" + m + "," + encodeURIComponent(blob));
	            }
	        }
	        // Blob but not URL:
	        fr = new FileReader();
	        fr.onload = function (e) {
	            saver(this.result);
	        };
	        fr.readAsDataURL(blob);
	    }
	    return true;
	} /* end download() */

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var graphql_1 = __webpack_require__(12);
	var isQuerySubscription = function isQuerySubscription(query, operationName) {
	    var ast = null;
	    // takes around 0.02ms -  1ms
	    try {
	        ast = graphql_1.parse(query);
	    } catch (e) {
	        //
	    }
	    var isSubscription = false;
	    if (ast) {
	        ast.definitions.forEach(function (definition) {
	            if (definition.operation === 'subscription') {
	                if (operationName && operationName.length > 0) {
	                    isSubscription = definition.name.value === operationName;
	                } else {
	                    isSubscription = true;
	                }
	            }
	        });
	    }
	    return isSubscription;
	};
	exports.default = isQuerySubscription;

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var Modal = __webpack_require__(192);
	var HistoryHeader_1 = __webpack_require__(585);
	var HistoryItems_1 = __webpack_require__(586);
	var CustomGraphiQL_1 = __webpack_require__(251);
	var graphcool_styles_1 = __webpack_require__(26);
	var constants_1 = __webpack_require__(101);
	var HistoryPopup = function (_super) {
	    __extends(HistoryPopup, _super);
	    function HistoryPopup(props) {
	        var _this = _super.call(this, props) || this;
	        _this.handleItemSelect = function (index) {
	            _this.setState({ selectedItemIndex: index });
	        };
	        _this.handleSelectFilter = function (filter) {
	            _this.setState({ selectedFilter: filter });
	        };
	        _this.handleSearch = function (term) {
	            _this.setState({ searchTerm: term });
	        };
	        _this.state = {
	            selectedFilter: 'HISTORY',
	            selectedItemIndex: 0,
	            searchTerm: ''
	        };
	        return _this;
	    }
	    HistoryPopup.prototype.render = function () {
	        var _this = this;
	        var _a = this.state,
	            searchTerm = _a.searchTerm,
	            selectedFilter = _a.selectedFilter;
	        var items = this.props.historyItems.filter(function (item) {
	            return selectedFilter === 'STARRED' ? item.starred : true && (searchTerm && searchTerm.length > 0 ? item.query.toLowerCase().includes(searchTerm.toLowerCase()) : true);
	        });
	        var selectedItem = items[this.state.selectedItemIndex];
	        var schema = selectedItem ? this.props.schemas[selectedItem.selectedEndpoint] : null;
	        return React.createElement(
	            Modal,
	            { isOpen: this.props.isOpen, onRequestClose: this.props.onRequestClose, contentLabel: "GraphiQL Session History", style: constants_1.modalStyle },
	            React.createElement(_style2.default, {
	                styleId: 1186519991,
	                css: ".history-popup[data-jsx=\"1186519991\"] {min-height: 500px;}.left[data-jsx=\"1186519991\"][data-jsx=\"1186519991\"]:after {content: \"\";position: absolute;bottom: 0px;height: 50px;left: 0;right: 0;width: 100%;background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0) 0%,rgba(255, 255, 255, 1) 100%);background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%,rgba(255, 255, 255, 1) 100%);}.right[data-jsx=\"1186519991\"] {-moz-flex: 0 0 464px;-webkit-box-flex: 0;-ms-flex: 0 0 464px;flex: 0 0 464px;}.right-header[data-jsx=\"1186519991\"] {padding-top: 20px;padding-bottom: 20px;}.flex,\n.history-popup[data-jsx=\"1186519991\"],\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {display: -ms-flexbox;display: flex;}.flex1,\n.left[data-jsx=\"1186519991\"] {-ms-flex: 1;flex: 1;}.flex1,\n.flexAuto,\n.left[data-jsx=\"1186519991\"] {min-width: 0;min-height: 0;}.bgWhite,\n.left[data-jsx=\"1186519991\"] {background-color: #fff;}.z2,\n.right[data-jsx=\"1186519991\"] {z-index: 2;}.justifyBetween,\n.right-header[data-jsx=\"1186519991\"] {-ms-flex-pack: justify;justify-content: space-between;}.flex,\n.history-popup[data-jsx=\"1186519991\"],\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {display: -ms-flexbox;display: flex;}.bgDarkBlue,\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"] {background-color: #172a3a;}.itemsCenter,\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.ph25,\n.right-header[data-jsx=\"1186519991\"] {padding-left: 25px;padding-right: 25px;}.bgDarkBlue,\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"] {background-color: #172a3a;}.h100,\n.right-empty[data-jsx=\"1186519991\"] {height: 100%;}.flex,\n.history-popup[data-jsx=\"1186519991\"],\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {display: -ms-flexbox;display: flex;}.justifyCenter,\n.right-empty[data-jsx=\"1186519991\"] {-ms-flex-pack: center;justify-content: center;}.itemsCenter,\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.f16,\n.right-empty-text[data-jsx=\"1186519991\"] {font-size: 16px;}.white60,\n.right-empty-text[data-jsx=\"1186519991\"] {color: hsla(0,0%,100%,.6);}.f14,\n.view[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {font-size: 14px;}.white40,\n.view[data-jsx=\"1186519991\"] {color: hsla(0,0%,100%,.4);}.ttu,\n.view[data-jsx=\"1186519991\"] {text-transform: uppercase;}.fw6,\n.view[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {font-weight: 600;}.f14,\n.view[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {font-size: 14px;}.fw6,\n.view[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {font-weight: 600;}.pv10,\n.use[data-jsx=\"1186519991\"] {padding-top: 10px;padding-bottom: 10px;}.ph16,\n.use[data-jsx=\"1186519991\"] {padding-left: 16px;padding-right: 16px;}.bgGreen,\n.use[data-jsx=\"1186519991\"] {background-color: #27ae60;}.flex,\n.history-popup[data-jsx=\"1186519991\"],\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {display: -ms-flexbox;display: flex;}.br2,\n.use[data-jsx=\"1186519991\"] {border-radius: 2px;}.itemsCenter,\n.right-header[data-jsx=\"1186519991\"],\n.right-empty[data-jsx=\"1186519991\"],\n.use[data-jsx=\"1186519991\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.pointer:hover,\n.use[data-jsx=\"1186519991\"]:hover {cursor: pointer;}.mr6,\n.use-text[data-jsx=\"1186519991\"] {margin-right: 6px;}.white,\n.use-text[data-jsx=\"1186519991\"] {color: #fff;}"
	            }),
	            React.createElement(
	                "div",
	                { className: "history-popup", "data-jsx": 1186519991
	                },
	                React.createElement(
	                    "div",
	                    { className: "left", "data-jsx": 1186519991
	                    },
	                    React.createElement(HistoryHeader_1.default, { onSelectFilter: this.handleSelectFilter, selectedFilter: this.state.selectedFilter, onSearch: this.handleSearch }),
	                    React.createElement(HistoryItems_1.default, { items: items, selectedItemIndex: this.state.selectedItemIndex, searchTerm: this.state.searchTerm, onItemSelect: this.handleItemSelect, onItemStarToggled: this.props.onItemStarToggled })
	                ),
	                Boolean(selectedItem) ? React.createElement(
	                    "div",
	                    { className: "right", "data-jsx": 1186519991
	                    },
	                    React.createElement(
	                        "div",
	                        { className: "right-header", "data-jsx": 1186519991
	                        },
	                        React.createElement(
	                            "div",
	                            { className: "view", "data-jsx": 1186519991
	                            },
	                            selectedItem.selectedEndpoint + " API / View as " + selectedItem.selectedViewer
	                        ),
	                        React.createElement(
	                            "div",
	                            { className: "use", onClick: function onClick() {
	                                    _this.props.onCreateSession(selectedItem);
	                                    _this.props.onRequestClose();
	                                }, "data-jsx": 1186519991
	                            },
	                            React.createElement(
	                                "div",
	                                { className: "use-text", "data-jsx": 1186519991
	                                },
	                                "Use"
	                            ),
	                            React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(1060), color: graphcool_styles_1.$v.white, stroke: true, width: 13, height: 13 })
	                        )
	                    ),
	                    React.createElement(CustomGraphiQL_1.CustomGraphiQL, { schema: schema, variables: selectedItem.variables, query: selectedItem.query, fetcher: this.props.fetcherCreater(selectedItem), disableQueryHeader: true, queryOnly: true, rerenderQuery: true })
	                ) : React.createElement(
	                    "div",
	                    { className: "right", "data-jsx": 1186519991
	                    },
	                    React.createElement(
	                        "div",
	                        { className: "right-empty", "data-jsx": 1186519991
	                        },
	                        React.createElement(
	                            "div",
	                            { className: "right-empty-text", "data-jsx": 1186519991
	                            },
	                            "No History yet"
	                        )
	                    )
	                )
	            )
	        );
	    };
	    return HistoryPopup;
	}(React.Component);
	exports.default = HistoryPopup;

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	var HistoryChooser = function HistoryChooser(_a) {
	  var selectedFilter = _a.selectedFilter,
	      onSelectFilter = _a.onSelectFilter;
	  return React.createElement(
	    "div",
	    {
	      "data-jsx": 1388776987
	    },
	    React.createElement(_style2.default, {
	      styleId: 1388776987,
	      css: ".filter[data-jsx=\"1388776987\"] {padding: 5px 13px 6px 13px;margin: 0 -2px;height: 24px}.filter[data-jsx=\"1388776987\"].active[data-jsx=\"1388776987\"] {padding: 7px 9px 8px 9px}.flex,\n.chooser[data-jsx=\"1388776987\"],\n.filter[data-jsx=\"1388776987\"] {display: -ms-flexbox;display: flex}.itemsCenter,\n.chooser[data-jsx=\"1388776987\"],\n.filter[data-jsx=\"1388776987\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center}.br2,\n.filter[data-jsx=\"1388776987\"] {border-radius: 2px}.relative,\n.filter[data-jsx=\"1388776987\"] {position: relative}.pointer:hover,\n.filter[data-jsx=\"1388776987\"]:hover {cursor: pointer}.ttu,\n.filter[data-jsx=\"1388776987\"] {text-transform: uppercase}.flex,\n.chooser[data-jsx=\"1388776987\"],\n.filter[data-jsx=\"1388776987\"] {display: -ms-flexbox;display: flex}.itemsCenter,\n.chooser[data-jsx=\"1388776987\"],\n.filter[data-jsx=\"1388776987\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center}.black30,\n.filter[data-jsx=\"1388776987\"] {color: rgba(0,0,0,.3)}.fw6,\n.filter[data-jsx=\"1388776987\"] {font-weight: 600}.f14,\n.filter[data-jsx=\"1388776987\"] {font-size: 14px}.bgBlack07,\n.filter[data-jsx=\"1388776987\"] {background-color: rgba(0,0,0,.07)}.cbox,\n.filter[data-jsx=\"1388776987\"] {box-sizing: content-box}.z2,\n.filter[data-jsx=\"1388776987\"].active[data-jsx=\"1388776987\"] {z-index: 2}.white,\n.filter[data-jsx=\"1388776987\"].active[data-jsx=\"1388776987\"] {color: #fff}.bgGreen,\n.filter[data-jsx=\"1388776987\"].active[data-jsx=\"1388776987\"] {background-color: #27ae60}.ml6,\n.filter-text[data-jsx=\"1388776987\"] {margin-left: 6px}"
	    }),
	    React.createElement(
	      "div",
	      { className: "chooser", "data-jsx": 1388776987
	      },
	      React.createElement(
	        "div",
	        { className: cx('filter', {
	            'active': selectedFilter === 'HISTORY'
	          }), onClick: function onClick() {
	            return onSelectFilter('HISTORY');
	          }, "data-jsx": 1388776987
	        },
	        React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(366), color: selectedFilter === 'HISTORY' ? graphcool_styles_1.$v.white : graphcool_styles_1.$v.gray30, stroke: true, strokeWidth: 3, width: 25, height: 25 }),
	        React.createElement(
	          "div",
	          { className: "filter-text", "data-jsx": 1388776987
	          },
	          "History"
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: cx('filter', {
	            'active': selectedFilter === 'STARRED'
	          }), onClick: function onClick() {
	            return onSelectFilter('STARRED');
	          }, "data-jsx": 1388776987
	        },
	        React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(363), color: selectedFilter === 'STARRED' ? graphcool_styles_1.$v.white : graphcool_styles_1.$v.gray30, width: 16, height: 16 }),
	        React.createElement(
	          "div",
	          { className: "filter-text", "data-jsx": 1388776987
	          },
	          "Starred"
	        )
	      )
	    )
	  );
	};
	exports.default = HistoryChooser;

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var HistoryChooser_1 = __webpack_require__(584);
	var SearchBox_1 = __webpack_require__(153);
	var HistoryHeader = function HistoryHeader(props) {
	    return React.createElement(
	        "div",
	        { className: "history-header", "data-jsx": 3148687307
	        },
	        React.createElement(_style2.default, {
	            styleId: 3148687307,
	            css: ".pa16,\n.history-header[data-jsx=\"3148687307\"] {padding: 16px\n}.flex,\n.history-header[data-jsx=\"3148687307\"] {display: -ms-flexbox;display: flex\n}.justifyBetween,\n.history-header[data-jsx=\"3148687307\"] {-ms-flex-pack: justify;justify-content: space-between\n}.itemsCenter,\n.history-header[data-jsx=\"3148687307\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center\n}.bgBlack02,\n.history-header[data-jsx=\"3148687307\"] {background-color: rgba(0,0,0,.02)\n}.pa0,\n.search-box[data-jsx=\"3148687307\"] {padding: 0\n}.bgTransparent,\n.search-box[data-jsx=\"3148687307\"] {background-color: transparent\n}"
	        }),
	        React.createElement(HistoryChooser_1.default, { onSelectFilter: props.onSelectFilter, selectedFilter: props.selectedFilter }),
	        React.createElement(SearchBox_1.default, { placeholder: "Search the history...", onSearch: props.onSearch, clean: true, isShown: true })
	    );
	};
	exports.default = HistoryHeader;

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var graphcool_styles_1 = __webpack_require__(26);
	var cx = __webpack_require__(13);
	var HistoryItems = function HistoryItems(_a) {
	  var items = _a.items,
	      onItemSelect = _a.onItemSelect,
	      selectedItemIndex = _a.selectedItemIndex,
	      onItemStarToggled = _a.onItemStarToggled,
	      searchTerm = _a.searchTerm;
	  return React.createElement(
	    "div",
	    { className: "history-items", "data-jsx": 4091426895
	    },
	    React.createElement(_style2.default, {
	      styleId: 4091426895,
	      css: ".history-items[data-jsx=\"4091426895\"] {max-height: calc(100vh - 121px);}.item[data-jsx=\"4091426895\"] {padding: 25px 20px}.operation[data-jsx=\"4091426895\"] {margin-left: 20px;}.operation-icon[data-jsx=\"4091426895\"] {height: 21px;width: 21px}.overflowYScroll,\n.history-items[data-jsx=\"4091426895\"] {overflow-y: scroll;}.flex,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyBetween,\n.item[data-jsx=\"4091426895\"] {-ms-flex-pack: justify;justify-content: space-between;}.bb,\n.item[data-jsx=\"4091426895\"] {border-bottom-style: solid;border-bottom-width: 1px;}.bBlack10,\n.item[data-jsx=\"4091426895\"] {border-color: rgba(0,0,0,.1);}.pointer:hover,\n.item[data-jsx=\"4091426895\"]:hover {cursor: pointer;}.bgBlack04,\n.item[data-jsx=\"4091426895\"].active[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {background-color: rgba(0,0,0,.04);}.flex,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.itemsCenter,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.fw3,\n.operation-text[data-jsx=\"4091426895\"] {font-weight: 300;}.f20,\n.operation-text[data-jsx=\"4091426895\"] {font-size: 20px;}.mr16,\n.operation-text[data-jsx=\"4091426895\"] {margin-right: 16px;}.br2,\n.operation-icon[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {border-radius: 2px;}.flex,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {display: -ms-flexbox;display: flex;}.itemsCenter,\n.item[data-jsx=\"4091426895\"],\n.operation[data-jsx=\"4091426895\"],\n.star[data-jsx=\"4091426895\"],\n.viewer[data-jsx=\"4091426895\"],\n.left[data-jsx=\"4091426895\"],\n.right[data-jsx=\"4091426895\"],\n.operation-icon[data-jsx=\"4091426895\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyCenter,\n.operation-icon[data-jsx=\"4091426895\"] {-ms-flex-pack: center;justify-content: center;}.mr4,\n.operation-icon[data-jsx=\"4091426895\"] {margin-right: 4px;}.fw7,\n.operation-icon[data-jsx=\"4091426895\"] {font-weight: 700;}.f12,\n.operation-icon[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {font-size: 12px;}.purple,\n.operation-icon[data-jsx=\"4091426895\"].subscription[data-jsx=\"4091426895\"] {color: #a4036f;}.bgPurple20,\n.operation-icon[data-jsx=\"4091426895\"].subscription[data-jsx=\"4091426895\"] {background-color: rgba(164,3,111,.2);}.blue,\n.operation-icon[data-jsx=\"4091426895\"].query[data-jsx=\"4091426895\"] {color: #2a7ed2;}.bgBlue20,\n.operation-icon[data-jsx=\"4091426895\"].query[data-jsx=\"4091426895\"] {background-color: rgba(42,126,210,.2);}.lightOrange,\n.operation-icon[data-jsx=\"4091426895\"].mutation[data-jsx=\"4091426895\"] {color: #f18f01;}.bgLightOrange20,\n.operation-icon[data-jsx=\"4091426895\"].mutation[data-jsx=\"4091426895\"] {background-color: rgba(241,143,1,.2);}.black30,\n.endpoint[data-jsx=\"4091426895\"] {color: rgba(0,0,0,.3);}.br2,\n.operation-icon[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {border-radius: 2px;}.ph6,\n.endpoint[data-jsx=\"4091426895\"] {padding-left: 6px;padding-right: 6px;}.pv4,\n.endpoint[data-jsx=\"4091426895\"] {padding-top: 4px;padding-bottom: 4px;}.ttu,\n.endpoint[data-jsx=\"4091426895\"] {text-transform: uppercase;}.fw6,\n.endpoint[data-jsx=\"4091426895\"] {font-weight: 600;}.f12,\n.operation-icon[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {font-size: 12px;}.nowrap,\n.endpoint[data-jsx=\"4091426895\"] {white-space: nowrap;}.bgBlack04,\n.item[data-jsx=\"4091426895\"].active[data-jsx=\"4091426895\"],\n.endpoint[data-jsx=\"4091426895\"] {background-color: rgba(0,0,0,.04);}.f14,\n.date[data-jsx=\"4091426895\"] {font-size: 14px;}.black50,\n.date[data-jsx=\"4091426895\"] {color: rgba(0,0,0,.5);}.ml16,\n.date[data-jsx=\"4091426895\"] {margin-left: 16px;}.ml6,\n.viewer[data-jsx=\"4091426895\"] {margin-left: 6px;}"
	    }),
	    items.map(function (item, index) {
	      return React.createElement(
	        "div",
	        { key: item.id, className: cx('item', {
	            'active': selectedItemIndex === index
	          }), onClick: function onClick() {
	            return onItemSelect(index);
	          }, "data-jsx": 4091426895
	        },
	        React.createElement(
	          "div",
	          { className: "left", "data-jsx": 4091426895
	          },
	          React.createElement(
	            "div",
	            { className: "star", onClick: function onClick() {
	                return onItemStarToggled(item);
	              }, "data-jsx": 4091426895
	            },
	            React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(363), color: item.starred ? 'rgb(221,171,0)' : graphcool_styles_1.$v.gray30, stroke: !item.starred, strokeWidth: 0.5, width: 25, height: 25 })
	          ),
	          React.createElement(
	            "div",
	            { className: "operation", "data-jsx": 4091426895
	            },
	            React.createElement(
	              "div",
	              { className: "operation-text", "data-jsx": 4091426895
	              },
	              item.operationName || item.queryTypes.firstOperationName || 'New Session'
	            ),
	            item.queryTypes.query && React.createElement(
	              "div",
	              { className: "operation-icon query", "data-jsx": 4091426895
	              },
	              "Q"
	            ),
	            item.queryTypes.mutation && React.createElement(
	              "div",
	              { className: "operation-icon mutation", "data-jsx": 4091426895
	              },
	              "M"
	            ),
	            item.queryTypes.subscription && React.createElement(
	              "div",
	              { className: "operation-icon subscription", "data-jsx": 4091426895
	              },
	              "S"
	            ),
	            React.createElement(
	              "div",
	              { className: "viewer", "data-jsx": 4091426895
	              },
	              item.selectedViewer === 'EVERYONE' && React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(206), color: graphcool_styles_1.$v.gray30, width: 18, height: 18 }),
	              item.selectedViewer === 'USER' && React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(205), color: graphcool_styles_1.$v.gray30, width: 18, height: 18 })
	            )
	          )
	        ),
	        React.createElement(
	          "div",
	          { className: "right", "data-jsx": 4091426895
	          },
	          React.createElement(
	            "div",
	            { className: "endpoint", "data-jsx": 4091426895
	            },
	            item.selectedEndpoint === 'SIMPLE' ? 'Simple API' : 'Relay API'
	          ),
	          item.date && React.createElement(
	            "div",
	            { className: "date", "data-jsx": 4091426895
	            },
	            item.date.getMonth() + 1,
	            "/",
	            item.date.getDay(),
	            "/",
	            item.date.getFullYear().toString().slice(2, 4)
	          )
	        )
	      );
	    })
	  );
	};
	exports.default = HistoryItems;

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, global) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	var __assign = undefined && undefined.__assign || Object.assign || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) {
	            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var CustomGraphiQL_1 = __webpack_require__(251);
	exports.CustomGraphiQL = CustomGraphiQL_1.CustomGraphiQL;
	var fetch = __webpack_require__(173);
	var graphql_1 = __webpack_require__(12);
	var TabBar_1 = __webpack_require__(578);
	var constants_1 = __webpack_require__(101);
	var cuid = __webpack_require__(472);
	var Immutable = __webpack_require__(362);
	var PlaygroundStorage_1 = __webpack_require__(588);
	var getQueryTypes_1 = __webpack_require__(580);
	var debounce_1 = __webpack_require__(156);
	var Observable_1 = __webpack_require__(1027);
	var subscriptions_transport_ws_1 = __webpack_require__(1045);
	var isQuerySubscription_1 = __webpack_require__(582);
	var HistoryPopup_1 = __webpack_require__(583);
	var cx = __webpack_require__(13);
	var SelectUserPopup_1 = __webpack_require__(589);
	var calculate_size_1 = __webpack_require__(126);
	var CodeGenerationPopup_1 = __webpack_require__(561);
	var graphql_2 = __webpack_require__(12);
	var data_1 = __webpack_require__(591);
	var httpApiPrefix = 'https://api.graph.cool';
	var wsApiPrefix = 'wss://dev.subscriptions.graph.cool/v1';
	var Playground = function (_super) {
	    __extends(Playground, _super);
	    function Playground(props) {
	        var _this = _super.call(this, props) || this;
	        _this.wsConnections = {};
	        _this.observers = {};
	        _this.graphiqlComponents = [];
	        _this.initialIndex = -1;
	        _this.updateQueryTypes = debounce_1.default(150, function (sessionId, query) {
	            var queryTypes = getQueryTypes_1.default(query);
	            _this.setValueInSession(sessionId, 'queryTypes', queryTypes);
	        });
	        _this.handleQueryChange = debounce_1.default(300, function (sessionId, query) {
	            _this.setValueInSession(sessionId, 'query', query);
	            _this.updateQueryTypes(sessionId, query);
	            if (_this.props.onboardingStep === 'STEP3_UNCOMMENT_DESCRIPTION' && _this.state.selectedSessionIndex === 0) {
	                var trimmedQuery = query.replace(/\s/g, '').replace(',', '');
	                if (trimmedQuery === data_1.onboardingQuery1Check && typeof _this.props.nextStep === 'function') {
	                    _this.props.nextStep();
	                }
	            }
	            if ((_this.props.onboardingStep === 'STEP3_ENTER_MUTATION1_VALUES' || _this.props.onboardingStep === 'STEP3_ENTER_MUTATION2_VALUE') && _this.state.selectedSessionIndex === 1) {
	                var trimmedTemplate = data_1.onboardingEmptyMutation.replace(/\s/g, '');
	                var trimmedQuery = query.replace(/\s/g, '').replace(',', '');
	                if (trimmedQuery !== trimmedTemplate && typeof _this.props.nextStep === 'function') {
	                    _this.props.nextStep();
	                }
	            }
	        });
	        _this.setWS = function (session) {
	            console.log('calling setWS');
	            var connectionParams = {};
	            if (session.selectedViewer === 'ADMIN' && _this.state.adminAuthToken) {
	                connectionParams['Authorization'] = "Bearer " + _this.state.adminAuthToken;
	                console.log('setWS: going for admin');
	            } else if (session.selectedViewer === 'USER' && session.selectedUserToken) {
	                connectionParams['Authorization'] = "Bearer " + session.selectedUserToken;
	                console.log('setWS: going for user');
	            } else {
	                console.log('going for everyone');
	            }
	            if (_this.wsConnections[session.id]) {
	                _this.wsConnections[session.id].unsubscribeAll();
	            }
	            _this.wsConnections[session.id] = new subscriptions_transport_ws_1.SubscriptionClient(_this.getWSEndpoint(), {
	                timeout: 20000,
	                connectionParams: connectionParams
	            });
	        };
	        _this.autofillMutation = function () {
	            var sessionId = _this.state.sessions[_this.state.selectedSessionIndex].id;
	            console.log('trying to autofill mutation', sessionId);
	            if (_this.props.onboardingStep === 'STEP3_ENTER_MUTATION1_VALUES') {
	                console.log('GOING FOR 1');
	                _this.setValueInSession(sessionId, 'query', data_1.onboardingFilledMutation1);
	            } else if (_this.props.onboardingStep === 'STEP3_ENTER_MUTATION2_VALUE') {
	                console.log('GOING FOR 2');
	                _this.setValueInSession(sessionId, 'query', data_1.onboardingFilledMutation2);
	            }
	            if (typeof _this.props.nextStep === 'function') {
	                _this.props.nextStep();
	            }
	        };
	        _this.handleClickCodeGeneration = function (session) {
	            _this.setState({
	                codeGenerationPopupOpen: true
	            });
	        };
	        _this.handleCloseCodeGeneration = function () {
	            _this.setState({ codeGenerationPopupOpen: false });
	        };
	        _this.handleUserSelection = function (user) {
	            var systemApi = _this.getSystemEndpoint();
	            var query = "\n      mutation {\n        signinClientUser(input: {\n          projectId: \"" + _this.props.projectId + "\"\n          clientUserId: \"" + user.id + "\"\n          clientMutationId: \"asd\"\n        }) {\n          token\n          clientMutationId\n        }\n      }\n    ";
	            fetch(systemApi, {
	                method: 'post',
	                body: JSON.stringify({ query: query }),
	                headers: {
	                    'Content-Type': 'application/json',
	                    'Authorization': "Bearer " + _this.state.adminAuthToken
	                }
	            }).then(function (res) {
	                return res.json();
	            }).then(function (res) {
	                var token = res.data.signinClientUser.token;
	                if (token && _this.state.selectUserSessionId) {
	                    _this.setValueInSession(_this.state.selectUserSessionId, 'selectedUserToken', token, function () {
	                        var session = _this.state.sessions[_this.state.selectedSessionIndex];
	                        _this.resetSubscription(session);
	                    });
	                }
	            });
	        };
	        _this.handleCreateSession = function (session) {
	            var newSession = _this.createSession(session);
	            _this.setState(function (state) {
	                return __assign({}, state, { sessions: state.sessions.concat(newSession), selectedSessionIndex: state.sessions.length });
	            });
	        };
	        _this.handleItemStarToggled = function (item) {
	            _this.setValueInHistory(item.id, 'starred', !item.starred);
	        };
	        _this.handleCloseSession = function (session) {
	            if (_this.state.sessions.length === 1) {
	                _this.handleNewSession(true);
	            }
	            _this.setState(function (state) {
	                var i = state.sessions.findIndex(function (s) {
	                    return s.id === session.id;
	                });
	                var nextSelectedSession = state.selectedSessionIndex;
	                if (nextSelectedSession > state.sessions.length - 2) {
	                    // if it's not the last session
	                    if (state.sessions.length > 1) {
	                        nextSelectedSession--;
	                    }
	                }
	                return __assign({}, state, { sessions: state.sessions.slice(0, i).concat(state.sessions.slice(i + 1, state.sessions.length)), selectedSessionIndex: nextSelectedSession });
	            });
	            _this.storage.removeSession(session);
	        };
	        _this.handleOpenHistory = function () {
	            _this.setState({ historyOpen: true });
	        };
	        _this.handleCloseHistory = function () {
	            _this.setState({ historyOpen: false });
	        };
	        _this.handleSelectSession = function (session) {
	            _this.setState(function (state) {
	                var i = state.sessions.findIndex(function (s) {
	                    return s.id === session.id;
	                });
	                if (_this.props.onboardingStep === 'STEP3_SELECT_QUERY_TAB' && i === 0 && typeof _this.props.nextStep === 'function') {
	                    _this.props.nextStep();
	                }
	                return __assign({}, state, { selectedSessionIndex: i });
	            });
	        };
	        _this.initSessions = function () {
	            if (['STEP3_UNCOMMENT_DESCRIPTION', 'STEP3_OPEN_PLAYGROUND'].indexOf(_this.props.onboardingStep || '') > -1) {
	                return _this.initOnboardingSessions();
	            }
	            // defaulting to admin for deserialized sessions
	            var sessions = _this.storage.getSessions(); // .map(session => Immutable.set(session, 'selectedViewer', 'ADMIN'))
	            var urlSession = _this.getUrlSession(sessions);
	            if (urlSession) {
	                if (sessions.length === 1 && sessions[0].query === constants_1.defaultQuery) {
	                    return [urlSession];
	                }
	                return sessions.concat(urlSession);
	            }
	            if (sessions.length > 0) {
	                return sessions;
	            }
	            return [_this.createSession()];
	        };
	        _this.saveSessions = function () {
	            _this.state.sessions.forEach(function (session) {
	                return _this.storage.saveSession(Immutable.set(session, 'subscriptionActive', false), false);
	            });
	        };
	        _this.saveHistory = function () {
	            _this.storage.syncHistory(_this.state.history);
	        };
	        _this.handleNewSession = function (newIndexZero) {
	            if (newIndexZero === void 0) {
	                newIndexZero = false;
	            }
	            var session = _this.createSession();
	            if (_this.props.onboardingStep === 'STEP3_CREATE_MUTATION_TAB') {
	                session = Immutable.set(session, 'query', data_1.onboardingEmptyMutation);
	                setTimeout(function () {
	                    _this.setCursor({
	                        line: 2,
	                        ch: 15
	                    });
	                }, 5);
	                if (typeof _this.props.nextStep === 'function') {
	                    _this.props.nextStep();
	                }
	            }
	            _this.setState(function (state) {
	                return __assign({}, state, { sessions: state.sessions.concat(session), selectedSessionIndex: newIndexZero ? 0 : state.sessions.length });
	            });
	        };
	        _this.createSession = function (session) {
	            var newSession;
	            if (session) {
	                newSession = Immutable.set(session, 'id', cuid());
	            } else {
	                var query = _this.storage.hasExecutedQuery() ? '' : constants_1.defaultQuery;
	                newSession = Immutable({
	                    id: cuid(),
	                    selectedEndpoint: 'SIMPLE',
	                    selectedViewer: 'ADMIN',
	                    query: query,
	                    variables: '',
	                    result: '',
	                    operationName: undefined,
	                    hasMutation: false,
	                    hasSubscription: false,
	                    hasQuery: false,
	                    queryTypes: getQueryTypes_1.default(query),
	                    starred: false
	                });
	            }
	            _this.storage.saveSession(newSession);
	            return newSession;
	        };
	        _this.createSessionFromQuery = function (query) {
	            return Immutable({
	                id: cuid(),
	                selectedEndpoint: 'SIMPLE',
	                selectedViewer: 'ADMIN',
	                query: query,
	                variables: '',
	                result: '',
	                operationName: undefined,
	                hasMutation: false,
	                hasSubscription: false,
	                hasQuery: false,
	                queryTypes: getQueryTypes_1.default(query),
	                starred: false
	            });
	        };
	        _this.handleViewerChange = function (sessionId, viewer) {
	            _this.setValueInSession(sessionId, 'selectedViewer', viewer, function () {
	                if (viewer === 'USER') {
	                    // give the user some time to realize whats going on
	                    setTimeout(function () {
	                        _this.setState({
	                            selectUserOpen: true,
	                            selectUserSessionId: sessionId
	                        });
	                    }, 300);
	                }
	                var session = _this.state.sessions.find(function (session) {
	                    return session.id === sessionId;
	                });
	                if (session) {
	                    _this.resetSubscription(session);
	                } else {
	                    throw new Error('session not found for viewer change');
	                }
	            });
	        };
	        _this.handleCloseSelectUser = function () {
	            _this.setState({
	                selectUserOpen: false
	            });
	        };
	        _this.handleEndpointChange = function (sessionId, endpoint) {
	            _this.setValueInSession(sessionId, 'selectedEndpoint', endpoint);
	        };
	        _this.handleVariableChange = function (sessionId, variables) {
	            _this.setValueInSession(sessionId, 'variables', variables);
	        };
	        _this.handleOperationNameChange = function (sessionId, operationName) {
	            _this.setValueInSession(sessionId, 'operationName', operationName);
	        };
	        _this.cancelSubscription = function (session) {
	            _this.setValueInSession(session.id, 'subscriptionActive', false);
	            if (session.subscriptionId) {
	                _this.wsConnections[session.id].unsubscribe(session.subscriptionId);
	                _this.setValueInSession(session.id, 'subscriptionId', null);
	            }
	        };
	        _this.fetcher = function (session) {
	            return function (graphQLParams) {
	                var query = graphQLParams.query,
	                    operationName = graphQLParams.operationName;
	                if (!query.includes('IntrospectionQuery')) {
	                    if (['STEP3_RUN_QUERY1', 'STEP3_RUN_MUTATION1', 'STEP3_RUN_MUTATION2', 'STEP3_RUN_QUERY2'].indexOf(_this.props.onboardingStep || '') > -1 && typeof _this.props.nextStep === 'function') {
	                        if (_this.props.onboardingStep === 'STEP3_RUN_QUERY2') {
	                            setTimeout(function () {
	                                // typescript wants to be happy...
	                                if (typeof _this.props.nextStep === 'function') {
	                                    _this.props.nextStep();
	                                }
	                            }, 2000);
	                        } else {
	                            _this.props.nextStep();
	                        }
	                    }
	                    if (!_this.historyIncludes(session)) {
	                        setImmediate(function () {
	                            _this.addToHistory(session);
	                        });
	                    }
	                    if (isQuerySubscription_1.default(query, operationName)) {
	                        return Observable_1.Observable.create(function (observer) {
	                            _this.observers[session.id] = observer;
	                            if (!session.subscriptionActive) {
	                                _this.setValueInSession(session.id, 'subscriptionActive', true);
	                            }
	                            var id = _this.wsConnections[session.id].subscribe(graphQLParams, function (err, res) {
	                                var data = { data: res, isSubscription: true };
	                                if (err) {
	                                    data['error'] = err;
	                                }
	                                observer.next(data);
	                            });
	                            _this.setValueInSession(session.id, 'subscriptionId', id);
	                            return function () {
	                                _this.cancelSubscription(session);
	                            };
	                        });
	                    }
	                }
	                var endpoint = session.selectedEndpoint === 'SIMPLE' ? _this.getSimpleEndpoint() : _this.getRelayEndpoint();
	                var headers = {
	                    'Content-Type': 'application/json',
	                    'x-graphcool-source': 'console:playground'
	                };
	                if (session.selectedViewer === 'ADMIN' && _this.state.adminAuthToken) {
	                    headers['Authorization'] = "Bearer " + _this.state.adminAuthToken;
	                } else if (session.selectedViewer === 'USER' && session.selectedUserToken) {
	                    headers['Authorization'] = "Bearer " + session.selectedUserToken;
	                }
	                return fetch(endpoint, {
	                    method: 'post',
	                    headers: headers,
	                    body: JSON.stringify(graphQLParams)
	                }).then(function (response) {
	                    if (typeof _this.props.onSuccess === 'function') {
	                        _this.props.onSuccess(graphQLParams, response);
	                    }
	                    if (_this.props.isEndpoint) {
	                        history.pushState({}, 'Graphcool Playground', "?query=" + encodeURIComponent(query));
	                    }
	                    _this.storage.executedQuery();
	                    return response.json();
	                });
	            };
	        };
	        _this.storage = new PlaygroundStorage_1.default(props.projectId);
	        var sessions = _this.initSessions();
	        var selectedSessionIndex = parseInt(_this.storage.getItem('selectedSessionIndex'), 10) || 0;
	        _this.state = {
	            schema: null,
	            schemaCache: {
	                SIMPLE: null,
	                RELAY: null
	            },
	            userFields: [],
	            sessions: sessions,
	            selectedSessionIndex: selectedSessionIndex < sessions.length && selectedSessionIndex > -1 ? selectedSessionIndex : 0,
	            historyOpen: false,
	            history: _this.storage.getHistory(),
	            httpApiPrefix: props.httpApiPrefix || httpApiPrefix,
	            wsApiPrefix: props.wsApiPrefix || wsApiPrefix,
	            adminAuthToken: props.adminAuthToken && props.adminAuthToken.length > 0 && props.adminAuthToken || localStorage.getItem('token'),
	            response: undefined,
	            selectUserOpen: false,
	            selectUserSessionId: undefined,
	            codeGenerationPopupOpen: false,
	            disableQueryHeader: false
	        };
	        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
	            window.addEventListener('beforeunload', function () {
	                _this.componentWillUnmount();
	            });
	        }
	        global['p'] = _this;
	        return _this;
	    }
	    Playground.prototype.componentWillMount = function () {
	        // look, if there is a session. if not, initiate one.
	        this.fetchSchemas().then(this.initSessions);
	    };
	    Playground.prototype.componentWillUnmount = function () {
	        this.storage.setItem('selectedSessionIndex', String(this.state.selectedSessionIndex));
	        this.saveSessions();
	        this.saveHistory();
	        this.storage.saveProject();
	    };
	    Playground.prototype.componentDidMount = function () {
	        if (this.initialIndex > -1) {
	            this.setState({
	                selectedSessionIndex: this.initialIndex
	            });
	        }
	        if (['STEP3_UNCOMMENT_DESCRIPTION', 'STEP3_OPEN_PLAYGROUND'].indexOf(this.props.onboardingStep || '') > -1) {
	            this.setCursor({ line: 3, ch: 6 });
	        }
	        this.initWebsockets();
	    };
	    Playground.prototype.initWebsockets = function () {
	        var _this = this;
	        this.state.sessions.forEach(function (session) {
	            return _this.setWS(session);
	        });
	    };
	    Playground.prototype.setCursor = function (position) {
	        var editor = this.graphiqlComponents[this.state.selectedSessionIndex].queryEditorComponent.editor;
	        editor.setCursor(position);
	    };
	    Playground.prototype.componentWillReceiveProps = function (nextProps) {
	        if (nextProps.projectId !== this.props.projectId || nextProps.adminAuthToken !== this.props.adminAuthToken) {
	            this.resetSubscriptions();
	            this.fetchSchemas();
	        }
	    };
	    Playground.prototype.fetchSchemas = function () {
	        var _this = this;
	        return Promise.all([this.props.isEndpoint ? Promise.resolve(null) : this.fetchSchema(this.getRelayEndpoint()), this.fetchSchema(this.getSimpleEndpoint())]).then(function (_a) {
	            var relaySchemaData = _a[0],
	                simpleSchemaData = _a[1];
	            if (!simpleSchemaData || simpleSchemaData.error) {
	                _this.setState({
	                    response: {
	                        date: simpleSchemaData.error,
	                        time: new Date()
	                    }
	                });
	                return;
	            }
	            var relaySchema = relaySchemaData && !relaySchemaData.error && graphql_1.buildClientSchema(relaySchemaData.data);
	            var simpleSchema = graphql_1.buildClientSchema(simpleSchemaData.data);
	            var userFields = _this.extractUserField(simpleSchema);
	            _this.setState({
	                schemaCache: {
	                    RELAY: relaySchema,
	                    SIMPLE: simpleSchema
	                },
	                userFields: userFields
	            });
	        });
	    };
	    Playground.prototype.extractUserField = function (simpleSchema) {
	        var userSchema = simpleSchema.getType('User');
	        if (userSchema) {
	            var userSchemaFields_1 = userSchema.getFields();
	            var userFields = Object.keys(userSchemaFields_1).map(function (fieldName) {
	                return userSchemaFields_1[fieldName];
	            }).filter(function (field) {
	                // filter password, meta fields and relation fields
	                return field.name[0] !== '_' && field.name !== 'password' && !(field.type instanceof graphql_2.GraphQLList || field.type instanceof graphql_2.GraphQLObjectType);
	            });
	            // put id to beginning
	            userFields.sort(function (a, b) {
	                if (a.name === 'id') {
	                    return -1;
	                }
	                if (b.name === 'id') {
	                    return 1;
	                }
	                return a.name > b.name ? 1 : -1;
	            });
	            return userFields.map(function (field) {
	                var size = calculate_size_1.default(field.name, {
	                    font: 'Open Sans',
	                    fontWeight: '600',
	                    fontSize: '16px'
	                });
	                var width = size.width;
	                if (field.name === 'id') {
	                    width = 220;
	                }
	                // TODO create type to field width map
	                field.width = Math.max(width, 185) + 50;
	                return field;
	            });
	        } else {
	            return [];
	        }
	    };
	    Playground.prototype.fetchSchema = function (endpointUrl) {
	        return fetch(endpointUrl, {
	            method: 'post',
	            headers: {
	                'Content-Type': 'application/json',
	                'x-graphcool-source': 'console:playground'
	            },
	            body: JSON.stringify({ query: constants_1.introspectionQuery })
	        }).then(function (response) {
	            return response.json();
	        });
	    };
	    Playground.prototype.render = function () {
	        var _this = this;
	        var _a = this.state,
	            sessions = _a.sessions,
	            selectedSessionIndex = _a.selectedSessionIndex;
	        var isEndpoint = this.props.isEndpoint;
	        // {
	        //   'blur': this.state.historyOpen,
	        // },
	        if (this.state.selectUserOpen && !this.props.adminAuthToken) {
	            throw new Error('The "Select User" Popup is open, but no admin token is provided.');
	        }
	        var selectedSession = sessions[selectedSessionIndex];
	        var selectedEndpointUrl = isEndpoint ? location.href : selectedSession.selectedEndpoint === 'SIMPLE' ? this.getSimpleEndpoint() : this.getRelayEndpoint();
	        // const canSelectUsers = this.state.userFields.length > 0
	        return React.createElement(
	            "div",
	            { className: cx('root'), "data-jsx": 3241802770
	            },
	            React.createElement(_style2.default, {
	                styleId: 3241802770,
	                css: ".blur[data-jsx=\"3241802770\"] {filter: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\"><filter id=\"filter\"><feGaussianBlur stdDeviation=\"5\" /></filter></svg>#filter');-webkit-filter: blur(5px);filter: blur(5px);}.graphiqls-container[data-jsx=\"3241802770\"] {height: calc(100vh - 57px);}.h100,\n.root[data-jsx=\"3241802770\"],\n.graphiql-wrapper[data-jsx=\"3241802770\"] {height: 100%;}.flex,\n.root[data-jsx=\"3241802770\"] {display: -ms-flexbox;display: flex;}.flexColumn,\n.root[data-jsx=\"3241802770\"] {-ms-flex-direction: column;flex-direction: column;}.relative,\n.graphiqls-container[data-jsx=\"3241802770\"],\n.graphiql-wrapper[data-jsx=\"3241802770\"] {position: relative;}.overflowHidden,\n.graphiqls-container[data-jsx=\"3241802770\"] {overflow: hidden;}.w100,\n.graphiql-wrapper[data-jsx=\"3241802770\"] {width: 100%;}.h100,\n.root[data-jsx=\"3241802770\"],\n.graphiql-wrapper[data-jsx=\"3241802770\"] {height: 100%;}.relative,\n.graphiqls-container[data-jsx=\"3241802770\"],\n.graphiql-wrapper[data-jsx=\"3241802770\"] {position: relative;}"
	            }),
	            React.createElement(TabBar_1.TabBar, { sessions: sessions, selectedSessionIndex: selectedSessionIndex, onNewSession: function onNewSession() {
	                    return _this.handleNewSession(false);
	                }, onCloseSession: this.handleCloseSession, onOpenHistory: this.handleOpenHistory, onSelectSession: this.handleSelectSession, onboardingStep: this.props.onboardingStep, nextStep: this.props.nextStep, tether: this.props.tether }),
	            React.createElement(
	                "div",
	                { className: "graphiqls-container docs-graphiql", "data-jsx": 3241802770
	                },
	                sessions.map(function (session, index) {
	                    return React.createElement(
	                        "div",
	                        { key: session.id, className: cx('graphiql-wrapper', {
	                                'active': index === selectedSessionIndex
	                            }), style: {
	                                top: "-" + 100 * selectedSessionIndex + "%"
	                            }, "data-jsx": 3241802770
	                        },
	                        React.createElement(CustomGraphiQL_1.CustomGraphiQL, { key: session.id, schema: _this.state.schemaCache[session.selectedEndpoint], fetcher: _this.fetcher(session), selectedEndpoint: session.selectedEndpoint, showQueryTitle: false, showResponseTitle: false, showViewAs: !isEndpoint, showSelectUser: true, showEndpoints: !isEndpoint, showDownloadJsonButton: true, showCodeGeneration: true, selectedViewer: session.selectedViewer, storage: _this.storage.getSessionStorage(session.id), query: session.query, variables: session.variables, operationName: session.operationName, onClickCodeGeneration: function onClickCodeGeneration() {
	                                return _this.handleClickCodeGeneration(session);
	                            }, onChangeEndpoint: function onChangeEndpoint(endpoint) {
	                                return _this.handleEndpointChange(session.id, endpoint);
	                            }, onChangeViewer: function onChangeViewer(viewer) {
	                                return _this.handleViewerChange(session.id, viewer);
	                            }, onEditOperationName: function onEditOperationName(name) {
	                                return _this.handleOperationNameChange(session.id, name);
	                            }, onEditVariables: function onEditVariables(variables) {
	                                return _this.handleVariableChange(session.id, variables);
	                            }, onEditQuery: function onEditQuery(query) {
	                                return _this.handleQueryChange(session.id, query);
	                            }, responses: _this.state.response ? [_this.state.response] : undefined, disableQueryHeader: _this.state.disableQueryHeader, disableResize: true, onboardingStep: index === selectedSessionIndex ? _this.props.onboardingStep : undefined, tether: _this.props.tether, nextStep: _this.props.nextStep, ref: function ref(_ref) {
	                                return _this.graphiqlComponents[index] = _ref;
	                            }, autofillMutation: _this.autofillMutation, rerenderQuery: _this.props.onboardingStep === 'STEP3_ENTER_MUTATION1_VALUES' || _this.props.onboardingStep === 'STEP3_ENTER_MUTATION2_VALUE', disableAnimation: true })
	                    );
	                })
	            ),
	            this.state.historyOpen && React.createElement(HistoryPopup_1.default, { isOpen: this.state.historyOpen, onRequestClose: this.handleCloseHistory, historyItems: this.state.history, onItemStarToggled: this.handleItemStarToggled, fetcherCreater: this.fetcher, schemas: this.state.schemaCache, onCreateSession: this.handleCreateSession }),
	            this.props.adminAuthToken && React.createElement(SelectUserPopup_1.default, { isOpen: this.state.selectUserOpen, onRequestClose: this.handleCloseSelectUser, projectId: this.props.projectId, adminAuthToken: this.props.adminAuthToken, userFields: this.state.userFields, onSelectUser: this.handleUserSelection, endpointUrl: this.getSimpleEndpoint() }),
	            this.state.codeGenerationPopupOpen && React.createElement(CodeGenerationPopup_1.CodeGenerationPopup, { endpointUrl: selectedEndpointUrl, isOpen: this.state.codeGenerationPopupOpen, onRequestClose: this.handleCloseCodeGeneration, query: selectedSession.query })
	        );
	    };
	    Playground.prototype.resetSubscriptions = function () {
	        var _this = this;
	        this.state.sessions.forEach(function (session) {
	            return _this.resetSubscription(session);
	        });
	    };
	    Playground.prototype.resetSubscription = function (session) {
	        if (this.observers[session.id]) {
	            this.observers[session.id].complete();
	            delete this.observers[session.id];
	        }
	        this.cancelSubscription(session);
	        this.setWS(session);
	    };
	    Playground.prototype.getUrlSession = function (sessions) {
	        var prefix = '?query=';
	        if (location.search.includes(prefix)) {
	            var uri = location.search.slice(prefix.length, location.search.length);
	            var query_1 = decodeURIComponent(uri);
	            var equivalent = sessions.findIndex(function (session) {
	                return session.query.trim() === query_1.trim();
	            });
	            if (equivalent > -1) {
	                this.initialIndex = equivalent;
	            } else {
	                return this.createSessionFromQuery(query_1);
	            }
	        }
	        return null;
	    };
	    Playground.prototype.initOnboardingSessions = function () {
	        var session = this.createSession();
	        return [__assign({}, session, { query: data_1.onboardingQuery1 })];
	    };
	    Playground.prototype.setValueInHistory = function (sessionId, key, value) {
	        this.setState(function (state) {
	            // TODO optimize the lookup with a lookup table
	            var i = state.history.findIndex(function (s) {
	                return s.id === sessionId;
	            });
	            return __assign({}, state, { history: Immutable.setIn(state.history, [i, key], value) });
	        });
	    };
	    Playground.prototype.setValueInSession = function (sessionId, key, value, cb) {
	        this.setState(function (state) {
	            // TODO optimize the lookup with a lookup table
	            var i = state.sessions.findIndex(function (s) {
	                return s.id === sessionId;
	            });
	            return __assign({}, state, { sessions: Immutable.setIn(state.sessions, [i, key], value) });
	        }, function () {
	            if (typeof cb === 'function') {
	                cb();
	            }
	        });
	    };
	    Playground.prototype.getSimpleEndpoint = function () {
	        if (this.props.isEndpoint) {
	            return location.pathname;
	        }
	        return this.state.httpApiPrefix + "/simple/v1/" + this.props.projectId;
	    };
	    Playground.prototype.getRelayEndpoint = function () {
	        return this.state.httpApiPrefix + "/relay/v1/" + this.props.projectId;
	    };
	    Playground.prototype.getSystemEndpoint = function () {
	        return this.state.httpApiPrefix + "/system";
	    };
	    Playground.prototype.getWSEndpoint = function () {
	        return this.state.wsApiPrefix + "/" + this.props.projectId;
	    };
	    Playground.prototype.addToHistory = function (session) {
	        var id = cuid();
	        var historySession = Immutable.merge(session, {
	            id: id,
	            date: new Date()
	        });
	        this.setState(function (state) {
	            return __assign({}, state, { history: [historySession].concat(state.history) });
	        });
	        this.storage.addToHistory(historySession);
	    };
	    Playground.prototype.historyIncludes = function (session) {
	        var duplicate = this.state.history.find(function (item) {
	            return session.query === item.query && session.variables === item.variables && session.operationName === item.operationName && session.selectedViewer === item.selectedViewer && session.selectedEndpoint === item.selectedEndpoint;
	        });
	        return Boolean(duplicate);
	    };
	    return Playground;
	}(React.Component);
	exports.default = Playground;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1053).setImmediate, (function() { return this; }())))

/***/ }),
/* 588 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var __assign = undefined && undefined.__assign || Object.assign || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) {
	            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var PlaygroundStorage = function () {
	    function PlaygroundStorage(projectId) {
	        this.storages = {};
	        this.projectId = projectId;
	        this.project = this.getProject();
	        this.executedQueryCount = this.getExecutedQueryCount();
	        if (!this.project) {
	            this.project = {
	                sessions: {},
	                history: [],
	                data: {}
	            };
	            this.saveProject();
	        }
	        global['s'] = this;
	    }
	    PlaygroundStorage.prototype.executedQuery = function () {
	        if (!this.executedQueryCount) {
	            this.executedQueryCount = 1;
	        } else {
	            this.executedQueryCount++;
	        }
	    };
	    PlaygroundStorage.prototype.hasExecutedQuery = function () {
	        return this.executedQueryCount >= 2;
	    };
	    PlaygroundStorage.prototype.getSessionStorage = function (sessionId) {
	        if (this.storages[sessionId]) {
	            return this.storages[sessionId];
	        }
	        var prefix = this.projectId + ":" + sessionId + ":";
	        var store = {
	            clear: function clear() {
	                Object.keys(localStorage).filter(function (key) {
	                    return key.startsWith(prefix);
	                }).forEach(function (key) {
	                    return localStorage.removeItem(key);
	                });
	            },
	            getItem: function getItem(key) {
	                return localStorage.getItem(prefix + key);
	            },
	            setItem: function setItem(key, item) {
	                return localStorage.setItem(prefix + key, item);
	            },
	            removeItem: function removeItem(key) {
	                return localStorage.removeItem(prefix + key);
	            }
	        };
	        this.storages[sessionId] = store;
	        return store;
	    };
	    PlaygroundStorage.prototype.getSessions = function () {
	        var _this = this;
	        return Object.keys(this.project.sessions).filter(function (key) {
	            return key !== 'undefined';
	        }).map(function (sessionId) {
	            return _this.project.sessions[sessionId];
	        });
	    };
	    PlaygroundStorage.prototype.removeSession = function (session) {
	        delete this.project.sessions[session.id];
	    };
	    PlaygroundStorage.prototype.saveSession = function (session, save) {
	        if (save === void 0) {
	            save = false;
	        }
	        this.project.sessions[session.id] = session;
	        if (save) {
	            this.saveProject();
	        }
	    };
	    PlaygroundStorage.prototype.syncHistory = function (history) {
	        this.project.history = history;
	    };
	    PlaygroundStorage.prototype.addToHistory = function (session) {
	        // limit by 1000 items
	        this.project.history.unshift(session);
	        this.project.history = this.project.history.slice(0, 1000);
	    };
	    PlaygroundStorage.prototype.getHistory = function () {
	        return this.project.history || [];
	    };
	    PlaygroundStorage.prototype.setItem = function (key, value) {
	        this.project.data[key] = value;
	    };
	    PlaygroundStorage.prototype.getItem = function (key) {
	        return this.project.data[key];
	    };
	    PlaygroundStorage.prototype.saveProject = function () {
	        var json = JSON.stringify(this.project);
	        localStorage.setItem(this.projectId, json);
	        localStorage.setItem('executedQueryCount', this.executedQueryCount.toString());
	    };
	    PlaygroundStorage.prototype.getProject = function () {
	        var result = null;
	        try {
	            result = JSON.parse(localStorage.getItem(this.projectId) || '');
	        } catch (e) {
	            //
	        }
	        if (result && result.history) {
	            result.history = result.history.map(function (item) {
	                return __assign({}, item, { date: new Date(item.date) });
	            });
	        }
	        return result;
	    };
	    PlaygroundStorage.prototype.getExecutedQueryCount = function () {
	        var count = 0;
	        try {
	            count = parseInt(localStorage.getItem('executedQueryCount') || '0', 10);
	        } catch (e) {
	            //
	        }
	        return count;
	    };
	    return PlaygroundStorage;
	}();
	exports.default = PlaygroundStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	var __assign = undefined && undefined.__assign || Object.assign || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) {
	            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var fetch = __webpack_require__(173);
	var constants_1 = __webpack_require__(101);
	var Modal = __webpack_require__(192);
	var graphcool_styles_1 = __webpack_require__(26);
	var Table_1 = __webpack_require__(590);
	var SearchBox_1 = __webpack_require__(153);
	var Immutable = __webpack_require__(362);
	var SelectUserPopup = function (_super) {
	    __extends(SelectUserPopup, _super);
	    function SelectUserPopup(props) {
	        var _this = _super.call(this, props) || this;
	        _this.handleRowSelection = function (_a) {
	            var index = _a.index,
	                rowData = _a.rowData;
	            if (index === _this.state.selectedRowIndex) {
	                return;
	            }
	            _this.setState(function (state) {
	                var users = state.users;
	                if (state.selectedRowIndex > -1) {
	                    users = Immutable.setIn(users, [state.selectedRowIndex, 'selected'], false);
	                }
	                users = Immutable.setIn(users, [index, 'selected'], true);
	                return __assign({}, state, { users: users, selectedRowIndex: index });
	            });
	            _this.props.onSelectUser(rowData);
	        };
	        _this.handleSearch = function (value) {
	            _this.setState({ query: value }, function () {
	                var _a = _this.state,
	                    startIndex = _a.startIndex,
	                    stopIndex = _a.stopIndex;
	                _this.getUsers({ startIndex: startIndex, stopIndex: stopIndex });
	            });
	        };
	        _this.getUsers = function (_a, userFieldsInput) {
	            var startIndex = _a.startIndex,
	                stopIndex = _a.stopIndex;
	            var query = _this.state.query;
	            var userFields = userFieldsInput || _this.props.userFields;
	            if (userFields.length === 0) {
	                return;
	            }
	            var filter = '';
	            if (query && query.length > 0) {
	                filter = ' filter: { OR: [';
	                var whiteList_1 = ['ID', 'String', 'Enum'];
	                var filtered = userFields.filter(function (field) {
	                    var typeName = field.type.name || field.type.ofType.name;
	                    return whiteList_1.indexOf(typeName) > -1;
	                });
	                filter += filtered.map(function (field) {
	                    return "{" + field.name + "_contains: \"" + query + "\"}";
	                }).join(',\n');
	                filter += ']}';
	            }
	            var count = stopIndex - startIndex;
	            var userQuery = "\n      {\n        _allUsersMeta {\n          count\n        }\n        allUsers(skip: " + startIndex + " first: " + count + filter + "){\n          " + userFields.map(function (f) {
	                return f.name;
	            }).join('\n') + "\n        }\n      }\n    ";
	            fetch(_this.props.endpointUrl, {
	                method: 'post',
	                headers: {
	                    'Content-Type': 'application/json',
	                    'Authorization': "Bearer " + _this.props.adminAuthToken,
	                    'X-GraphCool-Source': 'playground'
	                },
	                body: JSON.stringify({ query: userQuery })
	            }).then(function (res) {
	                return res.json();
	            }).then(function (res) {
	                if (!res.data) {
	                    return;
	                }
	                var _a = res.data,
	                    _allUsersMeta = _a._allUsersMeta,
	                    allUsers = _a.allUsers;
	                var users = _this.state.users;
	                // reset data if search changed
	                if (query !== _this.lastQuery) {
	                    users = Immutable([]);
	                }
	                allUsers.forEach(function (user, i) {
	                    users = Immutable.set(users, i + startIndex, user);
	                });
	                var newState = {
	                    users: users,
	                    count: _allUsersMeta.count
	                };
	                if (_this.lastQuery !== _this.state.query) {
	                    newState['scrollToIndex'] = 0;
	                    setTimeout(function () {
	                        _this.setState({
	                            scrollToIndex: undefined
	                        });
	                    }, 150);
	                }
	                _this.setState(newState);
	                _this.lastQuery = query;
	            }).catch(function (e) {
	                return console.error(e);
	            });
	        };
	        _this.state = {
	            startIndex: 0,
	            stopIndex: 50,
	            users: Immutable([]),
	            query: '',
	            count: 0,
	            selectedRowIndex: -1,
	            scrollToIndex: undefined
	        };
	        _this.getUsers({ startIndex: 0, stopIndex: 50 }, props.userFields);
	        _this.style = Object.assign({}, constants_1.modalStyle, {
	            overlay: constants_1.modalStyle.overlay,
	            content: Object.assign({}, constants_1.modalStyle.content, {
	                width: 'auto',
	                minWidth: '600px',
	                maxWidth: window.innerWidth - 100 + 'px'
	            })
	        });
	        global['s'] = _this;
	        return _this;
	    }
	    SelectUserPopup.prototype.componentWillReceiveProps = function (nextProps) {
	        var _a = this.state,
	            startIndex = _a.startIndex,
	            stopIndex = _a.stopIndex;
	        if (nextProps.userFields.length !== this.props.userFields.length) {
	            this.getUsers({ startIndex: startIndex, stopIndex: stopIndex }, nextProps.userFields);
	        }
	    };
	    SelectUserPopup.prototype.render = function () {
	        // put id to beginning
	        return React.createElement(
	            Modal,
	            { isOpen: this.props.isOpen, onRequestClose: this.props.onRequestClose, contentLabel: "Select a User", style: this.style },
	            React.createElement(_style2.default, {
	                styleId: 4162553977,
	                css: ".title-wrapper[data-jsx=\"1944216071\"] {padding: 45px;}.title[data-jsx=\"1944216071\"] {letter-spacing: 0.54px;}.search[data-jsx=\"1944216071\"] {margin-top: -24px;}.search-box[data-jsx=\"1944216071\"] {-moz-flex: 0 1 400px;-webkit-box-flex: 0;-ms-flex: 0 1 400px;flex: 0 1 400px;}.selected-user-id[data-jsx=\"1944216071\"] {font-family:            'Source Code Pro',            'Consolas',            'Inconsolata',            'Droid Sans Mono',            'Monaco',            monospace;}.bgWhite,\n.select-user-popup[data-jsx=\"1944216071\"] {background-color: #fff;}.relative,\n.select-user-popup[data-jsx=\"1944216071\"] {position: relative;}.mh25,\n.select-user-popup[data-jsx=\"1944216071\"] {margin-left: 25px;margin-right: 25px;}.flex,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {display: -ms-flexbox;display: flex;}.w100,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"] {width: 100%;}.itemsCenter,\n.title-wrapper[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.justifyCenter,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {-ms-flex-pack: center;justify-content: center;}.bb,\n.title-wrapper[data-jsx=\"1944216071\"] {border-bottom-style: solid;border-bottom-width: 1px;}.bBlack10,\n.title-wrapper[data-jsx=\"1944216071\"] {border-color: rgba(0,0,0,.1);}.fw3,\n.title[data-jsx=\"1944216071\"],\n.selected-user-id[data-jsx=\"1944216071\"] {font-weight: 300;}.f38,\n.title[data-jsx=\"1944216071\"] {font-size: 38px;}.absolute,\n.search[data-jsx=\"1944216071\"] {position: absolute;}.w100,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"] {width: 100%;}.bbox,\n.search[data-jsx=\"1944216071\"] {box-sizing: border-box;}.ph38,\n.search[data-jsx=\"1944216071\"] {padding-left: 38px;padding-right: 38px;}.z2,\n.search[data-jsx=\"1944216071\"] {z-index: 2;}.flex,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {display: -ms-flexbox;display: flex;}.justifyCenter,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {-ms-flex-pack: center;justify-content: center;}.ml25,\n.selected-user[data-jsx=\"1944216071\"] {margin-left: 25px;}.flex,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {display: -ms-flexbox;display: flex;}.flexColumn,\n.selected-user[data-jsx=\"1944216071\"] {-ms-flex-direction: column;flex-direction: column;}.justifyCenter,\n.title-wrapper[data-jsx=\"1944216071\"],\n.search[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {-ms-flex-pack: center;justify-content: center;}.itemsCenter,\n.title-wrapper[data-jsx=\"1944216071\"],\n.selected-user[data-jsx=\"1944216071\"] {-webkit-box-align: center;-ms-flex-align: center;-ms-grid-row-align: center;align-items: center;}.bgBlack04,\n.selected-user-id[data-jsx=\"1944216071\"] {background-color: rgba(0,0,0,.04);}.pa6,\n.selected-user-id[data-jsx=\"1944216071\"] {padding: 6px;}.br2,\n.selected-user-id[data-jsx=\"1944216071\"] {border-radius: 2px;}.black60,\n.selected-user-id[data-jsx=\"1944216071\"] {color: rgba(0,0,0,.6);}.f14,\n.selected-user-id[data-jsx=\"1944216071\"] {font-size: 14px;}.fw3,\n.title[data-jsx=\"1944216071\"],\n.selected-user-id[data-jsx=\"1944216071\"] {font-weight: 300;}.mt10,\n.selected-user-id[data-jsx=\"1944216071\"] {margin-top: 10px;}"
	            }),
	            React.createElement(_style2.default, {
	                styleId: 715398715,
	                css: "\n          .absolute,\n.popup-x {\n    position: absolute\n}\n.right0,\n.popup-x {\n    right: 0\n}\n.top0,\n.popup-x {\n    top: 0\n}\n.pointer:hover,\n.popup-x:hover {\n    cursor: pointer\n}\n.pt25,\n.popup-x {\n    padding-top: 25px\n}\n.pr25,\n.popup-x {\n    padding-right: 25px\n}\n        "
	            }),
	            React.createElement(
	                "div",
	                { className: "select-user-popup", "data-jsx": 1944216071
	                },
	                React.createElement(
	                    "div",
	                    { className: "title-wrapper", "data-jsx": 1944216071
	                    },
	                    React.createElement(
	                        "div",
	                        { className: "title", "data-jsx": 1944216071
	                        },
	                        "Select a User"
	                    ),
	                    this.state.selectedRowIndex > -1 && React.createElement(
	                        "div",
	                        { className: "selected-user", "data-jsx": 1944216071
	                        },
	                        React.createElement(
	                            "div",
	                            {
	                                "data-jsx": 1944216071
	                            },
	                            "Selected User ID"
	                        ),
	                        React.createElement(
	                            "div",
	                            { className: "selected-user-id", "data-jsx": 1944216071
	                            },
	                            this.state.users[this.state.selectedRowIndex].id
	                        )
	                    )
	                ),
	                React.createElement(graphcool_styles_1.Icon, { src: __webpack_require__(365), stroke: true, width: 25, height: 25, strokeWidth: 2, className: "popup-x", color: graphcool_styles_1.$v.gray50, onClick: this.props.onRequestClose }),
	                React.createElement(
	                    "div",
	                    { className: "search", "data-jsx": 1944216071
	                    },
	                    React.createElement(
	                        "div",
	                        { className: "search-box", "data-jsx": 1944216071
	                        },
	                        React.createElement(SearchBox_1.default, { placeholder: "Search for a user ...", onSearch: this.handleSearch, isShown: true, clean: true })
	                    )
	                ),
	                React.createElement(Table_1.default, { fields: this.props.userFields, rows: this.state.users, rowCount: this.state.count, loadMoreRows: this.getUsers, onRowSelection: this.handleRowSelection, scrollToIndex: this.state.scrollToIndex })
	            )
	        );
	    };
	    return SelectUserPopup;
	}(React.Component);
	exports.default = SelectUserPopup;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var _style = __webpack_require__(11);
	
	var _style2 = _interopRequireDefault(_style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var __extends = undefined && undefined.__extends || function () {
	    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	    } || function (d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) d[p] = b[p];
	        }
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(2);
	var react_virtualized_1 = __webpack_require__(843);
	function pZ(n) {
	    return n < 10 ? "0" + n : n;
	}
	var TableComponent = function (_super) {
	    __extends(TableComponent, _super);
	    function TableComponent(props) {
	        var _this = _super.call(this, props) || this;
	        _this.rowClassName = function (_a) {
	            var index = _a.index;
	            return "table-row " + (_this.props.rows[index] && _this.props.rows[index].selected ? 'selected' : '');
	        };
	        _this.noRowsRenderer = function () {
	            return React.createElement(
	                "div",
	                { className: "no-rows", "data-jsx": 1089156946
	                },
	                React.createElement(_style2.default, {
	                    styleId: 1089156946,
	                    css: ".w100,\n.no-rows[data-jsx=\"1089156946\"] {\n    width: 100%\n}\n.h100,\n.no-rows[data-jsx=\"1089156946\"] {\n    height: 100%\n}\n.flex,\n.no-rows[data-jsx=\"1089156946\"] {\n    display: -ms-flexbox;\n    display: flex\n}\n.justifyCenter,\n.no-rows[data-jsx=\"1089156946\"] {\n    -ms-flex-pack: center;\n    justify-content: center\n}\n.itemsCenter,\n.no-rows[data-jsx=\"1089156946\"] {\n    -webkit-box-align: center;\n    -ms-flex-align: center;\n    -ms-grid-row-align: center;\n    align-items: center\n}"
	                }),
	                React.createElement(
	                    "div",
	                    {
	                        "data-jsx": 1089156946
	                    },
	                    "No Users"
	                )
	            );
	        };
	        _this.rowGetter = function (_a) {
	            var index = _a.index;
	            var row = _this.props.rows[index];
	            if (!row) {
	                return {};
	            }
	            return Object.keys(row).reduce(function (prev, current) {
	                prev[current] = _this.textToString(row[current]);
	                return prev;
	            }, {});
	        };
	        // private cellRenderer = ({key, style, columnIndex, rowIndex}) => {
	        //   const field = this.props.fields[columnIndex]
	        //   const {selectedRow} = this.state
	        //   return (
	        //     <div
	        //       key={key}
	        //       style={style}
	        //       className={`cell ${selectedRow === rowIndex ? 'selected' : ''}`}
	        //       onClick={() => this.selectRow(rowIndex)}
	        //     >
	        //       <style jsx>{`
	        //         .cell {
	        //           @inherit: .bbox, .pv16, .ph25, .f16;
	        //           &.selected {
	        //             @inherit: .bgBlue, .white;
	        //           }
	        //         }
	        //       `}</style>
	        //       {this.textToString(this.props.rows[rowIndex][field])}
	        //     </div>
	        //   )
	        // }
	        // private selectRow(rowIndex: number) {
	        //   this.setState({selectedRow: rowIndex} as State)
	        // }
	        _this.isRowLoaded = function (_a) {
	            var index = _a.index;
	            var loaded = Boolean(_this.props.rows[index]);
	            return loaded;
	        };
	        _this.state = {
	            height: 400,
	            rowHeight: 54,
	            overscanRowCount: 20,
	            selectedRow: -1
	        };
	        global['t'] = _this;
	        return _this;
	    }
	    TableComponent.prototype.render = function () {
	        var _this = this;
	        var _a = this.props,
	            rowCount = _a.rowCount,
	            fields = _a.fields;
	        var _b = this.state,
	            height = _b.height,
	            rowHeight = _b.rowHeight,
	            overscanRowCount = _b.overscanRowCount;
	        return React.createElement(
	            "div",
	            { className: "popup-table", "data-jsx": 1270549037
	            },
	            React.createElement(_style2.default, {
	                styleId: 1270549037,
	                css: "\n          .popup-table {\n            padding-top: 30px;\n          }\n          .popup-table .table-row:focus {\n            outline: none;\n}\n          .ReactVirtualized__Table__Grid {\n            box-shadow: 0 1px 4px rgba(0, 0, 0, .1);\n          }\n          .bgBlack02,\n.popup-table {\n            background-color: rgba(0,0,0,.02);\n}\n          .w100,\n.popup-table {\n            width: 100%;\n}\n          .overflowXScroll,\n.popup-table {\n            overflow-x: scroll;\n}\n          .flex,\n.popup-table .table-row {\n            display: -ms-flexbox;\n            display: flex;\n}\n          .pointer:hover,\n.popup-table .table-row:hover {\n            cursor: pointer;\n}\n          .bgBlue,\n.popup-table .table-row.selected {\n            background-color: #2a7ed2;\n}\n          .white,\n.popup-table .table-row.selected {\n            color: #fff;\n}\n          .bgWhite,\n.ReactVirtualized__Table__Grid {\n            background-color: #fff;\n}\n          .fw6,\n.table-header {\n            font-weight: 600;\n}\n          .ph25,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            padding-left: 25px;\n            padding-right: 25px;\n}\n          .pv16,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            padding-top: 16px;\n            padding-bottom: 16px;\n}\n          .bbox,\n.ReactVirtualized__Table__headerColumn {\n            box-sizing: border-box;\n}\n          .overflowHidden,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            overflow: hidden;\n}\n          .toe,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            text-overflow: ellipsis;\n}\n          .black60,\n.ReactVirtualized__Table__headerColumn {\n            color: rgba(0,0,0,.6);\n}\n          .overflowHidden,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            overflow: hidden;\n}\n          .ph25,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            padding-left: 25px;\n            padding-right: 25px;\n}\n          .pv16,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            padding-top: 16px;\n            padding-bottom: 16px;\n}\n          .toe,\n.ReactVirtualized__Table__headerColumn,\n.ReactVirtualized__Table__rowColumn {\n            text-overflow: ellipsis;\n}\n          .br,\n.ReactVirtualized__Table__rowColumn {\n            border-right-style: solid;\n            border-right-width: 1px;\n}\n          .bb,\n.ReactVirtualized__Table__rowColumn {\n            border-bottom-style: solid;\n            border-bottom-width: 1px;\n}\n          .bBlack10,\n.ReactVirtualized__Table__rowColumn {\n            border-color: rgba(0,0,0,.1);\n}\n          .nowrap,\n.ReactVirtualized__Table__rowColumn {\n            white-space: nowrap;\n}\n        "
	            }),
	            React.createElement(
	                react_virtualized_1.InfiniteLoader,
	                { isRowLoaded: this.isRowLoaded, loadMoreRows: this.props.loadMoreRows, rowCount: rowCount },
	                function (_a) {
	                    var onRowsRendered = _a.onRowsRendered,
	                        registerChild = _a.registerChild;
	                    return React.createElement(
	                        react_virtualized_1.Table,
	                        { headerHeight: 54, height: height, noRowsRenderer: _this.noRowsRenderer, overscanRowCount: overscanRowCount, rowHeight: rowHeight, rowCount: rowCount, rowGetter: _this.rowGetter, headerClassName: "table-header", ref: registerChild, width: fields.map(function (field) {
	                                return field.width;
	                            }).reduce(function (acc, value) {
	                                return acc + value;
	                            }, 0), onRowsRendered: onRowsRendered, onRowClick: _this.props.onRowSelection, rowClassName: _this.rowClassName, scrollToIndex: _this.props.scrollToIndex },
	                        fields.map(function (field) {
	                            return React.createElement(react_virtualized_1.Column, { key: field.name, label: field.name, dataKey: field.name, width: field.width });
	                        })
	                    );
	                }
	            )
	        );
	    };
	    TableComponent.prototype.textToString = function (value) {
	        if (value instanceof Date) {
	            return pZ(value.getMonth() + 1) + "/" + pZ(value.getDate()) + "/" + value.getFullYear().toString().slice(2, 4) + " " + (value.getHours() + ":" + pZ(value.getMinutes()) + ":" + pZ(value.getSeconds()));
	        }
	        return String(value);
	    };
	    return TableComponent;
	}(React.Component);
	exports.default = TableComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 591 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.onboardingQuery1 = "{\n  allPosts {\n    imageUrl\n    # description\n  }\n}";
	exports.onboardingQuery1Check = "{allPosts{imageUrldescription}}";
	exports.onboardingEmptyMutation = "mutation {\n  createPost(\n    imageUrl: \"\"\n    description: \"\"\n  ) {\n    id\n  }\n}";
	exports.onboardingFilledMutation1 = "mutation {\n  createPost(\n    imageUrl: \"http://bit.ly/2pLtEdd\"\n    description: \"Cat\"\n  ) {\n    id\n  }\n}";
	exports.onboardingFilledMutation2 = "mutation {\n  createPost(\n    imageUrl: \"http://bit.ly/2pLDBrf\"\n    description: \"Another Cat\"\n  ) {\n    id\n  }\n}";

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _Argument = __webpack_require__(154);
	
	var _Argument2 = _interopRequireDefault(_Argument);
	
	var _MarkdownContent = __webpack_require__(155);
	
	var _MarkdownContent2 = _interopRequireDefault(_MarkdownContent);
	
	var _TypeLink = __webpack_require__(77);
	
	var _TypeLink2 = _interopRequireDefault(_TypeLink);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var FieldDoc = function (_React$Component) {
	  _inherits(FieldDoc, _React$Component);
	
	  function FieldDoc() {
	    _classCallCheck(this, FieldDoc);
	
	    return _possibleConstructorReturn(this, (FieldDoc.__proto__ || Object.getPrototypeOf(FieldDoc)).apply(this, arguments));
	  }
	
	  _createClass(FieldDoc, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps) {
	      return this.props.field !== nextProps.field;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var field = this.props.field;
	
	      var argsDef = void 0;
	      if (field.args && field.args.length > 0) {
	        argsDef = _react2.default.createElement(
	          'div',
	          { className: 'doc-category' },
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category-title' },
	            'arguments'
	          ),
	          field.args.map(function (arg) {
	            return _react2.default.createElement(
	              'div',
	              { key: arg.name, className: 'doc-category-item' },
	              _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(_Argument2.default, { arg: arg, onClickType: _this2.props.onClickType })
	              ),
	              _react2.default.createElement(_MarkdownContent2.default, {
	                className: 'doc-value-description',
	                markdown: arg.description
	              })
	            );
	          })
	        );
	      }
	
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(_MarkdownContent2.default, {
	          className: 'doc-type-description',
	          markdown: field.description || 'No Description'
	        }),
	        field.deprecationReason && _react2.default.createElement(_MarkdownContent2.default, {
	          className: 'doc-deprecation',
	          markdown: field.deprecationReason
	        }),
	        _react2.default.createElement(
	          'div',
	          { className: 'doc-category' },
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category-title' },
	            'type'
	          ),
	          _react2.default.createElement(_TypeLink2.default, { type: field.type, onClick: this.props.onClickType })
	        ),
	        argsDef
	      );
	    }
	  }]);
	
	  return FieldDoc;
	}(_react2.default.Component);
	
	FieldDoc.propTypes = {
	  field: _propTypes2.default.object,
	  onClickType: _propTypes2.default.func
	};
	exports.default = FieldDoc;

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _Argument = __webpack_require__(154);
	
	var _Argument2 = _interopRequireDefault(_Argument);
	
	var _TypeLink = __webpack_require__(77);
	
	var _TypeLink2 = _interopRequireDefault(_TypeLink);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var SearchResults = function (_React$Component) {
	  _inherits(SearchResults, _React$Component);
	
	  function SearchResults() {
	    _classCallCheck(this, SearchResults);
	
	    return _possibleConstructorReturn(this, (SearchResults.__proto__ || Object.getPrototypeOf(SearchResults)).apply(this, arguments));
	  }
	
	  _createClass(SearchResults, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps) {
	      return this.props.schema !== nextProps.schema || this.props.searchValue !== nextProps.searchValue;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var searchValue = this.props.searchValue;
	      var withinType = this.props.withinType;
	      var schema = this.props.schema;
	      var onClickType = this.props.onClickType;
	      var onClickField = this.props.onClickField;
	
	      var matchedWithin = [];
	      var matchedTypes = [];
	      var matchedFields = [];
	
	      var typeMap = schema.getTypeMap();
	      var typeNames = Object.keys(typeMap);
	
	      // Move the within type name to be the first searched.
	      if (withinType) {
	        typeNames = typeNames.filter(function (n) {
	          return n !== withinType.name;
	        });
	        typeNames.unshift(withinType.name);
	      }
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var typeName = _step.value;
	
	          if (matchedWithin.length + matchedTypes.length + matchedFields.length >= 100) {
	            return 'break';
	          }
	
	          var type = typeMap[typeName];
	          if (withinType !== type && isMatch(typeName, searchValue)) {
	            matchedTypes.push(_react2.default.createElement(
	              'div',
	              { className: 'doc-category-item', key: typeName },
	              _react2.default.createElement(_TypeLink2.default, { type: type, onClick: onClickType })
	            ));
	          }
	
	          if (type.getFields) {
	            var fields = type.getFields();
	            Object.keys(fields).forEach(function (fieldName) {
	              var field = fields[fieldName];
	              var matchingArgs = void 0;
	
	              if (!isMatch(fieldName, searchValue)) {
	                if (field.args && field.args.length) {
	                  matchingArgs = field.args.filter(function (arg) {
	                    return isMatch(arg.name, searchValue);
	                  });
	                  if (matchingArgs.length === 0) {
	                    return;
	                  }
	                } else {
	                  return;
	                }
	              }
	
	              var match = _react2.default.createElement(
	                'div',
	                { className: 'doc-category-item', key: typeName + '.' + fieldName },
	                withinType !== type && [_react2.default.createElement(_TypeLink2.default, { key: 'type', type: type, onClick: onClickType }), '.'],
	                _react2.default.createElement(
	                  'a',
	                  {
	                    className: 'field-name',
	                    onClick: function onClick(event) {
	                      return onClickField(field, type, event);
	                    } },
	                  field.name
	                ),
	                matchingArgs && ['(', _react2.default.createElement(
	                  'span',
	                  { key: 'args' },
	                  matchingArgs.map(function (arg) {
	                    return _react2.default.createElement(_Argument2.default, {
	                      key: arg.name,
	                      arg: arg,
	                      onClickType: onClickType,
	                      showDefaultValue: false
	                    });
	                  })
	                ), ')']
	              );
	
	              if (withinType === type) {
	                matchedWithin.push(match);
	              } else {
	                matchedFields.push(match);
	              }
	            });
	          }
	        };
	
	        for (var _iterator = typeNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var _ret = _loop();
	
	          if (_ret === 'break') break;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      if (matchedWithin.length + matchedTypes.length + matchedFields.length === 0) {
	        return _react2.default.createElement(
	          'span',
	          { className: 'doc-alert-text' },
	          'No results found.'
	        );
	      }
	
	      if (withinType && matchedTypes.length + matchedFields.length > 0) {
	        return _react2.default.createElement(
	          'div',
	          null,
	          matchedWithin,
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category' },
	            _react2.default.createElement(
	              'div',
	              { className: 'doc-category-title' },
	              'other results'
	            ),
	            matchedTypes,
	            matchedFields
	          )
	        );
	      }
	
	      return _react2.default.createElement(
	        'div',
	        null,
	        matchedWithin,
	        matchedTypes,
	        matchedFields
	      );
	    }
	  }]);
	
	  return SearchResults;
	}(_react2.default.Component);
	
	SearchResults.propTypes = {
	  schema: _propTypes2.default.object,
	  withinType: _propTypes2.default.object,
	  searchValue: _propTypes2.default.string,
	  onClickType: _propTypes2.default.func,
	  onClickField: _propTypes2.default.func
	};
	exports.default = SearchResults;
	
	
	function isMatch(sourceText, searchValue) {
	  try {
	    var escaped = searchValue.replace(/[^_0-9A-Za-z]/g, function (ch) {
	      return '\\' + ch;
	    });
	    return sourceText.search(new RegExp(escaped, 'i')) !== -1;
	  } catch (e) {
	    return sourceText.toLowerCase().indexOf(searchValue.toLowerCase()) !== -1;
	  }
	}

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _graphql = __webpack_require__(12);
	
	var _Argument = __webpack_require__(154);
	
	var _Argument2 = _interopRequireDefault(_Argument);
	
	var _MarkdownContent = __webpack_require__(155);
	
	var _MarkdownContent2 = _interopRequireDefault(_MarkdownContent);
	
	var _TypeLink = __webpack_require__(77);
	
	var _TypeLink2 = _interopRequireDefault(_TypeLink);
	
	var _DefaultValue = __webpack_require__(253);
	
	var _DefaultValue2 = _interopRequireDefault(_DefaultValue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var TypeDoc = function (_React$Component) {
	  _inherits(TypeDoc, _React$Component);
	
	  function TypeDoc(props) {
	    _classCallCheck(this, TypeDoc);
	
	    var _this = _possibleConstructorReturn(this, (TypeDoc.__proto__ || Object.getPrototypeOf(TypeDoc)).call(this, props));
	
	    _this.handleShowDeprecated = function () {
	      return _this.setState({ showDeprecated: true });
	    };
	
	    _this.state = { showDeprecated: false };
	    return _this;
	  }
	
	  _createClass(TypeDoc, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      return this.props.type !== nextProps.type || this.props.schema !== nextProps.schema || this.state.showDeprecated !== nextState.showDeprecated;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var schema = this.props.schema;
	      var type = this.props.type;
	      var onClickType = this.props.onClickType;
	      var onClickField = this.props.onClickField;
	
	      var typesTitle = void 0;
	      var types = void 0;
	      if (type instanceof _graphql.GraphQLUnionType) {
	        typesTitle = 'possible types';
	        types = schema.getPossibleTypes(type);
	      } else if (type instanceof _graphql.GraphQLInterfaceType) {
	        typesTitle = 'implementations';
	        types = schema.getPossibleTypes(type);
	      } else if (type instanceof _graphql.GraphQLObjectType) {
	        typesTitle = 'implements';
	        types = type.getInterfaces();
	      }
	
	      var typesDef = void 0;
	      if (types && types.length > 0) {
	        typesDef = _react2.default.createElement(
	          'div',
	          { className: 'doc-category' },
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category-title' },
	            typesTitle
	          ),
	          types.map(function (subtype) {
	            return _react2.default.createElement(
	              'div',
	              { key: subtype.name, className: 'doc-category-item' },
	              _react2.default.createElement(_TypeLink2.default, { type: subtype, onClick: onClickType })
	            );
	          })
	        );
	      }
	
	      // InputObject and Object
	      var fieldsDef = void 0;
	      var deprecatedFieldsDef = void 0;
	      if (type.getFields) {
	        var fieldMap = type.getFields();
	        var fields = Object.keys(fieldMap).map(function (name) {
	          return fieldMap[name];
	        });
	        fieldsDef = _react2.default.createElement(
	          'div',
	          { className: 'doc-category' },
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category-title' },
	            'fields'
	          ),
	          fields.filter(function (field) {
	            return !field.isDeprecated;
	          }).map(function (field) {
	            return _react2.default.createElement(Field, {
	              key: field.name,
	              type: type,
	              field: field,
	              onClickType: onClickType,
	              onClickField: onClickField
	            });
	          })
	        );
	
	        var deprecatedFields = fields.filter(function (field) {
	          return field.isDeprecated;
	        });
	        if (deprecatedFields.length > 0) {
	          deprecatedFieldsDef = _react2.default.createElement(
	            'div',
	            { className: 'doc-category' },
	            _react2.default.createElement(
	              'div',
	              { className: 'doc-category-title' },
	              'deprecated fields'
	            ),
	            !this.state.showDeprecated ? _react2.default.createElement(
	              'button',
	              {
	                className: 'show-btn',
	                onClick: this.handleShowDeprecated },
	              'Show deprecated fields...'
	            ) : deprecatedFields.map(function (field) {
	              return _react2.default.createElement(Field, {
	                key: field.name,
	                type: type,
	                field: field,
	                onClickType: onClickType,
	                onClickField: onClickField
	              });
	            })
	          );
	        }
	      }
	
	      var valuesDef = void 0;
	      var deprecatedValuesDef = void 0;
	      if (type instanceof _graphql.GraphQLEnumType) {
	        var values = type.getValues();
	        valuesDef = _react2.default.createElement(
	          'div',
	          { className: 'doc-category' },
	          _react2.default.createElement(
	            'div',
	            { className: 'doc-category-title' },
	            'values'
	          ),
	          values.filter(function (value) {
	            return !value.isDeprecated;
	          }).map(function (value) {
	            return _react2.default.createElement(EnumValue, { key: value.name, value: value });
	          })
	        );
	
	        var deprecatedValues = values.filter(function (value) {
	          return value.isDeprecated;
	        });
	        if (deprecatedValues.length > 0) {
	          deprecatedValuesDef = _react2.default.createElement(
	            'div',
	            { className: 'doc-category' },
	            _react2.default.createElement(
	              'div',
	              { className: 'doc-category-title' },
	              'deprecated values'
	            ),
	            !this.state.showDeprecated ? _react2.default.createElement(
	              'button',
	              {
	                className: 'show-btn',
	                onClick: this.handleShowDeprecated },
	              'Show deprecated values...'
	            ) : deprecatedValues.map(function (value) {
	              return _react2.default.createElement(EnumValue, { key: value.name, value: value });
	            })
	          );
	        }
	      }
	
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(_MarkdownContent2.default, {
	          className: 'doc-type-description',
	          markdown: type.description || 'No Description'
	        }),
	        type instanceof _graphql.GraphQLObjectType && typesDef,
	        fieldsDef,
	        deprecatedFieldsDef,
	        valuesDef,
	        deprecatedValuesDef,
	        !(type instanceof _graphql.GraphQLObjectType) && typesDef
	      );
	    }
	  }]);
	
	  return TypeDoc;
	}(_react2.default.Component);
	
	TypeDoc.propTypes = {
	  schema: _propTypes2.default.instanceOf(_graphql.GraphQLSchema),
	  type: _propTypes2.default.object,
	  onClickType: _propTypes2.default.func,
	  onClickField: _propTypes2.default.func
	};
	exports.default = TypeDoc;
	
	
	function Field(_ref) {
	  var type = _ref.type,
	      field = _ref.field,
	      onClickType = _ref.onClickType,
	      onClickField = _ref.onClickField;
	
	  return _react2.default.createElement(
	    'div',
	    { className: 'doc-category-item' },
	    _react2.default.createElement(
	      'a',
	      {
	        className: 'field-name',
	        onClick: function onClick(event) {
	          return onClickField(field, type, event);
	        } },
	      field.name
	    ),
	    field.args && field.args.length > 0 && ['(', _react2.default.createElement(
	      'span',
	      { key: 'args' },
	      field.args.map(function (arg) {
	        return _react2.default.createElement(_Argument2.default, { key: arg.name, arg: arg, onClickType: onClickType });
	      })
	    ), ')'],
	    ': ',
	    _react2.default.createElement(_TypeLink2.default, { type: field.type, onClick: onClickType }),
	    _react2.default.createElement(_DefaultValue2.default, { field: field }),
	    field.description && _react2.default.createElement(
	      'p',
	      { className: 'field-short-description' },
	      field.description
	    ),
	    field.deprecationReason && _react2.default.createElement(_MarkdownContent2.default, {
	      className: 'doc-deprecation',
	      markdown: field.deprecationReason
	    })
	  );
	}
	
	Field.propTypes = {
	  type: _propTypes2.default.object,
	  field: _propTypes2.default.object,
	  onClickType: _propTypes2.default.func,
	  onClickField: _propTypes2.default.func
	};
	
	function EnumValue(_ref2) {
	  var value = _ref2.value;
	
	  return _react2.default.createElement(
	    'div',
	    { className: 'doc-category-item' },
	    _react2.default.createElement(
	      'div',
	      { className: 'enum-value' },
	      value.name
	    ),
	    _react2.default.createElement(_MarkdownContent2.default, {
	      className: 'doc-value-description',
	      markdown: value.description
	    }),
	    value.deprecationReason && _react2.default.createElement(_MarkdownContent2.default, {
	      className: 'doc-deprecation',
	      markdown: value.deprecationReason
	    })
	  );
	}
	
	EnumValue.propTypes = {
	  value: _propTypes2.default.object
	};

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ToolbarButton = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/**
	 * ToolbarButton
	 *
	 * A button to use within the Toolbar.
	 */
	var ToolbarButton = exports.ToolbarButton = function (_React$Component) {
	  _inherits(ToolbarButton, _React$Component);
	
	  function ToolbarButton(props) {
	    _classCallCheck(this, ToolbarButton);
	
	    var _this = _possibleConstructorReturn(this, (ToolbarButton.__proto__ || Object.getPrototypeOf(ToolbarButton)).call(this, props));
	
	    _this.handleClick = function (e) {
	      e.preventDefault();
	      try {
	        _this.props.onClick();
	        _this.setState({ error: null });
	      } catch (error) {
	        _this.setState({ error: error });
	      }
	    };
	
	    _this.state = { error: null };
	    return _this;
	  }
	
	  _createClass(ToolbarButton, [{
	    key: 'render',
	    value: function render() {
	      var error = this.state.error;
	
	      return _react2.default.createElement(
	        'a',
	        {
	          className: 'toolbar-button' + (error ? ' error' : ''),
	          onMouseDown: preventDefault,
	          onClick: this.handleClick,
	          title: error ? error.message : this.props.title },
	        this.props.label
	      );
	    }
	  }]);
	
	  return ToolbarButton;
	}(_react2.default.Component);
	
	ToolbarButton.propTypes = {
	  onClick: _propTypes2.default.func,
	  title: _propTypes2.default.string,
	  label: _propTypes2.default.string
	};
	
	
	function preventDefault(e) {
	  e.preventDefault();
	}

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.VariableEditor = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _onHasCompletion = __webpack_require__(254);
	
	var _onHasCompletion2 = _interopRequireDefault(_onHasCompletion);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/**
	 * VariableEditor
	 *
	 * An instance of CodeMirror for editing variables defined in QueryEditor.
	 *
	 * Props:
	 *
	 *   - variableToType: A mapping of variable name to GraphQLType.
	 *   - value: The text of the editor.
	 *   - onEdit: A function called when the editor changes, given the edited text.
	 *   - readOnly: Turns the editor to read-only mode.
	 *
	 */
	var VariableEditor = exports.VariableEditor = function (_React$Component) {
	  _inherits(VariableEditor, _React$Component);
	
	  function VariableEditor(props) {
	    _classCallCheck(this, VariableEditor);
	
	    // Keep a cached version of the value, this cache will be updated when the
	    // editor is updated, which can later be used to protect the editor from
	    // unnecessary updates during the update lifecycle.
	    var _this = _possibleConstructorReturn(this, (VariableEditor.__proto__ || Object.getPrototypeOf(VariableEditor)).call(this));
	
	    _this._onKeyUp = function (cm, event) {
	      var code = event.keyCode;
	      if (code >= 65 && code <= 90 || // letters
	      !event.shiftKey && code >= 48 && code <= 57 || // numbers
	      event.shiftKey && code === 189 || // underscore
	      event.shiftKey && code === 222 // "
	      ) {
	          _this.editor.execCommand('autocomplete');
	        }
	    };
	
	    _this._onEdit = function () {
	      if (!_this.ignoreChangeEvent) {
	        _this.cachedValue = _this.editor.getValue();
	        if (_this.props.onEdit) {
	          _this.props.onEdit(_this.cachedValue);
	        }
	      }
	    };
	
	    _this._onHasCompletion = function (cm, data) {
	      (0, _onHasCompletion2.default)(cm, data, _this.props.onHintInformationRender);
	    };
	
	    _this.cachedValue = props.value || '';
	    return _this;
	  }
	
	  _createClass(VariableEditor, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      // Lazily require to ensure requiring GraphiQL outside of a Browser context
	      // does not produce an error.
	      var CodeMirror = __webpack_require__(5);
	      __webpack_require__(214);
	      __webpack_require__(127);
	      __webpack_require__(213);
	      __webpack_require__(128);
	      __webpack_require__(129);
	      __webpack_require__(215);
	      __webpack_require__(130);
	      __webpack_require__(405);
	      __webpack_require__(91);
	      __webpack_require__(131);
	      __webpack_require__(399);
	      __webpack_require__(400);
	      __webpack_require__(401);
	
	      this.editor = CodeMirror(this._node, {
	        value: this.props.value || '',
	        lineNumbers: true,
	        tabSize: 2,
	        mode: 'graphql-variables',
	        theme: this.props.editorTheme || 'graphiql',
	        keyMap: 'sublime',
	        autoCloseBrackets: true,
	        matchBrackets: true,
	        showCursorWhenSelecting: true,
	        readOnly: this.props.readOnly ? 'nocursor' : false,
	        foldGutter: {
	          minFoldSize: 4
	        },
	        lint: {
	          variableToType: this.props.variableToType
	        },
	        hintOptions: {
	          variableToType: this.props.variableToType
	        },
	        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],
	        extraKeys: {
	          'Cmd-Space': function CmdSpace() {
	            return _this2.editor.showHint({ completeSingle: false });
	          },
	          'Ctrl-Space': function CtrlSpace() {
	            return _this2.editor.showHint({ completeSingle: false });
	          },
	          'Alt-Space': function AltSpace() {
	            return _this2.editor.showHint({ completeSingle: false });
	          },
	          'Shift-Space': function ShiftSpace() {
	            return _this2.editor.showHint({ completeSingle: false });
	          },
	
	          'Cmd-Enter': function CmdEnter() {
	            if (_this2.props.onRunQuery) {
	              _this2.props.onRunQuery();
	            }
	          },
	          'Ctrl-Enter': function CtrlEnter() {
	            if (_this2.props.onRunQuery) {
	              _this2.props.onRunQuery();
	            }
	          },
	
	          'Shift-Ctrl-P': function ShiftCtrlP() {
	            if (_this2.props.onPrettifyQuery) {
	              _this2.props.onPrettifyQuery();
	            }
	          },
	
	          // Persistent search box in Query Editor
	          'Cmd-F': 'findPersistent',
	          'Ctrl-F': 'findPersistent',
	
	          // Editor improvements
	          'Ctrl-Left': 'goSubwordLeft',
	          'Ctrl-Right': 'goSubwordRight',
	          'Alt-Left': 'goGroupLeft',
	          'Alt-Right': 'goGroupRight'
	        }
	      });
	
	      this.editor.on('change', this._onEdit);
	      this.editor.on('keyup', this._onKeyUp);
	      this.editor.on('hasCompletion', this._onHasCompletion);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps) {
	      var CodeMirror = __webpack_require__(5);
	
	      // Ensure the changes caused by this update are not interpretted as
	      // user-input changes which could otherwise result in an infinite
	      // event loop.
	      this.ignoreChangeEvent = true;
	      if (this.props.variableToType !== prevProps.variableToType) {
	        this.editor.options.lint.variableToType = this.props.variableToType;
	        this.editor.options.hintOptions.variableToType = this.props.variableToType;
	        CodeMirror.signal(this.editor, 'change', this.editor);
	      }
	      if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
	        this.cachedValue = this.props.value;
	        this.editor.setValue(this.props.value);
	      }
	      this.ignoreChangeEvent = false;
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.editor.off('change', this._onEdit);
	      this.editor.off('keyup', this._onKeyUp);
	      this.editor.off('hasCompletion', this._onHasCompletion);
	      this.editor = null;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this3 = this;
	
	      return _react2.default.createElement('div', {
	        className: 'codemirrorWrap',
	        ref: function ref(node) {
	          _this3._node = node;
	        }
	      });
	    }
	
	    /**
	     * Public API for retrieving the CodeMirror instance from this
	     * React component.
	     */
	
	  }, {
	    key: 'getCodeMirror',
	    value: function getCodeMirror() {
	      return this.editor;
	    }
	
	    /**
	     * Public API for retrieving the DOM client height for this component.
	     */
	
	  }, {
	    key: 'getClientHeight',
	    value: function getClientHeight() {
	      return this._node && this._node.clientHeight;
	    }
	  }]);
	
	  return VariableEditor;
	}(_react2.default.Component);
	
	VariableEditor.propTypes = {
	  variableToType: _propTypes2.default.object,
	  value: _propTypes2.default.string,
	  onEdit: _propTypes2.default.func,
	  readOnly: _propTypes2.default.bool,
	  onHintInformationRender: _propTypes2.default.func,
	  onPrettifyQuery: _propTypes2.default.func,
	  onRunQuery: _propTypes2.default.func,
	  editorTheme: _propTypes2.default.string
	};

/***/ }),
/* 597 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	/**
	 * When a containing DOM node's height has been altered, trigger a resize of
	 * the related CodeMirror instance so that it is always correctly sized.
	 */
	var CodeMirrorSizer = function () {
	  function CodeMirrorSizer() {
	    _classCallCheck(this, CodeMirrorSizer);
	
	    this.sizes = [];
	  }
	
	  _createClass(CodeMirrorSizer, [{
	    key: "updateSizes",
	    value: function updateSizes(components) {
	      var _this = this;
	
	      components.forEach(function (component, i) {
	        var size = component.getClientHeight();
	        if (i <= _this.sizes.length && size !== _this.sizes[i]) {
	          component.getCodeMirror().setSize();
	        }
	        _this.sizes[i] = size;
	      });
	    }
	  }]);
	
	  return CodeMirrorSizer;
	}();
	
	exports.default = CodeMirrorSizer;

/***/ }),
/* 598 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getLeft = getLeft;
	exports.getTop = getTop;
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	/**
	 * Utility functions to get a pixel distance from left/top of the window.
	 */
	
	function getLeft(initialElem) {
	  var pt = 0;
	  var elem = initialElem;
	  while (elem.offsetParent) {
	    pt += elem.offsetLeft;
	    elem = elem.offsetParent;
	  }
	  return pt;
	}
	
	function getTop(initialElem) {
	  var pt = 0;
	  var elem = initialElem;
	  while (elem.offsetParent) {
	    pt += elem.offsetTop;
	    elem = elem.offsetParent;
	  }
	  return pt;
	}

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fillLeafs = fillLeafs;
	
	var _graphql = __webpack_require__(12);
	
	/**
	 * Given a document string which may not be valid due to terminal fields not
	 * representing leaf values (Spec Section: "Leaf Field Selections"), and a
	 * function which provides reasonable default field names for a given type,
	 * this function will attempt to produce a schema which is valid after filling
	 * in selection sets for the invalid fields.
	 *
	 * Note that there is no guarantee that the result will be a valid query, this
	 * utility represents a "best effort" which may be useful within IDE tools.
	 */
	function fillLeafs(schema, docString, getDefaultFieldNames) {
	  var insertions = [];
	
	  if (!schema) {
	    return { insertions: insertions, result: docString };
	  }
	
	  var ast = void 0;
	  try {
	    ast = (0, _graphql.parse)(docString);
	  } catch (error) {
	    return { insertions: insertions, result: docString };
	  }
	
	  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;
	  var typeInfo = new _graphql.TypeInfo(schema);
	  (0, _graphql.visit)(ast, {
	    leave: function leave(node) {
	      typeInfo.leave(node);
	    },
	    enter: function enter(node) {
	      typeInfo.enter(node);
	      if (node.kind === 'Field' && !node.selectionSet) {
	        var fieldType = typeInfo.getType();
	        var selectionSet = buildSelectionSet(fieldType, fieldNameFn);
	        if (selectionSet) {
	          var indent = getIndentation(docString, node.loc.start);
	          insertions.push({
	            index: node.loc.end,
	            string: ' ' + (0, _graphql.print)(selectionSet).replace(/\n/g, '\n' + indent)
	          });
	        }
	      }
	    }
	  });
	
	  // Apply the insertions, but also return the insertions metadata.
	  return {
	    insertions: insertions,
	    result: withInsertions(docString, insertions)
	  };
	}
	
	// The default function to use for producing the default fields from a type.
	// This function first looks for some common patterns, and falls back to
	// including all leaf-type fields.
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	function defaultGetDefaultFieldNames(type) {
	  // If this type cannot access fields, then return an empty set.
	  if (!type.getFields) {
	    return [];
	  }
	
	  var fields = type.getFields();
	
	  // Is there an `id` field?
	  if (fields['id']) {
	    return ['id'];
	  }
	
	  // Is there an `edges` field?
	  if (fields['edges']) {
	    return ['edges'];
	  }
	
	  // Is there an `node` field?
	  if (fields['node']) {
	    return ['node'];
	  }
	
	  // Include all leaf-type fields.
	  var leafFieldNames = [];
	  Object.keys(fields).forEach(function (fieldName) {
	    if ((0, _graphql.isLeafType)(fields[fieldName].type)) {
	      leafFieldNames.push(fieldName);
	    }
	  });
	  return leafFieldNames;
	}
	
	// Given a GraphQL type, and a function which produces field names, recursively
	// generate a SelectionSet which includes default fields.
	function buildSelectionSet(type, getDefaultFieldNames) {
	  // Unwrap any non-null or list types.
	  var namedType = (0, _graphql.getNamedType)(type);
	
	  // Unknown types and leaf types do not have selection sets.
	  if (!type || (0, _graphql.isLeafType)(type)) {
	    return;
	  }
	
	  // Get an array of field names to use.
	  var fieldNames = getDefaultFieldNames(namedType);
	
	  // If there are no field names to use, return no selection set.
	  if (!Array.isArray(fieldNames) || fieldNames.length === 0) {
	    return;
	  }
	
	  // Build a selection set of each field, calling buildSelectionSet recursively.
	  return {
	    kind: 'SelectionSet',
	    selections: fieldNames.map(function (fieldName) {
	      var fieldDef = namedType.getFields()[fieldName];
	      var fieldType = fieldDef ? fieldDef.type : null;
	      return {
	        kind: 'Field',
	        name: {
	          kind: 'Name',
	          value: fieldName
	        },
	        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)
	      };
	    })
	  };
	}
	
	// Given an initial string, and a list of "insertion" { index, string } objects,
	// return a new string with these insertions applied.
	function withInsertions(initial, insertions) {
	  if (insertions.length === 0) {
	    return initial;
	  }
	  var edited = '';
	  var prevIndex = 0;
	  insertions.forEach(function (_ref) {
	    var index = _ref.index,
	        string = _ref.string;
	
	    edited += initial.slice(prevIndex, index) + string;
	    prevIndex = index;
	  });
	  edited += initial.slice(prevIndex);
	  return edited;
	}
	
	// Given a string and an index, look backwards to find the string of whitespace
	// following the next previous line break.
	function getIndentation(str, index) {
	  var indentStart = index;
	  var indentEnd = index;
	  while (indentStart) {
	    var c = str.charCodeAt(indentStart - 1);
	    // line break
	    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {
	      break;
	    }
	    indentStart--;
	    // not white space
	    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {
	      indentEnd = indentStart;
	    }
	  }
	  return str.substring(indentStart, indentEnd);
	}

/***/ }),
/* 600 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = find;
	
	/* eslint-disable no-undef */
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	function find(list, predicate) {
	  for (var i = 0; i < list.length; i++) {
	    if (predicate(list[i])) {
	      return list[i];
	    }
	  }
	}

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getQueryFacts;
	exports.collectVariables = collectVariables;
	
	var _graphql = __webpack_require__(12);
	
	/**
	 * Provided previous "queryFacts", a GraphQL schema, and a query document
	 * string, return a set of facts about that query useful for GraphiQL features.
	 *
	 * If the query cannot be parsed, returns undefined.
	 */
	function getQueryFacts(schema, documentStr) {
	  if (!documentStr) {
	    return;
	  }
	
	  var documentAST = void 0;
	  try {
	    documentAST = (0, _graphql.parse)(documentStr);
	  } catch (e) {
	    return;
	  }
	
	  var variableToType = schema ? collectVariables(schema, documentAST) : null;
	
	  // Collect operations by their names.
	  var operations = [];
	  documentAST.definitions.forEach(function (def) {
	    if (def.kind === 'OperationDefinition') {
	      operations.push(def);
	    }
	  });
	
	  return { variableToType: variableToType, operations: operations };
	}
	
	/**
	 * Provided a schema and a document, produces a `variableToType` Object.
	 */
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	function collectVariables(schema, documentAST) {
	  var variableToType = Object.create(null);
	  documentAST.definitions.forEach(function (definition) {
	    if (definition.kind === 'OperationDefinition') {
	      var variableDefinitions = definition.variableDefinitions;
	      if (variableDefinitions) {
	        variableDefinitions.forEach(function (_ref) {
	          var variable = _ref.variable,
	              type = _ref.type;
	
	          var inputType = (0, _graphql.typeFromAST)(schema, type);
	          if (inputType) {
	            variableToType[variable.name.value] = inputType;
	          }
	        });
	      }
	    }
	  });
	  return variableToType;
	}

/***/ }),
/* 602 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getSelectedOperationName;
	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 */
	
	/**
	 * Provided optional previous operations and selected name, and a next list of
	 * operations, determine what the next selected operation should be.
	 */
	function getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {
	  // If there are not enough operations to bother with, return nothing.
	  if (!operations || operations.length < 1) {
	    return;
	  }
	
	  // If a previous selection still exists, continue to use it.
	  var names = operations.map(function (op) {
	    return op.name && op.name.value;
	  });
	  if (prevSelectedOperationName && names.indexOf(prevSelectedOperationName) !== -1) {
	    return prevSelectedOperationName;
	  }
	
	  // If a previous selection was the Nth operation, use the same Nth.
	  if (prevSelectedOperationName && prevOperations) {
	    var prevNames = prevOperations.map(function (op) {
	      return op.name && op.name.value;
	    });
	    var prevIndex = prevNames.indexOf(prevSelectedOperationName);
	    if (prevIndex !== -1 && prevIndex < names.length) {
	      return names[prevIndex];
	    }
	  }
	
	  // Use the first operation.
	  return names[0];
	}

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _graphql = __webpack_require__(12);
	
	Object.defineProperty(exports, 'introspectionQuery', {
	  enumerable: true,
	  get: function get() {
	    return _graphql.introspectionQuery;
	  }
	});
	
	
	// Some GraphQL services do not support subscriptions and fail an introspection
	// query which includes the `subscriptionType` field as the stock introspection
	// query does. This backup query removes that field.
	var introspectionQuerySansSubscriptions = exports.introspectionQuerySansSubscriptions = '\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n';

/***/ }),
/* 604 */
/***/ (function(module, exports) {

	/**
	 *  Copyright (c) Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the license found in the
	 *  LICENSE file in the root directory of this source tree.
	 *
	 *  @flow
	 */
	
	export {
	  getDefinitionState,
	  getFieldDef,
	  forEachState,
	  objectValues,
	  hintList,
	} from './autocompleteUtils';
	
	export {getAutocompleteSuggestions} from './getAutocompleteSuggestions';
	
	export {
	  LANGUAGE,
	  getDefinitionQueryResultForFragmentSpread,
	  getDefinitionQueryResultForDefinitionNode,
	} from './getDefinition';
	
	export {getDiagnostics} from './getDiagnostics';
	export {getOutline} from './getOutline';
	
	export {GraphQLLanguageService} from './GraphQLLanguageService';


/***/ }),
/* 605 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CharacterStream = function () {
	  function CharacterStream(sourceText) {
	    var _this = this;
	
	    _classCallCheck(this, CharacterStream);
	
	    this.getStartOfToken = function () {
	      return _this._start;
	    };
	
	    this.getCurrentPosition = function () {
	      return _this._pos;
	    };
	
	    this.eol = function () {
	      return _this._sourceText.length === _this._pos;
	    };
	
	    this.sol = function () {
	      return _this._pos === 0;
	    };
	
	    this.peek = function () {
	      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;
	    };
	
	    this.next = function () {
	      var char = _this._sourceText.charAt(_this._pos);
	      _this._pos++;
	      return char;
	    };
	
	    this.eat = function (pattern) {
	      var isMatched = _this._testNextCharacter(pattern);
	      if (isMatched) {
	        _this._start = _this._pos;
	        _this._pos++;
	        return _this._sourceText.charAt(_this._pos - 1);
	      }
	      return undefined;
	    };
	
	    this.eatWhile = function (match) {
	      var isMatched = _this._testNextCharacter(match);
	      var didEat = false;
	
	      // If a match, treat the total upcoming matches as one token
	      if (isMatched) {
	        didEat = isMatched;
	        _this._start = _this._pos;
	      }
	
	      while (isMatched) {
	        _this._pos++;
	        isMatched = _this._testNextCharacter(match);
	        didEat = true;
	      }
	
	      return didEat;
	    };
	
	    this.eatSpace = function () {
	      return _this.eatWhile(/[\s\u00a0]/);
	    };
	
	    this.skipToEnd = function () {
	      _this._pos = _this._sourceText.length;
	    };
	
	    this.skipTo = function (position) {
	      _this._pos = position;
	    };
	
	    this.match = function (pattern) {
	      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      var token = null;
	      var match = null;
	
	      if (typeof pattern === 'string') {
	        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');
	        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));
	        token = pattern;
	      } else if (pattern instanceof RegExp) {
	        match = _this._sourceText.slice(_this._pos).match(pattern);
	        token = match && match[0];
	      }
	
	      if (match != null) {
	        if (typeof pattern === 'string' || match instanceof Array &&
	        // String.match returns 'index' property, which flow fails to detect
	        // for some reason. The below is a workaround, but an easier solution
	        // is just checking if `match.index === 0`
	        _this._sourceText.startsWith(match[0], _this._pos)) {
	          if (consume) {
	            _this._start = _this._pos;
	            if (token && token.length) {
	              _this._pos += token.length;
	            }
	          }
	          return match;
	        }
	      }
	
	      // No match available.
	      return false;
	    };
	
	    this.backUp = function (num) {
	      _this._pos -= num;
	    };
	
	    this.column = function () {
	      return _this._pos;
	    };
	
	    this.indentation = function () {
	      var match = _this._sourceText.match(/\s*/);
	      var indent = 0;
	      if (match && match.length === 0) {
	        var whitespaces = match[0];
	        var pos = 0;
	        while (whitespaces.length > pos) {
	          if (whitespaces.charCodeAt(pos) === 9) {
	            indent += 2;
	          } else {
	            indent++;
	          }
	          pos++;
	        }
	      }
	
	      return indent;
	    };
	
	    this.current = function () {
	      return _this._sourceText.slice(_this._start, _this._pos);
	    };
	
	    this._start = 0;
	    this._pos = 0;
	    this._sourceText = sourceText;
	  }
	
	  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {
	    var character = this._sourceText.charAt(this._pos);
	    var isMatched = false;
	    if (typeof pattern === 'string') {
	      isMatched = character === pattern;
	    } else {
	      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
	    }
	    return isMatched;
	  };
	
	  return CharacterStream;
	}(); /**
	      *  Copyright (c) Facebook, Inc.
	      *  All rights reserved.
	      *
	      *  This source code is licensed under the license found in the
	      *  LICENSE file in the root directory of this source tree.
	      *
	      *  
	      */
	
	/**
	 * CharacterStream implements a stream of character tokens given a source text.
	 * The API design follows that of CodeMirror.StringStream.
	 *
	 * Required:
	 *
	 *      sourceText: (string), A raw GraphQL source text. Works best if a line
	 *        is supplied.
	 *
	 */
	
	exports.default = CharacterStream;

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
	                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.
	                                                                                                                                                                                                                                                                   *  All rights reserved.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the
	                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                                   *  
	                                                                                                                                                                                                                                                                   */
	
	/**
	 * Builds an online immutable parser, designed to be used as part of a syntax
	 * highlighting and code intelligence tools.
	 *
	 * Options:
	 *
	 *     eatWhitespace: (
	 *       stream: Stream | CodeMirror.StringStream | CharacterStream
	 *     ) => boolean
	 *       Use CodeMirror API.
	 *
	 *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.
	 *
	 *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.
	 *
	 *     editorConfig: { [name: string]: any }, Provides an editor-specific
	 *       configurations set.
	 *
	 */
	
	exports.default = onlineParser;
	
	var _Rules = __webpack_require__(257);
	
	function onlineParser() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	    eatWhitespace: function eatWhitespace(stream) {
	      return stream.eatWhile(_Rules.isIgnored);
	    },
	    lexRules: _Rules.LexRules,
	    parseRules: _Rules.ParseRules,
	    editorConfig: {}
	  };
	
	  return {
	    startState: function startState() {
	      var initialState = {
	        level: 0,
	        step: 0,
	        name: null,
	        kind: null,
	        type: null,
	        rule: null,
	        needsSeperator: false,
	        prevState: null
	      };
	      pushRule(options.parseRules, initialState, 'Document');
	      return initialState;
	    },
	    token: function token(stream, state) {
	      return getToken(stream, state, options);
	    }
	  };
	}
	
	function getToken(stream, state, options) {
	  var lexRules = options.lexRules,
	      parseRules = options.parseRules,
	      eatWhitespace = options.eatWhitespace,
	      editorConfig = options.editorConfig;
	  // Restore state after an empty-rule.
	
	  if (state.rule && state.rule.length === 0) {
	    popRule(state);
	  } else if (state.needsAdvance) {
	    state.needsAdvance = false;
	    advanceRule(state, true);
	  }
	
	  // Remember initial indentation
	  if (stream.sol()) {
	    var tabSize = editorConfig && editorConfig.tabSize || 2;
	    state.indentLevel = Math.floor(stream.indentation() / tabSize);
	  }
	
	  // Consume spaces and ignored characters
	  if (eatWhitespace(stream)) {
	    return 'ws';
	  }
	
	  // Get a matched token from the stream, using lex
	  var token = lex(lexRules, stream);
	
	  // If there's no matching token, skip ahead.
	  if (!token) {
	    stream.match(/\S+/);
	    pushRule(SpecialParseRules, state, 'Invalid');
	    return 'invalidchar';
	  }
	
	  // If the next token is a Comment, insert a Comment parsing rule.
	  if (token.kind === 'Comment') {
	    pushRule(SpecialParseRules, state, 'Comment');
	    return 'comment';
	  }
	
	  // Save state before continuing.
	  var backupState = assign({}, state);
	
	  // Handle changes in expected indentation level
	  if (token.kind === 'Punctuation') {
	    if (/^[{([]/.test(token.value)) {
	      // Push on the stack of levels one level deeper than the current level.
	      state.levels = (state.levels || []).concat(state.indentLevel + 1);
	    } else if (/^[})\]]/.test(token.value)) {
	      // Pop from the stack of levels.
	      // If the top of the stack is lower than the current level, lower the
	      // current level to match.
	      var levels = state.levels = (state.levels || []).slice(0, -1);
	      if (state.indentLevel) {
	        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
	          state.indentLevel = levels[levels.length - 1];
	        }
	      }
	    }
	  }
	
	  while (state.rule) {
	    // If this is a forking rule, determine what rule to use based on
	    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
	
	    // Seperator between list elements if necessary.
	    if (state.needsSeperator) {
	      expected = expected && expected.separator;
	    }
	
	    if (expected) {
	      // Un-wrap optional/list parseRules.
	      if (expected.ofRule) {
	        expected = expected.ofRule;
	      }
	
	      // A string represents a Rule
	      if (typeof expected === 'string') {
	        pushRule(parseRules, state, expected);
	        continue;
	      }
	
	      // Otherwise, match a Terminal.
	      if (expected.match && expected.match(token)) {
	        if (expected.update) {
	          expected.update(state, token);
	        }
	
	        // If this token was a punctuator, advance the parse rule, otherwise
	        // mark the state to be advanced before the next token. This ensures
	        // that tokens which can be appended to keep the appropriate state.
	        if (token.kind === 'Punctuation') {
	          advanceRule(state, true);
	        } else {
	          state.needsAdvance = true;
	        }
	
	        return expected.style;
	      }
	    }
	    unsuccessful(state);
	  }
	
	  // The parser does not know how to interpret this token, do not affect state.
	  assign(state, backupState);
	  pushRule(SpecialParseRules, state, 'Invalid');
	  return 'invalidchar';
	}
	
	// Utility function to assign from object to another object.
	function assign(to, from) {
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	// A special rule set for parsing comment tokens.
	var SpecialParseRules = {
	  Invalid: [],
	  Comment: []
	};
	
	// Push a new rule onto the state.
	function pushRule(rules, state, ruleKind) {
	  if (!rules[ruleKind]) {
	    throw new TypeError('Unknown rule: ' + ruleKind);
	  }
	  state.prevState = _extends({}, state);
	  state.kind = ruleKind;
	  state.name = null;
	  state.type = null;
	  state.rule = rules[ruleKind];
	  state.step = 0;
	  state.needsSeperator = false;
	}
	
	// Pop the current rule from the state.
	function popRule(state) {
	  // Check if there's anything to pop
	  if (!state.prevState) {
	    return;
	  }
	  state.kind = state.prevState.kind;
	  state.name = state.prevState.name;
	  state.type = state.prevState.type;
	  state.rule = state.prevState.rule;
	  state.step = state.prevState.step;
	  state.needsSeperator = state.prevState.needsSeperator;
	  state.prevState = state.prevState.prevState;
	}
	
	// Advance the step of the current rule.
	function advanceRule(state, successful) {
	  // If this is advancing successfully and the current state is a list, give
	  // it an opportunity to repeat itself.
	  if (isList(state)) {
	    if (state.rule && state.rule[state.step].separator) {
	      var separator = state.rule[state.step].separator;
	      state.needsSeperator = !state.needsSeperator;
	      // If the separator was optional, then give it an opportunity to repeat.
	      if (!state.needsSeperator && separator.ofRule) {
	        return;
	      }
	    }
	    // If this was a successful list parse, then allow it to repeat itself.
	    if (successful) {
	      return;
	    }
	  }
	
	  // Advance the step in the rule. If the rule is completed, pop
	  // the rule and advance the parent rule as well (recursively).
	  state.needsSeperator = false;
	  state.step++;
	
	  // While the current rule is completed.
	  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
	    popRule(state);
	
	    if (state.rule) {
	      // Do not advance a List step so it has the opportunity to repeat itself.
	      if (isList(state)) {
	        if (state.rule && state.rule[state.step].separator) {
	          state.needsSeperator = !state.needsSeperator;
	        }
	      } else {
	        state.needsSeperator = false;
	        state.step++;
	      }
	    }
	  }
	}
	
	function isList(state) {
	  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;
	}
	
	// Unwind the state after an unsuccessful match.
	function unsuccessful(state) {
	  // Fall back to the parent rule until you get to an optional or list rule or
	  // until the entire stack of rules is empty.
	  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
	    popRule(state);
	  }
	
	  // If there is still a rule, it must be an optional or list rule.
	  // Consider this rule a success so that we may move past it.
	  if (state.rule) {
	    advanceRule(state, false);
	  }
	}
	
	// Given a stream, returns a { kind, value } pair, or null.
	function lex(lexRules, stream) {
	  var kinds = Object.keys(lexRules);
	  for (var i = 0; i < kinds.length; i++) {
	    var match = stream.match(lexRules[kinds[i]]);
	    if (match && match instanceof Array) {
	      return { kind: kinds[i], value: match[0] };
	    }
	  }
	}

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getASTNodeAtPosition = getASTNodeAtPosition;
	exports.pointToOffset = pointToOffset;
	
	var _Range = __webpack_require__(258);
	
	var _graphql = __webpack_require__(12);
	
	function getASTNodeAtPosition(query, ast, point) {
	  var offset = pointToOffset(query, point);
	  var nodeContainingPosition = void 0;
	  (0, _graphql.visit)(ast, {
	    enter: function enter(node) {
	      if (node.kind !== 'Name' && // We're usually interested in their parents
	      node.loc.start <= offset && offset <= node.loc.end) {
	        nodeContainingPosition = node;
	      } else {
	        return false;
	      }
	    },
	    leave: function leave(node) {
	      if (node.loc.start <= offset && offset <= node.loc.end) {
	        return false;
	      }
	    }
	  });
	  return nodeContainingPosition;
	} /**
	   *  Copyright (c) Facebook, Inc.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the license found in the
	   *  LICENSE file in the root directory of this source tree.
	   *
	   *  
	   */
	
	function pointToOffset(text, point) {
	  var linesUntilPosition = text.split('\n').slice(0, point.line);
	  return point.character + linesUntilPosition.map(function (line) {
	    return line.length + 1;
	  } // count EOL
	  ).reduce(function (a, b) {
	    return a + b;
	  }, 0);
	}

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.validateWithCustomRules = validateWithCustomRules;
	
	var _graphql = __webpack_require__(12);
	
	/**
	 * Validate a GraphQL Document optionally with custom validation rules.
	 */
	function validateWithCustomRules(schema, ast, customRules) {
	  // Because every fragment is considered for determing model subsets that may
	  // be used anywhere in the codebase they're all technically "used" by clients
	  // of graphql-data. So we remove this rule from the validators.
	  var _require = __webpack_require__(169),
	      NoUnusedFragments = _require.NoUnusedFragments;
	
	  var rules = _graphql.specifiedRules.filter(function (rule) {
	    return rule !== NoUnusedFragments;
	  });
	
	  var typeInfo = new _graphql.TypeInfo(schema);
	  if (customRules) {
	    Array.prototype.push.apply(rules, customRules);
	  }
	
	  var errors = (0, _graphql.validate)(schema, ast, rules, typeInfo);
	
	  if (errors.length > 0) {
	    return errors;
	  }
	
	  return [];
	} /**
	   *  Copyright (c) Facebook, Inc.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the license found in the
	   *  LICENSE file in the root directory of this source tree.
	   *
	   *  
	   */

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.formatError = formatError;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Given a GraphQLError, format it according to the rules described by the
	 * Response Format, Errors section of the GraphQL Specification.
	 */
	function formatError(error) {
	  !error ? (0, _invariant2.default)(0, 'Received null or undefined error.') : void 0;
	  return {
	    message: error.message,
	    locations: error.locations,
	    path: error.path
	  };
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.syntaxError = syntaxError;
	
	var _location = __webpack_require__(165);
	
	var _GraphQLError = __webpack_require__(57);
	
	/**
	 * Produces a GraphQLError representing a syntax error, containing useful
	 * descriptive information about the syntax error's position in the source.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function syntaxError(source, position, description) {
	  var location = (0, _location.getLocation)(source, position);
	  var line = location.line + source.locationOffset.line - 1;
	  var columnOffset = getColumnOffset(source, location);
	  var column = location.column + columnOffset;
	  var error = new _GraphQLError.GraphQLError('Syntax Error ' + source.name + ' (' + line + ':' + column + ') ' + description + '\n\n' + highlightSourceAtLocation(source, location), undefined, source, [position]);
	  return error;
	}
	
	/**
	 * Render a helpful description of the location of the error in the GraphQL
	 * Source document.
	 */
	function highlightSourceAtLocation(source, location) {
	  var line = location.line;
	  var lineOffset = source.locationOffset.line - 1;
	  var columnOffset = getColumnOffset(source, location);
	  var contextLine = line + lineOffset;
	  var prevLineNum = (contextLine - 1).toString();
	  var lineNum = contextLine.toString();
	  var nextLineNum = (contextLine + 1).toString();
	  var padLen = nextLineNum.length;
	  var lines = source.body.split(/\r\n|[\n\r]/g);
	  lines[0] = whitespace(source.locationOffset.column - 1) + lines[0];
	  return (line >= 2 ? lpad(padLen, prevLineNum) + ': ' + lines[line - 2] + '\n' : '') + lpad(padLen, lineNum) + ': ' + lines[line - 1] + '\n' + whitespace(2 + padLen + location.column - 1 + columnOffset) + '^\n' + (line < lines.length ? lpad(padLen, nextLineNum) + ': ' + lines[line] + '\n' : '');
	}
	
	function getColumnOffset(source, location) {
	  return location.line === 1 ? source.locationOffset.column - 1 : 0;
	}
	
	function whitespace(len) {
	  return Array(len + 1).join(' ');
	}
	
	function lpad(len, str) {
	  return whitespace(len - str.length) + str;
	}

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _execute = __webpack_require__(159);
	
	Object.defineProperty(exports, 'execute', {
	  enumerable: true,
	  get: function get() {
	    return _execute.execute;
	  }
	});
	Object.defineProperty(exports, 'defaultFieldResolver', {
	  enumerable: true,
	  get: function get() {
	    return _execute.defaultFieldResolver;
	  }
	});
	Object.defineProperty(exports, 'responsePathAsArray', {
	  enumerable: true,
	  get: function get() {
	    return _execute.responsePathAsArray;
	  }
	});
	
	var _values = __webpack_require__(160);
	
	Object.defineProperty(exports, 'getDirectiveValues', {
	  enumerable: true,
	  get: function get() {
	    return _values.getDirectiveValues;
	  }
	});

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.graphql = graphql;
	
	var _parser = __webpack_require__(108);
	
	var _validate = __webpack_require__(290);
	
	var _execute = __webpack_require__(159);
	
	/**
	 * This is the primary entry point function for fulfilling GraphQL operations
	 * by parsing, validating, and executing a GraphQL document along side a
	 * GraphQL schema.
	 *
	 * More sophisticated GraphQL servers, such as those which persist queries,
	 * may wish to separate the validation and execution phases to a static time
	 * tooling step, and a server runtime step.
	 *
	 * Accepts either an object with named arguments, or individual arguments:
	 *
	 * schema:
	 *    The GraphQL type system to use when validating and executing a query.
	 * source:
	 *    A GraphQL language formatted string representing the requested operation.
	 * rootValue:
	 *    The value provided as the first argument to resolver functions on the top
	 *    level type (e.g. the query object type).
	 * variableValues:
	 *    A mapping of variable name to runtime value to use for all variables
	 *    defined in the requestString.
	 * operationName:
	 *    The name of the operation to use if requestString contains multiple
	 *    possible operations. Can be omitted if requestString contains only
	 *    one operation.
	 * fieldResolver:
	 *    A resolver function to use when one is not provided by the schema.
	 *    If not provided, the default field resolver is used (which looks for a
	 *    value or method on the source value with the field's name).
	 */
	
	/* eslint-disable no-redeclare */
	function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {
	  // Extract arguments from object args if provided.
	  return arguments.length === 1 ? graphqlImpl(argsOrSchema.schema, argsOrSchema.source, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : graphqlImpl(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver);
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function graphqlImpl(schema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {
	  return new Promise(function (resolve) {
	    // Parse
	    var document = void 0;
	    try {
	      document = (0, _parser.parse)(source);
	    } catch (syntaxError) {
	      return resolve({ errors: [syntaxError] });
	    }
	
	    // Validate
	    var validationErrors = (0, _validate.validate)(schema, document);
	    if (validationErrors.length > 0) {
	      return resolve({ errors: validationErrors });
	    }
	
	    // Execute
	    resolve((0, _execute.execute)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver));
	  });
	}

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BREAK = exports.getVisitFn = exports.visitWithTypeInfo = exports.visitInParallel = exports.visit = exports.Source = exports.print = exports.parseType = exports.parseValue = exports.parse = exports.TokenKind = exports.createLexer = exports.Kind = exports.getLocation = undefined;
	
	var _location = __webpack_require__(165);
	
	Object.defineProperty(exports, 'getLocation', {
	  enumerable: true,
	  get: function get() {
	    return _location.getLocation;
	  }
	});
	
	var _lexer = __webpack_require__(164);
	
	Object.defineProperty(exports, 'createLexer', {
	  enumerable: true,
	  get: function get() {
	    return _lexer.createLexer;
	  }
	});
	Object.defineProperty(exports, 'TokenKind', {
	  enumerable: true,
	  get: function get() {
	    return _lexer.TokenKind;
	  }
	});
	
	var _parser = __webpack_require__(108);
	
	Object.defineProperty(exports, 'parse', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parse;
	  }
	});
	Object.defineProperty(exports, 'parseValue', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parseValue;
	  }
	});
	Object.defineProperty(exports, 'parseType', {
	  enumerable: true,
	  get: function get() {
	    return _parser.parseType;
	  }
	});
	
	var _printer = __webpack_require__(27);
	
	Object.defineProperty(exports, 'print', {
	  enumerable: true,
	  get: function get() {
	    return _printer.print;
	  }
	});
	
	var _source = __webpack_require__(260);
	
	Object.defineProperty(exports, 'Source', {
	  enumerable: true,
	  get: function get() {
	    return _source.Source;
	  }
	});
	
	var _visitor = __webpack_require__(80);
	
	Object.defineProperty(exports, 'visit', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visit;
	  }
	});
	Object.defineProperty(exports, 'visitInParallel', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visitInParallel;
	  }
	});
	Object.defineProperty(exports, 'visitWithTypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.visitWithTypeInfo;
	  }
	});
	Object.defineProperty(exports, 'getVisitFn', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.getVisitFn;
	  }
	});
	Object.defineProperty(exports, 'BREAK', {
	  enumerable: true,
	  get: function get() {
	    return _visitor.BREAK;
	  }
	});
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.Kind = Kind;

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _subscribe = __webpack_require__(616);
	
	Object.defineProperty(exports, 'subscribe', {
	  enumerable: true,
	  get: function get() {
	    return _subscribe.subscribe;
	  }
	});
	Object.defineProperty(exports, 'createSourceEventStream', {
	  enumerable: true,
	  get: function get() {
	    return _subscribe.createSourceEventStream;
	  }
	});

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = mapAsyncIterator;
	
	var _iterall = __webpack_require__(61);
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
	                                                                                                                                                                                                                   * Copyright (c) 2017-present, Facebook, Inc.
	                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                   * 
	                                                                                                                                                                                                                   */
	
	/**
	 * Given an AsyncIterable and a callback function, return an AsyncIterator
	 * which produces values mapped via calling the callback function.
	 */
	function mapAsyncIterator(iterable, callback, rejectCallback) {
	  var iterator = (0, _iterall.getAsyncIterator)(iterable);
	  var $return = void 0;
	  var abruptClose = void 0;
	  if (typeof iterator.return === 'function') {
	    $return = iterator.return;
	    abruptClose = function abruptClose(error) {
	      var rethrow = function rethrow() {
	        return Promise.reject(error);
	      };
	      return $return.call(iterator).then(rethrow, rethrow);
	    };
	  }
	
	  function mapResult(result) {
	    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
	  }
	
	  var mapReject = void 0;
	  if (rejectCallback) {
	    // Capture rejectCallback to ensure it cannot be null.
	    var reject = rejectCallback;
	    mapReject = function mapReject(error) {
	      return asyncMapValue(error, reject).then(iteratorResult, abruptClose);
	    };
	  }
	
	  /* TODO: Flow doesn't support symbols as keys:
	     https://github.com/facebook/flow/issues/3258 */
	  return _defineProperty({
	    next: function next() {
	      return iterator.next().then(mapResult, mapReject);
	    },
	    return: function _return() {
	      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
	    },
	    throw: function _throw(error) {
	      if (typeof iterator.throw === 'function') {
	        return iterator.throw(error).then(mapResult, mapReject);
	      }
	      return Promise.reject(error).catch(abruptClose);
	    }
	  }, _iterall.$$asyncIterator, function () {
	    return this;
	  });
	}
	
	function asyncMapValue(value, callback) {
	  return new Promise(function (resolve) {
	    return resolve(callback(value));
	  });
	}
	
	function iteratorResult(value) {
	  return { value: value, done: false };
	}

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscribe = subscribe;
	exports.createSourceEventStream = createSourceEventStream;
	
	var _iterall = __webpack_require__(61);
	
	var _GraphQLError = __webpack_require__(57);
	
	var _locatedError = __webpack_require__(259);
	
	var _execute = __webpack_require__(159);
	
	var _schema = __webpack_require__(34);
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _mapAsyncIterator = __webpack_require__(615);
	
	var _mapAsyncIterator2 = _interopRequireDefault(_mapAsyncIterator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Implements the "Subscribe" algorithm described in the GraphQL specification.
	 *
	 * Returns a Promise which resolves to either an AsyncIterator (if successful)
	 * or an ExecutionResult (client error). The promise will be rejected if a
	 * server error occurs.
	 *
	 * If the client-provided arguments to this function do not result in a
	 * compliant subscription, a GraphQL Response (ExecutionResult) with
	 * descriptive errors and no data will be returned.
	 *
	 * If the the source stream could not be created due to faulty subscription
	 * resolver logic or underlying systems, the promise will resolve to a single
	 * ExecutionResult containing `errors` and no `data`.
	 *
	 * If the operation succeeded, the promise resolves to an AsyncIterator, which
	 * yields a stream of ExecutionResults representing the response stream.
	 *
	 * Accepts either an object with named arguments, or individual arguments.
	 */
	
	/* eslint-disable no-redeclare */
	function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
	  // Extract arguments from object args if provided.
	  var args = arguments.length === 1 ? argsOrSchema : undefined;
	  var schema = args ? args.schema : argsOrSchema;
	
	  return args ? subscribeImpl(schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.subscribeFieldResolver) : subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);
	}
	
	/**
	 * This function checks if the error is a GraphQLError. If it is, report it as
	 * an ExecutionResult, containing only errors and no data. Otherwise treat the
	 * error as a system-class error and re-throw it.
	 */
	/**
	 * Copyright (c) 2017-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function reportGraphQLError(error) {
	  if (error instanceof _GraphQLError.GraphQLError) {
	    return { errors: [error] };
	  }
	  throw error;
	}
	
	function subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
	  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
	
	  // For each payload yielded from a subscription, map it over the normal
	  // GraphQL `execute` function, with `payload` as the rootValue.
	  // This implements the "MapSourceToResponseEvent" algorithm described in
	  // the GraphQL specification. The `execute` function provides the
	  // "ExecuteSubscriptionEvent" algorithm, as it is nearly identical to the
	  // "ExecuteQuery" algorithm, for which `execute` is also used.
	  var mapSourceToResponse = function mapSourceToResponse(payload) {
	    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);
	  };
	
	  // Resolve the Source Stream, then map every source value to a
	  // ExecutionResult value as described above.
	  return sourcePromise.then(function (sourceStream) {
	    return (0, _mapAsyncIterator2.default)(sourceStream, mapSourceToResponse, reportGraphQLError);
	  }, reportGraphQLError);
	}
	
	/**
	 * Implements the "CreateSourceEventStream" algorithm described in the
	 * GraphQL specification, resolving the subscription source event stream.
	 *
	 * Returns a Promise<AsyncIterable>.
	 *
	 * If the client-provided invalid arguments, the source stream could not be
	 * created, or the resolver did not return an AsyncIterable, this function will
	 * will throw an error, which should be caught and handled by the caller.
	 *
	 * A Source Event Stream represents a sequence of events, each of which triggers
	 * a GraphQL execution for that event.
	 *
	 * This may be useful when hosting the stateful subscription service in a
	 * different process or machine than the stateless GraphQL execution engine,
	 * or otherwise separating these two steps. For more on this, see the
	 * "Supporting Subscriptions at Scale" information in the GraphQL specification.
	 */
	function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
	  // If arguments are missing or incorrectly typed, this is an internal
	  // developer mistake which should throw an early error.
	  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
	
	  return new Promise(function (resolve, reject) {
	    // If a valid context cannot be created due to incorrect arguments,
	    // this will throw an error.
	    var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
	
	    var type = (0, _execute.getOperationRootType)(schema, exeContext.operation);
	    var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));
	    var responseNames = Object.keys(fields);
	    var responseName = responseNames[0];
	    var fieldNodes = fields[responseName];
	    var fieldNode = fieldNodes[0];
	    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldNode.name.value);
	    !fieldDef ? (0, _invariant2.default)(0, 'This subscription is not defined by the schema.') : void 0;
	
	    // Call the `subscribe()` resolver or the default resolver to produce an
	    // AsyncIterable yielding raw payloads.
	    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;
	
	    var path = (0, _execute.addPath)(undefined, responseName);
	
	    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);
	
	    // resolveFieldValueOrError implements the "ResolveFieldEventStream"
	    // algorithm from GraphQL specification. It differs from
	    // "ResolveFieldValue" due to providing a different `resolveFn`.
	    Promise.resolve((0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info)).then(function (subscription) {
	      // Reject with a located GraphQLError if subscription source fails
	      // to resolve.
	      if (subscription instanceof Error) {
	        var error = (0, _locatedError.locatedError)(subscription, fieldNodes, (0, _execute.responsePathAsArray)(path));
	        reject(error);
	      }
	
	      if (!(0, _iterall.isAsyncIterable)(subscription)) {
	        reject(new Error('Subscription must return Async Iterable. ' + 'Received: ' + String(subscription)));
	      }
	
	      resolve(subscription);
	    }).catch(reject);
	  });
	}

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _schema = __webpack_require__(34);
	
	Object.defineProperty(exports, 'GraphQLSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schema.GraphQLSchema;
	  }
	});
	
	var _definition = __webpack_require__(7);
	
	Object.defineProperty(exports, 'isType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isType;
	  }
	});
	Object.defineProperty(exports, 'isInputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isInputType;
	  }
	});
	Object.defineProperty(exports, 'isOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isOutputType;
	  }
	});
	Object.defineProperty(exports, 'isLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isLeafType;
	  }
	});
	Object.defineProperty(exports, 'isCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isCompositeType;
	  }
	});
	Object.defineProperty(exports, 'isAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isAbstractType;
	  }
	});
	Object.defineProperty(exports, 'isNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.isNamedType;
	  }
	});
	Object.defineProperty(exports, 'assertType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertType;
	  }
	});
	Object.defineProperty(exports, 'assertInputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertInputType;
	  }
	});
	Object.defineProperty(exports, 'assertOutputType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertOutputType;
	  }
	});
	Object.defineProperty(exports, 'assertLeafType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertLeafType;
	  }
	});
	Object.defineProperty(exports, 'assertCompositeType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertCompositeType;
	  }
	});
	Object.defineProperty(exports, 'assertAbstractType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertAbstractType;
	  }
	});
	Object.defineProperty(exports, 'assertNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.assertNamedType;
	  }
	});
	Object.defineProperty(exports, 'getNullableType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.getNullableType;
	  }
	});
	Object.defineProperty(exports, 'getNamedType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.getNamedType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLScalarType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLScalarType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInterfaceType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLInterfaceType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLUnionType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLUnionType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLEnumType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLEnumType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLInputObjectType', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLInputObjectType;
	  }
	});
	Object.defineProperty(exports, 'GraphQLList', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLList;
	  }
	});
	Object.defineProperty(exports, 'GraphQLNonNull', {
	  enumerable: true,
	  get: function get() {
	    return _definition.GraphQLNonNull;
	  }
	});
	
	var _directives = __webpack_require__(33);
	
	Object.defineProperty(exports, 'DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _directives.DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLDirective;
	  }
	});
	Object.defineProperty(exports, 'specifiedDirectives', {
	  enumerable: true,
	  get: function get() {
	    return _directives.specifiedDirectives;
	  }
	});
	Object.defineProperty(exports, 'GraphQLIncludeDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLIncludeDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLSkipDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLSkipDirective;
	  }
	});
	Object.defineProperty(exports, 'GraphQLDeprecatedDirective', {
	  enumerable: true,
	  get: function get() {
	    return _directives.GraphQLDeprecatedDirective;
	  }
	});
	Object.defineProperty(exports, 'DEFAULT_DEPRECATION_REASON', {
	  enumerable: true,
	  get: function get() {
	    return _directives.DEFAULT_DEPRECATION_REASON;
	  }
	});
	
	var _scalars = __webpack_require__(42);
	
	Object.defineProperty(exports, 'GraphQLInt', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLInt;
	  }
	});
	Object.defineProperty(exports, 'GraphQLFloat', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLFloat;
	  }
	});
	Object.defineProperty(exports, 'GraphQLString', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLString;
	  }
	});
	Object.defineProperty(exports, 'GraphQLBoolean', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLBoolean;
	  }
	});
	Object.defineProperty(exports, 'GraphQLID', {
	  enumerable: true,
	  get: function get() {
	    return _scalars.GraphQLID;
	  }
	});
	
	var _introspection = __webpack_require__(41);
	
	Object.defineProperty(exports, 'TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeKind;
	  }
	});
	Object.defineProperty(exports, '__Schema', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Schema;
	  }
	});
	Object.defineProperty(exports, '__Directive', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Directive;
	  }
	});
	Object.defineProperty(exports, '__DirectiveLocation', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__DirectiveLocation;
	  }
	});
	Object.defineProperty(exports, '__Type', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Type;
	  }
	});
	Object.defineProperty(exports, '__Field', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__Field;
	  }
	});
	Object.defineProperty(exports, '__InputValue', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__InputValue;
	  }
	});
	Object.defineProperty(exports, '__EnumValue', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__EnumValue;
	  }
	});
	Object.defineProperty(exports, '__TypeKind', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.__TypeKind;
	  }
	});
	Object.defineProperty(exports, 'SchemaMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.SchemaMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeMetaFieldDef;
	  }
	});
	Object.defineProperty(exports, 'TypeNameMetaFieldDef', {
	  enumerable: true,
	  get: function get() {
	    return _introspection.TypeNameMetaFieldDef;
	  }
	});

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buildClientSchema = buildClientSchema;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	var _keyValMap = __webpack_require__(161);
	
	var _keyValMap2 = _interopRequireDefault(_keyValMap);
	
	var _valueFromAST = __webpack_require__(81);
	
	var _parser = __webpack_require__(108);
	
	var _schema = __webpack_require__(34);
	
	var _definition = __webpack_require__(7);
	
	var _introspection = __webpack_require__(41);
	
	var _scalars = __webpack_require__(42);
	
	var _directives = __webpack_require__(33);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Build a GraphQLSchema for use by client tools.
	 *
	 * Given the result of a client running the introspection query, creates and
	 * returns a GraphQLSchema instance which can be then used with all graphql-js
	 * tools, but cannot be used to execute a query, as introspection does not
	 * represent the "resolver", "parse" or "serialize" functions or any other
	 * server-internal mechanisms.
	 */
	function buildClientSchema(introspection) {
	
	  // Get the schema from the introspection result.
	  var schemaIntrospection = introspection.__schema;
	
	  // Converts the list of types into a keyMap based on the type names.
	  var typeIntrospectionMap = (0, _keyMap2.default)(schemaIntrospection.types, function (type) {
	    return type.name;
	  });
	
	  // A cache to use to store the actual GraphQLType definition objects by name.
	  // Initialize to the GraphQL built in scalars. All functions below are inline
	  // so that this type def cache is within the scope of the closure.
	  var typeDefCache = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };
	
	  // Given a type reference in introspection, return the GraphQLType instance.
	  // preferring cached instances before building new instances.
	  function getType(typeRef) {
	    if (typeRef.kind === _introspection.TypeKind.LIST) {
	      var itemRef = typeRef.ofType;
	      if (!itemRef) {
	        throw new Error('Decorated type deeper than introspection query.');
	      }
	      return new _definition.GraphQLList(getType(itemRef));
	    }
	    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
	      var nullableRef = typeRef.ofType;
	      if (!nullableRef) {
	        throw new Error('Decorated type deeper than introspection query.');
	      }
	      var nullableType = getType(nullableRef);
	      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getNamedType(typeRef.name);
	  }
	
	  function getNamedType(typeName) {
	    if (typeDefCache[typeName]) {
	      return typeDefCache[typeName];
	    }
	    var typeIntrospection = typeIntrospectionMap[typeName];
	    if (!typeIntrospection) {
	      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');
	    }
	    var typeDef = buildType(typeIntrospection);
	    typeDefCache[typeName] = typeDef;
	    return typeDef;
	  }
	
	  function getInputType(typeRef) {
	    var type = getType(typeRef);
	    !(0, _definition.isInputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide input type for arguments.') : void 0;
	    return type;
	  }
	
	  function getOutputType(typeRef) {
	    var type = getType(typeRef);
	    !(0, _definition.isOutputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide output type for fields.') : void 0;
	    return type;
	  }
	
	  function getObjectType(typeRef) {
	    var type = getType(typeRef);
	    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Introspection must provide object type for possibleTypes.') : void 0;
	    return type;
	  }
	
	  function getInterfaceType(typeRef) {
	    var type = getType(typeRef);
	    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Introspection must provide interface type for interfaces.') : void 0;
	    return type;
	  }
	
	  // Given a type's introspection result, construct the correct
	  // GraphQLType instance.
	  function buildType(type) {
	    switch (type.kind) {
	      case _introspection.TypeKind.SCALAR:
	        return buildScalarDef(type);
	      case _introspection.TypeKind.OBJECT:
	        return buildObjectDef(type);
	      case _introspection.TypeKind.INTERFACE:
	        return buildInterfaceDef(type);
	      case _introspection.TypeKind.UNION:
	        return buildUnionDef(type);
	      case _introspection.TypeKind.ENUM:
	        return buildEnumDef(type);
	      case _introspection.TypeKind.INPUT_OBJECT:
	        return buildInputObjectDef(type);
	      default:
	        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');
	    }
	  }
	
	  function buildScalarDef(scalarIntrospection) {
	    return new _definition.GraphQLScalarType({
	      name: scalarIntrospection.name,
	      description: scalarIntrospection.description,
	      serialize: function serialize(id) {
	        return id;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }
	
	  function buildObjectDef(objectIntrospection) {
	    return new _definition.GraphQLObjectType({
	      name: objectIntrospection.name,
	      description: objectIntrospection.description,
	      interfaces: objectIntrospection.interfaces.map(getInterfaceType),
	      fields: function fields() {
	        return buildFieldDefMap(objectIntrospection);
	      }
	    });
	  }
	
	  function buildInterfaceDef(interfaceIntrospection) {
	    return new _definition.GraphQLInterfaceType({
	      name: interfaceIntrospection.name,
	      description: interfaceIntrospection.description,
	      fields: function fields() {
	        return buildFieldDefMap(interfaceIntrospection);
	      },
	      resolveType: cannotExecuteClientSchema
	    });
	  }
	
	  function buildUnionDef(unionIntrospection) {
	    return new _definition.GraphQLUnionType({
	      name: unionIntrospection.name,
	      description: unionIntrospection.description,
	      types: unionIntrospection.possibleTypes.map(getObjectType),
	      resolveType: cannotExecuteClientSchema
	    });
	  }
	
	  function buildEnumDef(enumIntrospection) {
	    return new _definition.GraphQLEnumType({
	      name: enumIntrospection.name,
	      description: enumIntrospection.description,
	      values: (0, _keyValMap2.default)(enumIntrospection.enumValues, function (valueIntrospection) {
	        return valueIntrospection.name;
	      }, function (valueIntrospection) {
	        return {
	          description: valueIntrospection.description,
	          deprecationReason: valueIntrospection.deprecationReason
	        };
	      })
	    });
	  }
	
	  function buildInputObjectDef(inputObjectIntrospection) {
	    return new _definition.GraphQLInputObjectType({
	      name: inputObjectIntrospection.name,
	      description: inputObjectIntrospection.description,
	      fields: function fields() {
	        return buildInputValueDefMap(inputObjectIntrospection.inputFields);
	      }
	    });
	  }
	
	  function buildFieldDefMap(typeIntrospection) {
	    return (0, _keyValMap2.default)(typeIntrospection.fields, function (fieldIntrospection) {
	      return fieldIntrospection.name;
	    }, function (fieldIntrospection) {
	      return {
	        description: fieldIntrospection.description,
	        deprecationReason: fieldIntrospection.deprecationReason,
	        type: getOutputType(fieldIntrospection.type),
	        args: buildInputValueDefMap(fieldIntrospection.args)
	      };
	    });
	  }
	
	  function buildInputValueDefMap(inputValueIntrospections) {
	    return (0, _keyValMap2.default)(inputValueIntrospections, function (inputValue) {
	      return inputValue.name;
	    }, buildInputValue);
	  }
	
	  function buildInputValue(inputValueIntrospection) {
	    var type = getInputType(inputValueIntrospection.type);
	    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;
	    return {
	      name: inputValueIntrospection.name,
	      description: inputValueIntrospection.description,
	      type: type,
	      defaultValue: defaultValue
	    };
	  }
	
	  function buildDirective(directiveIntrospection) {
	    // Support deprecated `on****` fields for building `locations`, as this
	    // is used by GraphiQL which may need to support outdated servers.
	    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [_directives.DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [_directives.DirectiveLocation.QUERY, _directives.DirectiveLocation.MUTATION, _directives.DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [_directives.DirectiveLocation.FRAGMENT_DEFINITION, _directives.DirectiveLocation.FRAGMENT_SPREAD, _directives.DirectiveLocation.INLINE_FRAGMENT]);
	    return new _directives.GraphQLDirective({
	      name: directiveIntrospection.name,
	      description: directiveIntrospection.description,
	      locations: locations,
	      args: buildInputValueDefMap(directiveIntrospection.args)
	    });
	  }
	
	  // Iterate through all types, getting the type definition for each, ensuring
	  // that any type not directly referenced by a field will get created.
	  var types = schemaIntrospection.types.map(function (typeIntrospection) {
	    return getNamedType(typeIntrospection.name);
	  });
	
	  // Get the root Query, Mutation, and Subscription types.
	  var queryType = getObjectType(schemaIntrospection.queryType);
	
	  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
	
	  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
	
	  // Get the directives supported by Introspection, assuming empty-set if
	  // directives were not queried for.
	  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
	
	  // Then produce and return a Schema with these types.
	  return new _schema.GraphQLSchema({
	    query: queryType,
	    mutation: mutationType,
	    subscription: subscriptionType,
	    types: types,
	    directives: directives
	  });
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	function cannotExecuteClientSchema() {
	  throw new Error('Client Schema cannot use Interface or Union types for execution.');
	}

/***/ }),
/* 619 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.concatAST = concatAST;
	
	
	/**
	 * Provided a collection of ASTs, presumably each from different files,
	 * concatenate the ASTs together into batched AST, useful for validating many
	 * GraphQL source files which together represent one conceptual application.
	 */
	function concatAST(asts) {
	  var batchDefinitions = [];
	  for (var i = 0; i < asts.length; i++) {
	    var definitions = asts[i].definitions;
	    for (var j = 0; j < definitions.length; j++) {
	      batchDefinitions.push(definitions[j]);
	    }
	  }
	  return {
	    kind: 'Document',
	    definitions: batchDefinitions
	  };
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.extendSchema = extendSchema;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _keyMap = __webpack_require__(59);
	
	var _keyMap2 = _interopRequireDefault(_keyMap);
	
	var _keyValMap = __webpack_require__(161);
	
	var _keyValMap2 = _interopRequireDefault(_keyValMap);
	
	var _buildASTSchema = __webpack_require__(261);
	
	var _valueFromAST = __webpack_require__(81);
	
	var _GraphQLError = __webpack_require__(57);
	
	var _schema = __webpack_require__(34);
	
	var _definition = __webpack_require__(7);
	
	var _directives = __webpack_require__(33);
	
	var _introspection = __webpack_require__(41);
	
	var _scalars = __webpack_require__(42);
	
	var _kinds = __webpack_require__(14);
	
	var Kind = _interopRequireWildcard(_kinds);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Produces a new schema given an existing schema and a document which may
	 * contain GraphQL type extensions and definitions. The original schema will
	 * remain unaltered.
	 *
	 * Because a schema represents a graph of references, a schema cannot be
	 * extended without effectively making an entire copy. We do not know until it's
	 * too late if subgraphs remain unchanged.
	 *
	 * This algorithm copies the provided schema, applying extensions while
	 * producing the copy. The original schema remains unaltered.
	 */
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function extendSchema(schema, documentAST) {
	  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;
	
	  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0;
	
	  // Collect the type definitions and extensions found in the document.
	  var typeDefinitionMap = Object.create(null);
	  var typeExtensionsMap = Object.create(null);
	
	  // New directives and types are separate because a directives and types can
	  // have the same name. For example, a type named "skip".
	  var directiveDefinitions = [];
	
	  for (var i = 0; i < documentAST.definitions.length; i++) {
	    var def = documentAST.definitions[i];
	    switch (def.kind) {
	      case Kind.OBJECT_TYPE_DEFINITION:
	      case Kind.INTERFACE_TYPE_DEFINITION:
	      case Kind.ENUM_TYPE_DEFINITION:
	      case Kind.UNION_TYPE_DEFINITION:
	      case Kind.SCALAR_TYPE_DEFINITION:
	      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
	        // Sanity check that none of the defined types conflict with the
	        // schema's existing types.
	        var typeName = def.name.value;
	        if (schema.getType(typeName)) {
	          throw new _GraphQLError.GraphQLError('Type "' + typeName + '" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);
	        }
	        typeDefinitionMap[typeName] = def;
	        break;
	      case Kind.TYPE_EXTENSION_DEFINITION:
	        // Sanity check that this type extension exists within the
	        // schema's existing types.
	        var extendedTypeName = def.definition.name.value;
	        var existingType = schema.getType(extendedTypeName);
	        if (!existingType) {
	          throw new _GraphQLError.GraphQLError('Cannot extend type "' + extendedTypeName + '" because it does not ' + 'exist in the existing schema.', [def.definition]);
	        }
	        if (!(existingType instanceof _definition.GraphQLObjectType)) {
	          throw new _GraphQLError.GraphQLError('Cannot extend non-object type "' + extendedTypeName + '".', [def.definition]);
	        }
	        var extensions = typeExtensionsMap[extendedTypeName];
	        if (extensions) {
	          extensions.push(def);
	        } else {
	          extensions = [def];
	        }
	        typeExtensionsMap[extendedTypeName] = extensions;
	        break;
	      case Kind.DIRECTIVE_DEFINITION:
	        var directiveName = def.name.value;
	        var existingDirective = schema.getDirective(directiveName);
	        if (existingDirective) {
	          throw new _GraphQLError.GraphQLError('Directive "' + directiveName + '" already exists in the schema. It ' + 'cannot be redefined.', [def]);
	        }
	        directiveDefinitions.push(def);
	        break;
	    }
	  }
	
	  // If this document contains no new types, extensions, or directives then
	  // return the same unmodified GraphQLSchema instance.
	  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {
	    return schema;
	  }
	
	  // A cache to use to store the actual GraphQLType definition objects by name.
	  // Initialize to the GraphQL built in scalars and introspection types. All
	  // functions below are inline so that this type def cache is within the scope
	  // of the closure.
	  var typeDefCache = {
	    String: _scalars.GraphQLString,
	    Int: _scalars.GraphQLInt,
	    Float: _scalars.GraphQLFloat,
	    Boolean: _scalars.GraphQLBoolean,
	    ID: _scalars.GraphQLID,
	    __Schema: _introspection.__Schema,
	    __Directive: _introspection.__Directive,
	    __DirectiveLocation: _introspection.__DirectiveLocation,
	    __Type: _introspection.__Type,
	    __Field: _introspection.__Field,
	    __InputValue: _introspection.__InputValue,
	    __EnumValue: _introspection.__EnumValue,
	    __TypeKind: _introspection.__TypeKind
	  };
	
	  // Get the root Query, Mutation, and Subscription object types.
	  var queryType = getTypeFromDef(schema.getQueryType());
	
	  var existingMutationType = schema.getMutationType();
	  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;
	
	  var existingSubscriptionType = schema.getSubscriptionType();
	  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;
	
	  // Iterate through all types, getting the type definition for each, ensuring
	  // that any type not directly referenced by a field will get created.
	  var typeMap = schema.getTypeMap();
	  var types = Object.keys(typeMap).map(function (typeName) {
	    return getTypeFromDef(typeMap[typeName]);
	  });
	
	  // Do the same with new types, appending to the list of defined types.
	  Object.keys(typeDefinitionMap).forEach(function (typeName) {
	    types.push(getTypeFromAST(typeDefinitionMap[typeName]));
	  });
	
	  // Then produce and return a Schema with these types.
	  return new _schema.GraphQLSchema({
	    query: queryType,
	    mutation: mutationType,
	    subscription: subscriptionType,
	    types: types,
	    directives: getMergedDirectives(),
	    astNode: schema.astNode
	  });
	
	  // Below are functions used for producing this schema that have closed over
	  // this scope and have access to the schema, cache, and newly defined types.
	
	  function getMergedDirectives() {
	    var existingDirectives = schema.getDirectives();
	    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;
	
	    var newDirectives = directiveDefinitions.map(function (directiveNode) {
	      return getDirective(directiveNode);
	    });
	    return existingDirectives.concat(newDirectives);
	  }
	
	  function getTypeFromDef(typeDef) {
	    var type = _getNamedType(typeDef.name);
	    !type ? (0, _invariant2.default)(0, 'Missing type from schema') : void 0;
	    return type;
	  }
	
	  function getTypeFromAST(node) {
	    var type = _getNamedType(node.name.value);
	    if (!type) {
	      throw new _GraphQLError.GraphQLError('Unknown type: "' + node.name.value + '". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);
	    }
	    return type;
	  }
	
	  function getObjectTypeFromAST(node) {
	    var type = getTypeFromAST(node);
	    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Must be Object type.') : void 0;
	    return type;
	  }
	
	  function getInterfaceTypeFromAST(node) {
	    var type = getTypeFromAST(node);
	    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Must be Interface type.') : void 0;
	    return type;
	  }
	
	  function getInputTypeFromAST(node) {
	    return (0, _definition.assertInputType)(getTypeFromAST(node));
	  }
	
	  function getOutputTypeFromAST(node) {
	    return (0, _definition.assertOutputType)(getTypeFromAST(node));
	  }
	
	  // Given a name, returns a type from either the existing schema or an
	  // added type.
	  function _getNamedType(typeName) {
	    var cachedTypeDef = typeDefCache[typeName];
	    if (cachedTypeDef) {
	      return cachedTypeDef;
	    }
	
	    var existingType = schema.getType(typeName);
	    if (existingType) {
	      var typeDef = extendType(existingType);
	      typeDefCache[typeName] = typeDef;
	      return typeDef;
	    }
	
	    var typeNode = typeDefinitionMap[typeName];
	    if (typeNode) {
	      var _typeDef = buildType(typeNode);
	      typeDefCache[typeName] = _typeDef;
	      return _typeDef;
	    }
	  }
	
	  // Given a type's introspection result, construct the correct
	  // GraphQLType instance.
	  function extendType(type) {
	    if (type instanceof _definition.GraphQLObjectType) {
	      return extendObjectType(type);
	    }
	    if (type instanceof _definition.GraphQLInterfaceType) {
	      return extendInterfaceType(type);
	    }
	    if (type instanceof _definition.GraphQLUnionType) {
	      return extendUnionType(type);
	    }
	    return type;
	  }
	
	  function extendObjectType(type) {
	    var name = type.name;
	    var extensionASTNodes = type.extensionASTNodes;
	    if (typeExtensionsMap[name]) {
	      extensionASTNodes = extensionASTNodes.concat(typeExtensionsMap[name]);
	    }
	
	    return new _definition.GraphQLObjectType({
	      name: name,
	      description: type.description,
	      interfaces: function interfaces() {
	        return extendImplementedInterfaces(type);
	      },
	      fields: function fields() {
	        return extendFieldMap(type);
	      },
	      astNode: type.astNode,
	      extensionASTNodes: extensionASTNodes,
	      isTypeOf: type.isTypeOf
	    });
	  }
	
	  function extendInterfaceType(type) {
	    return new _definition.GraphQLInterfaceType({
	      name: type.name,
	      description: type.description,
	      fields: function fields() {
	        return extendFieldMap(type);
	      },
	      astNode: type.astNode,
	      resolveType: type.resolveType
	    });
	  }
	
	  function extendUnionType(type) {
	    return new _definition.GraphQLUnionType({
	      name: type.name,
	      description: type.description,
	      types: type.getTypes().map(getTypeFromDef),
	      astNode: type.astNode,
	      resolveType: type.resolveType
	    });
	  }
	
	  function extendImplementedInterfaces(type) {
	    var interfaces = type.getInterfaces().map(getTypeFromDef);
	
	    // If there are any extensions to the interfaces, apply those here.
	    var extensions = typeExtensionsMap[type.name];
	    if (extensions) {
	      extensions.forEach(function (extension) {
	        extension.definition.interfaces.forEach(function (namedType) {
	          var interfaceName = namedType.name.value;
	          if (interfaces.some(function (def) {
	            return def.name === interfaceName;
	          })) {
	            throw new _GraphQLError.GraphQLError('Type "' + type.name + '" already implements "' + interfaceName + '". ' + 'It cannot also be implemented in this type extension.', [namedType]);
	          }
	          interfaces.push(getInterfaceTypeFromAST(namedType));
	        });
	      });
	    }
	
	    return interfaces;
	  }
	
	  function extendFieldMap(type) {
	    var newFieldMap = Object.create(null);
	    var oldFieldMap = type.getFields();
	    Object.keys(oldFieldMap).forEach(function (fieldName) {
	      var field = oldFieldMap[fieldName];
	      newFieldMap[fieldName] = {
	        description: field.description,
	        deprecationReason: field.deprecationReason,
	        type: extendFieldType(field.type),
	        args: (0, _keyMap2.default)(field.args, function (arg) {
	          return arg.name;
	        }),
	        astNode: field.astNode,
	        resolve: field.resolve
	      };
	    });
	
	    // If there are any extensions to the fields, apply those here.
	    var extensions = typeExtensionsMap[type.name];
	    if (extensions) {
	      extensions.forEach(function (extension) {
	        extension.definition.fields.forEach(function (field) {
	          var fieldName = field.name.value;
	          if (oldFieldMap[fieldName]) {
	            throw new _GraphQLError.GraphQLError('Field "' + type.name + '.' + fieldName + '" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);
	          }
	          newFieldMap[fieldName] = {
	            description: (0, _buildASTSchema.getDescription)(field),
	            type: buildOutputFieldType(field.type),
	            args: buildInputValues(field.arguments),
	            deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),
	            astNode: field
	          };
	        });
	      });
	    }
	
	    return newFieldMap;
	  }
	
	  function extendFieldType(typeDef) {
	    if (typeDef instanceof _definition.GraphQLList) {
	      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));
	    }
	    if (typeDef instanceof _definition.GraphQLNonNull) {
	      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));
	    }
	    return getTypeFromDef(typeDef);
	  }
	
	  function buildType(typeNode) {
	    switch (typeNode.kind) {
	      case Kind.OBJECT_TYPE_DEFINITION:
	        return buildObjectType(typeNode);
	      case Kind.INTERFACE_TYPE_DEFINITION:
	        return buildInterfaceType(typeNode);
	      case Kind.UNION_TYPE_DEFINITION:
	        return buildUnionType(typeNode);
	      case Kind.SCALAR_TYPE_DEFINITION:
	        return buildScalarType(typeNode);
	      case Kind.ENUM_TYPE_DEFINITION:
	        return buildEnumType(typeNode);
	      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
	        return buildInputObjectType(typeNode);
	    }
	    throw new TypeError('Unknown type kind ' + typeNode.kind);
	  }
	
	  function buildObjectType(typeNode) {
	    return new _definition.GraphQLObjectType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      interfaces: function interfaces() {
	        return buildImplementedInterfaces(typeNode);
	      },
	      fields: function fields() {
	        return buildFieldMap(typeNode);
	      },
	      astNode: typeNode
	    });
	  }
	
	  function buildInterfaceType(typeNode) {
	    return new _definition.GraphQLInterfaceType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      fields: function fields() {
	        return buildFieldMap(typeNode);
	      },
	      astNode: typeNode,
	      resolveType: cannotExecuteExtendedSchema
	    });
	  }
	
	  function buildUnionType(typeNode) {
	    return new _definition.GraphQLUnionType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      types: typeNode.types.map(getObjectTypeFromAST),
	      astNode: typeNode,
	      resolveType: cannotExecuteExtendedSchema
	    });
	  }
	
	  function buildScalarType(typeNode) {
	    return new _definition.GraphQLScalarType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      astNode: typeNode,
	      serialize: function serialize(id) {
	        return id;
	      },
	      // Note: validation calls the parse functions to determine if a
	      // literal value is correct. Returning null would cause use of custom
	      // scalars to always fail validation. Returning false causes them to
	      // always pass validation.
	      parseValue: function parseValue() {
	        return false;
	      },
	      parseLiteral: function parseLiteral() {
	        return false;
	      }
	    });
	  }
	
	  function buildEnumType(typeNode) {
	    return new _definition.GraphQLEnumType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      values: (0, _keyValMap2.default)(typeNode.values, function (enumValue) {
	        return enumValue.name.value;
	      }, function (enumValue) {
	        return {
	          description: (0, _buildASTSchema.getDescription)(enumValue),
	          deprecationReason: (0, _buildASTSchema.getDeprecationReason)(enumValue),
	          astNode: enumValue
	        };
	      }),
	      astNode: typeNode
	    });
	  }
	
	  function buildInputObjectType(typeNode) {
	    return new _definition.GraphQLInputObjectType({
	      name: typeNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(typeNode),
	      fields: function fields() {
	        return buildInputValues(typeNode.fields);
	      },
	      astNode: typeNode
	    });
	  }
	
	  function getDirective(directiveNode) {
	    return new _directives.GraphQLDirective({
	      name: directiveNode.name.value,
	      description: (0, _buildASTSchema.getDescription)(directiveNode),
	      locations: directiveNode.locations.map(function (node) {
	        return node.value;
	      }),
	      args: directiveNode.arguments && buildInputValues(directiveNode.arguments),
	      astNode: directiveNode
	    });
	  }
	
	  function buildImplementedInterfaces(typeNode) {
	    return typeNode.interfaces && typeNode.interfaces.map(getInterfaceTypeFromAST);
	  }
	
	  function buildFieldMap(typeNode) {
	    return (0, _keyValMap2.default)(typeNode.fields, function (field) {
	      return field.name.value;
	    }, function (field) {
	      return {
	        type: buildOutputFieldType(field.type),
	        description: (0, _buildASTSchema.getDescription)(field),
	        args: buildInputValues(field.arguments),
	        deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),
	        astNode: field
	      };
	    });
	  }
	
	  function buildInputValues(values) {
	    return (0, _keyValMap2.default)(values, function (value) {
	      return value.name.value;
	    }, function (value) {
	      var type = buildInputFieldType(value.type);
	      return {
	        type: type,
	        description: (0, _buildASTSchema.getDescription)(value),
	        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),
	        astNode: value
	      };
	    });
	  }
	
	  function buildInputFieldType(typeNode) {
	    if (typeNode.kind === Kind.LIST_TYPE) {
	      return new _definition.GraphQLList(buildInputFieldType(typeNode.type));
	    }
	    if (typeNode.kind === Kind.NON_NULL_TYPE) {
	      var nullableType = buildInputFieldType(typeNode.type);
	      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getInputTypeFromAST(typeNode);
	  }
	
	  function buildOutputFieldType(typeNode) {
	    if (typeNode.kind === Kind.LIST_TYPE) {
	      return new _definition.GraphQLList(buildOutputFieldType(typeNode.type));
	    }
	    if (typeNode.kind === Kind.NON_NULL_TYPE) {
	      var nullableType = buildOutputFieldType(typeNode.type);
	      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;
	      return new _definition.GraphQLNonNull(nullableType);
	    }
	    return getOutputTypeFromAST(typeNode);
	  }
	}
	
	function cannotExecuteExtendedSchema() {
	  throw new Error('Extended Schema cannot use Interface or Union types for execution.');
	}

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DangerousChangeType = exports.BreakingChangeType = undefined;
	exports.findBreakingChanges = findBreakingChanges;
	exports.findDangerousChanges = findDangerousChanges;
	exports.findRemovedTypes = findRemovedTypes;
	exports.findTypesThatChangedKind = findTypesThatChangedKind;
	exports.findArgChanges = findArgChanges;
	exports.findFieldsThatChangedType = findFieldsThatChangedType;
	exports.findFieldsThatChangedTypeOnInputObjectTypes = findFieldsThatChangedTypeOnInputObjectTypes;
	exports.findTypesRemovedFromUnions = findTypesRemovedFromUnions;
	exports.findTypesAddedToUnions = findTypesAddedToUnions;
	exports.findValuesRemovedFromEnums = findValuesRemovedFromEnums;
	exports.findValuesAddedToEnums = findValuesAddedToEnums;
	exports.findInterfacesRemovedFromObjectTypes = findInterfacesRemovedFromObjectTypes;
	
	var _definition = __webpack_require__(7);
	
	var _schema = __webpack_require__(34);
	
	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var BreakingChangeType = exports.BreakingChangeType = {
	  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',
	  FIELD_REMOVED: 'FIELD_REMOVED',
	  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',
	  TYPE_REMOVED: 'TYPE_REMOVED',
	  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',
	  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',
	  ARG_REMOVED: 'ARG_REMOVED',
	  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',
	  NON_NULL_ARG_ADDED: 'NON_NULL_ARG_ADDED',
	  NON_NULL_INPUT_FIELD_ADDED: 'NON_NULL_INPUT_FIELD_ADDED',
	  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT'
	};
	
	var DangerousChangeType = exports.DangerousChangeType = {
	  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',
	  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',
	  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION'
	};
	
	/**
	 * Given two schemas, returns an Array containing descriptions of all the types
	 * of breaking changes covered by the other functions down below.
	 */
	function findBreakingChanges(oldSchema, newSchema) {
	  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedType(oldSchema, newSchema), findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema));
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of all the types
	 * of potentially dangerous changes covered by the other functions down below.
	 */
	function findDangerousChanges(oldSchema, newSchema) {
	  return [].concat(findArgChanges(oldSchema, newSchema).dangerousChanges, findValuesAddedToEnums(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema));
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing an entire type.
	 */
	function findRemovedTypes(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var breakingChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    if (!newTypeMap[typeName]) {
	      breakingChanges.push({
	        type: BreakingChangeType.TYPE_REMOVED,
	        description: typeName + ' was removed.'
	      });
	    }
	  });
	  return breakingChanges;
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to changing the type of a type.
	 */
	function findTypesThatChangedKind(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var breakingChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    if (!newTypeMap[typeName]) {
	      return;
	    }
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof newType.constructor)) {
	      breakingChanges.push({
	        type: BreakingChangeType.TYPE_CHANGED_KIND,
	        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')
	      });
	    }
	  });
	  return breakingChanges;
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any
	 * breaking or dangerous changes in the newSchema related to arguments
	 * (such as removal or change of type of an argument, or a change in an
	 * argument's default value).
	 */
	function findArgChanges(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var breakingChanges = [];
	  var dangerousChanges = [];
	
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLObjectType || oldType instanceof _definition.GraphQLInterfaceType) || !(newType instanceof oldType.constructor)) {
	      return;
	    }
	
	    var oldTypeFields = oldType.getFields();
	    var newTypeFields = newType.getFields();
	
	    Object.keys(oldTypeFields).forEach(function (fieldName) {
	      if (!newTypeFields[fieldName]) {
	        return;
	      }
	
	      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {
	        var newArgs = newTypeFields[fieldName].args;
	        var newArgDef = newArgs.find(function (arg) {
	          return arg.name === oldArgDef.name;
	        });
	
	        // Arg not present
	        if (!newArgDef) {
	          breakingChanges.push({
	            type: BreakingChangeType.ARG_REMOVED,
	            description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' was removed')
	          });
	        } else {
	          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
	          if (!isSafe) {
	            breakingChanges.push({
	              type: BreakingChangeType.ARG_CHANGED_KIND,
	              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed type from ') + (oldArgDef.type.toString() + ' to ' + newArgDef.type.toString())
	            });
	          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {
	            dangerousChanges.push({
	              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
	              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed defaultValue')
	            });
	          }
	        }
	      });
	      // Check if a non-null arg was added to the field
	      newTypeFields[fieldName].args.forEach(function (newArgDef) {
	        var oldArgs = oldTypeFields[fieldName].args;
	        var oldArgDef = oldArgs.find(function (arg) {
	          return arg.name === newArgDef.name;
	        });
	        if (!oldArgDef && newArgDef.type instanceof _definition.GraphQLNonNull) {
	          breakingChanges.push({
	            type: BreakingChangeType.NON_NULL_ARG_ADDED,
	            description: 'A non-null arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')
	          });
	        }
	      });
	    });
	  });
	
	  return {
	    breakingChanges: breakingChanges,
	    dangerousChanges: dangerousChanges
	  };
	}
	
	function typeKindName(type) {
	  if (type instanceof _definition.GraphQLScalarType) {
	    return 'a Scalar type';
	  }
	  if (type instanceof _definition.GraphQLObjectType) {
	    return 'an Object type';
	  }
	  if (type instanceof _definition.GraphQLInterfaceType) {
	    return 'an Interface type';
	  }
	  if (type instanceof _definition.GraphQLUnionType) {
	    return 'a Union type';
	  }
	  if (type instanceof _definition.GraphQLEnumType) {
	    return 'an Enum type';
	  }
	  if (type instanceof _definition.GraphQLInputObjectType) {
	    return 'an Input type';
	  }
	  throw new TypeError('Unknown type ' + type.constructor.name);
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to the fields on a type. This includes if
	 * a field has been removed from a type, if a field has changed type, or if
	 * a non-null field is added to an input type.
	 */
	function findFieldsThatChangedType(oldSchema, newSchema) {
	  return [].concat(findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema));
	}
	
	function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var breakingFieldChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLObjectType || oldType instanceof _definition.GraphQLInterfaceType) || !(newType instanceof oldType.constructor)) {
	      return;
	    }
	
	    var oldTypeFieldsDef = oldType.getFields();
	    var newTypeFieldsDef = newType.getFields();
	    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
	      // Check if the field is missing on the type in the new schema.
	      if (!(fieldName in newTypeFieldsDef)) {
	        breakingFieldChanges.push({
	          type: BreakingChangeType.FIELD_REMOVED,
	          description: typeName + '.' + fieldName + ' was removed.'
	        });
	      } else {
	        var oldFieldType = oldTypeFieldsDef[fieldName].type;
	        var newFieldType = newTypeFieldsDef[fieldName].type;
	        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);
	        if (!isSafe) {
	          var oldFieldTypeString = (0, _definition.isNamedType)(oldFieldType) ? oldFieldType.name : oldFieldType.toString();
	          var newFieldTypeString = (0, _definition.isNamedType)(newFieldType) ? newFieldType.name : newFieldType.toString();
	          breakingFieldChanges.push({
	            type: BreakingChangeType.FIELD_CHANGED_KIND,
	            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')
	          });
	        }
	      }
	    });
	  });
	  return breakingFieldChanges;
	}
	
	function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var breakingFieldChanges = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLInputObjectType) || !(newType instanceof _definition.GraphQLInputObjectType)) {
	      return;
	    }
	
	    var oldTypeFieldsDef = oldType.getFields();
	    var newTypeFieldsDef = newType.getFields();
	    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
	      // Check if the field is missing on the type in the new schema.
	      if (!(fieldName in newTypeFieldsDef)) {
	        breakingFieldChanges.push({
	          type: BreakingChangeType.FIELD_REMOVED,
	          description: typeName + '.' + fieldName + ' was removed.'
	        });
	      } else {
	        var oldFieldType = oldTypeFieldsDef[fieldName].type;
	        var newFieldType = newTypeFieldsDef[fieldName].type;
	
	        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);
	        if (!isSafe) {
	          var oldFieldTypeString = (0, _definition.isNamedType)(oldFieldType) ? oldFieldType.name : oldFieldType.toString();
	          var newFieldTypeString = (0, _definition.isNamedType)(newFieldType) ? newFieldType.name : newFieldType.toString();
	          breakingFieldChanges.push({
	            type: BreakingChangeType.FIELD_CHANGED_KIND,
	            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')
	          });
	        }
	      }
	    });
	    // Check if a non-null field was added to the input object type
	    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {
	      if (!(fieldName in oldTypeFieldsDef) && newTypeFieldsDef[fieldName].type instanceof _definition.GraphQLNonNull) {
	        breakingFieldChanges.push({
	          type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,
	          description: 'A non-null field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')
	        });
	      }
	    });
	  });
	  return breakingFieldChanges;
	}
	
	function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
	  if ((0, _definition.isNamedType)(oldType)) {
	    return (
	      // if they're both named types, see if their names are equivalent
	      (0, _definition.isNamedType)(newType) && oldType.name === newType.name ||
	      // moving from nullable to non-null of the same underlying type is safe
	      newType instanceof _definition.GraphQLNonNull && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
	    );
	  } else if (oldType instanceof _definition.GraphQLList) {
	    return (
	      // if they're both lists, make sure the underlying types are compatible
	      newType instanceof _definition.GraphQLList && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||
	      // moving from nullable to non-null of the same underlying type is safe
	      newType instanceof _definition.GraphQLNonNull && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
	    );
	  } else if (oldType instanceof _definition.GraphQLNonNull) {
	    // if they're both non-null, make sure the underlying types are compatible
	    return newType instanceof _definition.GraphQLNonNull && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
	  }
	  return false;
	}
	
	function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
	  if ((0, _definition.isNamedType)(oldType)) {
	    // if they're both named types, see if their names are equivalent
	    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
	  } else if (oldType instanceof _definition.GraphQLList) {
	    // if they're both lists, make sure the underlying types are compatible
	    return newType instanceof _definition.GraphQLList && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
	  } else if (oldType instanceof _definition.GraphQLNonNull) {
	    return (
	      // if they're both non-null, make sure the underlying types are
	      // compatible
	      newType instanceof _definition.GraphQLNonNull && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||
	      // moving from non-null to nullable of the same underlying type is safe
	      !(newType instanceof _definition.GraphQLNonNull) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
	    );
	  }
	  return false;
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing types from a union type.
	 */
	function findTypesRemovedFromUnions(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var typesRemovedFromUnion = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLUnionType) || !(newType instanceof _definition.GraphQLUnionType)) {
	      return;
	    }
	    var typeNamesInNewUnion = Object.create(null);
	    newType.getTypes().forEach(function (type) {
	      typeNamesInNewUnion[type.name] = true;
	    });
	    oldType.getTypes().forEach(function (type) {
	      if (!typeNamesInNewUnion[type.name]) {
	        typesRemovedFromUnion.push({
	          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
	          description: type.name + ' was removed from union type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return typesRemovedFromUnion;
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any dangerous
	 * changes in the newSchema related to adding types to a union type.
	 */
	function findTypesAddedToUnions(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var typesAddedToUnion = [];
	  Object.keys(newTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLUnionType) || !(newType instanceof _definition.GraphQLUnionType)) {
	      return;
	    }
	    var typeNamesInOldUnion = Object.create(null);
	    oldType.getTypes().forEach(function (type) {
	      typeNamesInOldUnion[type.name] = true;
	    });
	    newType.getTypes().forEach(function (type) {
	      if (!typeNamesInOldUnion[type.name]) {
	        typesAddedToUnion.push({
	          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
	          description: type.name + ' was added to union type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return typesAddedToUnion;
	}
	/**
	 * Given two schemas, returns an Array containing descriptions of any breaking
	 * changes in the newSchema related to removing values from an enum type.
	 */
	function findValuesRemovedFromEnums(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var valuesRemovedFromEnums = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLEnumType) || !(newType instanceof _definition.GraphQLEnumType)) {
	      return;
	    }
	    var valuesInNewEnum = Object.create(null);
	    newType.getValues().forEach(function (value) {
	      valuesInNewEnum[value.name] = true;
	    });
	    oldType.getValues().forEach(function (value) {
	      if (!valuesInNewEnum[value.name]) {
	        valuesRemovedFromEnums.push({
	          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
	          description: value.name + ' was removed from enum type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return valuesRemovedFromEnums;
	}
	
	/**
	 * Given two schemas, returns an Array containing descriptions of any dangerous
	 * changes in the newSchema related to adding values to an enum type.
	 */
	function findValuesAddedToEnums(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	
	  var valuesAddedToEnums = [];
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLEnumType) || !(newType instanceof _definition.GraphQLEnumType)) {
	      return;
	    }
	
	    var valuesInOldEnum = Object.create(null);
	    oldType.getValues().forEach(function (value) {
	      valuesInOldEnum[value.name] = true;
	    });
	    newType.getValues().forEach(function (value) {
	      if (!valuesInOldEnum[value.name]) {
	        valuesAddedToEnums.push({
	          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
	          description: value.name + ' was added to enum type ' + typeName + '.'
	        });
	      }
	    });
	  });
	  return valuesAddedToEnums;
	}
	
	function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {
	  var oldTypeMap = oldSchema.getTypeMap();
	  var newTypeMap = newSchema.getTypeMap();
	  var breakingChanges = [];
	
	  Object.keys(oldTypeMap).forEach(function (typeName) {
	    var oldType = oldTypeMap[typeName];
	    var newType = newTypeMap[typeName];
	    if (!(oldType instanceof _definition.GraphQLObjectType) || !(newType instanceof _definition.GraphQLObjectType)) {
	      return;
	    }
	
	    var oldInterfaces = oldType.getInterfaces();
	    var newInterfaces = newType.getInterfaces();
	    oldInterfaces.forEach(function (oldInterface) {
	      if (!newInterfaces.some(function (int) {
	        return int.name === oldInterface.name;
	      })) {
	        breakingChanges.push({
	          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
	          description: typeName + ' no longer implements interface ' + (oldInterface.name + '.')
	        });
	      }
	    });
	  });
	  return breakingChanges;
	}

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findDeprecatedUsages = findDeprecatedUsages;
	
	var _GraphQLError = __webpack_require__(57);
	
	var _visitor = __webpack_require__(80);
	
	var _definition = __webpack_require__(7);
	
	var _schema = __webpack_require__(34);
	
	var _TypeInfo = __webpack_require__(166);
	
	/**
	 * A validation rule which reports deprecated usages.
	 *
	 * Returns a list of GraphQLError instances describing each deprecated use.
	 */
	function findDeprecatedUsages(schema, ast) {
	  var errors = [];
	  var typeInfo = new _TypeInfo.TypeInfo(schema);
	
	  (0, _visitor.visit)(ast, (0, _visitor.visitWithTypeInfo)(typeInfo, {
	    Field: function Field(node) {
	      var fieldDef = typeInfo.getFieldDef();
	      if (fieldDef && fieldDef.isDeprecated) {
	        var parentType = typeInfo.getParentType();
	        if (parentType) {
	          var reason = fieldDef.deprecationReason;
	          errors.push(new _GraphQLError.GraphQLError('The field ' + parentType.name + '.' + fieldDef.name + ' is deprecated.' + (reason ? ' ' + reason : ''), [node]));
	        }
	      }
	    },
	    EnumValue: function EnumValue(node) {
	      var enumVal = typeInfo.getEnumValue();
	      if (enumVal && enumVal.isDeprecated) {
	        var type = (0, _definition.getNamedType)(typeInfo.getInputType());
	        if (type) {
	          var reason = enumVal.deprecationReason;
	          errors.push(new _GraphQLError.GraphQLError('The enum value ' + type.name + '.' + enumVal.name + ' is deprecated.' + (reason ? ' ' + reason : ''), [node]));
	        }
	      }
	    }
	  }));
	
	  return errors;
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _introspectionQuery = __webpack_require__(624);
	
	Object.defineProperty(exports, 'introspectionQuery', {
	  enumerable: true,
	  get: function get() {
	    return _introspectionQuery.introspectionQuery;
	  }
	});
	
	var _getOperationAST = __webpack_require__(262);
	
	Object.defineProperty(exports, 'getOperationAST', {
	  enumerable: true,
	  get: function get() {
	    return _getOperationAST.getOperationAST;
	  }
	});
	
	var _buildClientSchema = __webpack_require__(618);
	
	Object.defineProperty(exports, 'buildClientSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildClientSchema.buildClientSchema;
	  }
	});
	
	var _buildASTSchema = __webpack_require__(261);
	
	Object.defineProperty(exports, 'buildASTSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildASTSchema.buildASTSchema;
	  }
	});
	Object.defineProperty(exports, 'buildSchema', {
	  enumerable: true,
	  get: function get() {
	    return _buildASTSchema.buildSchema;
	  }
	});
	
	var _extendSchema = __webpack_require__(620);
	
	Object.defineProperty(exports, 'extendSchema', {
	  enumerable: true,
	  get: function get() {
	    return _extendSchema.extendSchema;
	  }
	});
	
	var _schemaPrinter = __webpack_require__(625);
	
	Object.defineProperty(exports, 'printSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schemaPrinter.printSchema;
	  }
	});
	Object.defineProperty(exports, 'printType', {
	  enumerable: true,
	  get: function get() {
	    return _schemaPrinter.printType;
	  }
	});
	Object.defineProperty(exports, 'printIntrospectionSchema', {
	  enumerable: true,
	  get: function get() {
	    return _schemaPrinter.printIntrospectionSchema;
	  }
	});
	
	var _typeFromAST = __webpack_require__(35);
	
	Object.defineProperty(exports, 'typeFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _typeFromAST.typeFromAST;
	  }
	});
	
	var _valueFromAST = __webpack_require__(81);
	
	Object.defineProperty(exports, 'valueFromAST', {
	  enumerable: true,
	  get: function get() {
	    return _valueFromAST.valueFromAST;
	  }
	});
	
	var _astFromValue = __webpack_require__(168);
	
	Object.defineProperty(exports, 'astFromValue', {
	  enumerable: true,
	  get: function get() {
	    return _astFromValue.astFromValue;
	  }
	});
	
	var _TypeInfo = __webpack_require__(166);
	
	Object.defineProperty(exports, 'TypeInfo', {
	  enumerable: true,
	  get: function get() {
	    return _TypeInfo.TypeInfo;
	  }
	});
	
	var _isValidJSValue = __webpack_require__(263);
	
	Object.defineProperty(exports, 'isValidJSValue', {
	  enumerable: true,
	  get: function get() {
	    return _isValidJSValue.isValidJSValue;
	  }
	});
	
	var _isValidLiteralValue = __webpack_require__(109);
	
	Object.defineProperty(exports, 'isValidLiteralValue', {
	  enumerable: true,
	  get: function get() {
	    return _isValidLiteralValue.isValidLiteralValue;
	  }
	});
	
	var _concatAST = __webpack_require__(619);
	
	Object.defineProperty(exports, 'concatAST', {
	  enumerable: true,
	  get: function get() {
	    return _concatAST.concatAST;
	  }
	});
	
	var _separateOperations = __webpack_require__(626);
	
	Object.defineProperty(exports, 'separateOperations', {
	  enumerable: true,
	  get: function get() {
	    return _separateOperations.separateOperations;
	  }
	});
	
	var _typeComparators = __webpack_require__(110);
	
	Object.defineProperty(exports, 'isEqualType', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.isEqualType;
	  }
	});
	Object.defineProperty(exports, 'isTypeSubTypeOf', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.isTypeSubTypeOf;
	  }
	});
	Object.defineProperty(exports, 'doTypesOverlap', {
	  enumerable: true,
	  get: function get() {
	    return _typeComparators.doTypesOverlap;
	  }
	});
	
	var _assertValidName = __webpack_require__(167);
	
	Object.defineProperty(exports, 'assertValidName', {
	  enumerable: true,
	  get: function get() {
	    return _assertValidName.assertValidName;
	  }
	});
	
	var _findBreakingChanges = __webpack_require__(621);
	
	Object.defineProperty(exports, 'BreakingChangeType', {
	  enumerable: true,
	  get: function get() {
	    return _findBreakingChanges.BreakingChangeType;
	  }
	});
	Object.defineProperty(exports, 'DangerousChangeType', {
	  enumerable: true,
	  get: function get() {
	    return _findBreakingChanges.DangerousChangeType;
	  }
	});
	Object.defineProperty(exports, 'findBreakingChanges', {
	  enumerable: true,
	  get: function get() {
	    return _findBreakingChanges.findBreakingChanges;
	  }
	});
	Object.defineProperty(exports, 'findDangerousChanges', {
	  enumerable: true,
	  get: function get() {
	    return _findBreakingChanges.findDangerousChanges;
	  }
	});
	
	var _findDeprecatedUsages = __webpack_require__(622);
	
	Object.defineProperty(exports, 'findDeprecatedUsages', {
	  enumerable: true,
	  get: function get() {
	    return _findDeprecatedUsages.findDeprecatedUsages;
	  }
	});

/***/ }),
/* 624 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var introspectionQuery = exports.introspectionQuery = '\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n'; /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright (c) 2015-present, Facebook, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This source code is licensed under the MIT license found in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * LICENSE file in the root directory of this source tree.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * 
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.printSchema = printSchema;
	exports.printIntrospectionSchema = printIntrospectionSchema;
	exports.printType = printType;
	
	var _invariant = __webpack_require__(17);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _isNullish = __webpack_require__(46);
	
	var _isNullish2 = _interopRequireDefault(_isNullish);
	
	var _isInvalid = __webpack_require__(79);
	
	var _isInvalid2 = _interopRequireDefault(_isInvalid);
	
	var _astFromValue = __webpack_require__(168);
	
	var _printer = __webpack_require__(27);
	
	var _definition = __webpack_require__(7);
	
	var _scalars = __webpack_require__(42);
	
	var _directives = __webpack_require__(33);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function printSchema(schema) {
	  return printFilteredSchema(schema, function (n) {
	    return !isSpecDirective(n);
	  }, isDefinedType);
	}
	
	function printIntrospectionSchema(schema) {
	  return printFilteredSchema(schema, isSpecDirective, isIntrospectionType);
	}
	
	function isSpecDirective(directiveName) {
	  return directiveName === 'skip' || directiveName === 'include' || directiveName === 'deprecated';
	}
	
	function isDefinedType(typename) {
	  return !isIntrospectionType(typename) && !isBuiltInScalar(typename);
	}
	
	function isIntrospectionType(typename) {
	  return typename.indexOf('__') === 0;
	}
	
	function isBuiltInScalar(typename) {
	  return typename === 'String' || typename === 'Boolean' || typename === 'Int' || typename === 'Float' || typename === 'ID';
	}
	
	function printFilteredSchema(schema, directiveFilter, typeFilter) {
	  var directives = schema.getDirectives().filter(function (directive) {
	    return directiveFilter(directive.name);
	  });
	  var typeMap = schema.getTypeMap();
	  var types = Object.keys(typeMap).filter(typeFilter).sort(function (name1, name2) {
	    return name1.localeCompare(name2);
	  }).map(function (typeName) {
	    return typeMap[typeName];
	  });
	
	  return [printSchemaDefinition(schema)].concat(directives.map(printDirective), types.map(printType)).filter(Boolean).join('\n\n') + '\n';
	}
	
	function printSchemaDefinition(schema) {
	  if (isSchemaOfCommonNames(schema)) {
	    return;
	  }
	
	  var operationTypes = [];
	
	  var queryType = schema.getQueryType();
	  if (queryType) {
	    operationTypes.push('  query: ' + queryType.name);
	  }
	
	  var mutationType = schema.getMutationType();
	  if (mutationType) {
	    operationTypes.push('  mutation: ' + mutationType.name);
	  }
	
	  var subscriptionType = schema.getSubscriptionType();
	  if (subscriptionType) {
	    operationTypes.push('  subscription: ' + subscriptionType.name);
	  }
	
	  return 'schema {\n' + operationTypes.join('\n') + '\n}';
	}
	
	/**
	 * GraphQL schema define root types for each type of operation. These types are
	 * the same as any other type and can be named in any manner, however there is
	 * a common naming convention:
	 *
	 *   schema {
	 *     query: Query
	 *     mutation: Mutation
	 *   }
	 *
	 * When using this naming convention, the schema description can be omitted.
	 */
	function isSchemaOfCommonNames(schema) {
	  var queryType = schema.getQueryType();
	  if (queryType && queryType.name !== 'Query') {
	    return false;
	  }
	
	  var mutationType = schema.getMutationType();
	  if (mutationType && mutationType.name !== 'Mutation') {
	    return false;
	  }
	
	  var subscriptionType = schema.getSubscriptionType();
	  if (subscriptionType && subscriptionType.name !== 'Subscription') {
	    return false;
	  }
	
	  return true;
	}
	
	function printType(type) {
	  if (type instanceof _definition.GraphQLScalarType) {
	    return printScalar(type);
	  } else if (type instanceof _definition.GraphQLObjectType) {
	    return printObject(type);
	  } else if (type instanceof _definition.GraphQLInterfaceType) {
	    return printInterface(type);
	  } else if (type instanceof _definition.GraphQLUnionType) {
	    return printUnion(type);
	  } else if (type instanceof _definition.GraphQLEnumType) {
	    return printEnum(type);
	  }
	  !(type instanceof _definition.GraphQLInputObjectType) ? (0, _invariant2.default)(0) : void 0;
	  return printInputObject(type);
	}
	
	function printScalar(type) {
	  return printDescription(type) + ('scalar ' + type.name);
	}
	
	function printObject(type) {
	  var interfaces = type.getInterfaces();
	  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {
	    return i.name;
	  }).join(', ') : '';
	  return printDescription(type) + ('type ' + type.name + implementedInterfaces + ' {\n') + printFields(type) + '\n' + '}';
	}
	
	function printInterface(type) {
	  return printDescription(type) + ('interface ' + type.name + ' {\n') + printFields(type) + '\n' + '}';
	}
	
	function printUnion(type) {
	  return printDescription(type) + ('union ' + type.name + ' = ' + type.getTypes().join(' | '));
	}
	
	function printEnum(type) {
	  return printDescription(type) + ('enum ' + type.name + ' {\n') + printEnumValues(type.getValues()) + '\n' + '}';
	}
	
	function printEnumValues(values) {
	  return values.map(function (value, i) {
	    return printDescription(value, '  ', !i) + '  ' + value.name + printDeprecated(value);
	  }).join('\n');
	}
	
	function printInputObject(type) {
	  var fieldMap = type.getFields();
	  var fields = Object.keys(fieldMap).map(function (fieldName) {
	    return fieldMap[fieldName];
	  });
	  return printDescription(type) + ('input ' + type.name + ' {\n') + fields.map(function (f, i) {
	    return printDescription(f, '  ', !i) + '  ' + printInputValue(f);
	  }).join('\n') + '\n' + '}';
	}
	
	function printFields(type) {
	  var fieldMap = type.getFields();
	  var fields = Object.keys(fieldMap).map(function (fieldName) {
	    return fieldMap[fieldName];
	  });
	  return fields.map(function (f, i) {
	    return printDescription(f, '  ', !i) + '  ' + f.name + printArgs(f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);
	  }).join('\n');
	}
	
	function printArgs(args) {
	  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	
	  if (args.length === 0) {
	    return '';
	  }
	
	  // If every arg does not have a description, print them on one line.
	  if (args.every(function (arg) {
	    return !arg.description;
	  })) {
	    return '(' + args.map(printInputValue).join(', ') + ')';
	  }
	
	  return '(\n' + args.map(function (arg, i) {
	    return printDescription(arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);
	  }).join('\n') + '\n' + indentation + ')';
	}
	
	function printInputValue(arg) {
	  var argDecl = arg.name + ': ' + String(arg.type);
	  if (!(0, _isInvalid2.default)(arg.defaultValue)) {
	    argDecl += ' = ' + (0, _printer.print)((0, _astFromValue.astFromValue)(arg.defaultValue, arg.type));
	  }
	  return argDecl;
	}
	
	function printDirective(directive) {
	  return printDescription(directive) + 'directive @' + directive.name + printArgs(directive.args) + ' on ' + directive.locations.join(' | ');
	}
	
	function printDeprecated(fieldOrEnumVal) {
	  var reason = fieldOrEnumVal.deprecationReason;
	  if ((0, _isNullish2.default)(reason)) {
	    return '';
	  }
	  if (reason === '' || reason === _directives.DEFAULT_DEPRECATION_REASON) {
	    return ' @deprecated';
	  }
	  return ' @deprecated(reason: ' + (0, _printer.print)((0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString)) + ')';
	}
	
	function printDescription(def) {
	  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var firstInBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	  if (!def.description) {
	    return '';
	  }
	  var lines = def.description.split('\n');
	  var description = indentation && !firstInBlock ? '\n' : '';
	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i] === '') {
	      description += indentation + '#\n';
	    } else {
	      // For > 120 character long lines, cut at space boundaries into sublines
	      // of ~80 chars.
	      var sublines = breakLine(lines[i], 120 - indentation.length);
	      for (var j = 0; j < sublines.length; j++) {
	        description += indentation + '# ' + sublines[j] + '\n';
	      }
	    }
	  }
	  return description;
	}
	
	function breakLine(line, len) {
	  if (line.length < len + 5) {
	    return [line];
	  }
	  var parts = line.split(new RegExp('((?: |^).{15,' + (len - 40) + '}(?= |$))'));
	  if (parts.length < 4) {
	    return [line];
	  }
	  var sublines = [parts[0] + parts[1] + parts[2]];
	  for (var i = 3; i < parts.length; i += 2) {
	    sublines.push(parts[i].slice(1) + parts[i + 1]);
	  }
	  return sublines;
	}

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.separateOperations = separateOperations;
	
	var _visitor = __webpack_require__(80);
	
	/**
	 * separateOperations accepts a single AST document which may contain many
	 * operations and fragments and returns a collection of AST documents each of
	 * which contains a single operation as well the fragment definitions it
	 * refers to.
	 */
	function separateOperations(documentAST) {
	  var operations = [];
	  var fragments = Object.create(null);
	  var positions = new Map();
	  var depGraph = Object.create(null);
	  var fromName = void 0;
	  var idx = 0;
	
	  // Populate metadata and build a dependency graph.
	  (0, _visitor.visit)(documentAST, {
	    OperationDefinition: function OperationDefinition(node) {
	      fromName = opName(node);
	      operations.push(node);
	      positions.set(node, idx++);
	    },
	    FragmentDefinition: function FragmentDefinition(node) {
	      fromName = node.name.value;
	      fragments[fromName] = node;
	      positions.set(node, idx++);
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      var toName = node.name.value;
	      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;
	    }
	  });
	
	  // For each operation, produce a new synthesized AST which includes only what
	  // is necessary for completing that operation.
	  var separatedDocumentASTs = Object.create(null);
	  operations.forEach(function (operation) {
	    var operationName = opName(operation);
	    var dependencies = Object.create(null);
	    collectTransitiveDependencies(dependencies, depGraph, operationName);
	
	    // The list of definition nodes to be included for this operation, sorted
	    // to retain the same order as the original document.
	    var definitions = [operation];
	    Object.keys(dependencies).forEach(function (name) {
	      definitions.push(fragments[name]);
	    });
	    definitions.sort(function (n1, n2) {
	      return (positions.get(n1) || 0) - (positions.get(n2) || 0);
	    });
	
	    separatedDocumentASTs[operationName] = {
	      kind: 'Document',
	      definitions: definitions
	    };
	  });
	
	  return separatedDocumentASTs;
	} /**
	   * Copyright (c) 2015-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   *
	   * 
	   */
	
	// Provides the empty string for anonymous operations.
	function opName(operation) {
	  return operation.name ? operation.name.value : '';
	}
	
	// From a dependency graph, collects a list of transitive dependencies by
	// recursing through a dependency graph.
	function collectTransitiveDependencies(collected, depGraph, fromName) {
	  var immediateDeps = depGraph[fromName];
	  if (immediateDeps) {
	    Object.keys(immediateDeps).forEach(function (toName) {
	      if (!collected[toName]) {
	        collected[toName] = true;
	        collectTransitiveDependencies(collected, depGraph, toName);
	      }
	    });
	  }
	}

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _validate = __webpack_require__(290);
	
	Object.defineProperty(exports, 'validate', {
	  enumerable: true,
	  get: function get() {
	    return _validate.validate;
	  }
	});
	Object.defineProperty(exports, 'ValidationContext', {
	  enumerable: true,
	  get: function get() {
	    return _validate.ValidationContext;
	  }
	});
	
	var _specifiedRules = __webpack_require__(289);
	
	Object.defineProperty(exports, 'specifiedRules', {
	  enumerable: true,
	  get: function get() {
	    return _specifiedRules.specifiedRules;
	  }
	});
	
	var _ArgumentsOfCorrectType = __webpack_require__(264);
	
	Object.defineProperty(exports, 'ArgumentsOfCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _ArgumentsOfCorrectType.ArgumentsOfCorrectType;
	  }
	});
	
	var _DefaultValuesOfCorrectType = __webpack_require__(265);
	
	Object.defineProperty(exports, 'DefaultValuesOfCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _DefaultValuesOfCorrectType.DefaultValuesOfCorrectType;
	  }
	});
	
	var _FieldsOnCorrectType = __webpack_require__(266);
	
	Object.defineProperty(exports, 'FieldsOnCorrectTypeRule', {
	  enumerable: true,
	  get: function get() {
	    return _FieldsOnCorrectType.FieldsOnCorrectType;
	  }
	});
	
	var _FragmentsOnCompositeTypes = __webpack_require__(267);
	
	Object.defineProperty(exports, 'FragmentsOnCompositeTypesRule', {
	  enumerable: true,
	  get: function get() {
	    return _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes;
	  }
	});
	
	var _KnownArgumentNames = __webpack_require__(268);
	
	Object.defineProperty(exports, 'KnownArgumentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _KnownArgumentNames.KnownArgumentNames;
	  }
	});
	
	var _KnownDirectives = __webpack_require__(269);
	
	Object.defineProperty(exports, 'KnownDirectivesRule', {
	  enumerable: true,
	  get: function get() {
	    return _KnownDirectives.KnownDirectives;
	  }
	});
	
	var _KnownFragmentNames = __webpack_require__(270);
	
	Object.defineProperty(exports, 'KnownFragmentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _KnownFragmentNames.KnownFragmentNames;
	  }
	});
	
	var _KnownTypeNames = __webpack_require__(271);
	
	Object.defineProperty(exports, 'KnownTypeNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _KnownTypeNames.KnownTypeNames;
	  }
	});
	
	var _LoneAnonymousOperation = __webpack_require__(272);
	
	Object.defineProperty(exports, 'LoneAnonymousOperationRule', {
	  enumerable: true,
	  get: function get() {
	    return _LoneAnonymousOperation.LoneAnonymousOperation;
	  }
	});
	
	var _NoFragmentCycles = __webpack_require__(273);
	
	Object.defineProperty(exports, 'NoFragmentCyclesRule', {
	  enumerable: true,
	  get: function get() {
	    return _NoFragmentCycles.NoFragmentCycles;
	  }
	});
	
	var _NoUndefinedVariables = __webpack_require__(274);
	
	Object.defineProperty(exports, 'NoUndefinedVariablesRule', {
	  enumerable: true,
	  get: function get() {
	    return _NoUndefinedVariables.NoUndefinedVariables;
	  }
	});
	
	var _NoUnusedFragments = __webpack_require__(169);
	
	Object.defineProperty(exports, 'NoUnusedFragmentsRule', {
	  enumerable: true,
	  get: function get() {
	    return _NoUnusedFragments.NoUnusedFragments;
	  }
	});
	
	var _NoUnusedVariables = __webpack_require__(275);
	
	Object.defineProperty(exports, 'NoUnusedVariablesRule', {
	  enumerable: true,
	  get: function get() {
	    return _NoUnusedVariables.NoUnusedVariables;
	  }
	});
	
	var _OverlappingFieldsCanBeMerged = __webpack_require__(276);
	
	Object.defineProperty(exports, 'OverlappingFieldsCanBeMergedRule', {
	  enumerable: true,
	  get: function get() {
	    return _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged;
	  }
	});
	
	var _PossibleFragmentSpreads = __webpack_require__(277);
	
	Object.defineProperty(exports, 'PossibleFragmentSpreadsRule', {
	  enumerable: true,
	  get: function get() {
	    return _PossibleFragmentSpreads.PossibleFragmentSpreads;
	  }
	});
	
	var _ProvidedNonNullArguments = __webpack_require__(278);
	
	Object.defineProperty(exports, 'ProvidedNonNullArgumentsRule', {
	  enumerable: true,
	  get: function get() {
	    return _ProvidedNonNullArguments.ProvidedNonNullArguments;
	  }
	});
	
	var _ScalarLeafs = __webpack_require__(279);
	
	Object.defineProperty(exports, 'ScalarLeafsRule', {
	  enumerable: true,
	  get: function get() {
	    return _ScalarLeafs.ScalarLeafs;
	  }
	});
	
	var _SingleFieldSubscriptions = __webpack_require__(280);
	
	Object.defineProperty(exports, 'SingleFieldSubscriptionsRule', {
	  enumerable: true,
	  get: function get() {
	    return _SingleFieldSubscriptions.SingleFieldSubscriptions;
	  }
	});
	
	var _UniqueArgumentNames = __webpack_require__(281);
	
	Object.defineProperty(exports, 'UniqueArgumentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueArgumentNames.UniqueArgumentNames;
	  }
	});
	
	var _UniqueDirectivesPerLocation = __webpack_require__(282);
	
	Object.defineProperty(exports, 'UniqueDirectivesPerLocationRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation;
	  }
	});
	
	var _UniqueFragmentNames = __webpack_require__(283);
	
	Object.defineProperty(exports, 'UniqueFragmentNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueFragmentNames.UniqueFragmentNames;
	  }
	});
	
	var _UniqueInputFieldNames = __webpack_require__(284);
	
	Object.defineProperty(exports, 'UniqueInputFieldNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueInputFieldNames.UniqueInputFieldNames;
	  }
	});
	
	var _UniqueOperationNames = __webpack_require__(285);
	
	Object.defineProperty(exports, 'UniqueOperationNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueOperationNames.UniqueOperationNames;
	  }
	});
	
	var _UniqueVariableNames = __webpack_require__(286);
	
	Object.defineProperty(exports, 'UniqueVariableNamesRule', {
	  enumerable: true,
	  get: function get() {
	    return _UniqueVariableNames.UniqueVariableNames;
	  }
	});
	
	var _VariablesAreInputTypes = __webpack_require__(287);
	
	Object.defineProperty(exports, 'VariablesAreInputTypesRule', {
	  enumerable: true,
	  get: function get() {
	    return _VariablesAreInputTypes.VariablesAreInputTypes;
	  }
	});
	
	var _VariablesInAllowedPosition = __webpack_require__(288);
	
	Object.defineProperty(exports, 'VariablesInAllowedPositionRule', {
	  enumerable: true,
	  get: function get() {
	    return _VariablesInAllowedPosition.VariablesInAllowedPosition;
	  }
	});

/***/ }),
/* 628 */
/***/ (function(module, exports) {

	'use strict';
	
	/* Expose. */
	module.exports = parse;
	
	/* Characters */
	var dot = '.'.charCodeAt(0);
	var hash = '#'.charCodeAt(0);
	
	/* Parse a simple CSS selector into a HAST node. */
	function parse(selector) {
	  var id = null;
	  var className = [];
	  var value = selector || '';
	  var name = 'div';
	  var node;
	  var type = null;
	  var index = -1;
	  var code;
	  var length = value.length;
	  var subvalue;
	  var lastIndex;
	
	  node = {
	    type: 'element',
	    tagName: null,
	    properties: {},
	    children: []
	  };
	
	  type = null;
	
	  while (++index <= length) {
	    code = value.charCodeAt(index);
	
	    if (!code || code === dot || code === hash) {
	      subvalue = value.slice(lastIndex, index);
	
	      if (subvalue) {
	        if (type === dot) {
	          className.push(subvalue);
	        } else if (type === hash) {
	          id = subvalue;
	        } else {
	          name = subvalue;
	        }
	      }
	
	      lastIndex = index + 1;
	      type = code;
	    }
	  }
	
	  node.tagName = name;
	
	  if (id) {
	    node.properties.id = id;
	  }
	
	  if (className.length !== 0) {
	    node.properties.className = className;
	  }
	
	  return node;
	}


/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var parseSelector = __webpack_require__(628);
	var camelcase = __webpack_require__(630);
	var propertyInformation = __webpack_require__(678);
	var spaces = __webpack_require__(1041).parse;
	var commas = __webpack_require__(410).parse;
	
	module.exports = h;
	
	/* Hyperscript compatible DSL for creating virtual HAST
	 * trees. */
	function h(selector, properties, children) {
	  var node = parseSelector(selector);
	  var property;
	
	  if (
	    properties &&
	    !children &&
	    (
	      typeof properties === 'string' ||
	      'length' in properties ||
	      isNode(node.tagName, properties)
	    )
	  ) {
	    children = properties;
	    properties = null;
	  }
	
	  if (properties) {
	    for (property in properties) {
	      addProperty(node.properties, property, properties[property]);
	    }
	  }
	
	  addChild(node.children, children);
	
	  if (node.tagName === 'template') {
	    node.content = {type: 'root', children: node.children};
	    node.children = [];
	  }
	
	  return node;
	}
	
	/* Check if `value` is a valid child node of `tagName`. */
	function isNode(tagName, value) {
	  var type = value.type;
	
	  if (typeof type === 'string') {
	    type = type.toLowerCase();
	  }
	
	  if (tagName === 'input' || !type || typeof type !== 'string') {
	    return false;
	  }
	
	  if (typeof value.children === 'object' && 'length' in value.children) {
	    return true;
	  }
	
	  if (tagName === 'button') {
	    return type !== 'menu' &&
	      type !== 'submit' &&
	      type !== 'reset' &&
	      type !== 'button';
	  }
	
	  return 'value' in value;
	}
	
	/* Add `value` as a child to `nodes`. */
	function addChild(nodes, value) {
	  var index;
	  var length;
	
	  if (value === null || value === undefined) {
	    return;
	  }
	
	  if (typeof value === 'string' || typeof value === 'number') {
	    value = {type: 'text', value: String(value)};
	  }
	
	  if (typeof value === 'object' && 'length' in value) {
	    index = -1;
	    length = value.length;
	
	    while (++index < length) {
	      addChild(nodes, value[index]);
	    }
	
	    return;
	  }
	
	  if (typeof value !== 'object' || !('type' in value)) {
	    throw new Error('Expected node, nodes, or string, got `' + value + '`');
	  }
	
	  nodes.push(value);
	}
	
	/* Add `name` and its `value` to `properties`. `properties` can
	 * be prefilled by `parseSelector`: it can have `id` and `className`
	 * properties. */
	function addProperty(properties, name, value) {
	  var info = propertyInformation(name) || {};
	  var result = value;
	  var key;
	
	  /* Ignore nully and NaN values. */
	  if (value === null || value === undefined || value !== value) {
	    return;
	  }
	
	  /* Handle values. */
	  if (name === 'style') {
	    /* Accept `object`. */
	    if (typeof value !== 'string') {
	      result = [];
	
	      for (key in value) {
	        result.push([key, value[key]].join(': '));
	      }
	
	      result = result.join('; ');
	    }
	  } else if (info.spaceSeparated) {
	    /* Accept both `string` and `Array`. */
	    result = typeof value === 'string' ? spaces(result) : result;
	
	    /* Class-names (which can be added both on
	     * the `selector` and here). */
	    if (name === 'class' && properties.className) {
	      result = properties.className.concat(result);
	    }
	  } else if (info.commaSeparated) {
	    /* Accept both `string` and `Array`. */
	    result = typeof value === 'string' ? commas(result) : result;
	  }
	
	  result = parsePrimitive(info, name, result);
	
	  properties[info.propertyName || camelcase(name)] = result;
	}
	
	/* Parse a (list of) primitives. */
	function parsePrimitive(info, name, value) {
	  var result = value;
	  var index;
	  var length;
	
	  if (typeof value === 'object' && 'length' in value) {
	    length = value.length;
	    index = -1;
	    result = [];
	
	    while (++index < length) {
	      result[index] = parsePrimitive(info, name, value[index]);
	    }
	
	    return result;
	  }
	
	  if (info.numeric || info.positiveNumeric) {
	    if (!isNaN(result) && result !== '') {
	      result = Number(result);
	    }
	  } else if (info.boolean || info.overloadedBoolean) {
	    /* Accept `boolean` and `string`. */
	    if (
	      typeof result === 'string' &&
	      (result === '' || value.toLowerCase() === name)
	    ) {
	      result = true;
	    }
	  }
	
	  return result;
	}


/***/ }),
/* 630 */
/***/ (function(module, exports) {

	'use strict';
	
	function preserveCamelCase(str) {
		var isLastCharLower = false;
	
		for (var i = 0; i < str.length; i++) {
			var c = str.charAt(i);
	
			if (isLastCharLower && (/[a-zA-Z]/).test(c) && c.toUpperCase() === c) {
				str = str.substr(0, i) + '-' + str.substr(i);
				isLastCharLower = false;
				i++;
			} else {
				isLastCharLower = (c.toLowerCase() === c);
			}
		}
	
		return str;
	}
	
	module.exports = function () {
		var str = [].map.call(arguments, function (str) {
			return str.trim();
		}).filter(function (str) {
			return str.length;
		}).join('-');
	
		if (!str.length) {
			return '';
		}
	
		if (str.length === 1) {
			return str.toLowerCase();
		}
	
		if (!(/[_.\- ]+/).test(str)) {
			if (str === str.toUpperCase()) {
				return str.toLowerCase();
			}
	
			if (str[0] !== str[0].toLowerCase()) {
				return str[0].toLowerCase() + str.slice(1);
			}
	
			return str;
		}
	
		str = preserveCamelCase(str);
	
		return str
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
			return p1.toUpperCase();
		});
	};


/***/ }),
/* 631 */,
/* 632 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 633 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var alphabetical = __webpack_require__(295);
	var decimal = __webpack_require__(113);
	
	module.exports = alphanumerical;
	
	/* Check if the given character code, or the character
	 * code at the first character, is alphanumerical. */
	function alphanumerical(character) {
	  return alphabetical(character) || decimal(character);
	}


/***/ }),
/* 635 */
/***/ (function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */
	
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}
	
	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}
	
	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ }),
/* 636 */
/***/ (function(module, exports) {

	'use strict';
	
	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	
	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	
	module.exports = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) { return false; }
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};


/***/ }),
/* 637 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = hexadecimal;
	
	/* Check if the given character code, or the character
	 * code at the first character, is hexadecimal. */
	function hexadecimal(character) {
	  var code = typeof character === 'string' ?
	    character.charCodeAt(0) : character;
	
	  return (code >= 97 /* a */ && code <= 102 /* z */) ||
	    (code >= 65 /* A */ && code <= 70 /* Z */) ||
	    (code >= 48 /* A */ && code <= 57 /* Z */);
	}


/***/ }),
/* 638 */
/***/ (function(module, exports) {

	'use strict';
	var toString = Object.prototype.toString;
	
	module.exports = function (x) {
		var prototype;
		return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
	};


/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = __webpack_require__(111);
	var regexExec = RegExp.prototype.exec;
	var gOPD = Object.getOwnPropertyDescriptor;
	
	var tryRegexExecCall = function tryRegexExec(value) {
		try {
			var lastIndex = value.lastIndex;
			value.lastIndex = 0;
	
			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		} finally {
			value.lastIndex = lastIndex;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	
	module.exports = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}
		if (!hasToStringTag) {
			return toStr.call(value) === regexClass;
		}
	
		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}
	
		return tryRegexExecCall(value);
	};


/***/ }),
/* 640 */
/***/ (function(module, exports) {

	'use strict';
	
	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';
	
	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') { return false; }
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') { return true; }
			if (toStr.call(value) !== '[object Symbol]') { return false; }
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}


/***/ }),
/* 641 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = wordCharacter;
	
	var fromCode = String.fromCharCode;
	var re = /\w/;
	
	/* Check if the given character code, or the character
	 * code at the first character, is a word character. */
	function wordCharacter(character) {
	  return re.test(
	    typeof character === 'number' ? fromCode(character) : character.charAt(0)
	  );
	}


/***/ }),
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */
/***/ (function(module, exports) {

	module.exports = {"AElig":"Æ","AMP":"&","Aacute":"Á","Acirc":"Â","Agrave":"À","Aring":"Å","Atilde":"Ã","Auml":"Ä","COPY":"©","Ccedil":"Ç","ETH":"Ð","Eacute":"É","Ecirc":"Ê","Egrave":"È","Euml":"Ë","GT":">","Iacute":"Í","Icirc":"Î","Igrave":"Ì","Iuml":"Ï","LT":"<","Ntilde":"Ñ","Oacute":"Ó","Ocirc":"Ô","Ograve":"Ò","Oslash":"Ø","Otilde":"Õ","Ouml":"Ö","QUOT":"\"","REG":"®","THORN":"Þ","Uacute":"Ú","Ucirc":"Û","Ugrave":"Ù","Uuml":"Ü","Yacute":"Ý","aacute":"á","acirc":"â","acute":"´","aelig":"æ","agrave":"à","amp":"&","aring":"å","atilde":"ã","auml":"ä","brvbar":"¦","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","curren":"¤","deg":"°","divide":"÷","eacute":"é","ecirc":"ê","egrave":"è","eth":"ð","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","iacute":"í","icirc":"î","iexcl":"¡","igrave":"ì","iquest":"¿","iuml":"ï","laquo":"«","lt":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","ntilde":"ñ","oacute":"ó","ocirc":"ô","ograve":"ò","ordf":"ª","ordm":"º","oslash":"ø","otilde":"õ","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\"","raquo":"»","reg":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","thorn":"þ","times":"×","uacute":"ú","ucirc":"û","ugrave":"ù","uml":"¨","uuml":"ü","yacute":"ý","yen":"¥","yuml":"ÿ"}

/***/ }),
/* 660 */
/***/ (function(module, exports) {

	module.exports = {"AEli":"Æ","AElig":"Æ","AM":"&","AMP":"&","Aacut":"Á","Aacute":"Á","Abreve":"Ă","Acir":"Â","Acirc":"Â","Acy":"А","Afr":"𝔄","Agrav":"À","Agrave":"À","Alpha":"Α","Amacr":"Ā","And":"⩓","Aogon":"Ą","Aopf":"𝔸","ApplyFunction":"⁡","Arin":"Å","Aring":"Å","Ascr":"𝒜","Assign":"≔","Atild":"Ã","Atilde":"Ã","Aum":"Ä","Auml":"Ä","Backslash":"∖","Barv":"⫧","Barwed":"⌆","Bcy":"Б","Because":"∵","Bernoullis":"ℬ","Beta":"Β","Bfr":"𝔅","Bopf":"𝔹","Breve":"˘","Bscr":"ℬ","Bumpeq":"≎","CHcy":"Ч","COP":"©","COPY":"©","Cacute":"Ć","Cap":"⋒","CapitalDifferentialD":"ⅅ","Cayleys":"ℭ","Ccaron":"Č","Ccedi":"Ç","Ccedil":"Ç","Ccirc":"Ĉ","Cconint":"∰","Cdot":"Ċ","Cedilla":"¸","CenterDot":"·","Cfr":"ℭ","Chi":"Χ","CircleDot":"⊙","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","Colon":"∷","Colone":"⩴","Congruent":"≡","Conint":"∯","ContourIntegral":"∮","Copf":"ℂ","Coproduct":"∐","CounterClockwiseContourIntegral":"∳","Cross":"⨯","Cscr":"𝒞","Cup":"⋓","CupCap":"≍","DD":"ⅅ","DDotrahd":"⤑","DJcy":"Ђ","DScy":"Ѕ","DZcy":"Џ","Dagger":"‡","Darr":"↡","Dashv":"⫤","Dcaron":"Ď","Dcy":"Д","Del":"∇","Delta":"Δ","Dfr":"𝔇","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","Diamond":"⋄","DifferentialD":"ⅆ","Dopf":"𝔻","Dot":"¨","DotDot":"⃜","DotEqual":"≐","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrow":"↓","DownArrowBar":"⤓","DownArrowUpArrow":"⇵","DownBreve":"̑","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVector":"↽","DownLeftVectorBar":"⥖","DownRightTeeVector":"⥟","DownRightVector":"⇁","DownRightVectorBar":"⥗","DownTee":"⊤","DownTeeArrow":"↧","Downarrow":"⇓","Dscr":"𝒟","Dstrok":"Đ","ENG":"Ŋ","ET":"Ð","ETH":"Ð","Eacut":"É","Eacute":"É","Ecaron":"Ě","Ecir":"Ê","Ecirc":"Ê","Ecy":"Э","Edot":"Ė","Efr":"𝔈","Egrav":"È","Egrave":"È","Element":"∈","Emacr":"Ē","EmptySmallSquare":"◻","EmptyVerySmallSquare":"▫","Eogon":"Ę","Eopf":"𝔼","Epsilon":"Ε","Equal":"⩵","EqualTilde":"≂","Equilibrium":"⇌","Escr":"ℰ","Esim":"⩳","Eta":"Η","Eum":"Ë","Euml":"Ë","Exists":"∃","ExponentialE":"ⅇ","Fcy":"Ф","Ffr":"𝔉","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","Fopf":"𝔽","ForAll":"∀","Fouriertrf":"ℱ","Fscr":"ℱ","GJcy":"Ѓ","G":">","GT":">","Gamma":"Γ","Gammad":"Ϝ","Gbreve":"Ğ","Gcedil":"Ģ","Gcirc":"Ĝ","Gcy":"Г","Gdot":"Ġ","Gfr":"𝔊","Gg":"⋙","Gopf":"𝔾","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","Gt":"≫","HARDcy":"Ъ","Hacek":"ˇ","Hat":"^","Hcirc":"Ĥ","Hfr":"ℌ","HilbertSpace":"ℋ","Hopf":"ℍ","HorizontalLine":"─","Hscr":"ℋ","Hstrok":"Ħ","HumpDownHump":"≎","HumpEqual":"≏","IEcy":"Е","IJlig":"Ĳ","IOcy":"Ё","Iacut":"Í","Iacute":"Í","Icir":"Î","Icirc":"Î","Icy":"И","Idot":"İ","Ifr":"ℑ","Igrav":"Ì","Igrave":"Ì","Im":"ℑ","Imacr":"Ī","ImaginaryI":"ⅈ","Implies":"⇒","Int":"∬","Integral":"∫","Intersection":"⋂","InvisibleComma":"⁣","InvisibleTimes":"⁢","Iogon":"Į","Iopf":"𝕀","Iota":"Ι","Iscr":"ℐ","Itilde":"Ĩ","Iukcy":"І","Ium":"Ï","Iuml":"Ï","Jcirc":"Ĵ","Jcy":"Й","Jfr":"𝔍","Jopf":"𝕁","Jscr":"𝒥","Jsercy":"Ј","Jukcy":"Є","KHcy":"Х","KJcy":"Ќ","Kappa":"Κ","Kcedil":"Ķ","Kcy":"К","Kfr":"𝔎","Kopf":"𝕂","Kscr":"𝒦","LJcy":"Љ","L":"<","LT":"<","Lacute":"Ĺ","Lambda":"Λ","Lang":"⟪","Laplacetrf":"ℒ","Larr":"↞","Lcaron":"Ľ","Lcedil":"Ļ","Lcy":"Л","LeftAngleBracket":"⟨","LeftArrow":"←","LeftArrowBar":"⇤","LeftArrowRightArrow":"⇆","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVector":"⇃","LeftDownVectorBar":"⥙","LeftFloor":"⌊","LeftRightArrow":"↔","LeftRightVector":"⥎","LeftTee":"⊣","LeftTeeArrow":"↤","LeftTeeVector":"⥚","LeftTriangle":"⊲","LeftTriangleBar":"⧏","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVector":"↿","LeftUpVectorBar":"⥘","LeftVector":"↼","LeftVectorBar":"⥒","Leftarrow":"⇐","Leftrightarrow":"⇔","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","LessLess":"⪡","LessSlantEqual":"⩽","LessTilde":"≲","Lfr":"𝔏","Ll":"⋘","Lleftarrow":"⇚","Lmidot":"Ŀ","LongLeftArrow":"⟵","LongLeftRightArrow":"⟷","LongRightArrow":"⟶","Longleftarrow":"⟸","Longleftrightarrow":"⟺","Longrightarrow":"⟹","Lopf":"𝕃","LowerLeftArrow":"↙","LowerRightArrow":"↘","Lscr":"ℒ","Lsh":"↰","Lstrok":"Ł","Lt":"≪","Map":"⤅","Mcy":"М","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","MinusPlus":"∓","Mopf":"𝕄","Mscr":"ℳ","Mu":"Μ","NJcy":"Њ","Nacute":"Ń","Ncaron":"Ň","Ncedil":"Ņ","Ncy":"Н","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","Nfr":"𝔑","NoBreak":"⁠","NonBreakingSpace":" ","Nopf":"ℕ","Not":"⫬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","NotLeftTriangle":"⋪","NotLeftTriangleBar":"⧏̸","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangle":"⋫","NotRightTriangleBar":"⧐̸","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","Nscr":"𝒩","Ntild":"Ñ","Ntilde":"Ñ","Nu":"Ν","OElig":"Œ","Oacut":"Ó","Oacute":"Ó","Ocir":"Ô","Ocirc":"Ô","Ocy":"О","Odblac":"Ő","Ofr":"𝔒","Ograv":"Ò","Ograve":"Ò","Omacr":"Ō","Omega":"Ω","Omicron":"Ο","Oopf":"𝕆","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","Or":"⩔","Oscr":"𝒪","Oslas":"Ø","Oslash":"Ø","Otild":"Õ","Otilde":"Õ","Otimes":"⨷","Oum":"Ö","Ouml":"Ö","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","PartialD":"∂","Pcy":"П","Pfr":"𝔓","Phi":"Φ","Pi":"Π","PlusMinus":"±","Poincareplane":"ℌ","Popf":"ℙ","Pr":"⪻","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","Prime":"″","Product":"∏","Proportion":"∷","Proportional":"∝","Pscr":"𝒫","Psi":"Ψ","QUO":"\"","QUOT":"\"","Qfr":"𝔔","Qopf":"ℚ","Qscr":"𝒬","RBarr":"⤐","RE":"®","REG":"®","Racute":"Ŕ","Rang":"⟫","Rarr":"↠","Rarrtl":"⤖","Rcaron":"Ř","Rcedil":"Ŗ","Rcy":"Р","Re":"ℜ","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","Rfr":"ℜ","Rho":"Ρ","RightAngleBracket":"⟩","RightArrow":"→","RightArrowBar":"⇥","RightArrowLeftArrow":"⇄","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVector":"⇂","RightDownVectorBar":"⥕","RightFloor":"⌋","RightTee":"⊢","RightTeeArrow":"↦","RightTeeVector":"⥛","RightTriangle":"⊳","RightTriangleBar":"⧐","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVector":"↾","RightUpVectorBar":"⥔","RightVector":"⇀","RightVectorBar":"⥓","Rightarrow":"⇒","Ropf":"ℝ","RoundImplies":"⥰","Rrightarrow":"⇛","Rscr":"ℛ","Rsh":"↱","RuleDelayed":"⧴","SHCHcy":"Щ","SHcy":"Ш","SOFTcy":"Ь","Sacute":"Ś","Sc":"⪼","Scaron":"Š","Scedil":"Ş","Scirc":"Ŝ","Scy":"С","Sfr":"𝔖","ShortDownArrow":"↓","ShortLeftArrow":"←","ShortRightArrow":"→","ShortUpArrow":"↑","Sigma":"Σ","SmallCircle":"∘","Sopf":"𝕊","Sqrt":"√","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","Sscr":"𝒮","Star":"⋆","Sub":"⋐","Subset":"⋐","SubsetEqual":"⊆","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","SuchThat":"∋","Sum":"∑","Sup":"⋑","Superset":"⊃","SupersetEqual":"⊇","Supset":"⋑","THOR":"Þ","THORN":"Þ","TRADE":"™","TSHcy":"Ћ","TScy":"Ц","Tab":"\t","Tau":"Τ","Tcaron":"Ť","Tcedil":"Ţ","Tcy":"Т","Tfr":"𝔗","Therefore":"∴","Theta":"Θ","ThickSpace":"  ","ThinSpace":" ","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","Topf":"𝕋","TripleDot":"⃛","Tscr":"𝒯","Tstrok":"Ŧ","Uacut":"Ú","Uacute":"Ú","Uarr":"↟","Uarrocir":"⥉","Ubrcy":"Ў","Ubreve":"Ŭ","Ucir":"Û","Ucirc":"Û","Ucy":"У","Udblac":"Ű","Ufr":"𝔘","Ugrav":"Ù","Ugrave":"Ù","Umacr":"Ū","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","Uopf":"𝕌","UpArrow":"↑","UpArrowBar":"⤒","UpArrowDownArrow":"⇅","UpDownArrow":"↕","UpEquilibrium":"⥮","UpTee":"⊥","UpTeeArrow":"↥","Uparrow":"⇑","Updownarrow":"⇕","UpperLeftArrow":"↖","UpperRightArrow":"↗","Upsi":"ϒ","Upsilon":"Υ","Uring":"Ů","Uscr":"𝒰","Utilde":"Ũ","Uum":"Ü","Uuml":"Ü","VDash":"⊫","Vbar":"⫫","Vcy":"В","Vdash":"⊩","Vdashl":"⫦","Vee":"⋁","Verbar":"‖","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","Vopf":"𝕍","Vscr":"𝒱","Vvdash":"⊪","Wcirc":"Ŵ","Wedge":"⋀","Wfr":"𝔚","Wopf":"𝕎","Wscr":"𝒲","Xfr":"𝔛","Xi":"Ξ","Xopf":"𝕏","Xscr":"𝒳","YAcy":"Я","YIcy":"Ї","YUcy":"Ю","Yacut":"Ý","Yacute":"Ý","Ycirc":"Ŷ","Ycy":"Ы","Yfr":"𝔜","Yopf":"𝕐","Yscr":"𝒴","Yuml":"Ÿ","ZHcy":"Ж","Zacute":"Ź","Zcaron":"Ž","Zcy":"З","Zdot":"Ż","ZeroWidthSpace":"​","Zeta":"Ζ","Zfr":"ℨ","Zopf":"ℤ","Zscr":"𝒵","aacut":"á","aacute":"á","abreve":"ă","ac":"∾","acE":"∾̳","acd":"∿","acir":"â","acirc":"â","acut":"´","acute":"´","acy":"а","aeli":"æ","aelig":"æ","af":"⁡","afr":"𝔞","agrav":"à","agrave":"à","alefsym":"ℵ","aleph":"ℵ","alpha":"α","amacr":"ā","amalg":"⨿","am":"&","amp":"&","and":"∧","andand":"⩕","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsd":"∡","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","aogon":"ą","aopf":"𝕒","ap":"≈","apE":"⩰","apacir":"⩯","ape":"≊","apid":"≋","apos":"'","approx":"≈","approxeq":"≊","arin":"å","aring":"å","ascr":"𝒶","ast":"*","asymp":"≈","asympeq":"≍","atild":"ã","atilde":"ã","aum":"ä","auml":"ä","awconint":"∳","awint":"⨑","bNot":"⫭","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","barvee":"⊽","barwed":"⌅","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","beta":"β","beth":"ℶ","between":"≬","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bnot":"⌐","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxDL":"╗","boxDR":"╔","boxDl":"╖","boxDr":"╓","boxH":"═","boxHD":"╦","boxHU":"╩","boxHd":"╤","boxHu":"╧","boxUL":"╝","boxUR":"╚","boxUl":"╜","boxUr":"╙","boxV":"║","boxVH":"╬","boxVL":"╣","boxVR":"╠","boxVh":"╫","boxVl":"╢","boxVr":"╟","boxbox":"⧉","boxdL":"╕","boxdR":"╒","boxdl":"┐","boxdr":"┌","boxh":"─","boxhD":"╥","boxhU":"╨","boxhd":"┬","boxhu":"┴","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxuL":"╛","boxuR":"╘","boxul":"┘","boxur":"└","boxv":"│","boxvH":"╪","boxvL":"╡","boxvR":"╞","boxvh":"┼","boxvl":"┤","boxvr":"├","bprime":"‵","breve":"˘","brvba":"¦","brvbar":"¦","bscr":"𝒷","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsol":"\\","bsolb":"⧅","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","bumpeq":"≏","cacute":"ć","cap":"∩","capand":"⩄","capbrcup":"⩉","capcap":"⩋","capcup":"⩇","capdot":"⩀","caps":"∩︀","caret":"⁁","caron":"ˇ","ccaps":"⩍","ccaron":"č","ccedi":"ç","ccedil":"ç","ccirc":"ĉ","ccups":"⩌","ccupssm":"⩐","cdot":"ċ","cedi":"¸","cedil":"¸","cemptyv":"⦲","cen":"¢","cent":"¢","centerdot":"·","cfr":"𝔠","chcy":"ч","check":"✓","checkmark":"✓","chi":"χ","cir":"○","cirE":"⧃","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledR":"®","circledS":"Ⓢ","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","clubs":"♣","clubsuit":"♣","colon":":","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","conint":"∮","copf":"𝕔","coprod":"∐","cop":"©","copy":"©","copysr":"℗","crarr":"↵","cross":"✗","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cup":"∪","cupbrcap":"⩈","cupcap":"⩆","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curre":"¤","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dArr":"⇓","dHar":"⥥","dagger":"†","daleth":"ℸ","darr":"↓","dash":"‐","dashv":"⊣","dbkarow":"⤏","dblac":"˝","dcaron":"ď","dcy":"д","dd":"ⅆ","ddagger":"‡","ddarr":"⇊","ddotseq":"⩷","de":"°","deg":"°","delta":"δ","demptyv":"⦱","dfisht":"⥿","dfr":"𝔡","dharl":"⇃","dharr":"⇂","diam":"⋄","diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","digamma":"ϝ","disin":"⋲","div":"÷","divid":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","dopf":"𝕕","dot":"˙","doteq":"≐","doteqdot":"≑","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","downarrow":"↓","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","dscr":"𝒹","dscy":"ѕ","dsol":"⧶","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","dzcy":"џ","dzigrarr":"⟿","eDDot":"⩷","eDot":"≑","eacut":"é","eacute":"é","easter":"⩮","ecaron":"ě","ecir":"ê","ecirc":"ê","ecolon":"≕","ecy":"э","edot":"ė","ee":"ⅇ","efDot":"≒","efr":"𝔢","eg":"⪚","egrav":"è","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","emacr":"ē","empty":"∅","emptyset":"∅","emptyv":"∅","emsp13":" ","emsp14":" ","emsp":" ","eng":"ŋ","ensp":" ","eogon":"ę","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","equals":"=","equest":"≟","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erDot":"≓","erarr":"⥱","escr":"ℯ","esdot":"≐","esim":"≂","eta":"η","et":"ð","eth":"ð","eum":"ë","euml":"ë","euro":"€","excl":"!","exist":"∃","expectation":"ℰ","exponentiale":"ⅇ","fallingdotseq":"≒","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","ffr":"𝔣","filig":"ﬁ","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","fopf":"𝕗","forall":"∀","fork":"⋔","forkv":"⫙","fpartint":"⨍","frac1":"¼","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac3":"¾","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","gE":"≧","gEl":"⪌","gacute":"ǵ","gamma":"γ","gammad":"ϝ","gap":"⪆","gbreve":"ğ","gcirc":"ĝ","gcy":"г","gdot":"ġ","ge":"≥","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","ges":"⩾","gescc":"⪩","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","gfr":"𝔤","gg":"≫","ggg":"⋙","gimel":"ℷ","gjcy":"ѓ","gl":"≷","glE":"⪒","gla":"⪥","glj":"⪤","gnE":"≩","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gneq":"⪈","gneqq":"≩","gnsim":"⋧","gopf":"𝕘","grave":"`","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","g":">","gt":">","gtcc":"⪧","gtcir":"⩺","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","hArr":"⇔","hairsp":" ","half":"½","hamilt":"ℋ","hardcy":"ъ","harr":"↔","harrcir":"⥈","harrw":"↭","hbar":"ℏ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","horbar":"―","hscr":"𝒽","hslash":"ℏ","hstrok":"ħ","hybull":"⁃","hyphen":"‐","iacut":"í","iacute":"í","ic":"⁣","icir":"î","icirc":"î","icy":"и","iecy":"е","iexc":"¡","iexcl":"¡","iff":"⇔","ifr":"𝔦","igrav":"ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","ijlig":"ĳ","imacr":"ī","image":"ℑ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","imof":"⊷","imped":"Ƶ","in":"∈","incare":"℅","infin":"∞","infintie":"⧝","inodot":"ı","int":"∫","intcal":"⊺","integers":"ℤ","intercal":"⊺","intlarhk":"⨗","intprod":"⨼","iocy":"ё","iogon":"į","iopf":"𝕚","iota":"ι","iprod":"⨼","iques":"¿","iquest":"¿","iscr":"𝒾","isin":"∈","isinE":"⋹","isindot":"⋵","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","itilde":"ĩ","iukcy":"і","ium":"ï","iuml":"ï","jcirc":"ĵ","jcy":"й","jfr":"𝔧","jmath":"ȷ","jopf":"𝕛","jscr":"𝒿","jsercy":"ј","jukcy":"є","kappa":"κ","kappav":"ϰ","kcedil":"ķ","kcy":"к","kfr":"𝔨","kgreen":"ĸ","khcy":"х","kjcy":"ќ","kopf":"𝕜","kscr":"𝓀","lAarr":"⇚","lArr":"⇐","lAtail":"⤛","lBarr":"⤎","lE":"≦","lEg":"⪋","lHar":"⥢","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","lambda":"λ","lang":"⟨","langd":"⦑","langle":"⟨","lap":"⪅","laqu":"«","laquo":"«","larr":"←","larrb":"⇤","larrbfs":"⤟","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","lat":"⪫","latail":"⤙","late":"⪭","lates":"⪭︀","lbarr":"⤌","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","lcaron":"ľ","lcedil":"ļ","lceil":"⌈","lcub":"{","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","leftarrow":"←","leftarrowtail":"↢","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","leftthreetimes":"⋋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","les":"⩽","lescc":"⪨","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","lessgtr":"≶","lesssim":"≲","lfisht":"⥼","lfloor":"⌊","lfr":"𝔩","lg":"≶","lgE":"⪑","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","ljcy":"љ","ll":"≪","llarr":"⇇","llcorner":"⌞","llhard":"⥫","lltri":"◺","lmidot":"ŀ","lmoust":"⎰","lmoustache":"⎰","lnE":"≨","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","longleftrightarrow":"⟷","longmapsto":"⟼","longrightarrow":"⟶","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","lstrok":"ł","l":"<","lt":"<","ltcc":"⪦","ltcir":"⩹","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltrPar":"⦖","ltri":"◃","ltrie":"⊴","ltrif":"◂","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","mDDot":"∺","mac":"¯","macr":"¯","male":"♂","malt":"✠","maltese":"✠","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","mcy":"м","mdash":"—","measuredangle":"∡","mfr":"𝔪","mho":"℧","micr":"µ","micro":"µ","mid":"∣","midast":"*","midcir":"⫰","middo":"·","middot":"·","minus":"−","minusb":"⊟","minusd":"∸","minusdu":"⨪","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","mopf":"𝕞","mp":"∓","mscr":"𝓂","mstpos":"∾","mu":"μ","multimap":"⊸","mumap":"⊸","nGg":"⋙̸","nGt":"≫⃒","nGtv":"≫̸","nLeftarrow":"⇍","nLeftrightarrow":"⇎","nLl":"⋘̸","nLt":"≪⃒","nLtv":"≪̸","nRightarrow":"⇏","nVDash":"⊯","nVdash":"⊮","nabla":"∇","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natur":"♮","natural":"♮","naturals":"ℕ","nbs":" ","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","ncaron":"ň","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","ncy":"н","ndash":"–","ne":"≠","neArr":"⇗","nearhk":"⤤","nearr":"↗","nearrow":"↗","nedot":"≐̸","nequiv":"≢","nesear":"⤨","nesim":"≂̸","nexist":"∄","nexists":"∄","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","ngsim":"≵","ngt":"≯","ngtr":"≯","nhArr":"⇎","nharr":"↮","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","njcy":"њ","nlArr":"⇍","nlE":"≦̸","nlarr":"↚","nldr":"‥","nle":"≰","nleftarrow":"↚","nleftrightarrow":"↮","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nlsim":"≴","nlt":"≮","nltri":"⋪","nltrie":"⋬","nmid":"∤","nopf":"𝕟","no":"¬","not":"¬","notin":"∉","notinE":"⋹̸","notindot":"⋵̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","npar":"∦","nparallel":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","npre":"⪯̸","nprec":"⊀","npreceq":"⪯̸","nrArr":"⇏","nrarr":"↛","nrarrc":"⤳̸","nrarrw":"↝̸","nrightarrow":"↛","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","ntild":"ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","nu":"ν","num":"#","numero":"№","numsp":" ","nvDash":"⊭","nvHarr":"⤄","nvap":"≍⃒","nvdash":"⊬","nvge":"≥⃒","nvgt":">⃒","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwArr":"⇖","nwarhk":"⤣","nwarr":"↖","nwarrow":"↖","nwnear":"⤧","oS":"Ⓢ","oacut":"ó","oacute":"ó","oast":"⊛","ocir":"ô","ocirc":"ô","ocy":"о","odash":"⊝","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","oelig":"œ","ofcir":"⦿","ofr":"𝔬","ogon":"˛","ograv":"ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","omacr":"ō","omega":"ω","omicron":"ο","omid":"⦶","ominus":"⊖","oopf":"𝕠","opar":"⦷","operp":"⦹","oplus":"⊕","or":"∨","orarr":"↻","ord":"º","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oscr":"ℴ","oslas":"ø","oslash":"ø","osol":"⊘","otild":"õ","otilde":"õ","otimes":"⊗","otimesas":"⨶","oum":"ö","ouml":"ö","ovbar":"⌽","par":"¶","para":"¶","parallel":"∥","parsim":"⫳","parsl":"⫽","part":"∂","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","pfr":"𝔭","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plus":"+","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plusdo":"∔","plusdu":"⨥","pluse":"⩲","plusm":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","pointint":"⨕","popf":"𝕡","poun":"£","pound":"£","pr":"≺","prE":"⪳","prap":"⪷","prcue":"≼","pre":"⪯","prec":"≺","precapprox":"⪷","preccurlyeq":"≼","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","precsim":"≾","prime":"′","primes":"ℙ","prnE":"⪵","prnap":"⪹","prnsim":"⋨","prod":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","propto":"∝","prsim":"≾","prurel":"⊰","pscr":"𝓅","psi":"ψ","puncsp":" ","qfr":"𝔮","qint":"⨌","qopf":"𝕢","qprime":"⁗","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quo":"\"","quot":"\"","rAarr":"⇛","rArr":"⇒","rAtail":"⤜","rBarr":"⤏","rHar":"⥤","race":"∽̱","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","rangd":"⦒","range":"⦥","rangle":"⟩","raqu":"»","raquo":"»","rarr":"→","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","rarrtl":"↣","rarrw":"↝","ratail":"⤚","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","rcaron":"ř","rcedil":"ŗ","rceil":"⌉","rcub":"}","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","rect":"▭","re":"®","reg":"®","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","rhard":"⇁","rharu":"⇀","rharul":"⥬","rho":"ρ","rhov":"ϱ","rightarrow":"→","rightarrowtail":"↣","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","rightthreetimes":"⋌","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoust":"⎱","rmoustache":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","roplus":"⨮","rotimes":"⨵","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","rsaquo":"›","rscr":"𝓇","rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","ruluhar":"⥨","rx":"℞","sacute":"ś","sbquo":"‚","sc":"≻","scE":"⪴","scap":"⪸","scaron":"š","sccue":"≽","sce":"⪰","scedil":"ş","scirc":"ŝ","scnE":"⪶","scnap":"⪺","scnsim":"⋩","scpolint":"⨓","scsim":"≿","scy":"с","sdot":"⋅","sdotb":"⊡","sdote":"⩦","seArr":"⇘","searhk":"⤥","searr":"↘","searrow":"↘","sec":"§","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","sfr":"𝔰","sfrown":"⌢","sharp":"♯","shchcy":"щ","shcy":"ш","shortmid":"∣","shortparallel":"∥","sh":"­","shy":"­","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","softcy":"ь","sol":"/","solb":"⧄","solbar":"⌿","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","squ":"□","square":"□","squarf":"▪","squf":"▪","srarr":"→","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","subE":"⫅","subdot":"⪽","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","subseteq":"⊆","subseteqq":"⫅","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succ":"≻","succapprox":"⪸","succcurlyeq":"≽","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","sum":"∑","sung":"♪","sup":"⊃","sup1":"¹","sup2":"²","sup3":"³","supE":"⫆","supdot":"⪾","supdsub":"⫘","supe":"⊇","supedot":"⫄","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swArr":"⇙","swarhk":"⤦","swarr":"↙","swarrow":"↙","swnwar":"⤪","szli":"ß","szlig":"ß","target":"⌖","tau":"τ","tbrk":"⎴","tcaron":"ť","tcedil":"ţ","tcy":"т","tdot":"⃛","telrec":"⌕","tfr":"𝔱","there4":"∴","therefore":"∴","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","thinsp":" ","thkap":"≈","thksim":"∼","thor":"þ","thorn":"þ","tilde":"˜","time":"×","times":"×","timesb":"⊠","timesbar":"⨱","timesd":"⨰","tint":"∭","toea":"⤨","top":"⊤","topbot":"⌶","topcir":"⫱","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","tscr":"𝓉","tscy":"ц","tshcy":"ћ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","uArr":"⇑","uHar":"⥣","uacut":"ú","uacute":"ú","uarr":"↑","ubrcy":"ў","ubreve":"ŭ","ucir":"û","ucirc":"û","ucy":"у","udarr":"⇅","udblac":"ű","udhar":"⥮","ufisht":"⥾","ufr":"𝔲","ugrav":"ù","ugrave":"ù","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","umacr":"ū","um":"¨","uml":"¨","uogon":"ų","uopf":"𝕦","uparrow":"↑","updownarrow":"↕","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","upsi":"υ","upsih":"ϒ","upsilon":"υ","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","uring":"ů","urtri":"◹","uscr":"𝓊","utdot":"⋰","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","uum":"ü","uuml":"ü","uwangle":"⦧","vArr":"⇕","vBar":"⫨","vBarv":"⫩","vDash":"⊨","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vcy":"в","vdash":"⊢","vee":"∨","veebar":"⊻","veeeq":"≚","vellip":"⋮","verbar":"|","vert":"|","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","vopf":"𝕧","vprop":"∝","vrtri":"⊳","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","vzigzag":"⦚","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","wedgeq":"≙","weierp":"℘","wfr":"𝔴","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","xfr":"𝔵","xhArr":"⟺","xharr":"⟷","xi":"ξ","xlArr":"⟸","xlarr":"⟵","xmap":"⟼","xnis":"⋻","xodot":"⨀","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrArr":"⟹","xrarr":"⟶","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","yacut":"ý","yacute":"ý","yacy":"я","ycirc":"ŷ","ycy":"ы","ye":"¥","yen":"¥","yfr":"𝔶","yicy":"ї","yopf":"𝕪","yscr":"𝓎","yucy":"ю","yum":"ÿ","yuml":"ÿ","zacute":"ź","zcaron":"ž","zcy":"з","zdot":"ż","zeetrf":"ℨ","zeta":"ζ","zfr":"𝔷","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 661 */
/***/ (function(module, exports) {

	module.exports = {"0":"�","128":"€","130":"‚","131":"ƒ","132":"„","133":"…","134":"†","135":"‡","136":"ˆ","137":"‰","138":"Š","139":"‹","140":"Œ","142":"Ž","145":"‘","146":"’","147":"“","148":"”","149":"•","150":"–","151":"—","152":"˜","153":"™","154":"š","155":"›","156":"œ","158":"ž","159":"Ÿ"}

/***/ }),
/* 662 */
/***/ (function(module, exports) {

	module.exports = ["address","article","aside","base","basefont","blockquote","body","caption","center","col","colgroup","dd","details","dialog","dir","div","dl","dt","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","iframe","legend","li","link","main","menu","menuitem","meta","nav","noframes","ol","optgroup","option","p","param","pre","section","source","title","summary","table","tbody","td","tfoot","th","thead","title","tr","track","ul"]

/***/ }),
/* 663 */
/***/ (function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object),
	    nativeMax = Math.max;
	
	/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
	var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];
	
	  var length = result.length,
	      skipIndexes = !!length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}
	
	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	
	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;
	
	    assignValue(object, key, newValue === undefined ? source[key] : newValue);
	  }
	  return object;
	}
	
	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;
	
	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;
	
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assignIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assign({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	module.exports = assign;


/***/ }),
/* 664 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;
	
	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};
	
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	
	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	
	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }
	
	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;
	
	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }
	
	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;
	
	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }
	
	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }
	
	  function trailingEdge(time) {
	    timerId = undefined;
	
	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }
	
	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }
	
	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }
	
	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);
	
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;
	
	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = debounce;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 665 */
/***/ (function(module, exports) {

	/**
	 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ }),
/* 666 */
/***/ (function(module, exports) {

	/**
	 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @type Function
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}
	
	module.exports = isString;


/***/ }),
/* 667 */,
/* 668 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = escapes;
	
	var defaults = [
	  '\\',
	  '`',
	  '*',
	  '{',
	  '}',
	  '[',
	  ']',
	  '(',
	  ')',
	  '#',
	  '+',
	  '-',
	  '.',
	  '!',
	  '_',
	  '>'
	];
	
	var gfm = defaults.concat(['~', '|']);
	
	var commonmark = gfm.concat([
	  '\n',
	  '"',
	  '$',
	  '%',
	  '&',
	  '\'',
	  ',',
	  '/',
	  ':',
	  ';',
	  '<',
	  '=',
	  '?',
	  '@',
	  '^'
	]);
	
	escapes.default = defaults;
	escapes.gfm = gfm;
	escapes.commonmark = commonmark;
	
	/* Get markdown escapes. */
	function escapes(options) {
	  var settings = options || {};
	
	  if (settings.commonmark) {
	    return commonmark;
	  }
	
	  return settings.gfm ? gfm : defaults;
	}


/***/ }),
/* 669 */,
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(671);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2));
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;


/***/ }),
/* 671 */
/***/ (function(module, exports) {

	'use strict';
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};


/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var define = __webpack_require__(236);
	
	var implementation = __webpack_require__(298);
	var getPolyfill = __webpack_require__(299);
	var shim = __webpack_require__(673);
	
	var polyfill = getPolyfill();
	
	define(polyfill, {
		getPolyfill: getPolyfill,
		implementation: implementation,
		shim: shim
	});
	
	module.exports = polyfill;


/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var getPolyfill = __webpack_require__(299);
	var define = __webpack_require__(236);
	
	module.exports = function shimEntries() {
		var polyfill = getPolyfill();
		define(Object, { entries: polyfill }, {
			entries: function testEntries() {
				return Object.entries !== polyfill;
			}
		});
		return polyfill;
	};


/***/ }),
/* 674 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var _self = (typeof window !== 'undefined')
		? window   // if in browser
		: (
			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
		);
	
	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 * MIT license http://www.opensource.org/licenses/mit-license.php/
	 * @author Lea Verou http://lea.verou.me
	 */
	
	var Prism = (function(){
	
	// Private helper vars
	var lang = /\blang(?:uage)?-(\w+)\b/i;
	var uniqueId = 0;
	
	var _ = _self.Prism = {
		manual: _self.Prism && _self.Prism.manual,
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
		util: {
			encode: function (tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
				} else if (_.util.type(tokens) === 'Array') {
					return tokens.map(_.util.encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},
	
			type: function (o) {
				return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
			},
	
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},
	
			// Deep clone a language definition (e.g. to extend it)
			clone: function (o) {
				var type = _.util.type(o);
	
				switch (type) {
					case 'Object':
						var clone = {};
	
						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = _.util.clone(o[key]);
							}
						}
	
						return clone;
	
					case 'Array':
						return o.map(function(v) { return _.util.clone(v); });
				}
	
				return o;
			}
		},
	
		languages: {
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);
	
				for (var key in redef) {
					lang[key] = redef[key];
				}
	
				return lang;
			},
	
			/**
			 * Insert a token before another token in a language literal
			 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
			 * we cannot just provide an object, we need anobject and a key.
			 * @param inside The key (or language id) of the parent
			 * @param before The key to insert before. If not provided, the function appends instead.
			 * @param insert Object with the key/value pairs to insert
			 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || _.languages;
				var grammar = root[inside];
	
				if (arguments.length == 2) {
					insert = arguments[1];
	
					for (var newToken in insert) {
						if (insert.hasOwnProperty(newToken)) {
							grammar[newToken] = insert[newToken];
						}
					}
	
					return grammar;
				}
	
				var ret = {};
	
				for (var token in grammar) {
	
					if (grammar.hasOwnProperty(token)) {
	
						if (token == before) {
	
							for (var newToken in insert) {
	
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}
	
						ret[token] = grammar[token];
					}
				}
	
				// Update references in other language definitions
				_.languages.DFS(_.languages, function(key, value) {
					if (value === root[inside] && key != inside) {
						this[key] = ret;
					}
				});
	
				return root[inside] = ret;
			},
	
			// Traverse a language definition with Depth First Search
			DFS: function(o, callback, type, visited) {
				visited = visited || {};
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);
	
						if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, null, visited);
						}
						else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, i, visited);
						}
					}
				}
			}
		},
		plugins: {},
	
		highlightAll: function(async, callback) {
			var env = {
				callback: callback,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};
	
			_.hooks.run("before-highlightall", env);
	
			var elements = env.elements || document.querySelectorAll(env.selector);
	
			for (var i=0, element; element = elements[i++];) {
				_.highlightElement(element, async === true, env.callback);
			}
		},
	
		highlightElement: function(element, async, callback) {
			// Find language
			var language, grammar, parent = element;
	
			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}
	
			if (parent) {
				language = (parent.className.match(lang) || [,''])[1].toLowerCase();
				grammar = _.languages[language];
			}
	
			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
	
			if (element.parentNode) {
				// Set language on the parent, for styling
				parent = element.parentNode;
	
				if (/pre/i.test(parent.nodeName)) {
					parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
				}
			}
	
			var code = element.textContent;
	
			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};
	
			_.hooks.run('before-sanity-check', env);
	
			if (!env.code || !env.grammar) {
				if (env.code) {
					_.hooks.run('before-highlight', env);
					env.element.textContent = env.code;
					_.hooks.run('after-highlight', env);
				}
				_.hooks.run('complete', env);
				return;
			}
	
			_.hooks.run('before-highlight', env);
	
			if (async && _self.Worker) {
				var worker = new Worker(_.filename);
	
				worker.onmessage = function(evt) {
					env.highlightedCode = evt.data;
	
					_.hooks.run('before-insert', env);
	
					env.element.innerHTML = env.highlightedCode;
	
					callback && callback.call(env.element);
					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				};
	
				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			}
			else {
				env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
	
				_.hooks.run('before-insert', env);
	
				env.element.innerHTML = env.highlightedCode;
	
				callback && callback.call(element);
	
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			}
		},
	
		highlight: function (text, grammar, language) {
			var tokens = _.tokenize(text, grammar);
			return Token.stringify(_.util.encode(tokens), language);
		},
	
		matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
			var Token = _.Token;
	
			for (var token in grammar) {
				if(!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}
	
				if (token == target) {
					return;
				}
	
				var patterns = grammar[token];
				patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];
	
				for (var j = 0; j < patterns.length; ++j) {
					var pattern = patterns[j],
						inside = pattern.inside,
						lookbehind = !!pattern.lookbehind,
						greedy = !!pattern.greedy,
						lookbehindLength = 0,
						alias = pattern.alias;
	
					if (greedy && !pattern.pattern.global) {
						// Without the global flag, lastIndex won't work
						var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
						pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
					}
	
					pattern = pattern.pattern || pattern;
	
					// Don’t cache length as it changes during the loop
					for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
	
						var str = strarr[i];
	
						if (strarr.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							return;
						}
	
						if (str instanceof Token) {
							continue;
						}
	
						pattern.lastIndex = 0;
	
						var match = pattern.exec(str),
						    delNum = 1;
	
						// Greedy patterns can override/remove up to two previously matched tokens
						if (!match && greedy && i != strarr.length - 1) {
							pattern.lastIndex = pos;
							match = pattern.exec(text);
							if (!match) {
								break;
							}
	
							var from = match.index + (lookbehind ? match[1].length : 0),
							    to = match.index + match[0].length,
							    k = i,
							    p = pos;
	
							for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
								p += strarr[k].length;
								// Move the index i to the element in strarr that is closest to from
								if (from >= p) {
									++i;
									pos = p;
								}
							}
	
							/*
							 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
							 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
							 */
							if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
								continue;
							}
	
							// Number of tokens to delete and replace with the new match
							delNum = k - i;
							str = text.slice(pos, p);
							match.index -= pos;
						}
	
						if (!match) {
							if (oneshot) {
								break;
							}
	
							continue;
						}
	
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}
	
						var from = match.index + lookbehindLength,
						    match = match[0].slice(lookbehindLength),
						    to = from + match.length,
						    before = str.slice(0, from),
						    after = str.slice(to);
	
						var args = [i, delNum];
	
						if (before) {
							++i;
							pos += before.length;
							args.push(before);
						}
	
						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);
	
						args.push(wrapped);
	
						if (after) {
							args.push(after);
						}
	
						Array.prototype.splice.apply(strarr, args);
	
						if (delNum != 1)
							_.matchGrammar(text, strarr, grammar, i, pos, true, token);
	
						if (oneshot)
							break;
					}
				}
			}
		},
	
		tokenize: function(text, grammar, language) {
			var strarr = [text];
	
			var rest = grammar.rest;
	
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}
	
				delete grammar.rest;
			}
	
			_.matchGrammar(text, strarr, grammar, 0, 0, false);
	
			return strarr;
		},
	
		hooks: {
			all: {},
	
			add: function (name, callback) {
				var hooks = _.hooks.all;
	
				hooks[name] = hooks[name] || [];
	
				hooks[name].push(callback);
			},
	
			run: function (name, env) {
				var callbacks = _.hooks.all[name];
	
				if (!callbacks || !callbacks.length) {
					return;
				}
	
				for (var i=0, callback; callback = callbacks[i++];) {
					callback(env);
				}
			}
		}
	};
	
	var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
		this.type = type;
		this.content = content;
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || "").length|0;
		this.greedy = !!greedy;
	};
	
	Token.stringify = function(o, language, parent) {
		if (typeof o == 'string') {
			return o;
		}
	
		if (_.util.type(o) === 'Array') {
			return o.map(function(element) {
				return Token.stringify(element, language, o);
			}).join('');
		}
	
		var env = {
			type: o.type,
			content: Token.stringify(o.content, language, parent),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language,
			parent: parent
		};
	
		if (o.alias) {
			var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
			Array.prototype.push.apply(env.classes, aliases);
		}
	
		_.hooks.run('wrap', env);
	
		var attributes = Object.keys(env.attributes).map(function(name) {
			return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}).join(' ');
	
		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
	
	};
	
	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _self.Prism;
		}
	
		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data),
					lang = message.language,
					code = message.code,
					immediateClose = message.immediateClose;
	
				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}
	
		return _self.Prism;
	}
	
	//Get current script and highlight
	var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
	
	if (script) {
		_.filename = script.src;
	
		if (!_.manual && !script.hasAttribute('data-manual')) {
			if(document.readyState !== "loading") {
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(_.highlightAll);
				} else {
					window.setTimeout(_.highlightAll, 16);
				}
			}
			else {
				document.addEventListener('DOMContentLoaded', _.highlightAll);
			}
		}
	}
	
	return _self.Prism;
	
	})();
	
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Prism;
	}
	
	// hack for components to work correctly in node.js
	if (typeof global !== 'undefined') {
		global.Prism = Prism;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */
/***/ (function(module, exports) {

	'use strict';
	
	/* Expose. */
	module.exports = getPropertyInformation;
	
	/* Constants. */
	var USE_ATTRIBUTE = 0x1;
	var USE_PROPERTY = 0x2;
	var BOOLEAN_VALUE = 0x8;
	var NUMERIC_VALUE = 0x10;
	var POSITIVE_NUMERIC_VALUE = 0x20 | 0x10;
	var OVERLOADED_BOOLEAN_VALUE = 0x40;
	var SPACE_SEPARATED = 0x80;
	var COMMA_SEPARATED = 0x100;
	
	/* Map of properties. Names are camel-cased properties. */
	var propertyConfig = {
	  /* Standard Properties. */
	  abbr: null,
	  accept: COMMA_SEPARATED,
	  acceptCharset: SPACE_SEPARATED,
	  accessKey: SPACE_SEPARATED,
	  action: null,
	  allowFullScreen: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  allowTransparency: USE_ATTRIBUTE,
	  alt: null,
	  /* https://html.spec.whatwg.org/#attr-link-as */
	  as: null,
	  async: BOOLEAN_VALUE,
	  autoComplete: SPACE_SEPARATED,
	  autoFocus: BOOLEAN_VALUE,
	  autoPlay: BOOLEAN_VALUE,
	  capture: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  cellPadding: null,
	  cellSpacing: null,
	  challenge: USE_ATTRIBUTE,
	  charSet: USE_ATTRIBUTE,
	  checked: USE_PROPERTY | BOOLEAN_VALUE,
	  cite: null,
	  /* To set className on SVG elements, it's necessary to
	   * use .setAttribute; this works on HTML elements too
	   * in all browsers except IE8. */
	  className: USE_ATTRIBUTE | SPACE_SEPARATED,
	  cols: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  colSpan: null,
	  command: null,
	  content: null,
	  contentEditable: null,
	  contextMenu: USE_ATTRIBUTE,
	  controls: USE_PROPERTY | BOOLEAN_VALUE,
	  /* https://github.com/WICG/controls-list/blob/gh-pages/explainer.md */
	  controlsList: SPACE_SEPARATED,
	  coords: NUMERIC_VALUE | COMMA_SEPARATED,
	  crossOrigin: null,
	  /* For `<object />` acts as `src`. */
	  data: null,
	  dateTime: USE_ATTRIBUTE,
	  default: BOOLEAN_VALUE,
	  defer: BOOLEAN_VALUE,
	  dir: null,
	  dirName: null,
	  disabled: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  download: OVERLOADED_BOOLEAN_VALUE,
	  draggable: null,
	  dropzone: SPACE_SEPARATED,
	  encType: null,
	  form: USE_ATTRIBUTE,
	  formAction: USE_ATTRIBUTE,
	  formEncType: USE_ATTRIBUTE,
	  formMethod: USE_ATTRIBUTE,
	  formNoValidate: BOOLEAN_VALUE,
	  formTarget: USE_ATTRIBUTE,
	  frameBorder: USE_ATTRIBUTE,
	  headers: SPACE_SEPARATED,
	  height: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  hidden: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  high: NUMERIC_VALUE,
	  href: null,
	  hrefLang: null,
	  htmlFor: SPACE_SEPARATED,
	  httpEquiv: SPACE_SEPARATED,
	  id: USE_PROPERTY,
	  inputMode: USE_ATTRIBUTE,
	  /* Web Components */
	  is: USE_ATTRIBUTE,
	  isMap: BOOLEAN_VALUE,
	  keyParams: USE_ATTRIBUTE,
	  keyType: USE_ATTRIBUTE,
	  kind: null,
	  label: null,
	  lang: null,
	  list: USE_ATTRIBUTE,
	  loop: USE_PROPERTY | BOOLEAN_VALUE,
	  low: NUMERIC_VALUE,
	  manifest: USE_ATTRIBUTE,
	  marginHeight: NUMERIC_VALUE,
	  marginWidth: NUMERIC_VALUE,
	  max: null,
	  maxLength: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  media: USE_ATTRIBUTE,
	  mediaGroup: null,
	  menu: null,
	  method: null,
	  min: null,
	  minLength: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  multiple: USE_PROPERTY | BOOLEAN_VALUE,
	  muted: USE_PROPERTY | BOOLEAN_VALUE,
	  name: null,
	  nonce: null,
	  noValidate: BOOLEAN_VALUE,
	  open: BOOLEAN_VALUE,
	  optimum: NUMERIC_VALUE,
	  pattern: null,
	  ping: SPACE_SEPARATED,
	  placeholder: null,
	  /* https://html.spec.whatwg.org/#attr-video-playsinline */
	  playsInline: BOOLEAN_VALUE,
	  poster: null,
	  preload: null,
	  /* https://html.spec.whatwg.org/#dom-head-profile */
	  profile: null,
	  radioGroup: null,
	  readOnly: USE_PROPERTY | BOOLEAN_VALUE,
	  /* https://html.spec.whatwg.org/#attr-link-referrerpolicy */
	  referrerPolicy: null,
	  /* `rel` is `relList` in DOM */
	  rel: SPACE_SEPARATED | USE_ATTRIBUTE,
	  required: BOOLEAN_VALUE,
	  reversed: BOOLEAN_VALUE,
	  role: USE_ATTRIBUTE,
	  rows: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  rowSpan: POSITIVE_NUMERIC_VALUE,
	  sandbox: SPACE_SEPARATED,
	  scope: null,
	  scoped: BOOLEAN_VALUE,
	  scrolling: null,
	  seamless: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  selected: USE_PROPERTY | BOOLEAN_VALUE,
	  shape: null,
	  size: USE_ATTRIBUTE | POSITIVE_NUMERIC_VALUE,
	  sizes: USE_ATTRIBUTE | SPACE_SEPARATED,
	  /* https://html.spec.whatwg.org/#attr-slot */
	  slot: null,
	  sortable: BOOLEAN_VALUE,
	  sorted: SPACE_SEPARATED,
	  span: POSITIVE_NUMERIC_VALUE,
	  spellCheck: null,
	  src: null,
	  srcDoc: USE_PROPERTY,
	  srcLang: null,
	  srcSet: USE_ATTRIBUTE | COMMA_SEPARATED,
	  start: NUMERIC_VALUE,
	  step: null,
	  style: null,
	  summary: null,
	  tabIndex: NUMERIC_VALUE,
	  target: null,
	  title: null,
	  translate: null,
	  type: null,
	  typeMustMatch: BOOLEAN_VALUE,
	  useMap: null,
	  value: USE_PROPERTY,
	  volume: POSITIVE_NUMERIC_VALUE,
	  width: USE_ATTRIBUTE | NUMERIC_VALUE,
	  wmode: USE_ATTRIBUTE,
	  wrap: null,
	
	  /* Non-standard Properties. */
	
	  /* `autoCapitalize` and `autoCorrect` are supported in
	   * Mobile Safari for keyboard hints. */
	  autoCapitalize: null,
	  autoCorrect: null,
	  /* `autoSave` allows WebKit/Blink to persist values of
	   * input fields on page reloads */
	  autoSave: null,
	  /* `itemProp`, `itemScope`, `itemType` are for Microdata
	   * support. See http://schema.org/docs/gs.html */
	  itemProp: USE_ATTRIBUTE | SPACE_SEPARATED,
	  itemScope: USE_ATTRIBUTE | BOOLEAN_VALUE,
	  itemType: USE_ATTRIBUTE | SPACE_SEPARATED,
	  /* `itemID` and `itemRef` are for Microdata support as well
	   * but only specified in the the WHATWG spec document.
	   * See https://html.spec.whatwg.org/multipage/
	   * microdata.html#microdata-dom-api */
	  itemID: USE_ATTRIBUTE,
	  itemRef: USE_ATTRIBUTE | SPACE_SEPARATED,
	  /* `property` is supported for OpenGraph in meta tags. */
	  property: null,
	  /* `results` show looking glass icon and recent searches
	   * on input search fields in WebKit/Blink */
	  results: null,
	  /* IE-only attribute that specifies security
	   * restrictions on an iframe as an alternative to the
	   * sandbox attribute on IE < 10 */
	  security: USE_ATTRIBUTE,
	  /* IE-only attribute that controls focus behavior */
	  unselectable: USE_ATTRIBUTE,
	
	  /* Ancient. */
	  xmlLang: USE_ATTRIBUTE,
	  xmlBase: USE_ATTRIBUTE
	};
	
	/* Map of properties to attributes.
	 * Names are lower-case properties.
	 * Values are HTML attributes. */
	var propertyToAttributeMapping = {
	  xmlbase: 'xml:base',
	  xmllang: 'xml:lang',
	  classname: 'class',
	  htmlfor: 'for',
	  httpequiv: 'http-equiv',
	  acceptcharset: 'accept-charset'
	};
	
	/* Expand config. */
	var information = {};
	var property;
	var name;
	var config;
	
	getPropertyInformation.all = information;
	
	for (property in propertyConfig) {
	  name = lower(property);
	  name = propertyToAttributeMapping[name] || name;
	  config = propertyConfig[property];
	
	  information[name] = {
	    name: name,
	    propertyName: property,
	    mustUseAttribute: check(config, USE_ATTRIBUTE),
	    mustUseProperty: check(config, USE_PROPERTY),
	    boolean: check(config, BOOLEAN_VALUE),
	    overloadedBoolean: check(config, OVERLOADED_BOOLEAN_VALUE),
	    numeric: check(config, NUMERIC_VALUE),
	    positiveNumeric: check(config, POSITIVE_NUMERIC_VALUE),
	    commaSeparated: check(config, COMMA_SEPARATED),
	    spaceSeparated: check(config, SPACE_SEPARATED)
	  };
	}
	
	/* Get a config for a property. */
	function getPropertyInformation(propertyName) {
	  var insensitive = lower(propertyName);
	
	  return information[propertyToAttributeMapping[insensitive] || insensitive];
	}
	
	/* Check a mask. */
	function check(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	/* Lower-case a string. */
	function lower(value) {
	  return value.toLowerCase();
	}


/***/ }),
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(2);
	var xtend = __webpack_require__(44);
	
	function astToReact(node, options) {
	  var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	
	  if (node.type === 'text') {
	    return node.value;
	  }
	
	  var renderer = options.renderers[node.type];
	  if (typeof renderer !== 'function' && typeof renderer !== 'string') {
	    throw new Error('Renderer for type `' + node.type + '` not defined or is not renderable');
	  }
	
	  var pos = node.position.start;
	  var key = [node.type, pos.line, pos.column].join('-');
	  var nodeProps = getNodeProps(node, key, options, renderer, parent, index);
	
	  return React.createElement(renderer, nodeProps, nodeProps.children || resolveChildren() || undefined);
	
	  function resolveChildren() {
	    return node.children && node.children.map(function (childNode, i) {
	      return astToReact(childNode, options, { node: node, props: nodeProps }, i);
	    });
	  }
	}
	
	// eslint-disable-next-line max-params, complexity
	function getNodeProps(node, key, opts, renderer, parent, index) {
	  var props = { key: key
	
	    // `sourcePos` is true if the user wants source information (line/column info from markdown source)
	  };if (opts.sourcePos && node.position) {
	    props['data-sourcepos'] = flattenPosition(node.position);
	  }
	
	  var ref = node.identifier ? opts.definitions[node.identifier] || {} : null;
	
	  switch (node.type) {
	    case 'root':
	      assignDefined(props, { className: opts.className });
	      break;
	    case 'heading':
	      props.level = node.depth;
	      break;
	    case 'list':
	      props.start = node.start;
	      props.ordered = node.ordered;
	      props.tight = !node.loose;
	      break;
	    case 'listItem':
	      props.checked = node.checked;
	      props.tight = !node.loose;
	      props.children = (props.tight ? unwrapParagraphs(node) : node.children).map(function (childNode, i) {
	        return astToReact(childNode, opts, { node: node, props: props }, i);
	      });
	      break;
	    case 'definition':
	      assignDefined(props, { identifier: node.identifier, title: node.title, url: node.url });
	      break;
	    case 'code':
	      assignDefined(props, { language: node.lang });
	      break;
	    case 'inlineCode':
	      props.children = node.value;
	      props.inline = true;
	      break;
	    case 'link':
	      assignDefined(props, {
	        title: node.title || undefined,
	        href: opts.transformLinkUri ? opts.transformLinkUri(node.url, node.children, node.title) : node.url
	      });
	      break;
	    case 'image':
	      assignDefined(props, {
	        alt: node.alt || undefined,
	        title: node.title || undefined,
	        src: opts.transformImageUri ? opts.transformImageUri(node.url, node.children, node.title, node.alt) : node.url
	      });
	      break;
	    case 'linkReference':
	      assignDefined(props, xtend(ref, {
	        href: opts.transformLinkUri ? opts.transformLinkUri(ref.href) : ref.href
	      }));
	      break;
	    case 'imageReference':
	      assignDefined(props, {
	        src: ref.href,
	        title: ref.title || undefined,
	        alt: node.alt || undefined
	      });
	      break;
	    case 'table':
	    case 'tableHead':
	    case 'tableBody':
	      props.columnAlignment = node.align;
	      break;
	    case 'tableRow':
	      props.isHeader = parent.node.type === 'tableHead';
	      props.columnAlignment = parent.props.columnAlignment;
	      break;
	    case 'tableCell':
	      assignDefined(props, {
	        isHeader: parent.props.isHeader,
	        align: parent.props.columnAlignment[index]
	      });
	      break;
	    case 'virtualHtml':
	      props.tag = node.tag;
	      break;
	    case 'html':
	      // @todo find a better way than this
	      props.isBlock = node.position.start.line !== node.position.end.line;
	      props.escapeHtml = opts.escapeHtml;
	      props.skipHtml = opts.skipHtml;
	      break;
	    default:
	  }
	
	  if (typeof renderer !== 'string' && node.value) {
	    props.value = node.value;
	  }
	
	  return props;
	}
	
	function assignDefined(target, attrs) {
	  for (var key in attrs) {
	    if (typeof attrs[key] !== 'undefined') {
	      target[key] = attrs[key];
	    }
	  }
	}
	
	function flattenPosition(pos) {
	  return [pos.start.line, ':', pos.start.column, '-', pos.end.line, ':', pos.end.column].map(String).join('');
	}
	
	function unwrapParagraphs(node) {
	  return node.children.reduce(function (array, child) {
	    return array.concat(child.type === 'paragraph' ? child.children || [] : [child]);
	  }, []);
	}
	
	module.exports = astToReact;

/***/ }),
/* 745 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function getDefinitions(node) {
	  var defs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  return (node.children || []).reduce(function (definitions, child) {
	    if (child.type === 'definition') {
	      definitions[child.identifier] = {
	        href: child.url,
	        title: child.title
	      };
	    }
	
	    return getDefinitions(child, definitions);
	  }, defs);
	};

/***/ }),
/* 746 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var visit = __webpack_require__(121);
	
	exports.ofType = function (types, mode) {
	  return function (node) {
	    types.forEach(function (type) {
	      return visit(node, type, disallow, true);
	    });
	    return node;
	  };
	
	  function disallow(node, index, parent) {
	    if (parent) {
	      untangle(node, index, parent, mode);
	    }
	  }
	};
	
	exports.ifNotMatch = function (allowNode, mode) {
	  return function (node) {
	    visit(node, disallow, true);
	    return node;
	  };
	
	  function disallow(node, index, parent) {
	    if (parent && !allowNode(node, index, parent)) {
	      untangle(node, index, parent, mode);
	    }
	  }
	};
	
	function untangle(node, index, parent, mode) {
	  if (mode === 'remove') {
	    parent.children.splice(index, 1);
	  } else if (mode === 'unwrap') {
	    var args = [index, 1].concat(node.children);
	    Array.prototype.splice.apply(parent.children, args);
	  }
	}

/***/ }),
/* 747 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Naive, simple plugin to match inline nodes without attributes
	 * This allows say <strong>foo</strong>, but not <strong class="very">foo</strong>
	 * For proper HTML support, you'll want a different plugin
	 **/
	var visit = __webpack_require__(121);
	
	var type = 'virtualHtml';
	var selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\s*\/?>$/i;
	var simpleTagRe = /^<(\/?)([a-z]+)\s*>$/;
	
	module.exports = function (tree) {
	  var open = void 0;
	  var currentParent = void 0;
	  visit(tree, 'html', function (node, index, parent) {
	    if (currentParent !== parent) {
	      open = [];
	      currentParent = parent;
	    }
	
	    var selfClosing = getSelfClosing(node);
	    if (selfClosing) {
	      parent.children.splice(index, 1, {
	        type: type,
	        tag: selfClosing,
	        position: node.position
	      });
	      return true;
	    }
	
	    var current = getSimpleTag(node, parent);
	    if (!current) {
	      return true;
	    }
	
	    var matching = findAndPull(open, current.tag);
	
	    if (matching) {
	      parent.children.splice(index, 0, virtual(current, matching, parent));
	    } else if (!current.opening) {
	      open.push(current);
	    }
	
	    return true;
	  }, true // Iterate in reverse
	  );
	
	  return tree;
	};
	
	function findAndPull(open, matchingTag) {
	  var i = open.length;
	  while (i--) {
	    if (open[i].tag === matchingTag) {
	      return open.splice(i, 1)[0];
	    }
	  }
	
	  return false;
	}
	
	function getSimpleTag(node, parent) {
	  var match = node.value.match(simpleTagRe);
	  return match ? { tag: match[2], opening: !match[1], node: node } : false;
	}
	
	function getSelfClosing(node) {
	  var match = node.value.match(selfClosingRe);
	  return match ? match[1] : false;
	}
	
	function virtual(fromNode, toNode, parent) {
	  var fromIndex = parent.children.indexOf(fromNode.node);
	  var toIndex = parent.children.indexOf(toNode.node);
	
	  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);
	  var children = extracted.slice(1, -1);
	  return {
	    type: type,
	    children: children,
	    tag: fromNode.tag,
	    position: {
	      start: fromNode.node.position.start,
	      end: toNode.node.position.end,
	      indent: []
	    }
	  };
	}

/***/ }),
/* 748 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var xtend = __webpack_require__(44);
	var unified = __webpack_require__(1056);
	var parse = __webpack_require__(985);
	var PropTypes = __webpack_require__(1);
	var naiveHtml = __webpack_require__(747);
	var disallowNode = __webpack_require__(746);
	var astToReact = __webpack_require__(744);
	var wrapTableRows = __webpack_require__(751);
	var getDefinitions = __webpack_require__(745);
	var uriTransformer = __webpack_require__(750);
	var defaultRenderers = __webpack_require__(749);
	
	var allTypes = Object.keys(defaultRenderers);
	
	var ReactMarkdown = function ReactMarkdown(props) {
	  var src = props.source || props.children || '';
	
	  if (props.allowedTypes && props.disallowedTypes) {
	    throw new Error('Only one of `allowedTypes` and `disallowedTypes` should be defined');
	  }
	
	  var renderers = xtend(defaultRenderers, props.renderers);
	
	  var plugins = [parse].concat(props.plugins || []);
	  var parser = plugins.reduce(applyParserPlugin, unified());
	
	  var rawAst = parser.parse(src);
	  var renderProps = xtend(props, {
	    renderers: renderers,
	    definitions: getDefinitions(rawAst)
	  });
	
	  var astPlugins = determineAstPlugins(props);
	  var ast = astPlugins.reduce(function (node, plugin) {
	    return plugin(node, renderProps);
	  }, rawAst);
	
	  return astToReact(ast, renderProps);
	};
	
	function applyParserPlugin(parser, plugin) {
	  return Array.isArray(plugin) ? parser.use(plugin[0], plugin[1]) : parser.use(plugin);
	}
	
	function determineAstPlugins(props) {
	  var plugins = [wrapTableRows];
	
	  var disallowedTypes = props.disallowedTypes;
	  if (props.allowedTypes) {
	    disallowedTypes = allTypes.filter(function (type) {
	      return type !== 'root' && props.allowedTypes.indexOf(type) === -1;
	    });
	  }
	
	  var removalMethod = props.unwrapDisallowed ? 'unwrap' : 'remove';
	  if (disallowedTypes && disallowedTypes.length > 0) {
	    plugins.push(disallowNode.ofType(disallowedTypes, removalMethod));
	  }
	
	  if (props.allowNode) {
	    plugins.push(disallowNode.ifNotMatch(props.allowNode, removalMethod));
	  }
	
	  var renderHtml = !props.escapeHtml && !props.skipHtml;
	  if (renderHtml) {
	    plugins.push(naiveHtml);
	  }
	
	  return props.astPlugins ? plugins.concat(props.astPlugins) : plugins;
	}
	
	ReactMarkdown.defaultProps = {
	  renderers: {},
	  escapeHtml: true,
	  skipHtml: false,
	  transformLinkUri: uriTransformer
	};
	
	ReactMarkdown.propTypes = {
	  className: PropTypes.string,
	  source: PropTypes.string,
	  children: PropTypes.string,
	  sourcePos: PropTypes.bool,
	  escapeHtml: PropTypes.bool,
	  skipHtml: PropTypes.bool,
	  allowNode: PropTypes.func,
	  allowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
	  disallowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
	  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
	  transformImageUri: PropTypes.func,
	  astPlugins: PropTypes.arrayOf(PropTypes.func),
	  unwrapDisallowed: PropTypes.bool,
	  renderers: PropTypes.object
	};
	
	ReactMarkdown.types = allTypes;
	ReactMarkdown.renderers = defaultRenderers;
	ReactMarkdown.uriTransformer = uriTransformer;
	
	module.exports = ReactMarkdown;

/***/ }),
/* 749 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint-disable react/prop-types, react/no-multi-comp */
	'use strict';
	
	var xtend = __webpack_require__(44);
	var React = __webpack_require__(2);
	var createElement = React.createElement;
	
	module.exports = {
	  root: 'div',
	  break: 'br',
	  paragraph: 'p',
	  emphasis: 'em',
	  strong: 'strong',
	  thematicBreak: 'hr',
	  blockquote: 'blockquote',
	  delete: 'del',
	  link: 'a',
	  image: 'img',
	  linkReference: 'a',
	  imageReference: 'img',
	  table: SimpleRenderer.bind(null, 'table'),
	  tableHead: SimpleRenderer.bind(null, 'thead'),
	  tableBody: SimpleRenderer.bind(null, 'tbody'),
	  tableRow: SimpleRenderer.bind(null, 'tr'),
	  tableCell: TableCell,
	
	  list: List,
	  listItem: ListItem,
	  definition: NullRenderer,
	  heading: Heading,
	  inlineCode: InlineCode,
	  code: CodeBlock,
	  html: Html,
	  virtualHtml: VirtualHtml
	};
	
	function SimpleRenderer(tag, props) {
	  return createElement(tag, getCoreProps(props), props.children);
	}
	
	function TableCell(props) {
	  var style = props.align ? { textAlign: props.align } : undefined;
	  var coreProps = getCoreProps(props);
	  return createElement(props.isHeader ? 'th' : 'td', style ? xtend({ style: style }, coreProps) : coreProps, props.children);
	}
	
	function Heading(props) {
	  return createElement('h' + props.level, getCoreProps(props), props.children);
	}
	
	function List(props) {
	  var attrs = getCoreProps(props);
	  if (props.start !== null && props.start !== 1) {
	    attrs.start = props.start.toString();
	  }
	
	  return createElement(props.ordered ? 'ol' : 'ul', attrs, props.children);
	}
	
	function ListItem(props) {
	  return createElement('li', getCoreProps(props), props.children);
	}
	
	function CodeBlock(props) {
	  var className = props.language && 'language-' + props.language;
	  var code = createElement('code', className ? { className: className } : null, props.value);
	  return createElement('pre', getCoreProps(props), code);
	}
	
	function InlineCode(props) {
	  return createElement('code', getCoreProps(props), props.children);
	}
	
	function Html(props) {
	  if (props.skipHtml) {
	    return null;
	  }
	
	  var tag = props.isBlock ? 'div' : 'span';
	  if (props.escapeHtml) {
	    // @todo when fiber lands, we can simply render props.value
	    return createElement(tag, null, props.value);
	  }
	
	  var nodeProps = { dangerouslySetInnerHTML: { __html: props.value } };
	  return createElement(tag, nodeProps);
	}
	
	function VirtualHtml(props) {
	  return createElement(props.tag, getCoreProps(props), props.children);
	}
	
	function NullRenderer() {
	  return null;
	}
	
	function getCoreProps(props) {
	  return props['data-sourcepos'] ? { 'data-sourcepos': props['data-sourcepos'] } : {};
	}

/***/ }),
/* 750 */
/***/ (function(module, exports) {

	'use strict';
	
	var protocols = ['http', 'https', 'mailto', 'tel'];
	
	module.exports = function uriTransformer(uri) {
	  var url = (uri || '').trim();
	  var first = url.charAt(0);
	
	  if (first === '#' || first === '/') {
	    return url;
	  }
	
	  var colon = url.indexOf(':');
	  if (colon === -1) {
	    return url;
	  }
	
	  var length = protocols.length;
	  var index = -1;
	
	  while (++index < length) {
	    var protocol = protocols[index];
	
	    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {
	      return url;
	    }
	  }
	
	  index = url.indexOf('?');
	  if (index !== -1 && colon > index) {
	    return url;
	  }
	
	  index = url.indexOf('#');
	  if (index !== -1 && colon > index) {
	    return url;
	  }
	
	  // eslint-disable-next-line no-script-url
	  return 'javascript:void(0)';
	};

/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var visit = __webpack_require__(121);
	
	module.exports = function (node) {
	  visit(node, 'table', wrap);
	  return node;
	};
	
	function wrap(table) {
	  var children = table.children;
	  table.children = [{
	    type: 'tableHead',
	    align: table.align,
	    children: [children[0]],
	    position: children[0].position
	  }, {
	    type: 'tableBody',
	    align: table.align,
	    children: children.slice(1),
	    position: {
	      start: children[1].position.start,
	      end: children[children.length - 1].position.end
	    }
	  }];
	}

/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bodyOpenClassName = exports.portalClassName = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(36);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _ModalPortal = __webpack_require__(753);
	
	var _ModalPortal2 = _interopRequireDefault(_ModalPortal);
	
	var _ariaAppHider = __webpack_require__(325);
	
	var ariaAppHider = _interopRequireWildcard(_ariaAppHider);
	
	var _safeHTMLElement = __webpack_require__(327);
	
	var _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var portalClassName = exports.portalClassName = "ReactModalPortal";
	var bodyOpenClassName = exports.bodyOpenClassName = "ReactModal__Body--open";
	
	var isReact16 = _reactDom2.default.createPortal !== undefined;
	var createPortal = isReact16 ? _reactDom2.default.createPortal : _reactDom2.default.unstable_renderSubtreeIntoContainer;
	
	function getParentElement(parentSelector) {
	  return parentSelector();
	}
	
	var Modal = function (_Component) {
	  _inherits(Modal, _Component);
	
	  function Modal() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, Modal);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.removePortal = function () {
	      !isReact16 && _reactDom2.default.unmountComponentAtNode(_this.node);
	      var parent = getParentElement(_this.props.parentSelector);
	      parent.removeChild(_this.node);
	    }, _this.portalRef = function (ref) {
	      _this.portal = ref;
	    }, _this.renderPortal = function (props) {
	      var portal = createPortal(_this, _react2.default.createElement(_ModalPortal2.default, _extends({ defaultStyles: Modal.defaultStyles }, props)), _this.node);
	      _this.portalRef(portal);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(Modal, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      if (!_safeHTMLElement.canUseDOM) return;
	
	      if (!isReact16) {
	        this.node = document.createElement("div");
	      }
	      this.node.className = this.props.portalClassName;
	
	      var parent = getParentElement(this.props.parentSelector);
	      parent.appendChild(this.node);
	
	      !isReact16 && this.renderPortal(this.props);
	    }
	  }, {
	    key: "componentWillReceiveProps",
	    value: function componentWillReceiveProps(newProps) {
	      if (!_safeHTMLElement.canUseDOM) return;
	      var isOpen = newProps.isOpen;
	      // Stop unnecessary renders if modal is remaining closed
	
	      if (!this.props.isOpen && !isOpen) return;
	
	      var currentParent = getParentElement(this.props.parentSelector);
	      var newParent = getParentElement(newProps.parentSelector);
	
	      if (newParent !== currentParent) {
	        currentParent.removeChild(this.node);
	        newParent.appendChild(this.node);
	      }
	
	      !isReact16 && this.renderPortal(newProps);
	    }
	  }, {
	    key: "componentWillUpdate",
	    value: function componentWillUpdate(newProps) {
	      if (!_safeHTMLElement.canUseDOM) return;
	      if (newProps.portalClassName !== this.props.portalClassName) {
	        this.node.className = newProps.portalClassName;
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      if (!_safeHTMLElement.canUseDOM || !this.node || !this.portal) return;
	
	      var state = this.portal.state;
	      var now = Date.now();
	      var closesAt = state.isOpen && this.props.closeTimeoutMS && (state.closesAt || now + this.props.closeTimeoutMS);
	
	      if (closesAt) {
	        if (!state.beforeClose) {
	          this.portal.closeWithTimeout();
	        }
	
	        setTimeout(this.removePortal, closesAt - now);
	      } else {
	        this.removePortal();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      if (!_safeHTMLElement.canUseDOM || !isReact16) {
	        return null;
	      }
	
	      if (!this.node && isReact16) {
	        this.node = document.createElement("div");
	      }
	
	      return createPortal(_react2.default.createElement(_ModalPortal2.default, _extends({
	        ref: this.portalRef,
	        defaultStyles: Modal.defaultStyles
	      }, this.props)), this.node);
	    }
	  }], [{
	    key: "setAppElement",
	    value: function setAppElement(element) {
	      ariaAppHider.setElement(element);
	    }
	
	    /* eslint-disable react/no-unused-prop-types */
	
	    /* eslint-enable react/no-unused-prop-types */
	
	  }]);
	
	  return Modal;
	}(_react.Component);
	
	Modal.propTypes = {
	  isOpen: _propTypes2.default.bool.isRequired,
	  style: _propTypes2.default.shape({
	    content: _propTypes2.default.object,
	    overlay: _propTypes2.default.object
	  }),
	  portalClassName: _propTypes2.default.string,
	  bodyOpenClassName: _propTypes2.default.string,
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
	    base: _propTypes2.default.string.isRequired,
	    afterOpen: _propTypes2.default.string.isRequired,
	    beforeClose: _propTypes2.default.string.isRequired
	  })]),
	  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
	    base: _propTypes2.default.string.isRequired,
	    afterOpen: _propTypes2.default.string.isRequired,
	    beforeClose: _propTypes2.default.string.isRequired
	  })]),
	  appElement: _propTypes2.default.instanceOf(_safeHTMLElement2.default),
	  onAfterOpen: _propTypes2.default.func,
	  onRequestClose: _propTypes2.default.func,
	  closeTimeoutMS: _propTypes2.default.number,
	  ariaHideApp: _propTypes2.default.bool,
	  shouldFocusAfterRender: _propTypes2.default.bool,
	  shouldCloseOnOverlayClick: _propTypes2.default.bool,
	  shouldReturnFocusAfterClose: _propTypes2.default.bool,
	  parentSelector: _propTypes2.default.func,
	  aria: _propTypes2.default.object,
	  role: _propTypes2.default.string,
	  contentLabel: _propTypes2.default.string,
	  shouldCloseOnEsc: _propTypes2.default.bool
	};
	Modal.defaultProps = {
	  isOpen: false,
	  portalClassName: portalClassName,
	  bodyOpenClassName: bodyOpenClassName,
	  ariaHideApp: true,
	  closeTimeoutMS: 0,
	  shouldFocusAfterRender: true,
	  shouldCloseOnEsc: true,
	  shouldCloseOnOverlayClick: true,
	  shouldReturnFocusAfterClose: true,
	  parentSelector: function parentSelector() {
	    return document.body;
	  }
	};
	Modal.defaultStyles = {
	  overlay: {
	    position: "fixed",
	    top: 0,
	    left: 0,
	    right: 0,
	    bottom: 0,
	    backgroundColor: "rgba(255, 255, 255, 0.75)"
	  },
	  content: {
	    position: "absolute",
	    top: "40px",
	    left: "40px",
	    right: "40px",
	    bottom: "40px",
	    border: "1px solid #ccc",
	    background: "#fff",
	    overflow: "auto",
	    WebkitOverflowScrolling: "touch",
	    borderRadius: "4px",
	    outline: "none",
	    padding: "20px"
	  }
	};
	exports.default = Modal;

/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _focusManager = __webpack_require__(755);
	
	var focusManager = _interopRequireWildcard(_focusManager);
	
	var _scopeTab = __webpack_require__(756);
	
	var _scopeTab2 = _interopRequireDefault(_scopeTab);
	
	var _ariaAppHider = __webpack_require__(325);
	
	var ariaAppHider = _interopRequireWildcard(_ariaAppHider);
	
	var _refCount = __webpack_require__(326);
	
	var refCount = _interopRequireWildcard(_refCount);
	
	var _bodyClassList = __webpack_require__(754);
	
	var bodyClassList = _interopRequireWildcard(_bodyClassList);
	
	var _safeHTMLElement = __webpack_require__(327);
	
	var _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// so that our CSS is statically analyzable
	var CLASS_NAMES = {
	  overlay: "ReactModal__Overlay",
	  content: "ReactModal__Content"
	};
	
	var TAB_KEY = 9;
	var ESC_KEY = 27;
	
	var ModalPortal = function (_Component) {
	  _inherits(ModalPortal, _Component);
	
	  function ModalPortal(props) {
	    _classCallCheck(this, ModalPortal);
	
	    var _this = _possibleConstructorReturn(this, (ModalPortal.__proto__ || Object.getPrototypeOf(ModalPortal)).call(this, props));
	
	    _this.setFocusAfterRender = function (focus) {
	      _this.focusAfterRender = _this.props.shouldFocusAfterRender && focus;
	    };
	
	    _this.setOverlayRef = function (overlay) {
	      _this.overlay = overlay;
	    };
	
	    _this.setContentRef = function (content) {
	      _this.content = content;
	    };
	
	    _this.afterClose = function () {
	      // Remove body class
	      bodyClassList.remove(_this.props.bodyOpenClassName);
	
	      if (_this.props.shouldFocusAfterRender) {
	        if (_this.props.shouldReturnFocusAfterClose) {
	          focusManager.returnFocus();
	          focusManager.teardownScopedFocus();
	        } else {
	          focusManager.popWithoutFocus();
	        }
	      }
	    };
	
	    _this.open = function () {
	      _this.beforeOpen();
	      if (_this.state.afterOpen && _this.state.beforeClose) {
	        clearTimeout(_this.closeTimer);
	        _this.setState({ beforeClose: false });
	      } else {
	        if (_this.props.shouldFocusAfterRender) {
	          focusManager.setupScopedFocus(_this.node);
	          focusManager.markForFocusLater();
	        }
	
	        _this.setState({ isOpen: true }, function () {
	          _this.setState({ afterOpen: true });
	
	          if (_this.props.isOpen && _this.props.onAfterOpen) {
	            _this.props.onAfterOpen();
	          }
	        });
	      }
	    };
	
	    _this.close = function () {
	      _this.beforeClose();
	      if (_this.props.closeTimeoutMS > 0) {
	        _this.closeWithTimeout();
	      } else {
	        _this.closeWithoutTimeout();
	      }
	    };
	
	    _this.focusContent = function () {
	      return _this.content && !_this.contentHasFocus() && _this.content.focus();
	    };
	
	    _this.closeWithTimeout = function () {
	      var closesAt = Date.now() + _this.props.closeTimeoutMS;
	      _this.setState({ beforeClose: true, closesAt: closesAt }, function () {
	        _this.closeTimer = setTimeout(_this.closeWithoutTimeout, _this.state.closesAt - Date.now());
	      });
	    };
	
	    _this.closeWithoutTimeout = function () {
	      _this.setState({
	        beforeClose: false,
	        isOpen: false,
	        afterOpen: false,
	        closesAt: null
	      }, _this.afterClose);
	    };
	
	    _this.handleKeyDown = function (event) {
	      if (event.keyCode === TAB_KEY) {
	        (0, _scopeTab2.default)(_this.content, event);
	      }
	
	      if (_this.props.shouldCloseOnEsc && event.keyCode === ESC_KEY) {
	        event.preventDefault();
	        _this.requestClose(event);
	      }
	    };
	
	    _this.handleOverlayOnClick = function (event) {
	      if (_this.shouldClose === null) {
	        _this.shouldClose = true;
	      }
	
	      if (_this.shouldClose && _this.props.shouldCloseOnOverlayClick) {
	        if (_this.ownerHandlesClose()) {
	          _this.requestClose(event);
	        } else {
	          _this.focusContent();
	        }
	      }
	      _this.shouldClose = null;
	      _this.moveFromContentToOverlay = null;
	    };
	
	    _this.handleOverlayOnMouseUp = function () {
	      if (_this.moveFromContentToOverlay === null) {
	        _this.shouldClose = false;
	      }
	    };
	
	    _this.handleContentOnMouseUp = function () {
	      _this.shouldClose = false;
	    };
	
	    _this.handleOverlayOnMouseDown = function (event) {
	      if (!_this.props.shouldCloseOnOverlayClick) {
	        event.preventDefault();
	      }
	      _this.moveFromContentToOverlay = false;
	    };
	
	    _this.handleContentOnClick = function () {
	      _this.shouldClose = false;
	    };
	
	    _this.handleContentOnMouseDown = function () {
	      _this.shouldClose = false;
	      _this.moveFromContentToOverlay = false;
	    };
	
	    _this.requestClose = function (event) {
	      return _this.ownerHandlesClose() && _this.props.onRequestClose(event);
	    };
	
	    _this.ownerHandlesClose = function () {
	      return _this.props.onRequestClose;
	    };
	
	    _this.shouldBeClosed = function () {
	      return !_this.state.isOpen && !_this.state.beforeClose;
	    };
	
	    _this.contentHasFocus = function () {
	      return document.activeElement === _this.content || _this.content.contains(document.activeElement);
	    };
	
	    _this.buildClassName = function (which, additional) {
	      var classNames = (typeof additional === "undefined" ? "undefined" : _typeof(additional)) === "object" ? additional : {
	        base: CLASS_NAMES[which],
	        afterOpen: CLASS_NAMES[which] + "--after-open",
	        beforeClose: CLASS_NAMES[which] + "--before-close"
	      };
	      var className = classNames.base;
	      if (_this.state.afterOpen) {
	        className = className + " " + classNames.afterOpen;
	      }
	      if (_this.state.beforeClose) {
	        className = className + " " + classNames.beforeClose;
	      }
	      return typeof additional === "string" && additional ? className + " " + additional : className;
	    };
	
	    _this.ariaAttributes = function (items) {
	      return Object.keys(items).reduce(function (acc, name) {
	        acc["aria-" + name] = items[name];
	        return acc;
	      }, {});
	    };
	
	    _this.state = {
	      afterOpen: false,
	      beforeClose: false
	    };
	
	    _this.shouldClose = null;
	    _this.moveFromContentToOverlay = null;
	    return _this;
	  }
	
	  _createClass(ModalPortal, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      // Focus needs to be set when mounting and already open
	      if (this.props.isOpen) {
	        this.setFocusAfterRender(true);
	        this.open();
	      }
	    }
	  }, {
	    key: "componentWillReceiveProps",
	    value: function componentWillReceiveProps(newProps) {
	      if (false) {
	        if (newProps.bodyOpenClassName !== this.props.bodyOpenClassName) {
	          // eslint-disable-next-line no-console
	          console.warn('React-Modal: "bodyOpenClassName" prop has been modified. ' + "This may cause unexpected behavior when multiple modals are open.");
	        }
	      }
	      // Focus only needs to be set once when the modal is being opened
	      if (!this.props.isOpen && newProps.isOpen) {
	        this.setFocusAfterRender(true);
	        this.open();
	      } else if (this.props.isOpen && !newProps.isOpen) {
	        this.close();
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      if (this.focusAfterRender) {
	        this.focusContent();
	        this.setFocusAfterRender(false);
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      // Remove body class
	      bodyClassList.remove(this.props.bodyOpenClassName);
	      this.beforeClose();
	      clearTimeout(this.closeTimer);
	    }
	  }, {
	    key: "beforeOpen",
	    value: function beforeOpen() {
	      var _props = this.props,
	          appElement = _props.appElement,
	          ariaHideApp = _props.ariaHideApp,
	          bodyOpenClassName = _props.bodyOpenClassName;
	      // Add body class
	
	      bodyClassList.add(bodyOpenClassName);
	      // Add aria-hidden to appElement
	      if (ariaHideApp) {
	        ariaAppHider.hide(appElement);
	      }
	    }
	  }, {
	    key: "beforeClose",
	    value: function beforeClose() {
	      var _props2 = this.props,
	          appElement = _props2.appElement,
	          ariaHideApp = _props2.ariaHideApp;
	      // Reset aria-hidden attribute if all modals have been removed
	
	      if (ariaHideApp && refCount.totalCount() < 1) {
	        ariaAppHider.show(appElement);
	      }
	    }
	
	    // Don't steal focus from inner elements
	
	  }, {
	    key: "render",
	    value: function render() {
	      var _props3 = this.props,
	          className = _props3.className,
	          overlayClassName = _props3.overlayClassName,
	          defaultStyles = _props3.defaultStyles;
	
	      var contentStyles = className ? {} : defaultStyles.content;
	      var overlayStyles = overlayClassName ? {} : defaultStyles.overlay;
	
	      return this.shouldBeClosed() ? null : _react2.default.createElement(
	        "div",
	        {
	          ref: this.setOverlayRef,
	          className: this.buildClassName("overlay", overlayClassName),
	          style: _extends({}, overlayStyles, this.props.style.overlay),
	          onClick: this.handleOverlayOnClick,
	          onMouseDown: this.handleOverlayOnMouseDown,
	          onMouseUp: this.handleOverlayOnMouseUp
	        },
	        _react2.default.createElement(
	          "div",
	          _extends({
	            ref: this.setContentRef,
	            style: _extends({}, contentStyles, this.props.style.content),
	            className: this.buildClassName("content", className),
	            tabIndex: "-1",
	            onKeyDown: this.handleKeyDown,
	            onMouseDown: this.handleContentOnMouseDown,
	            onMouseUp: this.handleContentOnMouseUp,
	            onClick: this.handleContentOnClick,
	            role: this.props.role,
	            "aria-label": this.props.contentLabel
	          }, this.ariaAttributes(this.props.aria || {})),
	          this.props.children
	        )
	      );
	    }
	  }]);
	
	  return ModalPortal;
	}(_react.Component);
	
	ModalPortal.defaultProps = {
	  style: {
	    overlay: {},
	    content: {}
	  }
	};
	ModalPortal.propTypes = {
	  isOpen: _propTypes2.default.bool.isRequired,
	  defaultStyles: _propTypes2.default.shape({
	    content: _propTypes2.default.object,
	    overlay: _propTypes2.default.object
	  }),
	  style: _propTypes2.default.shape({
	    content: _propTypes2.default.object,
	    overlay: _propTypes2.default.object
	  }),
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
	  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
	  bodyOpenClassName: _propTypes2.default.string,
	  ariaHideApp: _propTypes2.default.bool,
	  appElement: _propTypes2.default.instanceOf(_safeHTMLElement2.default),
	  onAfterOpen: _propTypes2.default.func,
	  onRequestClose: _propTypes2.default.func,
	  closeTimeoutMS: _propTypes2.default.number,
	  shouldFocusAfterRender: _propTypes2.default.bool,
	  shouldCloseOnOverlayClick: _propTypes2.default.bool,
	  shouldReturnFocusAfterClose: _propTypes2.default.bool,
	  role: _propTypes2.default.string,
	  contentLabel: _propTypes2.default.string,
	  aria: _propTypes2.default.object,
	  children: _propTypes2.default.node,
	  shouldCloseOnEsc: _propTypes2.default.bool
	};
	exports.default = ModalPortal;
	module.exports = exports["default"];

/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.add = add;
	exports.remove = remove;
	
	var _refCount = __webpack_require__(326);
	
	var refCount = _interopRequireWildcard(_refCount);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function add(bodyClass) {
	  // Increment class(es) on refCount tracker and add class(es) to body
	  bodyClass.split(" ").map(refCount.add).forEach(function (className) {
	    return document.body.classList.add(className);
	  });
	}
	
	function remove(bodyClass) {
	  var classListMap = refCount.get();
	  // Decrement class(es) from the refCount tracker
	  // and remove unused class(es) from body
	  bodyClass.split(" ").map(refCount.remove).filter(function (className) {
	    return classListMap[className] === 0;
	  }).forEach(function (className) {
	    return document.body.classList.remove(className);
	  });
	}

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.handleBlur = handleBlur;
	exports.handleFocus = handleFocus;
	exports.markForFocusLater = markForFocusLater;
	exports.returnFocus = returnFocus;
	exports.popWithoutFocus = popWithoutFocus;
	exports.setupScopedFocus = setupScopedFocus;
	exports.teardownScopedFocus = teardownScopedFocus;
	
	var _tabbable = __webpack_require__(328);
	
	var _tabbable2 = _interopRequireDefault(_tabbable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var focusLaterElements = [];
	var modalElement = null;
	var needToFocus = false;
	
	function handleBlur() {
	  needToFocus = true;
	}
	
	function handleFocus() {
	  if (needToFocus) {
	    needToFocus = false;
	    if (!modalElement) {
	      return;
	    }
	    // need to see how jQuery shims document.on('focusin') so we don't need the
	    // setTimeout, firefox doesn't support focusin, if it did, we could focus
	    // the element outside of a setTimeout. Side-effect of this implementation
	    // is that the document.body gets focus, and then we focus our element right
	    // after, seems fine.
	    setTimeout(function () {
	      if (modalElement.contains(document.activeElement)) {
	        return;
	      }
	      var el = (0, _tabbable2.default)(modalElement)[0] || modalElement;
	      el.focus();
	    }, 0);
	  }
	}
	
	function markForFocusLater() {
	  focusLaterElements.push(document.activeElement);
	}
	
	/* eslint-disable no-console */
	function returnFocus() {
	  var toFocus = null;
	  try {
	    toFocus = focusLaterElements.pop();
	    toFocus.focus();
	    return;
	  } catch (e) {
	    console.warn(["You tried to return focus to", toFocus, "but it is not in the DOM anymore"].join(" "));
	  }
	}
	/* eslint-enable no-console */
	
	function popWithoutFocus() {
	  focusLaterElements.length > 0 && focusLaterElements.pop();
	}
	
	function setupScopedFocus(element) {
	  modalElement = element;
	
	  if (window.addEventListener) {
	    window.addEventListener("blur", handleBlur, false);
	    document.addEventListener("focus", handleFocus, true);
	  } else {
	    window.attachEvent("onBlur", handleBlur);
	    document.attachEvent("onFocus", handleFocus);
	  }
	}
	
	function teardownScopedFocus() {
	  modalElement = null;
	
	  if (window.addEventListener) {
	    window.removeEventListener("blur", handleBlur);
	    document.removeEventListener("focus", handleFocus);
	  } else {
	    window.detachEvent("onBlur", handleBlur);
	    document.detachEvent("onFocus", handleFocus);
	  }
	}

/***/ }),
/* 756 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = scopeTab;
	
	var _tabbable = __webpack_require__(328);
	
	var _tabbable2 = _interopRequireDefault(_tabbable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function scopeTab(node, event) {
	  var tabbable = (0, _tabbable2.default)(node);
	
	  if (!tabbable.length) {
	    // Do nothing, since there are no elements that can receive focus.
	    event.preventDefault();
	    return;
	  }
	
	  var shiftKey = event.shiftKey;
	  var head = tabbable[0];
	  var tail = tabbable[tabbable.length - 1];
	
	  // proceed with default browser behavior
	  if (node === document.activeElement) {
	    return;
	  }
	
	  var target;
	  if (tail === document.activeElement && !shiftKey) {
	    target = head;
	  }
	
	  if (head === document.activeElement && shiftKey) {
	    target = tail;
	  }
	
	  if (target) {
	    event.preventDefault();
	    target.focus();
	    return;
	  }
	
	  // Safari radio issue.
	  //
	  // Safari does not move the focus to the radio button,
	  // so we need to force it to really walk through all elements.
	  //
	  // This is very error prune, since we are trying to guess
	  // if it is a safari browser from the first occurence between
	  // chrome or safari.
	  //
	  // The chrome user agent contains the first ocurrence
	  // as the 'chrome/version' and later the 'safari/version'.
	  var checkSafari = /(\bChrome\b|\bSafari\b)\//.exec(navigator.userAgent);
	  var isSafariDesktop = checkSafari != null && checkSafari[1] != "Chrome" && /\biPod\b|\biPad\b/g.exec(navigator.userAgent) == null;
	
	  // If we are not in safari desktop, let the browser control
	  // the focus
	  if (!isSafariDesktop) return;
	
	  var x = tabbable.indexOf(document.activeElement);
	
	  if (x > -1) {
	    x += shiftKey ? -1 : 1;
	  }
	
	  event.preventDefault();
	
	  tabbable[x].focus();
	}
	module.exports = exports["default"];

/***/ }),
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(123);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _extends2 = __webpack_require__(210);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	exports.createStyleObject = createStyleObject;
	exports.createClassNameString = createClassNameString;
	exports.createChildren = createChildren;
	exports.default = createElement;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createStyleObject(classNames) {
	  var elementStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var stylesheet = arguments[2];
	
	  return classNames.reduce(function (styleObject, className) {
	    return (0, _extends3.default)({}, styleObject, stylesheet[className]);
	  }, elementStyle);
	}
	
	function createClassNameString(classNames) {
	  return classNames.join(' ');
	}
	
	function createChildren(stylesheet, useInlineStyles) {
	  var childrenCount = 0;
	  return function (children) {
	    childrenCount += 1;
	    return children.map(function (child, i) {
	      return createElement({
	        node: child,
	        stylesheet: stylesheet,
	        useInlineStyles: useInlineStyles,
	        key: 'code-segment-' + childrenCount + '-' + i
	      });
	    });
	  };
	}
	
	function createElement(_ref) {
	  var node = _ref.node,
	      stylesheet = _ref.stylesheet,
	      _ref$style = _ref.style,
	      style = _ref$style === undefined ? {} : _ref$style,
	      useInlineStyles = _ref.useInlineStyles,
	      key = _ref.key;
	  var properties = node.properties,
	      type = node.type,
	      TagName = node.tagName,
	      value = node.value;
	
	  if (type === 'text') {
	    return value;
	  } else if (TagName) {
	    var childrenCreator = createChildren(stylesheet, useInlineStyles);
	    var props = useInlineStyles ? {
	      style: createStyleObject(properties.className, (0, _assign2.default)({}, properties.style, style), stylesheet)
	    } : { className: createClassNameString(properties.className) };
	    var children = childrenCreator(node.children);
	    return _react2.default.createElement(
	      TagName,
	      (0, _extends3.default)({ key: key }, props),
	      children
	    );
	  }
	}

/***/ }),
/* 776 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _objectWithoutProperties2 = __webpack_require__(211);
	
	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);
	
	var _assign = __webpack_require__(123);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (astGenerator, defaultStyle) {
	  return function SyntaxHighlighter(_ref6) {
	    var language = _ref6.language,
	        children = _ref6.children,
	        _ref6$style = _ref6.style,
	        style = _ref6$style === undefined ? defaultStyle : _ref6$style,
	        _ref6$customStyle = _ref6.customStyle,
	        customStyle = _ref6$customStyle === undefined ? {} : _ref6$customStyle,
	        _ref6$codeTagProps = _ref6.codeTagProps,
	        codeTagProps = _ref6$codeTagProps === undefined ? { style: style['code[class*=\"language-\"]'] } : _ref6$codeTagProps,
	        _ref6$useInlineStyles = _ref6.useInlineStyles,
	        useInlineStyles = _ref6$useInlineStyles === undefined ? true : _ref6$useInlineStyles,
	        _ref6$showLineNumbers = _ref6.showLineNumbers,
	        showLineNumbers = _ref6$showLineNumbers === undefined ? false : _ref6$showLineNumbers,
	        _ref6$startingLineNum = _ref6.startingLineNumber,
	        startingLineNumber = _ref6$startingLineNum === undefined ? 1 : _ref6$startingLineNum,
	        lineNumberContainerStyle = _ref6.lineNumberContainerStyle,
	        lineNumberStyle = _ref6.lineNumberStyle,
	        wrapLines = _ref6.wrapLines,
	        _ref6$lineStyle = _ref6.lineStyle,
	        lineStyle = _ref6$lineStyle === undefined ? {} : _ref6$lineStyle,
	        renderer = _ref6.renderer,
	        _ref6$PreTag = _ref6.PreTag,
	        PreTag = _ref6$PreTag === undefined ? 'pre' : _ref6$PreTag,
	        _ref6$CodeTag = _ref6.CodeTag,
	        CodeTag = _ref6$CodeTag === undefined ? 'code' : _ref6$CodeTag,
	        _ref6$code = _ref6.code,
	        code = _ref6$code === undefined ? Array.isArray(children) ? children[0] : children : _ref6$code,
	        rest = (0, _objectWithoutProperties3.default)(_ref6, ['language', 'children', 'style', 'customStyle', 'codeTagProps', 'useInlineStyles', 'showLineNumbers', 'startingLineNumber', 'lineNumberContainerStyle', 'lineNumberStyle', 'wrapLines', 'lineStyle', 'renderer', 'PreTag', 'CodeTag', 'code']);
	
	    /* 
	     * some custom renderers rely on individual row elements so we need to turn wrapLines on 
	     * if renderer is provided and wrapLines is undefined
	    */
	    wrapLines = renderer && wrapLines === undefined ? true : wrapLines;
	    renderer = renderer || defaultRenderer;
	    var defaultCodeValue = [{ type: 'text', value: code }];
	    var codeTree = getCodeTree({ astGenerator: astGenerator, language: language, code: code, defaultCodeValue: defaultCodeValue });
	    if (codeTree.language === null) {
	      codeTree.value = defaultCodeValue;
	    }
	    var defaultPreStyle = style.hljs || style['pre[class*=\"language-\"]'] || { backgroundColor: '#fff' };
	    var preProps = useInlineStyles ? (0, _assign2.default)({}, rest, { style: (0, _assign2.default)({}, defaultPreStyle, customStyle) }) : (0, _assign2.default)({}, rest, { className: 'hljs' });
	    var tree = wrapLines ? wrapLinesInSpan(codeTree, lineStyle) : codeTree.value;
	    var lineNumbers = showLineNumbers ? _react2.default.createElement(LineNumbers, {
	      containerStyle: lineNumberContainerStyle,
	      codeStyle: codeTagProps.style || {},
	      numberStyle: lineNumberStyle,
	      startingLineNumber: startingLineNumber,
	      codeString: code
	    }) : null;
	    return _react2.default.createElement(
	      PreTag,
	      preProps,
	      lineNumbers,
	      _react2.default.createElement(
	        CodeTag,
	        codeTagProps,
	        renderer({ rows: tree, stylesheet: style, useInlineStyles: useInlineStyles })
	      )
	    );
	  };
	};
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createElement = __webpack_require__(775);
	
	var _createElement2 = _interopRequireDefault(_createElement);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var newLineRegex = /\n/g;
	function getNewLines(str) {
	  return str.match(newLineRegex);
	}
	
	function getLineNumbers(_ref) {
	  var lines = _ref.lines,
	      startingLineNumber = _ref.startingLineNumber,
	      style = _ref.style;
	
	  return lines.map(function (_, i) {
	    var number = i + startingLineNumber;
	    return _react2.default.createElement(
	      'span',
	      {
	        key: 'line-' + i,
	        className: 'react-syntax-highlighter-line-number',
	        style: typeof style === 'function' ? style(number) : style
	      },
	      number + '\n'
	    );
	  });
	}
	
	function LineNumbers(_ref2) {
	  var codeString = _ref2.codeString,
	      codeStyle = _ref2.codeStyle,
	      _ref2$containerStyle = _ref2.containerStyle,
	      containerStyle = _ref2$containerStyle === undefined ? { float: 'left', paddingRight: '10px' } : _ref2$containerStyle,
	      _ref2$numberStyle = _ref2.numberStyle,
	      numberStyle = _ref2$numberStyle === undefined ? {} : _ref2$numberStyle,
	      startingLineNumber = _ref2.startingLineNumber;
	
	  return _react2.default.createElement(
	    'code',
	    { style: (0, _assign2.default)({}, codeStyle, containerStyle) },
	    getLineNumbers({
	      lines: codeString.replace(/\n$/, '').split('\n'),
	      style: numberStyle,
	      startingLineNumber: startingLineNumber
	    })
	  );
	}
	
	function createLineElement(_ref3) {
	  var children = _ref3.children,
	      lineNumber = _ref3.lineNumber,
	      lineStyle = _ref3.lineStyle,
	      _ref3$className = _ref3.className,
	      className = _ref3$className === undefined ? [] : _ref3$className;
	
	  return {
	    type: 'element',
	    tagName: 'span',
	    properties: {
	      className: className,
	      style: typeof lineStyle === 'function' ? lineStyle(lineNumber) : lineStyle
	    },
	    children: children
	  };
	}
	
	function flattenCodeTree(tree) {
	  var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var newTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	
	  for (var i = 0; i < tree.length; i++) {
	    var node = tree[i];
	    if (node.type === 'text') {
	      newTree.push(createLineElement({
	        children: [node],
	        className: className
	      }));
	    } else if (node.children) {
	      var classNames = className.concat(node.properties.className);
	      newTree = newTree.concat(flattenCodeTree(node.children, classNames));
	    }
	  }
	  return newTree;
	}
	
	function wrapLinesInSpan(codeTree, lineStyle) {
	  var tree = flattenCodeTree(codeTree.value);
	  var newTree = [];
	  var lastLineBreakIndex = -1;
	  var index = 0;
	
	  var _loop = function _loop() {
	    var node = tree[index];
	    var value = node.children[0].value;
	    var newLines = getNewLines(value);
	    if (newLines) {
	      var splitValue = value.split('\n');
	      splitValue.forEach(function (text, i) {
	        var lineNumber = newTree.length + 1;
	        var newChild = { type: 'text', value: text + '\n' };
	        if (i === 0) {
	          var _children = tree.slice(lastLineBreakIndex + 1, index).concat(createLineElement({ children: [newChild], className: node.properties.className }));
	          newTree.push(createLineElement({ children: _children, lineNumber: lineNumber, lineStyle: lineStyle }));
	        } else if (i === splitValue.length - 1) {
	          var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
	          if (stringChild) {
	            var lastLineInPreviousSpan = { type: 'text', value: '' + text };
	            var newElem = createLineElement({ children: [lastLineInPreviousSpan], className: node.properties.className });
	            tree.splice(index + 1, 0, newElem);
	          } else {
	            newTree.push(createLineElement({ children: [newChild], lineNumber: lineNumber, lineStyle: lineStyle }));
	          }
	        } else {
	          newTree.push(createLineElement({ children: [newChild], lineNumber: lineNumber, lineStyle: lineStyle }));
	        }
	      });
	      lastLineBreakIndex = index;
	    }
	    index++;
	  };
	
	  while (index < tree.length) {
	    _loop();
	  }
	  if (lastLineBreakIndex !== tree.length - 1) {
	    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
	    if (children && children.length) {
	      newTree.push(createLineElement({ children: children, lineNumber: newTree.length + 1, lineStyle: lineStyle }));
	    }
	  }
	  return newTree;
	}
	
	function defaultRenderer(_ref4) {
	  var rows = _ref4.rows,
	      stylesheet = _ref4.stylesheet,
	      useInlineStyles = _ref4.useInlineStyles;
	
	  return rows.map(function (node, i) {
	    return (0, _createElement2.default)({
	      node: node,
	      stylesheet: stylesheet,
	      useInlineStyles: useInlineStyles,
	      key: 'code-segement' + i
	    });
	  });
	}
	
	function getCodeTree(_ref5) {
	  var astGenerator = _ref5.astGenerator,
	      language = _ref5.language,
	      code = _ref5.code,
	      defaultCodeValue = _ref5.defaultCodeValue;
	
	  if (astGenerator.getLanguage) {
	    var hasLanguage = language && astGenerator.getLanguage(language);
	    if (language === 'text') {
	      return { value: defaultCodeValue, language: 'text' };
	    } else if (hasLanguage) {
	      return astGenerator.highlight(language, code);
	    } else {
	      return astGenerator.highlightAuto(code);
	    }
	  }
	  return language && language !== 'text' ? { value: astGenerator.highlight(code, language) } : { value: defaultCodeValue };
	}

/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _highlight = __webpack_require__(776);
	
	var _highlight2 = _interopRequireDefault(_highlight);
	
	var _prism = __webpack_require__(332);
	
	var _prism2 = _interopRequireDefault(_prism);
	
	var _refractor = __webpack_require__(862);
	
	var _refractor2 = _interopRequireDefault(_refractor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _highlight2.default)(_refractor2.default, _prism2.default);

/***/ }),
/* 778 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#c5c8c6",
	        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
	        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#c5c8c6",
	        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
	        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "borderRadius": "0.3em",
	        "background": "#1d1f21"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#1d1f21",
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#7C7C7C"
	    },
	    "prolog": {
	        "color": "#7C7C7C"
	    },
	    "doctype": {
	        "color": "#7C7C7C"
	    },
	    "cdata": {
	        "color": "#7C7C7C"
	    },
	    "punctuation": {
	        "color": "#c5c8c6"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "#96CBFE"
	    },
	    "keyword": {
	        "color": "#96CBFE"
	    },
	    "tag": {
	        "color": "#96CBFE"
	    },
	    "class-name": {
	        "color": "#FFFFB6",
	        "textDecoration": "underline"
	    },
	    "boolean": {
	        "color": "#99CC99"
	    },
	    "constant": {
	        "color": "#99CC99"
	    },
	    "symbol": {
	        "color": "#f92672"
	    },
	    "deleted": {
	        "color": "#f92672"
	    },
	    "number": {
	        "color": "#FF73FD"
	    },
	    "selector": {
	        "color": "#A8FF60"
	    },
	    "attr-name": {
	        "color": "#A8FF60"
	    },
	    "string": {
	        "color": "#A8FF60"
	    },
	    "char": {
	        "color": "#A8FF60"
	    },
	    "builtin": {
	        "color": "#A8FF60"
	    },
	    "inserted": {
	        "color": "#A8FF60"
	    },
	    "variable": {
	        "color": "#C6C5FE"
	    },
	    "operator": {
	        "color": "#EDEDED"
	    },
	    "entity": {
	        "color": "#FFFFB6",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#96CBFE"
	    },
	    ".language-css .token.string": {
	        "color": "#87C38A"
	    },
	    ".style .token.string": {
	        "color": "#87C38A"
	    },
	    "atrule": {
	        "color": "#F9EE98"
	    },
	    "attr-value": {
	        "color": "#F9EE98"
	    },
	    "function": {
	        "color": "#DAD085"
	    },
	    "regex": {
	        "color": "#E9C062"
	    },
	    "important": {
	        "color": "#fd971f",
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 779 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#f5f7ff",
	        "color": "#5e6687"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#f5f7ff",
	        "color": "#5e6687",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#dfe2f1"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#898ea4"
	    },
	    "prolog": {
	        "color": "#898ea4"
	    },
	    "doctype": {
	        "color": "#898ea4"
	    },
	    "cdata": {
	        "color": "#898ea4"
	    },
	    "punctuation": {
	        "color": "#5e6687"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "operator": {
	        "color": "#c76b29"
	    },
	    "boolean": {
	        "color": "#c76b29"
	    },
	    "number": {
	        "color": "#c76b29"
	    },
	    "property": {
	        "color": "#c08b30"
	    },
	    "tag": {
	        "color": "#3d8fd1"
	    },
	    "string": {
	        "color": "#22a2c9"
	    },
	    "selector": {
	        "color": "#6679cc"
	    },
	    "attr-name": {
	        "color": "#c76b29"
	    },
	    "entity": {
	        "color": "#22a2c9",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#22a2c9"
	    },
	    ".language-css .token.string": {
	        "color": "#22a2c9"
	    },
	    ".style .token.string": {
	        "color": "#22a2c9"
	    },
	    "attr-value": {
	        "color": "#ac9739"
	    },
	    "keyword": {
	        "color": "#ac9739"
	    },
	    "control": {
	        "color": "#ac9739"
	    },
	    "directive": {
	        "color": "#ac9739"
	    },
	    "unit": {
	        "color": "#ac9739"
	    },
	    "statement": {
	        "color": "#22a2c9"
	    },
	    "regex": {
	        "color": "#22a2c9"
	    },
	    "atrule": {
	        "color": "#22a2c9"
	    },
	    "placeholder": {
	        "color": "#3d8fd1"
	    },
	    "variable": {
	        "color": "#3d8fd1"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #202746",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#c94922"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": "0.4em solid #c94922",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#dfe2f1"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#979db4"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(107, 115, 148, 0.2) 70%, rgba(107, 115, 148, 0))"
	    }
	};

/***/ }),
/* 780 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#fff",
	        "textShadow": "0 1px 1px #000",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "wordSpacing": "normal",
	        "whiteSpace": "pre",
	        "wordWrap": "normal",
	        "lineHeight": "1.4",
	        "background": "none",
	        "border": "0",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#fff",
	        "textShadow": "0 1px 1px #000",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "wordSpacing": "normal",
	        "whiteSpace": "pre",
	        "wordWrap": "normal",
	        "lineHeight": "1.4",
	        "background": "#222",
	        "border": "0",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "15px",
	        "margin": "1em 0",
	        "overflow": "auto",
	        "MozBorderRadius": "8px",
	        "WebkitBorderRadius": "8px",
	        "borderRadius": "8px"
	    },
	    "pre[class*=\"language-\"] code": {
	        "float": "left",
	        "padding": "0 15px 0 0"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#222",
	        "padding": "5px 10px",
	        "lineHeight": "1",
	        "MozBorderRadius": "3px",
	        "WebkitBorderRadius": "3px",
	        "borderRadius": "3px"
	    },
	    "comment": {
	        "color": "#797979"
	    },
	    "prolog": {
	        "color": "#797979"
	    },
	    "doctype": {
	        "color": "#797979"
	    },
	    "cdata": {
	        "color": "#797979"
	    },
	    "selector": {
	        "color": "#fff"
	    },
	    "operator": {
	        "color": "#fff"
	    },
	    "punctuation": {
	        "color": "#fff"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#ffd893"
	    },
	    "boolean": {
	        "color": "#ffd893"
	    },
	    "atrule": {
	        "color": "#B0C975"
	    },
	    "attr-value": {
	        "color": "#B0C975"
	    },
	    "hex": {
	        "color": "#B0C975"
	    },
	    "string": {
	        "color": "#B0C975"
	    },
	    "property": {
	        "color": "#c27628"
	    },
	    "entity": {
	        "color": "#c27628",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#c27628"
	    },
	    "attr-name": {
	        "color": "#c27628"
	    },
	    "keyword": {
	        "color": "#c27628"
	    },
	    "regex": {
	        "color": "#9B71C6"
	    },
	    "function": {
	        "color": "#e5a638"
	    },
	    "constant": {
	        "color": "#e5a638"
	    },
	    "variable": {
	        "color": "#fdfba8"
	    },
	    "number": {
	        "color": "#8799B0"
	    },
	    "important": {
	        "color": "#E45734"
	    },
	    "deliminator": {
	        "color": "#E45734"
	    },
	    "pre[data-line]": {
	        "position": "relative",
	        "padding": "1em 0 1em 3em"
	    },
	    ".line-highlight": {
	        "position": "absolute",
	        "left": "0",
	        "right": "0",
	        "marginTop": "1em",
	        "background": "rgba(255,255,255,.2)",
	        "pointerEvents": "none",
	        "lineHeight": "inherit",
	        "whiteSpace": "pre"
	    },
	    ".line-highlight:before": {
	        "content": "attr(data-start)",
	        "position": "absolute",
	        "top": ".3em",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0 .5em",
	        "backgroundColor": "rgba(255,255,255,.3)",
	        "color": "#fff",
	        "font": "bold 65%/1.5 sans-serif",
	        "textAlign": "center",
	        "MozBorderRadius": "8px",
	        "WebkitBorderRadius": "8px",
	        "borderRadius": "8px",
	        "textShadow": "none"
	    },
	    ".line-highlight[data-end]:after": {
	        "content": "attr(data-end)",
	        "position": "absolute",
	        "top": "auto",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0 .5em",
	        "backgroundColor": "rgba(255,255,255,.3)",
	        "color": "#fff",
	        "font": "bold 65%/1.5 sans-serif",
	        "textAlign": "center",
	        "MozBorderRadius": "8px",
	        "WebkitBorderRadius": "8px",
	        "borderRadius": "8px",
	        "textShadow": "none",
	        "bottom": ".4em"
	    },
	    ".line-numbers-rows": {
	        "margin": "0"
	    },
	    ".line-numbers-rows span": {
	        "paddingRight": "10px",
	        "borderRight": "3px #d9d336 solid"
	    }
	};

/***/ }),
/* 781 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "black",
	        "background": "none",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "black",
	        "background": "none",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "position": "relative",
	        "margin": ".5em 0",
	        "overflow": "visible",
	        "padding": "0",
	        "backgroundColor": "#fdfdfd",
	        "WebkitBoxSizing": "border-box",
	        "MozBoxSizing": "border-box",
	        "boxSizing": "border-box",
	        "marginBottom": "1em"
	    },
	    "pre[class*=\"language-\"]>code": {
	        "position": "relative",
	        "borderLeft": "10px solid #358ccb",
	        "boxShadow": "-1px 0px 0px 0px #358ccb, 0px 0px 0px 1px #dfdfdf",
	        "backgroundColor": "#fdfdfd",
	        "backgroundImage": "linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%)",
	        "backgroundSize": "3em 3em",
	        "backgroundOrigin": "content-box",
	        "backgroundAttachment": "local"
	    },
	    "code[class*=\"language\"]": {
	        "maxHeight": "inherit",
	        "height": "100%",
	        "padding": "0 1em",
	        "display": "block",
	        "overflow": "auto"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "backgroundColor": "#fdfdfd",
	        "WebkitBoxSizing": "border-box",
	        "MozBoxSizing": "border-box",
	        "boxSizing": "border-box",
	        "marginBottom": "1em",
	        "position": "relative",
	        "padding": ".2em",
	        "borderRadius": "0.3em",
	        "color": "#c92c2c",
	        "border": "1px solid rgba(0, 0, 0, 0.1)",
	        "display": "inline",
	        "whiteSpace": "normal"
	    },
	    "pre[class*=\"language-\"]:before": {
	        "content": "''",
	        "zIndex": "-2",
	        "display": "block",
	        "position": "absolute",
	        "bottom": "0.75em",
	        "left": "0.18em",
	        "width": "40%",
	        "height": "20%",
	        "maxHeight": "13em",
	        "boxShadow": "0px 13px 8px #979797",
	        "WebkitTransform": "rotate(-2deg)",
	        "MozTransform": "rotate(-2deg)",
	        "msTransform": "rotate(-2deg)",
	        "OTransform": "rotate(-2deg)",
	        "transform": "rotate(-2deg)"
	    },
	    "pre[class*=\"language-\"]:after": {
	        "content": "''",
	        "zIndex": "-2",
	        "display": "block",
	        "position": "absolute",
	        "bottom": "0.75em",
	        "left": "auto",
	        "width": "40%",
	        "height": "20%",
	        "maxHeight": "13em",
	        "boxShadow": "0px 13px 8px #979797",
	        "WebkitTransform": "rotate(2deg)",
	        "MozTransform": "rotate(2deg)",
	        "msTransform": "rotate(2deg)",
	        "OTransform": "rotate(2deg)",
	        "transform": "rotate(2deg)",
	        "right": "0.75em"
	    },
	    ":not(pre) > code[class*=\"language-\"]:after": {
	        "right": "0.75em",
	        "left": "auto",
	        "WebkitTransform": "rotate(2deg)",
	        "MozTransform": "rotate(2deg)",
	        "msTransform": "rotate(2deg)",
	        "OTransform": "rotate(2deg)",
	        "transform": "rotate(2deg)"
	    },
	    "comment": {
	        "color": "#7D8B99"
	    },
	    "block-comment": {
	        "color": "#7D8B99"
	    },
	    "prolog": {
	        "color": "#7D8B99"
	    },
	    "doctype": {
	        "color": "#7D8B99"
	    },
	    "cdata": {
	        "color": "#7D8B99"
	    },
	    "punctuation": {
	        "color": "#5F6364"
	    },
	    "property": {
	        "color": "#c92c2c"
	    },
	    "tag": {
	        "color": "#c92c2c"
	    },
	    "boolean": {
	        "color": "#c92c2c"
	    },
	    "number": {
	        "color": "#c92c2c"
	    },
	    "function-name": {
	        "color": "#c92c2c"
	    },
	    "constant": {
	        "color": "#c92c2c"
	    },
	    "symbol": {
	        "color": "#c92c2c"
	    },
	    "deleted": {
	        "color": "#c92c2c"
	    },
	    "selector": {
	        "color": "#2f9c0a"
	    },
	    "attr-name": {
	        "color": "#2f9c0a"
	    },
	    "string": {
	        "color": "#2f9c0a"
	    },
	    "char": {
	        "color": "#2f9c0a"
	    },
	    "function": {
	        "color": "#2f9c0a"
	    },
	    "builtin": {
	        "color": "#2f9c0a"
	    },
	    "inserted": {
	        "color": "#2f9c0a"
	    },
	    "operator": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)"
	    },
	    "entity": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)"
	    },
	    "variable": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)"
	    },
	    "atrule": {
	        "color": "#1990b8"
	    },
	    "attr-value": {
	        "color": "#1990b8"
	    },
	    "keyword": {
	        "color": "#1990b8"
	    },
	    "class-name": {
	        "color": "#1990b8"
	    },
	    "regex": {
	        "color": "#e90"
	    },
	    "important": {
	        "color": "#e90",
	        "fontWeight": "normal"
	    },
	    ".language-css .token.string": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)"
	    },
	    ".style .token.string": {
	        "color": "#a67f59",
	        "background": "rgba(255, 255, 255, 0.5)"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "tab:not(:empty):before": {
	        "color": "#e0d7d1"
	    },
	    "cr:before": {
	        "color": "#e0d7d1"
	    },
	    "lf:before": {
	        "color": "#e0d7d1"
	    },
	    "pre[class*=\"language-\"].line-numbers": {
	        "paddingLeft": "0"
	    },
	    "pre[class*=\"language-\"].line-numbers code": {
	        "paddingLeft": "3.8em"
	    },
	    "pre[class*=\"language-\"].line-numbers .line-numbers-rows": {
	        "left": "0"
	    },
	    "pre[class*=\"language-\"][data-line]": {
	        "paddingTop": "0",
	        "paddingBottom": "0",
	        "paddingLeft": "0"
	    },
	    "pre[data-line] code": {
	        "position": "relative",
	        "paddingLeft": "4em"
	    },
	    "pre .line-highlight": {
	        "marginTop": "0"
	    }
	};

/***/ }),
/* 782 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#a9b7c6",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#a9b7c6",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "background": "#2b2b2b"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "color": "inherit",
	        "background": "rgba(33,66,131,.85)"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#2b2b2b",
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#808080"
	    },
	    "prolog": {
	        "color": "#808080"
	    },
	    "cdata": {
	        "color": "#808080"
	    },
	    "delimiter": {
	        "color": "#cc7832"
	    },
	    "boolean": {
	        "color": "#cc7832"
	    },
	    "keyword": {
	        "color": "#cc7832"
	    },
	    "selector": {
	        "color": "#cc7832"
	    },
	    "important": {
	        "color": "#cc7832"
	    },
	    "atrule": {
	        "color": "#cc7832"
	    },
	    "operator": {
	        "color": "#a9b7c6"
	    },
	    "punctuation": {
	        "color": "#a9b7c6"
	    },
	    "attr-name": {
	        "color": "#a9b7c6"
	    },
	    "tag": {
	        "color": "#e8bf6a"
	    },
	    "tag .punctuation": {
	        "color": "#e8bf6a"
	    },
	    "doctype": {
	        "color": "#e8bf6a"
	    },
	    "builtin": {
	        "color": "#e8bf6a"
	    },
	    "entity": {
	        "color": "#6897bb"
	    },
	    "number": {
	        "color": "#6897bb"
	    },
	    "symbol": {
	        "color": "#6897bb"
	    },
	    "property": {
	        "color": "#9876aa"
	    },
	    "constant": {
	        "color": "#9876aa"
	    },
	    "variable": {
	        "color": "#9876aa"
	    },
	    "string": {
	        "color": "#6a8759"
	    },
	    "char": {
	        "color": "#6a8759"
	    },
	    "attr-value": {
	        "color": "#a5c261"
	    },
	    "attr-value .punctuation": {
	        "color": "#a5c261"
	    },
	    "attr-value .punctuation:first-child": {
	        "color": "#a9b7c6"
	    },
	    "url": {
	        "color": "#287bde",
	        "textDecoration": "underline"
	    },
	    "function": {
	        "color": "#ffc66d"
	    },
	    "regex": {
	        "background": "#364135"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "inserted": {
	        "background": "#294436"
	    },
	    "deleted": {
	        "background": "#484a4a"
	    },
	    "code.language-css .token.property": {
	        "color": "#a9b7c6"
	    },
	    "code.language-css .token.property + .token.punctuation": {
	        "color": "#a9b7c6"
	    },
	    "code.language-css .token.id": {
	        "color": "#ffc66d"
	    },
	    "code.language-css .token.selector > .token.class": {
	        "color": "#ffc66d"
	    },
	    "code.language-css .token.selector > .token.attribute": {
	        "color": "#ffc66d"
	    },
	    "code.language-css .token.selector > .token.pseudo-class": {
	        "color": "#ffc66d"
	    },
	    "code.language-css .token.selector > .token.pseudo-element": {
	        "color": "#ffc66d"
	    }
	};

/***/ }),
/* 783 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "white",
	        "background": "none",
	        "textShadow": "0 -.1em .2em black",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "white",
	        "background": "hsl(30, 20%, 25%)",
	        "textShadow": "0 -.1em .2em black",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "border": ".3em solid hsl(30, 20%, 40%)",
	        "borderRadius": ".5em",
	        "boxShadow": "1px 1px .5em black inset"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "hsl(30, 20%, 25%)",
	        "padding": ".15em .2em .05em",
	        "borderRadius": ".3em",
	        "border": ".13em solid hsl(30, 20%, 40%)",
	        "boxShadow": "1px 1px .3em -.1em black inset",
	        "whiteSpace": "normal"
	    },
	    "comment": {
	        "color": "hsl(30, 20%, 50%)"
	    },
	    "prolog": {
	        "color": "hsl(30, 20%, 50%)"
	    },
	    "doctype": {
	        "color": "hsl(30, 20%, 50%)"
	    },
	    "cdata": {
	        "color": "hsl(30, 20%, 50%)"
	    },
	    "punctuation": {
	        "Opacity": ".7"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "tag": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "boolean": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "number": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "constant": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "symbol": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "selector": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "attr-name": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "string": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "char": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "builtin": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "inserted": {
	        "color": "hsl(75, 70%, 60%)"
	    },
	    "operator": {
	        "color": "hsl(40, 90%, 60%)"
	    },
	    "entity": {
	        "color": "hsl(40, 90%, 60%)",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "hsl(40, 90%, 60%)"
	    },
	    ".language-css .token.string": {
	        "color": "hsl(40, 90%, 60%)"
	    },
	    ".style .token.string": {
	        "color": "hsl(40, 90%, 60%)"
	    },
	    "variable": {
	        "color": "hsl(40, 90%, 60%)"
	    },
	    "atrule": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "attr-value": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "keyword": {
	        "color": "hsl(350, 40%, 70%)"
	    },
	    "regex": {
	        "color": "#e90"
	    },
	    "important": {
	        "color": "#e90",
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "deleted": {
	        "color": "red"
	    }
	};

/***/ }),
/* 784 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#2a2734",
	        "color": "#9a86fd"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#2a2734",
	        "color": "#9a86fd",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#6a51e6"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#6c6783"
	    },
	    "prolog": {
	        "color": "#6c6783"
	    },
	    "doctype": {
	        "color": "#6c6783"
	    },
	    "cdata": {
	        "color": "#6c6783"
	    },
	    "punctuation": {
	        "color": "#6c6783"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#e09142"
	    },
	    "operator": {
	        "color": "#e09142"
	    },
	    "number": {
	        "color": "#e09142"
	    },
	    "property": {
	        "color": "#9a86fd"
	    },
	    "function": {
	        "color": "#9a86fd"
	    },
	    "tag-id": {
	        "color": "#eeebff"
	    },
	    "selector": {
	        "color": "#eeebff"
	    },
	    "atrule-id": {
	        "color": "#eeebff"
	    },
	    "code.language-javascript": {
	        "color": "#c4b9fe"
	    },
	    "attr-name": {
	        "color": "#c4b9fe"
	    },
	    "code.language-css": {
	        "color": "#ffcc99"
	    },
	    "code.language-scss": {
	        "color": "#ffcc99"
	    },
	    "boolean": {
	        "color": "#ffcc99"
	    },
	    "string": {
	        "color": "#ffcc99"
	    },
	    "entity": {
	        "color": "#ffcc99",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#ffcc99"
	    },
	    ".language-css .token.string": {
	        "color": "#ffcc99"
	    },
	    ".language-scss .token.string": {
	        "color": "#ffcc99"
	    },
	    ".style .token.string": {
	        "color": "#ffcc99"
	    },
	    "attr-value": {
	        "color": "#ffcc99"
	    },
	    "keyword": {
	        "color": "#ffcc99"
	    },
	    "control": {
	        "color": "#ffcc99"
	    },
	    "directive": {
	        "color": "#ffcc99"
	    },
	    "unit": {
	        "color": "#ffcc99"
	    },
	    "statement": {
	        "color": "#ffcc99"
	    },
	    "regex": {
	        "color": "#ffcc99"
	    },
	    "atrule": {
	        "color": "#ffcc99"
	    },
	    "placeholder": {
	        "color": "#ffcc99"
	    },
	    "variable": {
	        "color": "#ffcc99"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #eeebff",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#c4b9fe"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #8a75f5",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#2c2937"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#3c3949"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(224, 145, 66, 0.2) 70%, rgba(224, 145, 66, 0))"
	    }
	};

/***/ }),
/* 785 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#322d29",
	        "color": "#88786d"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#322d29",
	        "color": "#88786d",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#6f5849"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#6a5f58"
	    },
	    "prolog": {
	        "color": "#6a5f58"
	    },
	    "doctype": {
	        "color": "#6a5f58"
	    },
	    "cdata": {
	        "color": "#6a5f58"
	    },
	    "punctuation": {
	        "color": "#6a5f58"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#bfa05a"
	    },
	    "operator": {
	        "color": "#bfa05a"
	    },
	    "number": {
	        "color": "#bfa05a"
	    },
	    "property": {
	        "color": "#88786d"
	    },
	    "function": {
	        "color": "#88786d"
	    },
	    "tag-id": {
	        "color": "#fff3eb"
	    },
	    "selector": {
	        "color": "#fff3eb"
	    },
	    "atrule-id": {
	        "color": "#fff3eb"
	    },
	    "code.language-javascript": {
	        "color": "#a48774"
	    },
	    "attr-name": {
	        "color": "#a48774"
	    },
	    "code.language-css": {
	        "color": "#fcc440"
	    },
	    "code.language-scss": {
	        "color": "#fcc440"
	    },
	    "boolean": {
	        "color": "#fcc440"
	    },
	    "string": {
	        "color": "#fcc440"
	    },
	    "entity": {
	        "color": "#fcc440",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#fcc440"
	    },
	    ".language-css .token.string": {
	        "color": "#fcc440"
	    },
	    ".language-scss .token.string": {
	        "color": "#fcc440"
	    },
	    ".style .token.string": {
	        "color": "#fcc440"
	    },
	    "attr-value": {
	        "color": "#fcc440"
	    },
	    "keyword": {
	        "color": "#fcc440"
	    },
	    "control": {
	        "color": "#fcc440"
	    },
	    "directive": {
	        "color": "#fcc440"
	    },
	    "unit": {
	        "color": "#fcc440"
	    },
	    "statement": {
	        "color": "#fcc440"
	    },
	    "regex": {
	        "color": "#fcc440"
	    },
	    "atrule": {
	        "color": "#fcc440"
	    },
	    "placeholder": {
	        "color": "#fcc440"
	    },
	    "variable": {
	        "color": "#fcc440"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #fff3eb",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#a48774"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #816d5f",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#35302b"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#46403d"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(191, 160, 90, 0.2) 70%, rgba(191, 160, 90, 0))"
	    }
	};

/***/ }),
/* 786 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#2a2d2a",
	        "color": "#687d68"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#2a2d2a",
	        "color": "#687d68",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#435643"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#535f53"
	    },
	    "prolog": {
	        "color": "#535f53"
	    },
	    "doctype": {
	        "color": "#535f53"
	    },
	    "cdata": {
	        "color": "#535f53"
	    },
	    "punctuation": {
	        "color": "#535f53"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#a2b34d"
	    },
	    "operator": {
	        "color": "#a2b34d"
	    },
	    "number": {
	        "color": "#a2b34d"
	    },
	    "property": {
	        "color": "#687d68"
	    },
	    "function": {
	        "color": "#687d68"
	    },
	    "tag-id": {
	        "color": "#f0fff0"
	    },
	    "selector": {
	        "color": "#f0fff0"
	    },
	    "atrule-id": {
	        "color": "#f0fff0"
	    },
	    "code.language-javascript": {
	        "color": "#b3d6b3"
	    },
	    "attr-name": {
	        "color": "#b3d6b3"
	    },
	    "code.language-css": {
	        "color": "#e5fb79"
	    },
	    "code.language-scss": {
	        "color": "#e5fb79"
	    },
	    "boolean": {
	        "color": "#e5fb79"
	    },
	    "string": {
	        "color": "#e5fb79"
	    },
	    "entity": {
	        "color": "#e5fb79",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#e5fb79"
	    },
	    ".language-css .token.string": {
	        "color": "#e5fb79"
	    },
	    ".language-scss .token.string": {
	        "color": "#e5fb79"
	    },
	    ".style .token.string": {
	        "color": "#e5fb79"
	    },
	    "attr-value": {
	        "color": "#e5fb79"
	    },
	    "keyword": {
	        "color": "#e5fb79"
	    },
	    "control": {
	        "color": "#e5fb79"
	    },
	    "directive": {
	        "color": "#e5fb79"
	    },
	    "unit": {
	        "color": "#e5fb79"
	    },
	    "statement": {
	        "color": "#e5fb79"
	    },
	    "regex": {
	        "color": "#e5fb79"
	    },
	    "atrule": {
	        "color": "#e5fb79"
	    },
	    "placeholder": {
	        "color": "#e5fb79"
	    },
	    "variable": {
	        "color": "#e5fb79"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #f0fff0",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#b3d6b3"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #5c705c",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#2c302c"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#3b423b"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(162, 179, 77, 0.2) 70%, rgba(162, 179, 77, 0))"
	    }
	};

/***/ }),
/* 787 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#faf8f5",
	        "color": "#728fcb"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#faf8f5",
	        "color": "#728fcb",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#faf8f5"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#b6ad9a"
	    },
	    "prolog": {
	        "color": "#b6ad9a"
	    },
	    "doctype": {
	        "color": "#b6ad9a"
	    },
	    "cdata": {
	        "color": "#b6ad9a"
	    },
	    "punctuation": {
	        "color": "#b6ad9a"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#063289"
	    },
	    "operator": {
	        "color": "#063289"
	    },
	    "number": {
	        "color": "#063289"
	    },
	    "property": {
	        "color": "#b29762"
	    },
	    "function": {
	        "color": "#b29762"
	    },
	    "tag-id": {
	        "color": "#2d2006"
	    },
	    "selector": {
	        "color": "#2d2006"
	    },
	    "atrule-id": {
	        "color": "#2d2006"
	    },
	    "code.language-javascript": {
	        "color": "#896724"
	    },
	    "attr-name": {
	        "color": "#896724"
	    },
	    "code.language-css": {
	        "color": "#728fcb"
	    },
	    "code.language-scss": {
	        "color": "#728fcb"
	    },
	    "boolean": {
	        "color": "#728fcb"
	    },
	    "string": {
	        "color": "#728fcb"
	    },
	    "entity": {
	        "color": "#728fcb",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#728fcb"
	    },
	    ".language-css .token.string": {
	        "color": "#728fcb"
	    },
	    ".language-scss .token.string": {
	        "color": "#728fcb"
	    },
	    ".style .token.string": {
	        "color": "#728fcb"
	    },
	    "attr-value": {
	        "color": "#728fcb"
	    },
	    "keyword": {
	        "color": "#728fcb"
	    },
	    "control": {
	        "color": "#728fcb"
	    },
	    "directive": {
	        "color": "#728fcb"
	    },
	    "unit": {
	        "color": "#728fcb"
	    },
	    "statement": {
	        "color": "#728fcb"
	    },
	    "regex": {
	        "color": "#728fcb"
	    },
	    "atrule": {
	        "color": "#728fcb"
	    },
	    "placeholder": {
	        "color": "#93abdc"
	    },
	    "variable": {
	        "color": "#93abdc"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #2d2006",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#896724"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #896724",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#ece8de"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#cdc4b1"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0))"
	    }
	};

/***/ }),
/* 788 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#1d262f",
	        "color": "#57718e"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#1d262f",
	        "color": "#57718e",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#004a9e"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#4a5f78"
	    },
	    "prolog": {
	        "color": "#4a5f78"
	    },
	    "doctype": {
	        "color": "#4a5f78"
	    },
	    "cdata": {
	        "color": "#4a5f78"
	    },
	    "punctuation": {
	        "color": "#4a5f78"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#0aa370"
	    },
	    "operator": {
	        "color": "#0aa370"
	    },
	    "number": {
	        "color": "#0aa370"
	    },
	    "property": {
	        "color": "#57718e"
	    },
	    "function": {
	        "color": "#57718e"
	    },
	    "tag-id": {
	        "color": "#ebf4ff"
	    },
	    "selector": {
	        "color": "#ebf4ff"
	    },
	    "atrule-id": {
	        "color": "#ebf4ff"
	    },
	    "code.language-javascript": {
	        "color": "#7eb6f6"
	    },
	    "attr-name": {
	        "color": "#7eb6f6"
	    },
	    "code.language-css": {
	        "color": "#47ebb4"
	    },
	    "code.language-scss": {
	        "color": "#47ebb4"
	    },
	    "boolean": {
	        "color": "#47ebb4"
	    },
	    "string": {
	        "color": "#47ebb4"
	    },
	    "entity": {
	        "color": "#47ebb4",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#47ebb4"
	    },
	    ".language-css .token.string": {
	        "color": "#47ebb4"
	    },
	    ".language-scss .token.string": {
	        "color": "#47ebb4"
	    },
	    ".style .token.string": {
	        "color": "#47ebb4"
	    },
	    "attr-value": {
	        "color": "#47ebb4"
	    },
	    "keyword": {
	        "color": "#47ebb4"
	    },
	    "control": {
	        "color": "#47ebb4"
	    },
	    "directive": {
	        "color": "#47ebb4"
	    },
	    "unit": {
	        "color": "#47ebb4"
	    },
	    "statement": {
	        "color": "#47ebb4"
	    },
	    "regex": {
	        "color": "#47ebb4"
	    },
	    "atrule": {
	        "color": "#47ebb4"
	    },
	    "placeholder": {
	        "color": "#47ebb4"
	    },
	    "variable": {
	        "color": "#47ebb4"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #ebf4ff",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#7eb6f6"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #34659d",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#1f2932"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#2c3847"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(10, 163, 112, 0.2) 70%, rgba(10, 163, 112, 0))"
	    }
	};

/***/ }),
/* 789 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#24242e",
	        "color": "#767693"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace",
	        "fontSize": "14px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "#24242e",
	        "color": "#767693",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "#5151e6"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#5b5b76"
	    },
	    "prolog": {
	        "color": "#5b5b76"
	    },
	    "doctype": {
	        "color": "#5b5b76"
	    },
	    "cdata": {
	        "color": "#5b5b76"
	    },
	    "punctuation": {
	        "color": "#5b5b76"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "#dd672c"
	    },
	    "operator": {
	        "color": "#dd672c"
	    },
	    "number": {
	        "color": "#dd672c"
	    },
	    "property": {
	        "color": "#767693"
	    },
	    "function": {
	        "color": "#767693"
	    },
	    "tag-id": {
	        "color": "#ebebff"
	    },
	    "selector": {
	        "color": "#ebebff"
	    },
	    "atrule-id": {
	        "color": "#ebebff"
	    },
	    "code.language-javascript": {
	        "color": "#aaaaca"
	    },
	    "attr-name": {
	        "color": "#aaaaca"
	    },
	    "code.language-css": {
	        "color": "#fe8c52"
	    },
	    "code.language-scss": {
	        "color": "#fe8c52"
	    },
	    "boolean": {
	        "color": "#fe8c52"
	    },
	    "string": {
	        "color": "#fe8c52"
	    },
	    "entity": {
	        "color": "#fe8c52",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#fe8c52"
	    },
	    ".language-css .token.string": {
	        "color": "#fe8c52"
	    },
	    ".language-scss .token.string": {
	        "color": "#fe8c52"
	    },
	    ".style .token.string": {
	        "color": "#fe8c52"
	    },
	    "attr-value": {
	        "color": "#fe8c52"
	    },
	    "keyword": {
	        "color": "#fe8c52"
	    },
	    "control": {
	        "color": "#fe8c52"
	    },
	    "directive": {
	        "color": "#fe8c52"
	    },
	    "unit": {
	        "color": "#fe8c52"
	    },
	    "statement": {
	        "color": "#fe8c52"
	    },
	    "regex": {
	        "color": "#fe8c52"
	    },
	    "atrule": {
	        "color": "#fe8c52"
	    },
	    "placeholder": {
	        "color": "#fe8c52"
	    },
	    "variable": {
	        "color": "#fe8c52"
	    },
	    "deleted": {
	        "textDecoration": "line-through"
	    },
	    "inserted": {
	        "borderBottom": "1px dotted #ebebff",
	        "textDecoration": "none"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "important": {
	        "fontWeight": "bold",
	        "color": "#aaaaca"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid #7676f4",
	        "OutlineOffset": ".4em"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#262631"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#393949"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(221, 103, 44, 0.2) 70%, rgba(221, 103, 44, 0))"
	    }
	};

/***/ }),
/* 790 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "background": "black",
	        "color": "white",
	        "boxShadow": "-.3em 0 0 .3em black, .3em 0 0 .3em black"
	    },
	    "pre[class*=\"language-\"]": {
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": ".4em .8em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "background": "url('data:image/svg+xml;charset=utf-8,<svg%20version%3D\"1.1\"%20xmlns%3D\"http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg\"%20width%3D\"100\"%20height%3D\"100\"%20fill%3D\"rgba(0%2C0%2C0%2C.2)\">%0D%0A<polygon%20points%3D\"0%2C50%2050%2C0%200%2C0\"%20%2F>%0D%0A<polygon%20points%3D\"0%2C100%2050%2C100%20100%2C50%20100%2C0\"%20%2F>%0D%0A<%2Fsvg>')",
	        "backgroundSize": "1em 1em"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".2em",
	        "borderRadius": ".3em",
	        "boxShadow": "none",
	        "whiteSpace": "normal"
	    },
	    "comment": {
	        "color": "#aaa"
	    },
	    "prolog": {
	        "color": "#aaa"
	    },
	    "doctype": {
	        "color": "#aaa"
	    },
	    "cdata": {
	        "color": "#aaa"
	    },
	    "punctuation": {
	        "color": "#999"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "#0cf"
	    },
	    "tag": {
	        "color": "#0cf"
	    },
	    "boolean": {
	        "color": "#0cf"
	    },
	    "number": {
	        "color": "#0cf"
	    },
	    "constant": {
	        "color": "#0cf"
	    },
	    "symbol": {
	        "color": "#0cf"
	    },
	    "selector": {
	        "color": "yellow"
	    },
	    "attr-name": {
	        "color": "yellow"
	    },
	    "string": {
	        "color": "yellow"
	    },
	    "char": {
	        "color": "yellow"
	    },
	    "builtin": {
	        "color": "yellow"
	    },
	    "operator": {
	        "color": "yellowgreen"
	    },
	    "entity": {
	        "color": "yellowgreen",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "yellowgreen"
	    },
	    ".language-css .token.string": {
	        "color": "yellowgreen"
	    },
	    ".toke.variable": {
	        "color": "yellowgreen"
	    },
	    "inserted": {
	        "color": "yellowgreen"
	    },
	    "atrule": {
	        "color": "deeppink"
	    },
	    "attr-value": {
	        "color": "deeppink"
	    },
	    "keyword": {
	        "color": "deeppink"
	    },
	    "regex": {
	        "color": "orange"
	    },
	    "important": {
	        "color": "orange",
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "deleted": {
	        "color": "red"
	    }
	};

/***/ }),
/* 791 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#393A34",
	        "fontFamily": "\"Consolas\", \"Bitstream Vera Sans Mono\", \"Courier New\", Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "fontSize": "0.95em",
	        "lineHeight": "1.2em",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#393A34",
	        "fontFamily": "\"Consolas\", \"Bitstream Vera Sans Mono\", \"Courier New\", Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "fontSize": "0.95em",
	        "lineHeight": "1.2em",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "border": "1px solid #dddddd",
	        "backgroundColor": "white"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "background": "#b3d4fc"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "background": "#b3d4fc"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "background": "#b3d4fc"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".2em",
	        "paddingTop": "1px",
	        "paddingBottom": "1px",
	        "background": "#f8f8f8",
	        "border": "1px solid #dddddd"
	    },
	    "comment": {
	        "color": "#999988",
	        "fontStyle": "italic"
	    },
	    "prolog": {
	        "color": "#999988",
	        "fontStyle": "italic"
	    },
	    "doctype": {
	        "color": "#999988",
	        "fontStyle": "italic"
	    },
	    "cdata": {
	        "color": "#999988",
	        "fontStyle": "italic"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "string": {
	        "color": "#e3116c"
	    },
	    "attr-value": {
	        "color": "#e3116c"
	    },
	    "punctuation": {
	        "color": "#393A34"
	    },
	    "operator": {
	        "color": "#393A34"
	    },
	    "entity": {
	        "color": "#36acaa"
	    },
	    "url": {
	        "color": "#36acaa"
	    },
	    "symbol": {
	        "color": "#36acaa"
	    },
	    "number": {
	        "color": "#36acaa"
	    },
	    "boolean": {
	        "color": "#36acaa"
	    },
	    "variable": {
	        "color": "#36acaa"
	    },
	    "constant": {
	        "color": "#36acaa"
	    },
	    "property": {
	        "color": "#36acaa"
	    },
	    "regex": {
	        "color": "#36acaa"
	    },
	    "inserted": {
	        "color": "#36acaa"
	    },
	    "atrule": {
	        "color": "#00a4db"
	    },
	    "keyword": {
	        "color": "#00a4db"
	    },
	    "attr-name": {
	        "color": "#00a4db"
	    },
	    ".language-autohotkey .token.selector": {
	        "color": "#00a4db"
	    },
	    "function": {
	        "color": "#9a050f",
	        "fontWeight": "bold"
	    },
	    "deleted": {
	        "color": "#9a050f"
	    },
	    ".language-autohotkey .token.tag": {
	        "color": "#9a050f"
	    },
	    "tag": {
	        "color": "#00009f"
	    },
	    "selector": {
	        "color": "#00009f"
	    },
	    ".language-autohotkey .token.keyword": {
	        "color": "#00009f"
	    },
	    "important": {
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 792 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#b9b5b8",
	        "fontFamily": "\"Fira Mono\", Menlo, Monaco, \"Lucida Console\",\"Courier New\", Courier, monospace",
	        "fontSize": "16px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "wordSpacing": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordBreak": "break-all",
	        "wordWrap": "break-word",
	        "background": "#322931"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#b9b5b8",
	        "fontFamily": "\"Fira Mono\", Menlo, Monaco, \"Lucida Console\",\"Courier New\", Courier, monospace",
	        "fontSize": "16px",
	        "lineHeight": "1.375",
	        "direction": "ltr",
	        "textAlign": "left",
	        "wordSpacing": "normal",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordBreak": "break-all",
	        "wordWrap": "break-word",
	        "background": "#322931",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#797379"
	    },
	    "prolog": {
	        "color": "#797379"
	    },
	    "doctype": {
	        "color": "#797379"
	    },
	    "cdata": {
	        "color": "#797379"
	    },
	    "punctuation": {
	        "color": "#b9b5b8"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "null": {
	        "color": "#fd8b19"
	    },
	    "operator": {
	        "color": "#fd8b19"
	    },
	    "boolean": {
	        "color": "#fd8b19"
	    },
	    "number": {
	        "color": "#fd8b19"
	    },
	    "property": {
	        "color": "#fdcc59"
	    },
	    "tag": {
	        "color": "#1290bf"
	    },
	    "string": {
	        "color": "#149b93"
	    },
	    "selector": {
	        "color": "#c85e7c"
	    },
	    "attr-name": {
	        "color": "#fd8b19"
	    },
	    "entity": {
	        "color": "#149b93",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#149b93"
	    },
	    ".language-css .token.string": {
	        "color": "#149b93"
	    },
	    ".style .token.string": {
	        "color": "#149b93"
	    },
	    "attr-value": {
	        "color": "#8fc13e"
	    },
	    "keyword": {
	        "color": "#8fc13e"
	    },
	    "control": {
	        "color": "#8fc13e"
	    },
	    "directive": {
	        "color": "#8fc13e"
	    },
	    "unit": {
	        "color": "#8fc13e"
	    },
	    "statement": {
	        "color": "#149b93"
	    },
	    "regex": {
	        "color": "#149b93"
	    },
	    "atrule": {
	        "color": "#149b93"
	    },
	    "placeholder": {
	        "color": "#1290bf"
	    },
	    "variable": {
	        "color": "#1290bf"
	    },
	    "important": {
	        "color": "#dd464c",
	        "fontWeight": "bold"
	    },
	    "pre > code.highlight": {
	        "Outline": ".4em solid red",
	        "OutlineOffset": ".4em"
	    }
	};

/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _coy = __webpack_require__(781);
	
	Object.defineProperty(exports, 'coy', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_coy).default;
	  }
	});
	
	var _dark = __webpack_require__(783);
	
	Object.defineProperty(exports, 'dark', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_dark).default;
	  }
	});
	
	var _funky = __webpack_require__(790);
	
	Object.defineProperty(exports, 'funky', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_funky).default;
	  }
	});
	
	var _okaidia = __webpack_require__(794);
	
	Object.defineProperty(exports, 'okaidia', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_okaidia).default;
	  }
	});
	
	var _solarizedlight = __webpack_require__(796);
	
	Object.defineProperty(exports, 'solarizedlight', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_solarizedlight).default;
	  }
	});
	
	var _tomorrow = __webpack_require__(797);
	
	Object.defineProperty(exports, 'tomorrow', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_tomorrow).default;
	  }
	});
	
	var _twilight = __webpack_require__(798);
	
	Object.defineProperty(exports, 'twilight', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_twilight).default;
	  }
	});
	
	var _prism = __webpack_require__(332);
	
	Object.defineProperty(exports, 'prism', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_prism).default;
	  }
	});
	
	var _atomDark = __webpack_require__(778);
	
	Object.defineProperty(exports, 'atomDark', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_atomDark).default;
	  }
	});
	
	var _base16Ateliersulphurpool = __webpack_require__(779);
	
	Object.defineProperty(exports, 'base16AteliersulphurpoolLight', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_base16Ateliersulphurpool).default;
	  }
	});
	
	var _cb = __webpack_require__(780);
	
	Object.defineProperty(exports, 'cb', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_cb).default;
	  }
	});
	
	var _darcula = __webpack_require__(782);
	
	Object.defineProperty(exports, 'darcula', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_darcula).default;
	  }
	});
	
	var _duotoneDark = __webpack_require__(784);
	
	Object.defineProperty(exports, 'duotoneDark', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneDark).default;
	  }
	});
	
	var _duotoneEarth = __webpack_require__(785);
	
	Object.defineProperty(exports, 'duotoneEarth', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneEarth).default;
	  }
	});
	
	var _duotoneForest = __webpack_require__(786);
	
	Object.defineProperty(exports, 'duotoneForest', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneForest).default;
	  }
	});
	
	var _duotoneLight = __webpack_require__(787);
	
	Object.defineProperty(exports, 'duotoneLight', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneLight).default;
	  }
	});
	
	var _duotoneSea = __webpack_require__(788);
	
	Object.defineProperty(exports, 'duotoneSea', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneSea).default;
	  }
	});
	
	var _duotoneSpace = __webpack_require__(789);
	
	Object.defineProperty(exports, 'duotoneSpace', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_duotoneSpace).default;
	  }
	});
	
	var _ghcolors = __webpack_require__(791);
	
	Object.defineProperty(exports, 'ghcolors', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ghcolors).default;
	  }
	});
	
	var _hopscotch = __webpack_require__(792);
	
	Object.defineProperty(exports, 'hopscotch', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_hopscotch).default;
	  }
	});
	
	var _pojoaque = __webpack_require__(795);
	
	Object.defineProperty(exports, 'pojoaque', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_pojoaque).default;
	  }
	});
	
	var _vs = __webpack_require__(799);
	
	Object.defineProperty(exports, 'vs', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_vs).default;
	  }
	});
	
	var _xonokai = __webpack_require__(800);
	
	Object.defineProperty(exports, 'xonokai', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_xonokai).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 794 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#f8f8f2",
	        "background": "none",
	        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#f8f8f2",
	        "background": "#272822",
	        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "borderRadius": "0.3em"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#272822",
	        "padding": ".1em",
	        "borderRadius": ".3em",
	        "whiteSpace": "normal"
	    },
	    "comment": {
	        "color": "slategray"
	    },
	    "prolog": {
	        "color": "slategray"
	    },
	    "doctype": {
	        "color": "slategray"
	    },
	    "cdata": {
	        "color": "slategray"
	    },
	    "punctuation": {
	        "color": "#f8f8f2"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "#f92672"
	    },
	    "tag": {
	        "color": "#f92672"
	    },
	    "constant": {
	        "color": "#f92672"
	    },
	    "symbol": {
	        "color": "#f92672"
	    },
	    "deleted": {
	        "color": "#f92672"
	    },
	    "boolean": {
	        "color": "#ae81ff"
	    },
	    "number": {
	        "color": "#ae81ff"
	    },
	    "selector": {
	        "color": "#a6e22e"
	    },
	    "attr-name": {
	        "color": "#a6e22e"
	    },
	    "string": {
	        "color": "#a6e22e"
	    },
	    "char": {
	        "color": "#a6e22e"
	    },
	    "builtin": {
	        "color": "#a6e22e"
	    },
	    "inserted": {
	        "color": "#a6e22e"
	    },
	    "operator": {
	        "color": "#f8f8f2"
	    },
	    "entity": {
	        "color": "#f8f8f2",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#f8f8f2"
	    },
	    ".language-css .token.string": {
	        "color": "#f8f8f2"
	    },
	    ".style .token.string": {
	        "color": "#f8f8f2"
	    },
	    "variable": {
	        "color": "#f8f8f2"
	    },
	    "atrule": {
	        "color": "#e6db74"
	    },
	    "attr-value": {
	        "color": "#e6db74"
	    },
	    "function": {
	        "color": "#e6db74"
	    },
	    "keyword": {
	        "color": "#66d9ef"
	    },
	    "regex": {
	        "color": "#fd971f"
	    },
	    "important": {
	        "color": "#fd971f",
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 795 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordBreak": "break-all",
	        "wordWrap": "break-word",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "fontSize": "15px",
	        "lineHeight": "1.5",
	        "color": "#dccf8f",
	        "textShadow": "0"
	    },
	    "pre[class*=\"language-\"]": {
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordBreak": "break-all",
	        "wordWrap": "break-word",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "fontSize": "15px",
	        "lineHeight": "1.5",
	        "color": "#DCCF8F",
	        "textShadow": "0",
	        "borderRadius": "5px",
	        "border": "1px solid #000",
	        "background": "#181914 url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQACQYGBgcGCQcHCQ0IBwgNDwsJCQsPEQ4ODw4OERENDg4ODg0RERQUFhQUERoaHBwaGiYmJiYmKysrKysrKysrKwEJCAgJCgkMCgoMDwwODA8TDg4ODhMVDg4PDg4VGhMRERERExoXGhYWFhoXHR0aGh0dJCQjJCQrKysrKysrKysr/8AAEQgAjACMAwEiAAIRAQMRAf/EAF4AAQEBAAAAAAAAAAAAAAAAAAABBwEBAQAAAAAAAAAAAAAAAAAAAAIQAAEDAwIHAQEAAAAAAAAAAADwAREhYaExkUFRcYGxwdHh8REBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AyGFEjHaBS2fDDs2zkhKmBKktb7km+ZwwCnXPkLVmCTMItj6AXFxRS465/BTnkAJvkLkJe+7AKKoi2AtRS2zuAWsCb5GOlBN8gKfmuGHZ8MFqIth3ALmFoFwbwKWyAlTAp17uKqBvgBD8sM4fTjhvAhkzhaRkBMKBrfs7jGPIpzy7gFrAqnC0C0gB0EWwBDW2cBVQwm+QtPpa3wBO3sVvszCnLAhkzgL5/RLf13cLQd8/AGlu0Cb5HTx9KuAEieGJEdcehS3eRTp2ATdt3CpIm+QtZwAhROXFeb7swp/ahaM3kBE/jSIUBc/AWrgBN8uNFAl+b7sAXFxFn2YLUU5Ns7gFX8C4ib+hN8gFWXwK3bZglxEJm+gKdciLPsFV/TClsgJUwKJ5FVA7tvIFrfZhVfGJDcsCKaYgAqv6YRbE+RWOWBtu7+AL3yRalXLyKqAIIfk+zARbDgFyEsncYwJvlgFRW+GEWntIi2P0BooyFxcNr8Ep3+ANLbMO+QyhvbiqdgC0kVvgUUiLYgBS2QtPbiVI1/sgOmG9uO+Y8DW+7jS2zAOnj6O2BndwuIAUtkdRN8gFoK3wwXMQyZwHVbClsuNLd4E3yAUR6FVDBR+BafQGt93LVMxJTv8ABts4CVLhcfYWsCb5kC9/BHdU8CLYFY5bMAd+eX9MGthhpbA1vu4B7+RKkaW2Yq4AQtVBBFsAJU/AuIXBhN8gGWnstefhiZyWvLAEnbYS1uzSFP6Jvn4Baxx70JKkQojLib5AVTey1jjgkKJGO0AKWyOm7N7cSpgSpAdPH0Tfd/gp1z5C1ZgKqN9J2wFxcUUuAFLZAm+QC0Fb4YUVRFsAOvj4KW2dwtYE3yAWk/wS/PLMKfmuGHZ8MAXF/Ja32Yi5haAKWz4Ydm2cSpgU693Atb7km+Zwwh+WGcPpxw3gAkzCLY+iYUDW/Z3Adc/gpzyFrAqnALkJe+7DoItgAtRS2zuKqGE3yAx0oJvkdvYrfZmALURbDuL5/RLf13cAuDeBS2RpbtAm+QFVA3wR+3fUtFHoBDJnC0jIXH0HWsgMY8inPLuOkd9chp4z20ALQLSA8cI9jYAIa2zjzjBd8gRafS1vgiUho/kAKcsCGTOGWvoOpkAtB3z8Hm8x2Ff5ADp4+lXAlIvcmwH/2Q==') repeat left top",
	        "padding": "12px",
	        "overflow": "auto"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "borderRadius": "5px",
	        "border": "1px solid #000",
	        "color": "#DCCF8F",
	        "background": "#181914 url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQACQYGBgcGCQcHCQ0IBwgNDwsJCQsPEQ4ODw4OERENDg4ODg0RERQUFhQUERoaHBwaGiYmJiYmKysrKysrKysrKwEJCAgJCgkMCgoMDwwODA8TDg4ODhMVDg4PDg4VGhMRERERExoXGhYWFhoXHR0aGh0dJCQjJCQrKysrKysrKysr/8AAEQgAjACMAwEiAAIRAQMRAf/EAF4AAQEBAAAAAAAAAAAAAAAAAAABBwEBAQAAAAAAAAAAAAAAAAAAAAIQAAEDAwIHAQEAAAAAAAAAAADwAREhYaExkUFRcYGxwdHh8REBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AyGFEjHaBS2fDDs2zkhKmBKktb7km+ZwwCnXPkLVmCTMItj6AXFxRS465/BTnkAJvkLkJe+7AKKoi2AtRS2zuAWsCb5GOlBN8gKfmuGHZ8MFqIth3ALmFoFwbwKWyAlTAp17uKqBvgBD8sM4fTjhvAhkzhaRkBMKBrfs7jGPIpzy7gFrAqnC0C0gB0EWwBDW2cBVQwm+QtPpa3wBO3sVvszCnLAhkzgL5/RLf13cLQd8/AGlu0Cb5HTx9KuAEieGJEdcehS3eRTp2ATdt3CpIm+QtZwAhROXFeb7swp/ahaM3kBE/jSIUBc/AWrgBN8uNFAl+b7sAXFxFn2YLUU5Ns7gFX8C4ib+hN8gFWXwK3bZglxEJm+gKdciLPsFV/TClsgJUwKJ5FVA7tvIFrfZhVfGJDcsCKaYgAqv6YRbE+RWOWBtu7+AL3yRalXLyKqAIIfk+zARbDgFyEsncYwJvlgFRW+GEWntIi2P0BooyFxcNr8Ep3+ANLbMO+QyhvbiqdgC0kVvgUUiLYgBS2QtPbiVI1/sgOmG9uO+Y8DW+7jS2zAOnj6O2BndwuIAUtkdRN8gFoK3wwXMQyZwHVbClsuNLd4E3yAUR6FVDBR+BafQGt93LVMxJTv8ABts4CVLhcfYWsCb5kC9/BHdU8CLYFY5bMAd+eX9MGthhpbA1vu4B7+RKkaW2Yq4AQtVBBFsAJU/AuIXBhN8gGWnstefhiZyWvLAEnbYS1uzSFP6Jvn4Baxx70JKkQojLib5AVTey1jjgkKJGO0AKWyOm7N7cSpgSpAdPH0Tfd/gp1z5C1ZgKqN9J2wFxcUUuAFLZAm+QC0Fb4YUVRFsAOvj4KW2dwtYE3yAWk/wS/PLMKfmuGHZ8MAXF/Ja32Yi5haAKWz4Ydm2cSpgU693Atb7km+Zwwh+WGcPpxw3gAkzCLY+iYUDW/Z3Adc/gpzyFrAqnALkJe+7DoItgAtRS2zuKqGE3yAx0oJvkdvYrfZmALURbDuL5/RLf13cAuDeBS2RpbtAm+QFVA3wR+3fUtFHoBDJnC0jIXH0HWsgMY8inPLuOkd9chp4z20ALQLSA8cI9jYAIa2zjzjBd8gRafS1vgiUho/kAKcsCGTOGWvoOpkAtB3z8Hm8x2Ff5ADp4+lXAlIvcmwH/2Q==') repeat left top",
	        "padding": "2px 6px"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "comment": {
	        "color": "#586e75",
	        "fontStyle": "italic"
	    },
	    "prolog": {
	        "color": "#586e75",
	        "fontStyle": "italic"
	    },
	    "doctype": {
	        "color": "#586e75",
	        "fontStyle": "italic"
	    },
	    "cdata": {
	        "color": "#586e75",
	        "fontStyle": "italic"
	    },
	    "number": {
	        "color": "#b89859"
	    },
	    "string": {
	        "color": "#468966"
	    },
	    "char": {
	        "color": "#468966"
	    },
	    "builtin": {
	        "color": "#468966"
	    },
	    "inserted": {
	        "color": "#468966"
	    },
	    "attr-name": {
	        "color": "#b89859"
	    },
	    "operator": {
	        "color": "#dccf8f"
	    },
	    "entity": {
	        "color": "#dccf8f",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#dccf8f"
	    },
	    ".language-css .token.string": {
	        "color": "#dccf8f"
	    },
	    ".style .token.string": {
	        "color": "#dccf8f"
	    },
	    "selector": {
	        "color": "#859900"
	    },
	    "regex": {
	        "color": "#859900"
	    },
	    "atrule": {
	        "color": "#cb4b16"
	    },
	    "keyword": {
	        "color": "#cb4b16"
	    },
	    "attr-value": {
	        "color": "#468966"
	    },
	    "function": {
	        "color": "#b58900"
	    },
	    "variable": {
	        "color": "#b58900"
	    },
	    "placeholder": {
	        "color": "#b58900"
	    },
	    "property": {
	        "color": "#b89859"
	    },
	    "tag": {
	        "color": "#ffb03b"
	    },
	    "boolean": {
	        "color": "#b89859"
	    },
	    "constant": {
	        "color": "#b89859"
	    },
	    "symbol": {
	        "color": "#b89859"
	    },
	    "important": {
	        "color": "#dc322f"
	    },
	    "statement": {
	        "color": "#dc322f"
	    },
	    "deleted": {
	        "color": "#dc322f"
	    },
	    "punctuation": {
	        "color": "#dccf8f"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 796 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#657b83",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#657b83",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "borderRadius": "0.3em",
	        "backgroundColor": "#fdf6e3"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "background": "#073642"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "background": "#073642"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "background": "#073642"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "background": "#073642"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "background": "#073642"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "background": "#073642"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "background": "#073642"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "background": "#073642"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "backgroundColor": "#fdf6e3",
	        "padding": ".1em",
	        "borderRadius": ".3em"
	    },
	    "comment": {
	        "color": "#93a1a1"
	    },
	    "prolog": {
	        "color": "#93a1a1"
	    },
	    "doctype": {
	        "color": "#93a1a1"
	    },
	    "cdata": {
	        "color": "#93a1a1"
	    },
	    "punctuation": {
	        "color": "#586e75"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "property": {
	        "color": "#268bd2"
	    },
	    "tag": {
	        "color": "#268bd2"
	    },
	    "boolean": {
	        "color": "#268bd2"
	    },
	    "number": {
	        "color": "#268bd2"
	    },
	    "constant": {
	        "color": "#268bd2"
	    },
	    "symbol": {
	        "color": "#268bd2"
	    },
	    "deleted": {
	        "color": "#268bd2"
	    },
	    "selector": {
	        "color": "#2aa198"
	    },
	    "attr-name": {
	        "color": "#2aa198"
	    },
	    "string": {
	        "color": "#2aa198"
	    },
	    "char": {
	        "color": "#2aa198"
	    },
	    "builtin": {
	        "color": "#2aa198"
	    },
	    "url": {
	        "color": "#2aa198"
	    },
	    "inserted": {
	        "color": "#2aa198"
	    },
	    "entity": {
	        "color": "#657b83",
	        "background": "#eee8d5",
	        "cursor": "help"
	    },
	    "atrule": {
	        "color": "#859900"
	    },
	    "attr-value": {
	        "color": "#859900"
	    },
	    "keyword": {
	        "color": "#859900"
	    },
	    "function": {
	        "color": "#b58900"
	    },
	    "regex": {
	        "color": "#cb4b16"
	    },
	    "important": {
	        "color": "#cb4b16",
	        "fontWeight": "bold"
	    },
	    "variable": {
	        "color": "#cb4b16"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    }
	};

/***/ }),
/* 797 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#ccc",
	        "background": "none",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#ccc",
	        "background": "#2d2d2d",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "#2d2d2d",
	        "padding": ".1em",
	        "borderRadius": ".3em",
	        "whiteSpace": "normal"
	    },
	    "comment": {
	        "color": "#999"
	    },
	    "block-comment": {
	        "color": "#999"
	    },
	    "prolog": {
	        "color": "#999"
	    },
	    "doctype": {
	        "color": "#999"
	    },
	    "cdata": {
	        "color": "#999"
	    },
	    "punctuation": {
	        "color": "#ccc"
	    },
	    "tag": {
	        "color": "#e2777a"
	    },
	    "attr-name": {
	        "color": "#e2777a"
	    },
	    "namespace": {
	        "color": "#e2777a"
	    },
	    "deleted": {
	        "color": "#e2777a"
	    },
	    "function-name": {
	        "color": "#6196cc"
	    },
	    "boolean": {
	        "color": "#f08d49"
	    },
	    "number": {
	        "color": "#f08d49"
	    },
	    "function": {
	        "color": "#f08d49"
	    },
	    "property": {
	        "color": "#f8c555"
	    },
	    "class-name": {
	        "color": "#f8c555"
	    },
	    "constant": {
	        "color": "#f8c555"
	    },
	    "symbol": {
	        "color": "#f8c555"
	    },
	    "selector": {
	        "color": "#cc99cd"
	    },
	    "important": {
	        "color": "#cc99cd",
	        "fontWeight": "bold"
	    },
	    "atrule": {
	        "color": "#cc99cd"
	    },
	    "keyword": {
	        "color": "#cc99cd"
	    },
	    "builtin": {
	        "color": "#cc99cd"
	    },
	    "string": {
	        "color": "#7ec699"
	    },
	    "char": {
	        "color": "#7ec699"
	    },
	    "attr-value": {
	        "color": "#7ec699"
	    },
	    "regex": {
	        "color": "#7ec699"
	    },
	    "variable": {
	        "color": "#7ec699"
	    },
	    "operator": {
	        "color": "#67cdcc"
	    },
	    "entity": {
	        "color": "#67cdcc",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#67cdcc"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "inserted": {
	        "color": "green"
	    }
	};

/***/ }),
/* 798 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "white",
	        "background": "none",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "textShadow": "0 -.1em .2em black",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "white",
	        "background": "hsl(0, 0%, 8%)",
	        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
	        "textAlign": "left",
	        "textShadow": "0 -.1em .2em black",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "wordWrap": "normal",
	        "lineHeight": "1.5",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "borderRadius": ".5em",
	        "border": ".3em solid hsl(0, 0%, 33%)",
	        "boxShadow": "1px 1px .5em black inset",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "padding": "1em"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "background": "hsl(0, 0%, 8%)",
	        "borderRadius": ".3em",
	        "border": ".13em solid hsl(0, 0%, 33%)",
	        "boxShadow": "1px 1px .3em -.1em black inset",
	        "padding": ".15em .2em .05em",
	        "whiteSpace": "normal"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "background": "hsla(0, 0%, 93%, 0.15)",
	        "textShadow": "none"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "background": "hsla(0, 0%, 93%, 0.15)",
	        "textShadow": "none"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "textShadow": "none",
	        "background": "hsla(0, 0%, 93%, 0.15)"
	    },
	    "comment": {
	        "color": "hsl(0, 0%, 47%)"
	    },
	    "prolog": {
	        "color": "hsl(0, 0%, 47%)"
	    },
	    "doctype": {
	        "color": "hsl(0, 0%, 47%)"
	    },
	    "cdata": {
	        "color": "hsl(0, 0%, 47%)"
	    },
	    "punctuation": {
	        "Opacity": ".7"
	    },
	    ".namespace": {
	        "Opacity": ".7"
	    },
	    "tag": {
	        "color": "hsl(14, 58%, 55%)"
	    },
	    "boolean": {
	        "color": "hsl(14, 58%, 55%)"
	    },
	    "number": {
	        "color": "hsl(14, 58%, 55%)"
	    },
	    "deleted": {
	        "color": "hsl(14, 58%, 55%)"
	    },
	    "keyword": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "property": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "selector": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "constant": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "symbol": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "builtin": {
	        "color": "hsl(53, 89%, 79%)"
	    },
	    "attr-name": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "attr-value": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "string": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "char": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "operator": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "entity": {
	        "color": "hsl(76, 21%, 52%)",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    ".language-css .token.string": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    ".style .token.string": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "variable": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "inserted": {
	        "color": "hsl(76, 21%, 52%)"
	    },
	    "atrule": {
	        "color": "hsl(218, 22%, 55%)"
	    },
	    "regex": {
	        "color": "hsl(42, 75%, 65%)"
	    },
	    "important": {
	        "color": "hsl(42, 75%, 65%)",
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "pre[data-line]": {
	        "padding": "1em 0 1em 3em",
	        "position": "relative"
	    },
	    ".language-markup .token.tag": {
	        "color": "hsl(33, 33%, 52%)"
	    },
	    ".language-markup .token.attr-name": {
	        "color": "hsl(33, 33%, 52%)"
	    },
	    ".language-markup .token.punctuation": {
	        "color": "hsl(33, 33%, 52%)"
	    },
	    "": {
	        "position": "relative",
	        "zIndex": "1"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, hsla(0, 0%, 33%, .1) 70%, hsla(0, 0%, 33%, 0))",
	        "borderBottom": "1px dashed hsl(0, 0%, 33%)",
	        "borderTop": "1px dashed hsl(0, 0%, 33%)",
	        "left": "0",
	        "lineHeight": "inherit",
	        "marginTop": "0.75em",
	        "padding": "inherit 0",
	        "pointerEvents": "none",
	        "position": "absolute",
	        "right": "0",
	        "whiteSpace": "pre",
	        "zIndex": "0"
	    },
	    ".line-highlight:before": {
	        "backgroundColor": "hsl(215, 15%, 59%)",
	        "borderRadius": "999px",
	        "boxShadow": "0 1px white",
	        "color": "hsl(24, 20%, 95%)",
	        "content": "attr(data-start)",
	        "font": "bold 65%/1.5 sans-serif",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0 .5em",
	        "position": "absolute",
	        "textAlign": "center",
	        "textShadow": "none",
	        "top": ".4em",
	        "verticalAlign": ".3em"
	    },
	    ".line-highlight[data-end]:after": {
	        "backgroundColor": "hsl(215, 15%, 59%)",
	        "borderRadius": "999px",
	        "boxShadow": "0 1px white",
	        "color": "hsl(24, 20%, 95%)",
	        "content": "attr(data-end)",
	        "font": "bold 65%/1.5 sans-serif",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0 .5em",
	        "position": "absolute",
	        "textAlign": "center",
	        "textShadow": "none",
	        "top": "auto",
	        "verticalAlign": ".3em",
	        "bottom": ".4em"
	    }
	};

/***/ }),
/* 799 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "color": "#393A34",
	        "fontFamily": "\"Consolas\", \"Bitstream Vera Sans Mono\", \"Courier New\", Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "fontSize": "0.95em",
	        "lineHeight": "1.2em",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "color": "#393A34",
	        "fontFamily": "\"Consolas\", \"Bitstream Vera Sans Mono\", \"Courier New\", Courier, monospace",
	        "direction": "ltr",
	        "textAlign": "left",
	        "whiteSpace": "pre",
	        "wordSpacing": "normal",
	        "wordBreak": "normal",
	        "fontSize": "0.95em",
	        "lineHeight": "1.2em",
	        "MozTabSize": "4",
	        "OTabSize": "4",
	        "tabSize": "4",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "padding": "1em",
	        "margin": ".5em 0",
	        "overflow": "auto",
	        "border": "1px solid #dddddd",
	        "backgroundColor": "white"
	    },
	    "pre[class*=\"language-\"]::-moz-selection": {
	        "background": "#C1DEF1"
	    },
	    "pre[class*=\"language-\"] ::-moz-selection": {
	        "background": "#C1DEF1"
	    },
	    "code[class*=\"language-\"]::-moz-selection": {
	        "background": "#C1DEF1"
	    },
	    "code[class*=\"language-\"] ::-moz-selection": {
	        "background": "#C1DEF1"
	    },
	    "pre[class*=\"language-\"]::selection": {
	        "background": "#C1DEF1"
	    },
	    "pre[class*=\"language-\"] ::selection": {
	        "background": "#C1DEF1"
	    },
	    "code[class*=\"language-\"]::selection": {
	        "background": "#C1DEF1"
	    },
	    "code[class*=\"language-\"] ::selection": {
	        "background": "#C1DEF1"
	    },
	    ":not(pre) > code[class*=\"language-\"]": {
	        "padding": ".2em",
	        "paddingTop": "1px",
	        "paddingBottom": "1px",
	        "background": "#f8f8f8",
	        "border": "1px solid #dddddd"
	    },
	    "comment": {
	        "color": "#008000",
	        "fontStyle": "italic"
	    },
	    "prolog": {
	        "color": "#008000",
	        "fontStyle": "italic"
	    },
	    "doctype": {
	        "color": "#008000",
	        "fontStyle": "italic"
	    },
	    "cdata": {
	        "color": "#008000",
	        "fontStyle": "italic"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "string": {
	        "color": "#A31515"
	    },
	    "punctuation": {
	        "color": "#393A34"
	    },
	    "operator": {
	        "color": "#393A34"
	    },
	    "url": {
	        "color": "#36acaa"
	    },
	    "symbol": {
	        "color": "#36acaa"
	    },
	    "number": {
	        "color": "#36acaa"
	    },
	    "boolean": {
	        "color": "#36acaa"
	    },
	    "variable": {
	        "color": "#36acaa"
	    },
	    "constant": {
	        "color": "#36acaa"
	    },
	    "inserted": {
	        "color": "#36acaa"
	    },
	    "atrule": {
	        "color": "#0000ff"
	    },
	    "keyword": {
	        "color": "#0000ff"
	    },
	    "attr-value": {
	        "color": "#0000ff"
	    },
	    ".language-autohotkey .token.selector": {
	        "color": "#0000ff"
	    },
	    ".language-json .token.boolean": {
	        "color": "#0000ff"
	    },
	    ".language-json .token.number": {
	        "color": "#0000ff"
	    },
	    "code[class*=\"language-css\"]": {
	        "color": "#0000ff"
	    },
	    "function": {
	        "color": "#393A34"
	    },
	    "deleted": {
	        "color": "#9a050f"
	    },
	    ".language-autohotkey .token.tag": {
	        "color": "#9a050f"
	    },
	    "selector": {
	        "color": "#800000"
	    },
	    ".language-autohotkey .token.keyword": {
	        "color": "#00009f"
	    },
	    "important": {
	        "fontWeight": "bold"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "class-name": {
	        "color": "#2B91AF"
	    },
	    ".language-json .token.property": {
	        "color": "#2B91AF"
	    },
	    "tag": {
	        "color": "#800000"
	    },
	    "attr-name": {
	        "color": "#ff0000"
	    },
	    "property": {
	        "color": "#ff0000"
	    },
	    "regex": {
	        "color": "#ff0000"
	    },
	    "entity": {
	        "color": "#ff0000"
	    },
	    "directive.tag  .tag": {
	        "background": "#ffff00",
	        "color": "#393A34"
	    },
	    ".line-numbers .line-numbers-rows": {
	        "borderRightColor": "#a5a5a5"
	    },
	    ".line-numbers-rows > span:before": {
	        "color": "#2B91AF"
	    },
	    ".line-highlight": {
	        "background": "linear-gradient(to right, rgba(193, 222, 241, 0.2) 70%, rgba(221, 222, 241, 0))"
	    }
	};

/***/ }),
/* 800 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    "code[class*=\"language-\"]": {
	        "MozTabSize": "2",
	        "OTabSize": "2",
	        "tabSize": "2",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordWrap": "normal",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "fontSize": "14px",
	        "color": "#76d9e6",
	        "textShadow": "none"
	    },
	    "pre[class*=\"language-\"]": {
	        "MozTabSize": "2",
	        "OTabSize": "2",
	        "tabSize": "2",
	        "WebkitHyphens": "none",
	        "MozHyphens": "none",
	        "msHyphens": "none",
	        "hyphens": "none",
	        "whiteSpace": "pre-wrap",
	        "wordWrap": "normal",
	        "fontFamily": "Menlo, Monaco, \"Courier New\", monospace",
	        "fontSize": "14px",
	        "color": "#76d9e6",
	        "textShadow": "none",
	        "background": "#2a2a2a",
	        "padding": "15px",
	        "borderRadius": "4px",
	        "border": "1px solid #e1e1e8",
	        "overflow": "auto",
	        "position": "relative"
	    },
	    ":not(pre)>code[class*=\"language-\"]": {
	        "background": "#2a2a2a",
	        "padding": "0.15em 0.2em 0.05em",
	        "borderRadius": ".3em",
	        "border": "0.13em solid #7a6652",
	        "boxShadow": "1px 1px 0.3em -0.1em #000 inset"
	    },
	    "pre[class*=\"language-\"] code": {
	        "whiteSpace": "pre",
	        "display": "block"
	    },
	    "namespace": {
	        "Opacity": ".7"
	    },
	    "comment": {
	        "color": "#6f705e"
	    },
	    "prolog": {
	        "color": "#6f705e"
	    },
	    "doctype": {
	        "color": "#6f705e"
	    },
	    "cdata": {
	        "color": "#6f705e"
	    },
	    "operator": {
	        "color": "#a77afe"
	    },
	    "boolean": {
	        "color": "#a77afe"
	    },
	    "number": {
	        "color": "#a77afe"
	    },
	    "attr-name": {
	        "color": "#e6d06c"
	    },
	    "string": {
	        "color": "#e6d06c"
	    },
	    "entity": {
	        "color": "#e6d06c",
	        "cursor": "help"
	    },
	    "url": {
	        "color": "#e6d06c"
	    },
	    ".language-css .token.string": {
	        "color": "#e6d06c"
	    },
	    ".style .token.string": {
	        "color": "#e6d06c"
	    },
	    "selector": {
	        "color": "#a6e22d"
	    },
	    "inserted": {
	        "color": "#a6e22d"
	    },
	    "atrule": {
	        "color": "#ef3b7d"
	    },
	    "attr-value": {
	        "color": "#ef3b7d"
	    },
	    "keyword": {
	        "color": "#ef3b7d"
	    },
	    "important": {
	        "color": "#ef3b7d",
	        "fontWeight": "bold"
	    },
	    "deleted": {
	        "color": "#ef3b7d"
	    },
	    "regex": {
	        "color": "#76d9e6"
	    },
	    "statement": {
	        "color": "#76d9e6",
	        "fontWeight": "bold"
	    },
	    "placeholder": {
	        "color": "#fff"
	    },
	    "variable": {
	        "color": "#fff"
	    },
	    "bold": {
	        "fontWeight": "bold"
	    },
	    "punctuation": {
	        "color": "#bebec5"
	    },
	    "italic": {
	        "fontStyle": "italic"
	    },
	    "code.language-markup": {
	        "color": "#f9f9f9"
	    },
	    "code.language-markup .token.tag": {
	        "color": "#ef3b7d"
	    },
	    "code.language-markup .token.attr-name": {
	        "color": "#a6e22d"
	    },
	    "code.language-markup .token.attr-value": {
	        "color": "#e6d06c"
	    },
	    "code.language-markup .token.style": {
	        "color": "#76d9e6"
	    },
	    "code.language-markup .token.script": {
	        "color": "#76d9e6"
	    },
	    "code.language-markup .token.script .token.keyword": {
	        "color": "#76d9e6"
	    },
	    "pre[class*=\"language-\"][data-line]": {
	        "position": "relative",
	        "padding": "1em 0 1em 3em"
	    },
	    "pre[data-line] .line-highlight": {
	        "position": "absolute",
	        "left": "0",
	        "right": "0",
	        "padding": "0",
	        "marginTop": "1em",
	        "background": "rgba(255, 255, 255, 0.08)",
	        "pointerEvents": "none",
	        "lineHeight": "inherit",
	        "whiteSpace": "pre"
	    },
	    "pre[data-line] .line-highlight:before": {
	        "content": "attr(data-start)",
	        "position": "absolute",
	        "top": ".4em",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0.2em 0.5em",
	        "backgroundColor": "rgba(255, 255, 255, 0.4)",
	        "color": "black",
	        "font": "bold 65%/1 sans-serif",
	        "height": "1em",
	        "lineHeight": "1em",
	        "textAlign": "center",
	        "borderRadius": "999px",
	        "textShadow": "none",
	        "boxShadow": "0 1px 1px rgba(255, 255, 255, 0.7)"
	    },
	    "pre[data-line] .line-highlight[data-end]:after": {
	        "content": "attr(data-end)",
	        "position": "absolute",
	        "top": "auto",
	        "left": ".6em",
	        "minWidth": "1em",
	        "padding": "0.2em 0.5em",
	        "backgroundColor": "rgba(255, 255, 255, 0.4)",
	        "color": "black",
	        "font": "bold 65%/1 sans-serif",
	        "height": "1em",
	        "lineHeight": "1em",
	        "textAlign": "center",
	        "borderRadius": "999px",
	        "textShadow": "none",
	        "boxShadow": "0 1px 1px rgba(255, 255, 255, 0.7)",
	        "bottom": ".4em"
	    }
	};

/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _TransitionGroup = __webpack_require__(803);
	
	var _TransitionGroup2 = _interopRequireDefault(_TransitionGroup);
	
	var _CSSTransitionGroupChild = __webpack_require__(802);
	
	var _CSSTransitionGroupChild2 = _interopRequireDefault(_CSSTransitionGroupChild);
	
	var _PropTypes = __webpack_require__(333);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var propTypes = {
	  transitionName: _PropTypes.nameShape.isRequired,
	
	  transitionAppear: _propTypes2.default.bool,
	  transitionEnter: _propTypes2.default.bool,
	  transitionLeave: _propTypes2.default.bool,
	  transitionAppearTimeout: (0, _PropTypes.transitionTimeout)('Appear'),
	  transitionEnterTimeout: (0, _PropTypes.transitionTimeout)('Enter'),
	  transitionLeaveTimeout: (0, _PropTypes.transitionTimeout)('Leave')
	};
	
	var defaultProps = {
	  transitionAppear: false,
	  transitionEnter: true,
	  transitionLeave: true
	};
	
	var CSSTransitionGroup = function (_React$Component) {
	  _inherits(CSSTransitionGroup, _React$Component);
	
	  function CSSTransitionGroup() {
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, CSSTransitionGroup);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this._wrapChild = function (child) {
	      return _react2.default.createElement(_CSSTransitionGroupChild2.default, {
	        name: _this.props.transitionName,
	        appear: _this.props.transitionAppear,
	        enter: _this.props.transitionEnter,
	        leave: _this.props.transitionLeave,
	        appearTimeout: _this.props.transitionAppearTimeout,
	        enterTimeout: _this.props.transitionEnterTimeout,
	        leaveTimeout: _this.props.transitionLeaveTimeout
	      }, child);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  // We need to provide this childFactory so that
	  // ReactCSSTransitionGroupChild can receive updates to name, enter, and
	  // leave while it is leaving.
	
	
	  CSSTransitionGroup.prototype.render = function render() {
	    return _react2.default.createElement(_TransitionGroup2.default, _extends({}, this.props, { childFactory: this._wrapChild }));
	  };
	
	  return CSSTransitionGroup;
	}(_react2.default.Component);
	
	CSSTransitionGroup.displayName = 'CSSTransitionGroup';
	
	
	CSSTransitionGroup.propTypes =  false ? propTypes : {};
	CSSTransitionGroup.defaultProps = defaultProps;
	
	exports.default = CSSTransitionGroup;
	module.exports = exports['default'];

/***/ }),
/* 802 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _addClass = __webpack_require__(476);
	
	var _addClass2 = _interopRequireDefault(_addClass);
	
	var _removeClass = __webpack_require__(478);
	
	var _removeClass2 = _interopRequireDefault(_removeClass);
	
	var _requestAnimationFrame = __webpack_require__(238);
	
	var _requestAnimationFrame2 = _interopRequireDefault(_requestAnimationFrame);
	
	var _properties = __webpack_require__(483);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _reactDom = __webpack_require__(36);
	
	var _PropTypes = __webpack_require__(333);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var events = [];
	if (_properties.transitionEnd) events.push(_properties.transitionEnd);
	if (_properties.animationEnd) events.push(_properties.animationEnd);
	
	function addEndListener(node, listener) {
	  if (events.length) {
	    events.forEach(function (e) {
	      return node.addEventListener(e, listener, false);
	    });
	  } else {
	    setTimeout(listener, 0);
	  }
	
	  return function () {
	    if (!events.length) return;
	    events.forEach(function (e) {
	      return node.removeEventListener(e, listener, false);
	    });
	  };
	}
	
	var propTypes = {
	  children: _propTypes2.default.node,
	  name: _PropTypes.nameShape.isRequired,
	
	  // Once we require timeouts to be specified, we can remove the
	  // boolean flags (appear etc.) and just accept a number
	  // or a bool for the timeout flags (appearTimeout etc.)
	  appear: _propTypes2.default.bool,
	  enter: _propTypes2.default.bool,
	  leave: _propTypes2.default.bool,
	  appearTimeout: _propTypes2.default.number,
	  enterTimeout: _propTypes2.default.number,
	  leaveTimeout: _propTypes2.default.number
	};
	
	var CSSTransitionGroupChild = function (_React$Component) {
	  _inherits(CSSTransitionGroupChild, _React$Component);
	
	  function CSSTransitionGroupChild() {
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, CSSTransitionGroupChild);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.componentWillAppear = function (done) {
	      if (_this.props.appear) {
	        _this.transition('appear', done, _this.props.appearTimeout);
	      } else {
	        done();
	      }
	    }, _this.componentWillEnter = function (done) {
	      if (_this.props.enter) {
	        _this.transition('enter', done, _this.props.enterTimeout);
	      } else {
	        done();
	      }
	    }, _this.componentWillLeave = function (done) {
	      if (_this.props.leave) {
	        _this.transition('leave', done, _this.props.leaveTimeout);
	      } else {
	        done();
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  CSSTransitionGroupChild.prototype.componentWillMount = function componentWillMount() {
	    this.classNameAndNodeQueue = [];
	    this.transitionTimeouts = [];
	  };
	
	  CSSTransitionGroupChild.prototype.componentWillUnmount = function componentWillUnmount() {
	    this.unmounted = true;
	
	    if (this.timeout) {
	      clearTimeout(this.timeout);
	    }
	    this.transitionTimeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	
	    this.classNameAndNodeQueue.length = 0;
	  };
	
	  CSSTransitionGroupChild.prototype.transition = function transition(animationType, finishCallback, timeout) {
	    var node = (0, _reactDom.findDOMNode)(this);
	
	    if (!node) {
	      if (finishCallback) {
	        finishCallback();
	      }
	      return;
	    }
	
	    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
	    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
	    var timer = null;
	    var removeListeners = void 0;
	
	    (0, _addClass2.default)(node, className);
	
	    // Need to do this to actually trigger a transition.
	    this.queueClassAndNode(activeClassName, node);
	
	    // Clean-up the animation after the specified delay
	    var finish = function finish(e) {
	      if (e && e.target !== node) {
	        return;
	      }
	
	      clearTimeout(timer);
	      if (removeListeners) removeListeners();
	
	      (0, _removeClass2.default)(node, className);
	      (0, _removeClass2.default)(node, activeClassName);
	
	      if (removeListeners) removeListeners();
	
	      // Usually this optional callback is used for informing an owner of
	      // a leave animation and telling it to remove the child.
	      if (finishCallback) {
	        finishCallback();
	      }
	    };
	
	    if (timeout) {
	      timer = setTimeout(finish, timeout);
	      this.transitionTimeouts.push(timer);
	    } else if (_properties.transitionEnd) {
	      removeListeners = addEndListener(node, finish);
	    }
	  };
	
	  CSSTransitionGroupChild.prototype.queueClassAndNode = function queueClassAndNode(className, node) {
	    var _this2 = this;
	
	    this.classNameAndNodeQueue.push({
	      className: className,
	      node: node
	    });
	
	    if (!this.rafHandle) {
	      this.rafHandle = (0, _requestAnimationFrame2.default)(function () {
	        return _this2.flushClassNameAndNodeQueue();
	      });
	    }
	  };
	
	  CSSTransitionGroupChild.prototype.flushClassNameAndNodeQueue = function flushClassNameAndNodeQueue() {
	    if (!this.unmounted) {
	      this.classNameAndNodeQueue.forEach(function (obj) {
	        // This is for to force a repaint,
	        // which is necessary in order to transition styles when adding a class name.
	        /* eslint-disable no-unused-expressions */
	        obj.node.scrollTop;
	        /* eslint-enable no-unused-expressions */
	        (0, _addClass2.default)(obj.node, obj.className);
	      });
	    }
	    this.classNameAndNodeQueue.length = 0;
	    this.rafHandle = null;
	  };
	
	  CSSTransitionGroupChild.prototype.render = function render() {
	    var props = _extends({}, this.props);
	    delete props.name;
	    delete props.appear;
	    delete props.enter;
	    delete props.leave;
	    delete props.appearTimeout;
	    delete props.enterTimeout;
	    delete props.leaveTimeout;
	    delete props.children;
	    return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), props);
	  };
	
	  return CSSTransitionGroupChild;
	}(_react2.default.Component);
	
	CSSTransitionGroupChild.displayName = 'CSSTransitionGroupChild';
	
	
	CSSTransitionGroupChild.propTypes =  false ? propTypes : {};
	
	exports.default = CSSTransitionGroupChild;
	module.exports = exports['default'];

/***/ }),
/* 803 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _chainFunction = __webpack_require__(391);
	
	var _chainFunction2 = _interopRequireDefault(_chainFunction);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _warning = __webpack_require__(23);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ChildMapping = __webpack_require__(804);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var propTypes = {
	  component: _propTypes2.default.any,
	  childFactory: _propTypes2.default.func,
	  children: _propTypes2.default.node
	};
	
	var defaultProps = {
	  component: 'span',
	  childFactory: function childFactory(child) {
	    return child;
	  }
	};
	
	var TransitionGroup = function (_React$Component) {
	  _inherits(TransitionGroup, _React$Component);
	
	  function TransitionGroup(props, context) {
	    _classCallCheck(this, TransitionGroup);
	
	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));
	
	    _this.performAppear = function (key, component) {
	      _this.currentlyTransitioningKeys[key] = true;
	
	      if (component.componentWillAppear) {
	        component.componentWillAppear(_this._handleDoneAppearing.bind(_this, key, component));
	      } else {
	        _this._handleDoneAppearing(key, component);
	      }
	    };
	
	    _this._handleDoneAppearing = function (key, component) {
	      if (component.componentDidAppear) {
	        component.componentDidAppear();
	      }
	
	      delete _this.currentlyTransitioningKeys[key];
	
	      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);
	
	      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	        // This was removed before it had fully appeared. Remove it.
	        _this.performLeave(key, component);
	      }
	    };
	
	    _this.performEnter = function (key, component) {
	      _this.currentlyTransitioningKeys[key] = true;
	
	      if (component.componentWillEnter) {
	        component.componentWillEnter(_this._handleDoneEntering.bind(_this, key, component));
	      } else {
	        _this._handleDoneEntering(key, component);
	      }
	    };
	
	    _this._handleDoneEntering = function (key, component) {
	      if (component.componentDidEnter) {
	        component.componentDidEnter();
	      }
	
	      delete _this.currentlyTransitioningKeys[key];
	
	      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);
	
	      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	        // This was removed before it had fully entered. Remove it.
	        _this.performLeave(key, component);
	      }
	    };
	
	    _this.performLeave = function (key, component) {
	      _this.currentlyTransitioningKeys[key] = true;
	
	      if (component.componentWillLeave) {
	        component.componentWillLeave(_this._handleDoneLeaving.bind(_this, key, component));
	      } else {
	        // Note that this is somewhat dangerous b/c it calls setState()
	        // again, effectively mutating the component before all the work
	        // is done.
	        _this._handleDoneLeaving(key, component);
	      }
	    };
	
	    _this._handleDoneLeaving = function (key, component) {
	      if (component.componentDidLeave) {
	        component.componentDidLeave();
	      }
	
	      delete _this.currentlyTransitioningKeys[key];
	
	      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);
	
	      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
	        // This entered again before it fully left. Add it again.
	        _this.keysToEnter.push(key);
	      } else {
	        _this.setState(function (state) {
	          var newChildren = _extends({}, state.children);
	          delete newChildren[key];
	          return { children: newChildren };
	        });
	      }
	    };
	
	    _this.childRefs = Object.create(null);
	
	    _this.state = {
	      children: (0, _ChildMapping.getChildMapping)(props.children)
	    };
	    return _this;
	  }
	
	  TransitionGroup.prototype.componentWillMount = function componentWillMount() {
	    this.currentlyTransitioningKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	  };
	
	  TransitionGroup.prototype.componentDidMount = function componentDidMount() {
	    var initialChildMapping = this.state.children;
	    for (var key in initialChildMapping) {
	      if (initialChildMapping[key]) {
	        this.performAppear(key, this.childRefs[key]);
	      }
	    }
	  };
	
	  TransitionGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    var nextChildMapping = (0, _ChildMapping.getChildMapping)(nextProps.children);
	    var prevChildMapping = this.state.children;
	
	    this.setState({
	      children: (0, _ChildMapping.mergeChildMappings)(prevChildMapping, nextChildMapping)
	    });
	
	    for (var key in nextChildMapping) {
	      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
	      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
	        this.keysToEnter.push(key);
	      }
	    }
	
	    for (var _key in prevChildMapping) {
	      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(_key);
	      if (prevChildMapping[_key] && !hasNext && !this.currentlyTransitioningKeys[_key]) {
	        this.keysToLeave.push(_key);
	      }
	    }
	
	    // If we want to someday check for reordering, we could do it here.
	  };
	
	  TransitionGroup.prototype.componentDidUpdate = function componentDidUpdate() {
	    var _this2 = this;
	
	    var keysToEnter = this.keysToEnter;
	    this.keysToEnter = [];
	    keysToEnter.forEach(function (key) {
	      return _this2.performEnter(key, _this2.childRefs[key]);
	    });
	
	    var keysToLeave = this.keysToLeave;
	    this.keysToLeave = [];
	    keysToLeave.forEach(function (key) {
	      return _this2.performLeave(key, _this2.childRefs[key]);
	    });
	  };
	
	  TransitionGroup.prototype.render = function render() {
	    var _this3 = this;
	
	    // TODO: we could get rid of the need for the wrapper node
	    // by cloning a single child
	    var childrenToRender = [];
	
	    var _loop = function _loop(key) {
	      var child = _this3.state.children[key];
	      if (child) {
	        var isCallbackRef = typeof child.ref !== 'string';
	        var factoryChild = _this3.props.childFactory(child);
	        var ref = function ref(r) {
	          _this3.childRefs[key] = r;
	        };
	
	         false ? (0, _warning2.default)(isCallbackRef, 'string refs are not supported on children of TransitionGroup and will be ignored. ' + 'Please use a callback ref instead: https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute') : void 0;
	
	        // Always chaining the refs leads to problems when the childFactory
	        // wraps the child. The child ref callback gets called twice with the
	        // wrapper and the child. So we only need to chain the ref if the
	        // factoryChild is not different from child.
	        if (factoryChild === child && isCallbackRef) {
	          ref = (0, _chainFunction2.default)(child.ref, ref);
	        }
	
	        // You may need to apply reactive updates to a child as it is leaving.
	        // The normal React way to do it won't work since the child will have
	        // already been removed. In case you need this behavior you can provide
	        // a childFactory function to wrap every child, even the ones that are
	        // leaving.
	        childrenToRender.push(_react2.default.cloneElement(factoryChild, {
	          key: key,
	          ref: ref
	        }));
	      }
	    };
	
	    for (var key in this.state.children) {
	      _loop(key);
	    }
	
	    // Do not forward TransitionGroup props to primitive DOM nodes
	    var props = _extends({}, this.props);
	    delete props.transitionLeave;
	    delete props.transitionName;
	    delete props.transitionAppear;
	    delete props.transitionEnter;
	    delete props.childFactory;
	    delete props.transitionLeaveTimeout;
	    delete props.transitionEnterTimeout;
	    delete props.transitionAppearTimeout;
	    delete props.component;
	
	    return _react2.default.createElement(this.props.component, props, childrenToRender);
	  };
	
	  return TransitionGroup;
	}(_react2.default.Component);
	
	TransitionGroup.displayName = 'TransitionGroup';
	
	
	TransitionGroup.propTypes =  false ? propTypes : {};
	TransitionGroup.defaultProps = defaultProps;
	
	exports.default = TransitionGroup;
	module.exports = exports['default'];

/***/ }),
/* 804 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.getChildMapping = getChildMapping;
	exports.mergeChildMappings = mergeChildMappings;
	
	var _react = __webpack_require__(2);
	
	/**
	 * Given `this.props.children`, return an object mapping key to child.
	 *
	 * @param {*} children `this.props.children`
	 * @return {object} Mapping of key to child
	 */
	function getChildMapping(children) {
	  if (!children) {
	    return children;
	  }
	  var result = {};
	  _react.Children.map(children, function (child) {
	    return child;
	  }).forEach(function (child) {
	    result[child.key] = child;
	  });
	  return result;
	}
	
	/**
	 * When you're adding or removing children some may be added or removed in the
	 * same render pass. We want to show *both* since we want to simultaneously
	 * animate elements in and out. This function takes a previous set of keys
	 * and a new set of keys and merges them with its best guess of the correct
	 * ordering. In the future we may expose some of the utilities in
	 * ReactMultiChild to make this easy, but for now React itself does not
	 * directly have this concept of the union of prevChildren and nextChildren
	 * so we implement it here.
	 *
	 * @param {object} prev prev children as returned from
	 * `ReactTransitionChildMapping.getChildMapping()`.
	 * @param {object} next next children as returned from
	 * `ReactTransitionChildMapping.getChildMapping()`.
	 * @return {object} a key set that contains all keys in `prev` and all keys
	 * in `next` in a reasonable order.
	 */
	function mergeChildMappings(prev, next) {
	  prev = prev || {};
	  next = next || {};
	
	  function getValueForKey(key) {
	    if (next.hasOwnProperty(key)) {
	      return next[key];
	    }
	
	    return prev[key];
	  }
	
	  // For each key of `next`, the list of keys to insert before that key in
	  // the combined list
	  var nextKeysPending = {};
	
	  var pendingKeys = [];
	  for (var prevKey in prev) {
	    if (next.hasOwnProperty(prevKey)) {
	      if (pendingKeys.length) {
	        nextKeysPending[prevKey] = pendingKeys;
	        pendingKeys = [];
	      }
	    } else {
	      pendingKeys.push(prevKey);
	    }
	  }
	
	  var i = void 0;
	  var childMapping = {};
	  for (var nextKey in next) {
	    if (nextKeysPending.hasOwnProperty(nextKey)) {
	      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
	        var pendingNextKey = nextKeysPending[nextKey][i];
	        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
	      }
	    }
	    childMapping[nextKey] = getValueForKey(nextKey);
	  }
	
	  // Finally, add the keys which didn't appear before any key in `next`
	  for (i = 0; i < pendingKeys.length; i++) {
	    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
	  }
	
	  return childMapping;
	}

/***/ }),
/* 805 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_RenderedSection = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_RenderedSection || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_ScrollIndices = __webpack_require__(807).babelPluginFlowReactPropTypes_proptype_ScrollIndices || __webpack_require__(1).any;
	
	/**
	 * This HOC decorates a virtualized component and responds to arrow-key events by scrolling one row or column at a time.
	 */
	
	var ArrowKeyStepper = function (_React$PureComponent) {
	  _inherits(ArrowKeyStepper, _React$PureComponent);
	
	  function ArrowKeyStepper(props) {
	    _classCallCheck(this, ArrowKeyStepper);
	
	    var _this = _possibleConstructorReturn(this, (ArrowKeyStepper.__proto__ || Object.getPrototypeOf(ArrowKeyStepper)).call(this, props));
	
	    _this._columnStartIndex = 0;
	    _this._columnStopIndex = 0;
	    _this._rowStartIndex = 0;
	    _this._rowStopIndex = 0;
	
	    _this._onKeyDown = function (event) {
	      var _this$props = _this.props,
	          columnCount = _this$props.columnCount,
	          disabled = _this$props.disabled,
	          mode = _this$props.mode,
	          rowCount = _this$props.rowCount;
	
	
	      if (disabled) {
	        return;
	      }
	
	      var _this$_getScrollState = _this._getScrollState(),
	          scrollToColumnPrevious = _this$_getScrollState.scrollToColumn,
	          scrollToRowPrevious = _this$_getScrollState.scrollToRow;
	
	      var _this$_getScrollState2 = _this._getScrollState(),
	          scrollToColumn = _this$_getScrollState2.scrollToColumn,
	          scrollToRow = _this$_getScrollState2.scrollToRow;
	
	      // The above cases all prevent default event event behavior.
	      // This is to keep the grid from scrolling after the snap-to update.
	
	
	      switch (event.key) {
	        case 'ArrowDown':
	          scrollToRow = mode === 'cells' ? Math.min(scrollToRow + 1, rowCount - 1) : Math.min(_this._rowStopIndex + 1, rowCount - 1);
	          break;
	        case 'ArrowLeft':
	          scrollToColumn = mode === 'cells' ? Math.max(scrollToColumn - 1, 0) : Math.max(_this._columnStartIndex - 1, 0);
	          break;
	        case 'ArrowRight':
	          scrollToColumn = mode === 'cells' ? Math.min(scrollToColumn + 1, columnCount - 1) : Math.min(_this._columnStopIndex + 1, columnCount - 1);
	          break;
	        case 'ArrowUp':
	          scrollToRow = mode === 'cells' ? Math.max(scrollToRow - 1, 0) : Math.max(_this._rowStartIndex - 1, 0);
	          break;
	      }
	
	      if (scrollToColumn !== scrollToColumnPrevious || scrollToRow !== scrollToRowPrevious) {
	        event.preventDefault();
	
	        _this._updateScrollState({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
	      }
	    };
	
	    _this._onSectionRendered = function (_ref) {
	      var columnStartIndex = _ref.columnStartIndex,
	          columnStopIndex = _ref.columnStopIndex,
	          rowStartIndex = _ref.rowStartIndex,
	          rowStopIndex = _ref.rowStopIndex;
	
	      _this._columnStartIndex = columnStartIndex;
	      _this._columnStopIndex = columnStopIndex;
	      _this._rowStartIndex = rowStartIndex;
	      _this._rowStopIndex = rowStopIndex;
	    };
	
	    _this.state = {
	      scrollToColumn: props.scrollToColumn,
	      scrollToRow: props.scrollToRow
	    };
	    return _this;
	  }
	
	  _createClass(ArrowKeyStepper, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      if (this.props.isControlled) {
	        return;
	      }
	
	      var scrollToColumn = nextProps.scrollToColumn,
	          scrollToRow = nextProps.scrollToRow;
	      var _props = this.props,
	          prevScrollToColumn = _props.scrollToColumn,
	          prevScrollToRow = _props.scrollToRow;
	
	
	      if (prevScrollToColumn !== scrollToColumn && prevScrollToRow !== scrollToRow) {
	        this.setState({
	          scrollToColumn: scrollToColumn,
	          scrollToRow: scrollToRow
	        });
	      } else if (prevScrollToColumn !== scrollToColumn) {
	        this.setState({ scrollToColumn: scrollToColumn });
	      } else if (prevScrollToRow !== scrollToRow) {
	        this.setState({ scrollToRow: scrollToRow });
	      }
	    }
	  }, {
	    key: 'setScrollIndexes',
	    value: function setScrollIndexes(_ref2) {
	      var scrollToColumn = _ref2.scrollToColumn,
	          scrollToRow = _ref2.scrollToRow;
	
	      this.setState({
	        scrollToRow: scrollToRow,
	        scrollToColumn: scrollToColumn
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props2 = this.props,
	          className = _props2.className,
	          children = _props2.children;
	
	      var _getScrollState2 = this._getScrollState(),
	          scrollToColumn = _getScrollState2.scrollToColumn,
	          scrollToRow = _getScrollState2.scrollToRow;
	
	      return _react2.default.createElement(
	        'div',
	        { className: className, onKeyDown: this._onKeyDown },
	        children({
	          onSectionRendered: this._onSectionRendered,
	          scrollToColumn: scrollToColumn,
	          scrollToRow: scrollToRow
	        })
	      );
	    }
	  }, {
	    key: '_getScrollState',
	    value: function _getScrollState() {
	      return this.props.isControlled ? this.props : this.state;
	    }
	  }, {
	    key: '_updateScrollState',
	    value: function _updateScrollState(_ref3) {
	      var scrollToColumn = _ref3.scrollToColumn,
	          scrollToRow = _ref3.scrollToRow;
	      var _props3 = this.props,
	          isControlled = _props3.isControlled,
	          onScrollToChange = _props3.onScrollToChange;
	
	
	      if (typeof onScrollToChange === 'function') {
	        onScrollToChange({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
	      }
	
	      if (!isControlled) {
	        this.setState({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
	      }
	    }
	  }]);
	
	  return ArrowKeyStepper;
	}(_react2.default.PureComponent);
	
	ArrowKeyStepper.defaultProps = {
	  disabled: false,
	  isControlled: false,
	  mode: 'edges',
	  scrollToColumn: 0,
	  scrollToRow: 0
	};
	ArrowKeyStepper.propTypes = {
	  children: __webpack_require__(1).func.isRequired,
	  className: __webpack_require__(1).string,
	  columnCount: __webpack_require__(1).number.isRequired,
	  disabled: __webpack_require__(1).bool.isRequired,
	  isControlled: __webpack_require__(1).bool.isRequired,
	  mode: __webpack_require__(1).oneOf(['cells', 'edges']).isRequired,
	  onScrollToChange: __webpack_require__(1).func,
	  rowCount: __webpack_require__(1).number.isRequired,
	  scrollToColumn: __webpack_require__(1).number.isRequired,
	  scrollToRow: __webpack_require__(1).number.isRequired
	};
	exports.default = ArrowKeyStepper;

/***/ }),
/* 806 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ArrowKeyStepper = __webpack_require__(805);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ArrowKeyStepper).default;
	  }
	});
	Object.defineProperty(exports, 'ArrowKeyStepper', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ArrowKeyStepper).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 807 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_ScrollIndices", {
	  value: {
	    scrollToColumn: __webpack_require__(1).number.isRequired,
	    scrollToRow: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});

/***/ }),
/* 808 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _detectElementResize = __webpack_require__(847);
	
	var _detectElementResize2 = _interopRequireDefault(_detectElementResize);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_Size = __webpack_require__(810).babelPluginFlowReactPropTypes_proptype_Size || __webpack_require__(1).any;
	
	var AutoSizer = function (_React$PureComponent) {
	  _inherits(AutoSizer, _React$PureComponent);
	
	  function AutoSizer() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, AutoSizer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      height: _this.props.defaultHeight || 0,
	      width: _this.props.defaultWidth || 0
	    }, _this._onResize = function () {
	      var _this$props = _this.props,
	          disableHeight = _this$props.disableHeight,
	          disableWidth = _this$props.disableWidth,
	          onResize = _this$props.onResize;
	
	
	      if (_this._parentNode) {
	        // Guard against AutoSizer component being removed from the DOM immediately after being added.
	        // This can result in invalid style values which can result in NaN values if we don't handle them.
	        // See issue #150 for more context.
	
	        var height = _this._parentNode.offsetHeight || 0;
	        var width = _this._parentNode.offsetWidth || 0;
	
	        var style = window.getComputedStyle(_this._parentNode) || {};
	        var paddingLeft = parseInt(style.paddingLeft, 10) || 0;
	        var paddingRight = parseInt(style.paddingRight, 10) || 0;
	        var paddingTop = parseInt(style.paddingTop, 10) || 0;
	        var paddingBottom = parseInt(style.paddingBottom, 10) || 0;
	
	        var newHeight = height - paddingTop - paddingBottom;
	        var newWidth = width - paddingLeft - paddingRight;
	
	        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
	          _this.setState({
	            height: height - paddingTop - paddingBottom,
	            width: width - paddingLeft - paddingRight
	          });
	
	          onResize({ height: height, width: width });
	        }
	      }
	    }, _this._setRef = function (autoSizer) {
	      _this._autoSizer = autoSizer;
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(AutoSizer, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var nonce = this.props.nonce;
	
	      if (this._autoSizer && this._autoSizer.parentNode instanceof HTMLElement) {
	        // Delay access of parentNode until mount.
	        // This handles edge-cases where the component has already been unmounted before its ref has been set,
	        // As well as libraries like react-lite which have a slightly different lifecycle.
	        this._parentNode = this._autoSizer.parentNode;
	
	        // Defer requiring resize handler in order to support server-side rendering.
	        // See issue #41
	        this._detectElementResize = (0, _detectElementResize2.default)(nonce);
	        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
	
	        this._onResize();
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      if (this._detectElementResize && this._parentNode) {
	        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          children = _props.children,
	          disableHeight = _props.disableHeight,
	          disableWidth = _props.disableWidth;
	      var _state = this.state,
	          height = _state.height,
	          width = _state.width;
	
	      // Outer div should not force width/height since that may prevent containers from shrinking.
	      // Inner component should overflow and use calculated width/height.
	      // See issue #68 for more information.
	
	      var outerStyle = { overflow: 'visible' };
	      var childParams = {};
	
	      if (!disableHeight) {
	        outerStyle.height = 0;
	        childParams.height = height;
	      }
	
	      if (!disableWidth) {
	        outerStyle.width = 0;
	        childParams.width = width;
	      }
	
	      /**
	       * TODO: Avoid rendering children before the initial measurements have been collected.
	       * At best this would just be wasting cycles.
	       * Add this check into version 10 though as it could break too many ref callbacks in version 9.
	       * Note that if default width/height props were provided this would still work with SSR.
	      if (
	        height !== 0 &&
	        width !== 0
	      ) {
	        child = children({ height, width })
	      }
	      */
	
	      return _react2.default.createElement(
	        'div',
	        { ref: this._setRef, style: outerStyle },
	        children(childParams)
	      );
	    }
	  }]);
	
	  return AutoSizer;
	}(_react2.default.PureComponent);
	
	AutoSizer.defaultProps = {
	  onResize: function onResize() {},
	  disableHeight: false,
	  disableWidth: false
	};
	AutoSizer.propTypes = {
	  children: __webpack_require__(1).func.isRequired,
	  defaultHeight: __webpack_require__(1).number,
	  defaultWidth: __webpack_require__(1).number,
	  disableHeight: __webpack_require__(1).bool.isRequired,
	  disableWidth: __webpack_require__(1).bool.isRequired,
	  nonce: __webpack_require__(1).string,
	  onResize: __webpack_require__(1).func.isRequired
	};
	exports.default = AutoSizer;

/***/ }),
/* 809 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _AutoSizer = __webpack_require__(808);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_AutoSizer).default;
	  }
	});
	Object.defineProperty(exports, 'AutoSizer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_AutoSizer).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 810 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Size", {
	  value: {
	    height: __webpack_require__(1).number.isRequired,
	    width: __webpack_require__(1).number.isRequired
	  },
	  configurable: true
	});

/***/ }),
/* 811 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(36);
	
	var _CellMeasurerCache = __webpack_require__(334);
	
	var _CellMeasurerCache2 = _interopRequireDefault(_CellMeasurerCache);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Wraps a cell and measures its rendered content.
	 * Measurements are stored in a per-cell cache.
	 * Cached-content is not be re-measured.
	 */
	var CellMeasurer = function (_React$PureComponent) {
	  _inherits(CellMeasurer, _React$PureComponent);
	
	  function CellMeasurer() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, CellMeasurer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = CellMeasurer.__proto__ || Object.getPrototypeOf(CellMeasurer)).call.apply(_ref, [this].concat(args))), _this), _this._measure = function () {
	      var _this$props = _this.props,
	          cache = _this$props.cache,
	          _this$props$columnInd = _this$props.columnIndex,
	          columnIndex = _this$props$columnInd === undefined ? 0 : _this$props$columnInd,
	          parent = _this$props.parent,
	          _this$props$rowIndex = _this$props.rowIndex,
	          rowIndex = _this$props$rowIndex === undefined ? _this.props.index || 0 : _this$props$rowIndex;
	
	      var _this$_getCellMeasure = _this._getCellMeasurements(),
	          height = _this$_getCellMeasure.height,
	          width = _this$_getCellMeasure.width;
	
	      if (height !== cache.getHeight(rowIndex, columnIndex) || width !== cache.getWidth(rowIndex, columnIndex)) {
	        cache.set(rowIndex, columnIndex, width, height);
	
	        if (parent && typeof parent.recomputeGridSize === 'function') {
	          parent.recomputeGridSize({
	            columnIndex: columnIndex,
	            rowIndex: rowIndex
	          });
	        }
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(CellMeasurer, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this._maybeMeasureCell();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._maybeMeasureCell();
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var children = this.props.children;
	
	
	      return typeof children === 'function' ? children({ measure: this._measure }) : children;
	    }
	  }, {
	    key: '_getCellMeasurements',
	    value: function _getCellMeasurements() {
	      var cache = this.props.cache;
	
	
	      var node = (0, _reactDom.findDOMNode)(this);
	
	      // TODO Check for a bad combination of fixedWidth and missing numeric width or vice versa with height
	
	      if (node instanceof HTMLElement) {
	        var styleWidth = node.style.width;
	        var styleHeight = node.style.height;
	
	        // If we are re-measuring a cell that has already been measured,
	        // It will have a hard-coded width/height from the previous measurement.
	        // The fact that we are measuring indicates this measurement is probably stale,
	        // So explicitly clear it out (eg set to "auto") so we can recalculate.
	        // See issue #593 for more info.
	        // Even if we are measuring initially- if we're inside of a MultiGrid component,
	        // Explicitly clear width/height before measuring to avoid being tainted by another Grid.
	        // eg top/left Grid renders before bottom/right Grid
	        // Since the CellMeasurerCache is shared between them this taints derived cell size values.
	        if (!cache.hasFixedWidth()) {
	          node.style.width = 'auto';
	        }
	        if (!cache.hasFixedHeight()) {
	          node.style.height = 'auto';
	        }
	
	        var height = Math.ceil(node.offsetHeight);
	        var width = Math.ceil(node.offsetWidth);
	
	        // Reset after measuring to avoid breaking styles; see #660
	        if (styleWidth) {
	          node.style.width = styleWidth;
	        }
	        if (styleHeight) {
	          node.style.height = styleHeight;
	        }
	
	        return { height: height, width: width };
	      } else {
	        return { height: 0, width: 0 };
	      }
	    }
	  }, {
	    key: '_maybeMeasureCell',
	    value: function _maybeMeasureCell() {
	      var _props = this.props,
	          cache = _props.cache,
	          _props$columnIndex = _props.columnIndex,
	          columnIndex = _props$columnIndex === undefined ? 0 : _props$columnIndex,
	          parent = _props.parent,
	          _props$rowIndex = _props.rowIndex,
	          rowIndex = _props$rowIndex === undefined ? this.props.index || 0 : _props$rowIndex;
	
	
	      if (!cache.has(rowIndex, columnIndex)) {
	        var _getCellMeasurements2 = this._getCellMeasurements(),
	            height = _getCellMeasurements2.height,
	            width = _getCellMeasurements2.width;
	
	        cache.set(rowIndex, columnIndex, width, height);
	
	        // If size has changed, let Grid know to re-render.
	        if (parent && typeof parent.invalidateCellSizeAfterRender === 'function') {
	          parent.invalidateCellSizeAfterRender({
	            columnIndex: columnIndex,
	            rowIndex: rowIndex
	          });
	        }
	      }
	    }
	  }]);
	
	  return CellMeasurer;
	}(_react2.default.PureComponent);
	
	// Used for DEV mode warning check
	
	
	CellMeasurer.__internalCellMeasurerFlag = false;
	CellMeasurer.propTypes = {
	  cache: typeof _CellMeasurerCache2.default === 'function' ? __webpack_require__(1).instanceOf(_CellMeasurerCache2.default).isRequired : __webpack_require__(1).any.isRequired,
	  children: __webpack_require__(1).oneOfType([__webpack_require__(1).func, typeof (_react2.default.Element == null ? {} : _react2.default.Element) === 'function' ? __webpack_require__(1).instanceOf(_react2.default.Element == null ? {} : _react2.default.Element) : __webpack_require__(1).any]).isRequired,
	  columnIndex: __webpack_require__(1).number,
	  index: __webpack_require__(1).number,
	  parent: __webpack_require__(1).shape({
	    invalidateCellSizeAfterRender: __webpack_require__(1).func,
	    recomputeGridSize: __webpack_require__(1).func
	  }).isRequired,
	  rowIndex: __webpack_require__(1).number
	};
	exports.default = CellMeasurer;
	if (false) {
	  CellMeasurer.__internalCellMeasurerFlag = true;
	}

/***/ }),
/* 812 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _CollectionView = __webpack_require__(813);
	
	var _CollectionView2 = _interopRequireDefault(_CollectionView);
	
	var _calculateSizeAndPositionData2 = __webpack_require__(817);
	
	var _calculateSizeAndPositionData3 = _interopRequireDefault(_calculateSizeAndPositionData2);
	
	var _getUpdatedOffsetForIndex = __webpack_require__(845);
	
	var _getUpdatedOffsetForIndex2 = _interopRequireDefault(_getUpdatedOffsetForIndex);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Renders scattered or non-linear data.
	 * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.
	 */
	var babelPluginFlowReactPropTypes_proptype_SizeInfo = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_SizeInfo || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_ScrollPosition = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_ScrollPosition || __webpack_require__(1).any;
	
	var Collection = function (_PureComponent) {
	  _inherits(Collection, _PureComponent);
	
	  function Collection(props, context) {
	    _classCallCheck(this, Collection);
	
	    var _this = _possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).call(this, props, context));
	
	    _this._cellMetadata = [];
	    _this._lastRenderedCellIndices = [];
	
	    // Cell cache during scroll (for perforamnce)
	    _this._cellCache = [];
	
	    _this._isScrollingChange = _this._isScrollingChange.bind(_this);
	    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_this);
	    return _this;
	  }
	
	  _createClass(Collection, [{
	    key: 'forceUpdate',
	    value: function forceUpdate() {
	      if (this._collectionView !== undefined) {
	        this._collectionView.forceUpdate();
	      }
	    }
	
	    /** See Collection#recomputeCellSizesAndPositions */
	
	  }, {
	    key: 'recomputeCellSizesAndPositions',
	    value: function recomputeCellSizesAndPositions() {
	      this._cellCache = [];
	      this._collectionView.recomputeCellSizesAndPositions();
	    }
	
	    /** React lifecycle methods */
	
	  }, {
	    key: 'render',
	    value: function render() {
	      var props = _objectWithoutProperties(this.props, []);
	
	      return _react2.default.createElement(_CollectionView2.default, _extends({
	        cellLayoutManager: this,
	        isScrollingChange: this._isScrollingChange,
	        ref: this._setCollectionViewRef
	      }, props));
	    }
	
	    /** CellLayoutManager interface */
	
	  }, {
	    key: 'calculateSizeAndPositionData',
	    value: function calculateSizeAndPositionData() {
	      var _props = this.props,
	          cellCount = _props.cellCount,
	          cellSizeAndPositionGetter = _props.cellSizeAndPositionGetter,
	          sectionSize = _props.sectionSize;
	
	
	      var data = (0, _calculateSizeAndPositionData3.default)({
	        cellCount: cellCount,
	        cellSizeAndPositionGetter: cellSizeAndPositionGetter,
	        sectionSize: sectionSize
	      });
	
	      this._cellMetadata = data.cellMetadata;
	      this._sectionManager = data.sectionManager;
	      this._height = data.height;
	      this._width = data.width;
	    }
	
	    /**
	     * Returns the most recently rendered set of cell indices.
	     */
	
	  }, {
	    key: 'getLastRenderedIndices',
	    value: function getLastRenderedIndices() {
	      return this._lastRenderedCellIndices;
	    }
	
	    /**
	     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.
	     */
	
	  }, {
	    key: 'getScrollPositionForCell',
	    value: function getScrollPositionForCell(_ref) {
	      var align = _ref.align,
	          cellIndex = _ref.cellIndex,
	          height = _ref.height,
	          scrollLeft = _ref.scrollLeft,
	          scrollTop = _ref.scrollTop,
	          width = _ref.width;
	      var cellCount = this.props.cellCount;
	
	
	      if (cellIndex >= 0 && cellIndex < cellCount) {
	        var cellMetadata = this._cellMetadata[cellIndex];
	
	        scrollLeft = (0, _getUpdatedOffsetForIndex2.default)({
	          align: align,
	          cellOffset: cellMetadata.x,
	          cellSize: cellMetadata.width,
	          containerSize: width,
	          currentOffset: scrollLeft,
	          targetIndex: cellIndex
	        });
	
	        scrollTop = (0, _getUpdatedOffsetForIndex2.default)({
	          align: align,
	          cellOffset: cellMetadata.y,
	          cellSize: cellMetadata.height,
	          containerSize: height,
	          currentOffset: scrollTop,
	          targetIndex: cellIndex
	        });
	      }
	
	      return {
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop
	      };
	    }
	  }, {
	    key: 'getTotalSize',
	    value: function getTotalSize() {
	      return {
	        height: this._height,
	        width: this._width
	      };
	    }
	  }, {
	    key: 'cellRenderers',
	    value: function cellRenderers(_ref2) {
	      var _this2 = this;
	
	      var height = _ref2.height,
	          isScrolling = _ref2.isScrolling,
	          width = _ref2.width,
	          x = _ref2.x,
	          y = _ref2.y;
	      var _props2 = this.props,
	          cellGroupRenderer = _props2.cellGroupRenderer,
	          cellRenderer = _props2.cellRenderer;
	
	      // Store for later calls to getLastRenderedIndices()
	
	      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({
	        height: height,
	        width: width,
	        x: x,
	        y: y
	      });
	
	      return cellGroupRenderer({
	        cellCache: this._cellCache,
	        cellRenderer: cellRenderer,
	        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {
	          var index = _ref3.index;
	          return _this2._sectionManager.getCellMetadata({ index: index });
	        },
	        indices: this._lastRenderedCellIndices,
	        isScrolling: isScrolling
	      });
	    }
	  }, {
	    key: '_isScrollingChange',
	    value: function _isScrollingChange(isScrolling) {
	      if (!isScrolling) {
	        this._cellCache = [];
	      }
	    }
	  }, {
	    key: '_setCollectionViewRef',
	    value: function _setCollectionViewRef(ref) {
	      this._collectionView = ref;
	    }
	  }]);
	
	  return Collection;
	}(_react.PureComponent);
	
	Collection.defaultProps = {
	  'aria-label': 'grid',
	  cellGroupRenderer: defaultCellGroupRenderer
	};
	exports.default = Collection;
	Collection.propTypes =  false ? {
	  'aria-label': _propTypes2.default.string,
	
	  /**
	   * Number of cells in Collection.
	   */
	  cellCount: _propTypes2.default.number.isRequired,
	
	  /**
	   * Responsible for rendering a group of cells given their indices.
	   * Should implement the following interface: ({
	   *   cellSizeAndPositionGetter:Function,
	   *   indices: Array<number>,
	   *   cellRenderer: Function
	   * }): Array<PropTypes.node>
	   */
	  cellGroupRenderer: _propTypes2.default.func.isRequired,
	
	  /**
	   * Responsible for rendering a cell given an row and column index.
	   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element
	   */
	  cellRenderer: _propTypes2.default.func.isRequired,
	
	  /**
	   * Callback responsible for returning size and offset/position information for a given cell (index).
	   * ({ index: number }): { height: number, width: number, x: number, y: number }
	   */
	  cellSizeAndPositionGetter: _propTypes2.default.func.isRequired,
	
	  /**
	   * Optionally override the size of the sections a Collection's cells are split into.
	   */
	  sectionSize: _propTypes2.default.number
	} : {};
	
	
	function defaultCellGroupRenderer(_ref4) {
	  var cellCache = _ref4.cellCache,
	      cellRenderer = _ref4.cellRenderer,
	      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,
	      indices = _ref4.indices,
	      isScrolling = _ref4.isScrolling;
	
	  return indices.map(function (index) {
	    var cellMetadata = cellSizeAndPositionGetter({ index: index });
	
	    var cellRendererProps = {
	      index: index,
	      isScrolling: isScrolling,
	      key: index,
	      style: {
	        height: cellMetadata.height,
	        left: cellMetadata.x,
	        position: 'absolute',
	        top: cellMetadata.y,
	        width: cellMetadata.width
	      }
	    };
	
	    // Avoid re-creating cells while scrolling.
	    // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
	    // If a scroll is in progress- cache and reuse cells.
	    // This cache will be thrown away once scrolling complets.
	    if (isScrolling) {
	      if (!(index in cellCache)) {
	        cellCache[index] = cellRenderer(cellRendererProps);
	      }
	
	      return cellCache[index];
	    } else {
	      return cellRenderer(cellRendererProps);
	    }
	  }).filter(function (renderedCell) {
	    return !!renderedCell;
	  });
	}

/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _createCallbackMemoizer = __webpack_require__(199);
	
	var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);
	
	var _scrollbarSize = __webpack_require__(239);
	
	var _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// @TODO Merge Collection and CollectionView
	
	/**
	 * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
	 * This improves performance and makes scrolling smoother.
	 */
	var IS_SCROLLING_TIMEOUT = 150;
	
	/**
	 * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
	 * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
	 */
	var SCROLL_POSITION_CHANGE_REASONS = {
	  OBSERVED: 'observed',
	  REQUESTED: 'requested'
	};
	
	/**
	 * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.
	 * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.
	 */
	
	var CollectionView = function (_PureComponent) {
	  _inherits(CollectionView, _PureComponent);
	
	  function CollectionView(props, context) {
	    _classCallCheck(this, CollectionView);
	
	    var _this = _possibleConstructorReturn(this, (CollectionView.__proto__ || Object.getPrototypeOf(CollectionView)).call(this, props, context));
	
	    _this.state = {
	      isScrolling: false,
	      scrollLeft: 0,
	      scrollTop: 0
	    };
	
	    _this._calculateSizeAndPositionDataOnNextUpdate = false;
	
	    // Invokes callbacks only when their values have changed.
	    _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();
	    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);
	
	    // Bind functions to instance so they don't lose context when passed around.
	    _this._invokeOnSectionRenderedHelper = _this._invokeOnSectionRenderedHelper.bind(_this);
	    _this._onScroll = _this._onScroll.bind(_this);
	    _this._setScrollingContainerRef = _this._setScrollingContainerRef.bind(_this);
	    _this._updateScrollPositionForScrollToCell = _this._updateScrollPositionForScrollToCell.bind(_this);
	    return _this;
	  }
	
	  /**
	   * Forced recompute of cell sizes and positions.
	   * This function should be called if cell sizes have changed but nothing else has.
	   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.
	   */
	
	
	  _createClass(CollectionView, [{
	    key: 'recomputeCellSizesAndPositions',
	    value: function recomputeCellSizesAndPositions() {
	      this._calculateSizeAndPositionDataOnNextUpdate = true;
	      this.forceUpdate();
	    }
	
	    /* ---------------------------- Component lifecycle methods ---------------------------- */
	
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          cellLayoutManager = _props.cellLayoutManager,
	          scrollLeft = _props.scrollLeft,
	          scrollToCell = _props.scrollToCell,
	          scrollTop = _props.scrollTop;
	
	      // If this component was first rendered server-side, scrollbar size will be undefined.
	      // In that event we need to remeasure.
	
	      if (!this._scrollbarSizeMeasured) {
	        this._scrollbarSize = (0, _scrollbarSize2.default)();
	        this._scrollbarSizeMeasured = true;
	        this.setState({});
	      }
	
	      if (scrollToCell >= 0) {
	        this._updateScrollPositionForScrollToCell();
	      } else if (scrollLeft >= 0 || scrollTop >= 0) {
	        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });
	      }
	
	      // Update onSectionRendered callback.
	      this._invokeOnSectionRenderedHelper();
	
	      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),
	          totalHeight = _cellLayoutManager$ge.height,
	          totalWidth = _cellLayoutManager$ge.width;
	
	      // Initialize onScroll callback.
	
	
	      this._invokeOnScrollMemoizer({
	        scrollLeft: scrollLeft || 0,
	        scrollTop: scrollTop || 0,
	        totalHeight: totalHeight,
	        totalWidth: totalWidth
	      });
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      var _props2 = this.props,
	          height = _props2.height,
	          scrollToAlignment = _props2.scrollToAlignment,
	          scrollToCell = _props2.scrollToCell,
	          width = _props2.width;
	      var _state = this.state,
	          scrollLeft = _state.scrollLeft,
	          scrollPositionChangeReason = _state.scrollPositionChangeReason,
	          scrollTop = _state.scrollTop;
	
	      // Make sure requested changes to :scrollLeft or :scrollTop get applied.
	      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
	      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
	      // So we only set these when we require an adjustment of the scroll position.
	      // See issue #2 for more information.
	
	      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
	        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {
	          this._scrollingContainer.scrollLeft = scrollLeft;
	        }
	        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {
	          this._scrollingContainer.scrollTop = scrollTop;
	        }
	      }
	
	      // Update scroll offsets if the current :scrollToCell values requires it
	      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {
	        this._updateScrollPositionForScrollToCell();
	      }
	
	      // Update onRowsRendered callback if start/stop indices have changed
	      this._invokeOnSectionRenderedHelper();
	    }
	  }, {
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      var cellLayoutManager = this.props.cellLayoutManager;
	
	
	      cellLayoutManager.calculateSizeAndPositionData();
	
	      // If this component is being rendered server-side, getScrollbarSize() will return undefined.
	      // We handle this case in componentDidMount()
	      this._scrollbarSize = (0, _scrollbarSize2.default)();
	      if (this._scrollbarSize === undefined) {
	        this._scrollbarSizeMeasured = false;
	        this._scrollbarSize = 0;
	      } else {
	        this._scrollbarSizeMeasured = true;
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      if (this._disablePointerEventsTimeoutId) {
	        clearTimeout(this._disablePointerEventsTimeoutId);
	      }
	    }
	
	    /**
	     * @private
	     * This method updates scrollLeft/scrollTop in state for the following conditions:
	     * 1) Empty content (0 rows or columns)
	     * 2) New scroll props overriding the current state
	     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
	     */
	
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var _state2 = this.state,
	          scrollLeft = _state2.scrollLeft,
	          scrollTop = _state2.scrollTop;
	
	
	      if (nextProps.cellCount === 0 && (scrollLeft !== 0 || scrollTop !== 0)) {
	        this._setScrollPosition({
	          scrollLeft: 0,
	          scrollTop: 0
	        });
	      } else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
	        this._setScrollPosition({
	          scrollLeft: nextProps.scrollLeft,
	          scrollTop: nextProps.scrollTop
	        });
	      }
	
	      if (nextProps.cellCount !== this.props.cellCount || nextProps.cellLayoutManager !== this.props.cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {
	        nextProps.cellLayoutManager.calculateSizeAndPositionData();
	      }
	
	      if (this._calculateSizeAndPositionDataOnNextUpdate) {
	        this._calculateSizeAndPositionDataOnNextUpdate = false;
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props3 = this.props,
	          autoHeight = _props3.autoHeight,
	          cellCount = _props3.cellCount,
	          cellLayoutManager = _props3.cellLayoutManager,
	          className = _props3.className,
	          height = _props3.height,
	          horizontalOverscanSize = _props3.horizontalOverscanSize,
	          id = _props3.id,
	          noContentRenderer = _props3.noContentRenderer,
	          style = _props3.style,
	          verticalOverscanSize = _props3.verticalOverscanSize,
	          width = _props3.width;
	      var _state3 = this.state,
	          isScrolling = _state3.isScrolling,
	          scrollLeft = _state3.scrollLeft,
	          scrollTop = _state3.scrollTop;
	
	      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),
	          totalHeight = _cellLayoutManager$ge2.height,
	          totalWidth = _cellLayoutManager$ge2.width;
	
	      // Safely expand the rendered area by the specified overscan amount
	
	
	      var left = Math.max(0, scrollLeft - horizontalOverscanSize);
	      var top = Math.max(0, scrollTop - verticalOverscanSize);
	      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);
	      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);
	
	      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({
	        height: bottom - top,
	        isScrolling: isScrolling,
	        width: right - left,
	        x: left,
	        y: top
	      }) : [];
	
	      var collectionStyle = {
	        boxSizing: 'border-box',
	        direction: 'ltr',
	        height: autoHeight ? 'auto' : height,
	        position: 'relative',
	        WebkitOverflowScrolling: 'touch',
	        width: width,
	        willChange: 'transform'
	      };
	
	      // Force browser to hide scrollbars when we know they aren't necessary.
	      // Otherwise once scrollbars appear they may not disappear again.
	      // For more info see issue #116
	      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;
	      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;
	
	      // Also explicitly init styles to 'auto' if scrollbars are required.
	      // This works around an obscure edge case where external CSS styles have not yet been loaded,
	      // But an initial scroll index of offset is set as an external prop.
	      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
	      // This was originally reported via clauderic/react-infinite-calendar/issues/23
	      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
	      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';
	
	      return _react2.default.createElement(
	        'div',
	        {
	          ref: this._setScrollingContainerRef,
	          'aria-label': this.props['aria-label'],
	          className: (0, _classnames2.default)('ReactVirtualized__Collection', className),
	          id: id,
	          onScroll: this._onScroll,
	          role: 'grid',
	          style: _extends({}, collectionStyle, style),
	          tabIndex: 0 },
	        cellCount > 0 && _react2.default.createElement(
	          'div',
	          {
	            className: 'ReactVirtualized__Collection__innerScrollContainer',
	            style: {
	              height: totalHeight,
	              maxHeight: totalHeight,
	              maxWidth: totalWidth,
	              overflow: 'hidden',
	              pointerEvents: isScrolling ? 'none' : '',
	              width: totalWidth
	            } },
	          childrenToDisplay
	        ),
	        cellCount === 0 && noContentRenderer()
	      );
	    }
	
	    /* ---------------------------- Helper methods ---------------------------- */
	
	    /**
	     * Sets an :isScrolling flag for a small window of time.
	     * This flag is used to disable pointer events on the scrollable portion of the Collection.
	     * This prevents jerky/stuttery mouse-wheel scrolling.
	     */
	
	  }, {
	    key: '_enablePointerEventsAfterDelay',
	    value: function _enablePointerEventsAfterDelay() {
	      var _this2 = this;
	
	      if (this._disablePointerEventsTimeoutId) {
	        clearTimeout(this._disablePointerEventsTimeoutId);
	      }
	
	      this._disablePointerEventsTimeoutId = setTimeout(function () {
	        var isScrollingChange = _this2.props.isScrollingChange;
	
	
	        isScrollingChange(false);
	
	        _this2._disablePointerEventsTimeoutId = null;
	        _this2.setState({
	          isScrolling: false
	        });
	      }, IS_SCROLLING_TIMEOUT);
	    }
	  }, {
	    key: '_invokeOnSectionRenderedHelper',
	    value: function _invokeOnSectionRenderedHelper() {
	      var _props4 = this.props,
	          cellLayoutManager = _props4.cellLayoutManager,
	          onSectionRendered = _props4.onSectionRendered;
	
	
	      this._onSectionRenderedMemoizer({
	        callback: onSectionRendered,
	        indices: {
	          indices: cellLayoutManager.getLastRenderedIndices()
	        }
	      });
	    }
	  }, {
	    key: '_invokeOnScrollMemoizer',
	    value: function _invokeOnScrollMemoizer(_ref) {
	      var _this3 = this;
	
	      var scrollLeft = _ref.scrollLeft,
	          scrollTop = _ref.scrollTop,
	          totalHeight = _ref.totalHeight,
	          totalWidth = _ref.totalWidth;
	
	      this._onScrollMemoizer({
	        callback: function callback(_ref2) {
	          var scrollLeft = _ref2.scrollLeft,
	              scrollTop = _ref2.scrollTop;
	          var _props5 = _this3.props,
	              height = _props5.height,
	              onScroll = _props5.onScroll,
	              width = _props5.width;
	
	
	          onScroll({
	            clientHeight: height,
	            clientWidth: width,
	            scrollHeight: totalHeight,
	            scrollLeft: scrollLeft,
	            scrollTop: scrollTop,
	            scrollWidth: totalWidth
	          });
	        },
	        indices: {
	          scrollLeft: scrollLeft,
	          scrollTop: scrollTop
	        }
	      });
	    }
	  }, {
	    key: '_setScrollingContainerRef',
	    value: function _setScrollingContainerRef(ref) {
	      this._scrollingContainer = ref;
	    }
	  }, {
	    key: '_setScrollPosition',
	    value: function _setScrollPosition(_ref3) {
	      var scrollLeft = _ref3.scrollLeft,
	          scrollTop = _ref3.scrollTop;
	
	      var newState = {
	        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
	      };
	
	      if (scrollLeft >= 0) {
	        newState.scrollLeft = scrollLeft;
	      }
	
	      if (scrollTop >= 0) {
	        newState.scrollTop = scrollTop;
	      }
	
	      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
	        this.setState(newState);
	      }
	    }
	  }, {
	    key: '_updateScrollPositionForScrollToCell',
	    value: function _updateScrollPositionForScrollToCell() {
	      var _props6 = this.props,
	          cellLayoutManager = _props6.cellLayoutManager,
	          height = _props6.height,
	          scrollToAlignment = _props6.scrollToAlignment,
	          scrollToCell = _props6.scrollToCell,
	          width = _props6.width;
	      var _state4 = this.state,
	          scrollLeft = _state4.scrollLeft,
	          scrollTop = _state4.scrollTop;
	
	
	      if (scrollToCell >= 0) {
	        var scrollPosition = cellLayoutManager.getScrollPositionForCell({
	          align: scrollToAlignment,
	          cellIndex: scrollToCell,
	          height: height,
	          scrollLeft: scrollLeft,
	          scrollTop: scrollTop,
	          width: width
	        });
	
	        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {
	          this._setScrollPosition(scrollPosition);
	        }
	      }
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(event) {
	      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
	      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
	      // See issue #404 for more information.
	      if (event.target !== this._scrollingContainer) {
	        return;
	      }
	
	      // Prevent pointer events from interrupting a smooth scroll
	      this._enablePointerEventsAfterDelay();
	
	      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
	      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
	      // This causes a series of rapid renders that is slow for long lists.
	      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.
	      var _props7 = this.props,
	          cellLayoutManager = _props7.cellLayoutManager,
	          height = _props7.height,
	          isScrollingChange = _props7.isScrollingChange,
	          width = _props7.width;
	
	      var scrollbarSize = this._scrollbarSize;
	
	      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),
	          totalHeight = _cellLayoutManager$ge3.height,
	          totalWidth = _cellLayoutManager$ge3.width;
	
	      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));
	      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));
	
	      // Certain devices (like Apple touchpad) rapid-fire duplicate events.
	      // Don't force a re-render if this is the case.
	      // The mouse may move faster then the animation frame does.
	      // Use requestAnimationFrame to avoid over-updating.
	      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
	        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.
	        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).
	        // All things considered, this seems to be the best current work around that I'm aware of.
	        // For more information see https://github.com/bvaughn/react-virtualized/pull/124
	        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;
	
	        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)
	        if (!this.state.isScrolling) {
	          isScrollingChange(true);
	        }
	
	        this.setState({
	          isScrolling: true,
	          scrollLeft: scrollLeft,
	          scrollPositionChangeReason: scrollPositionChangeReason,
	          scrollTop: scrollTop
	        });
	      }
	
	      this._invokeOnScrollMemoizer({
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop,
	        totalWidth: totalWidth,
	        totalHeight: totalHeight
	      });
	    }
	  }]);
	
	  return CollectionView;
	}(_react.PureComponent);
	
	CollectionView.defaultProps = {
	  'aria-label': 'grid',
	  horizontalOverscanSize: 0,
	  noContentRenderer: function noContentRenderer() {
	    return null;
	  },
	  onScroll: function onScroll() {
	    return null;
	  },
	  onSectionRendered: function onSectionRendered() {
	    return null;
	  },
	  scrollToAlignment: 'auto',
	  scrollToCell: -1,
	  style: {},
	  verticalOverscanSize: 0
	};
	exports.default = CollectionView;
	CollectionView.propTypes =  false ? {
	  'aria-label': _propTypes2.default.string,
	
	  /**
	   * Removes fixed height from the scrollingContainer so that the total height
	   * of rows can stretch the window. Intended for use with WindowScroller
	   */
	  autoHeight: _propTypes2.default.bool,
	
	  /**
	   * Number of cells in collection.
	   */
	  cellCount: _propTypes2.default.number.isRequired,
	
	  /**
	   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.
	   */
	  cellLayoutManager: _propTypes2.default.object.isRequired,
	
	  /**
	   * Optional custom CSS class name to attach to root Collection element.
	   */
	  className: _propTypes2.default.string,
	
	  /**
	   * Height of Collection; this property determines the number of visible (vs virtualized) rows.
	   */
	  height: _propTypes2.default.number.isRequired,
	
	  /**
	   * Optional custom id to attach to root Collection element.
	   */
	  id: _propTypes2.default.string,
	
	  /**
	   * Enables the `Collection` to horiontally "overscan" its content similar to how `Grid` does.
	   * This can reduce flicker around the edges when a user scrolls quickly.
	   */
	  horizontalOverscanSize: _propTypes2.default.number.isRequired,
	
	  isScrollingChange: _propTypes2.default.func,
	
	  /**
	   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.
	   */
	  noContentRenderer: _propTypes2.default.func.isRequired,
	
	  /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void
	   */
	  onScroll: _propTypes2.default.func.isRequired,
	
	  /**
	   * Callback invoked with information about the section of the Collection that was just rendered.
	   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.
	   */
	  onSectionRendered: _propTypes2.default.func.isRequired,
	
	  /**
	   * Horizontal offset.
	   */
	  scrollLeft: _propTypes2.default.number,
	
	  /**
	   * Controls scroll-to-cell behavior of the Grid.
	   * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
	   * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
	   */
	  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,
	
	  /**
	   * Cell index to ensure visible (by forcefully scrolling if necessary).
	   */
	  scrollToCell: _propTypes2.default.number.isRequired,
	
	  /**
	   * Vertical offset.
	   */
	  scrollTop: _propTypes2.default.number,
	
	  /**
	   * Optional custom inline style to attach to root Collection element.
	   */
	  style: _propTypes2.default.object,
	
	  /**
	   * Enables the `Collection` to vertically "overscan" its content similar to how `Grid` does.
	   * This can reduce flicker around the edges when a user scrolls quickly.
	   */
	  verticalOverscanSize: _propTypes2.default.number.isRequired,
	
	  /**
	   * Width of Collection; this property determines the number of visible (vs virtualized) columns.
	   */
	  width: _propTypes2.default.number.isRequired
	} : {};

/***/ }),
/* 814 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A section of the Window.
	 * Window Sections are used to group nearby cells.
	 * This enables us to more quickly determine which cells to display in a given region of the Window.
	 * Sections have a fixed size and contain 0 to many cells (tracked by their indices).
	 */
	var babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo || __webpack_require__(1).any; /** @rlow */
	
	
	var babelPluginFlowReactPropTypes_proptype_Index = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_Index || __webpack_require__(1).any;
	
	var Section = function () {
	  function Section(_ref) {
	    var height = _ref.height,
	        width = _ref.width,
	        x = _ref.x,
	        y = _ref.y;
	
	    _classCallCheck(this, Section);
	
	    this.height = height;
	    this.width = width;
	    this.x = x;
	    this.y = y;
	
	    this._indexMap = {};
	    this._indices = [];
	  }
	
	  /** Add a cell to this section. */
	
	
	  _createClass(Section, [{
	    key: 'addCellIndex',
	    value: function addCellIndex(_ref2) {
	      var index = _ref2.index;
	
	      if (!this._indexMap[index]) {
	        this._indexMap[index] = true;
	        this._indices.push(index);
	      }
	    }
	
	    /** Get all cell indices that have been added to this section. */
	
	  }, {
	    key: 'getCellIndices',
	    value: function getCellIndices() {
	      return this._indices;
	    }
	
	    /** Intended for debugger/test purposes only */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.x + ',' + this.y + ' ' + this.width + 'x' + this.height;
	    }
	  }]);
	
	  return Section;
	}();
	
	exports.default = Section;

/***/ }),
/* 815 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Window Sections are used to group nearby cells.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This enables us to more quickly determine which cells to display in a given region of the Window.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	
	var _Section = __webpack_require__(814);
	
	var _Section2 = _interopRequireDefault(_Section);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Index = __webpack_require__(65).babelPluginFlowReactPropTypes_proptype_Index || __webpack_require__(1).any;
	
	var SECTION_SIZE = 100;
	
	/**
	 * Contains 0 to many Sections.
	 * Grows (and adds Sections) dynamically as cells are registered.
	 * Automatically adds cells to the appropriate Section(s).
	 */
	var SectionManager = function () {
	  function SectionManager() {
	    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;
	
	    _classCallCheck(this, SectionManager);
	
	    this._sectionSize = sectionSize;
	
	    this._cellMetadata = [];
	    this._sections = {};
	  }
	
	  /**
	   * Gets all cell indices contained in the specified region.
	   * A region may encompass 1 or more Sections.
	   */
	
	
	  _createClass(SectionManager, [{
	    key: 'getCellIndices',
	    value: function getCellIndices(_ref) {
	      var height = _ref.height,
	          width = _ref.width,
	          x = _ref.x,
	          y = _ref.y;
	
	      var indices = {};
	
	      this.getSections({ height: height, width: width, x: x, y: y }).forEach(function (section) {
	        return section.getCellIndices().forEach(function (index) {
	          indices[index] = index;
	        });
	      });
	
	      // Object keys are strings; this function returns numbers
	      return Object.keys(indices).map(function (index) {
	        return indices[index];
	      });
	    }
	
	    /** Get size and position information for the cell specified. */
	
	  }, {
	    key: 'getCellMetadata',
	    value: function getCellMetadata(_ref2) {
	      var index = _ref2.index;
	
	      return this._cellMetadata[index];
	    }
	
	    /** Get all Sections overlapping the specified region. */
	
	  }, {
	    key: 'getSections',
	    value: function getSections(_ref3) {
	      var height = _ref3.height,
	          width = _ref3.width,
	          x = _ref3.x,
	          y = _ref3.y;
	
	      var sectionXStart = Math.floor(x / this._sectionSize);
	      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);
	      var sectionYStart = Math.floor(y / this._sectionSize);
	      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);
	
	      var sections = [];
	
	      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {
	        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {
	          var key = sectionX + '.' + sectionY;
	
	          if (!this._sections[key]) {
	            this._sections[key] = new _Section2.default({
	              height: this._sectionSize,
	              width: this._sectionSize,
	              x: sectionX * this._sectionSize,
	              y: sectionY * this._sectionSize
	            });
	          }
	
	          sections.push(this._sections[key]);
	        }
	      }
	
	      return sections;
	    }
	
	    /** Total number of Sections based on the currently registered cells. */
	
	  }, {
	    key: 'getTotalSectionCount',
	    value: function getTotalSectionCount() {
	      return Object.keys(this._sections).length;
	    }
	
	    /** Intended for debugger/test purposes only */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var _this = this;
	
	      return Object.keys(this._sections).map(function (index) {
	        return _this._sections[index].toString();
	      });
	    }
	
	    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */
	
	  }, {
	    key: 'registerCell',
	    value: function registerCell(_ref4) {
	      var cellMetadatum = _ref4.cellMetadatum,
	          index = _ref4.index;
	
	      this._cellMetadata[index] = cellMetadatum;
	
	      this.getSections(cellMetadatum).forEach(function (section) {
	        return section.addCellIndex({ index: index });
	      });
	    }
	  }]);
	
	  return SectionManager;
	}();
	
	exports.default = SectionManager;

/***/ }),
/* 816 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Collection = undefined;
	
	var _Collection = __webpack_require__(812);
	
	var _Collection2 = _interopRequireDefault(_Collection);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _Collection2.default;
	exports.Collection = _Collection2.default;

/***/ }),
/* 817 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = calculateSizeAndPositionData;
	
	var _SectionManager = __webpack_require__(815);
	
	var _SectionManager2 = _interopRequireDefault(_SectionManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function calculateSizeAndPositionData(_ref) {
	  var cellCount = _ref.cellCount,
	      cellSizeAndPositionGetter = _ref.cellSizeAndPositionGetter,
	      sectionSize = _ref.sectionSize;
	
	  var cellMetadata = [];
	  var sectionManager = new _SectionManager2.default(sectionSize);
	  var height = 0;
	  var width = 0;
	
	  for (var index = 0; index < cellCount; index++) {
	    var cellMetadatum = cellSizeAndPositionGetter({ index: index });
	
	    if (cellMetadatum.height == null || isNaN(cellMetadatum.height) || cellMetadatum.width == null || isNaN(cellMetadatum.width) || cellMetadatum.x == null || isNaN(cellMetadatum.x) || cellMetadatum.y == null || isNaN(cellMetadatum.y)) {
	      throw Error('Invalid metadata returned for cell ' + index + ':\n        x:' + cellMetadatum.x + ', y:' + cellMetadatum.y + ', width:' + cellMetadatum.width + ', height:' + cellMetadatum.height);
	    }
	
	    height = Math.max(height, cellMetadatum.y + cellMetadatum.height);
	    width = Math.max(width, cellMetadatum.x + cellMetadatum.width);
	
	    cellMetadata[index] = cellMetadatum;
	    sectionManager.registerCell({
	      cellMetadatum: cellMetadatum,
	      index: index
	    });
	  }
	
	  return {
	    cellMetadata: cellMetadata,
	    height: height,
	    sectionManager: sectionManager,
	    width: width
	  };
	}

/***/ }),
/* 818 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * High-order component that auto-calculates column-widths for `Grid` cells.
	 */
	var ColumnSizer = function (_PureComponent) {
	  _inherits(ColumnSizer, _PureComponent);
	
	  function ColumnSizer(props, context) {
	    _classCallCheck(this, ColumnSizer);
	
	    var _this = _possibleConstructorReturn(this, (ColumnSizer.__proto__ || Object.getPrototypeOf(ColumnSizer)).call(this, props, context));
	
	    _this._registerChild = _this._registerChild.bind(_this);
	    return _this;
	  }
	
	  _createClass(ColumnSizer, [{
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps) {
	      var _props = this.props,
	          columnMaxWidth = _props.columnMaxWidth,
	          columnMinWidth = _props.columnMinWidth,
	          columnCount = _props.columnCount,
	          width = _props.width;
	
	
	      if (columnMaxWidth !== prevProps.columnMaxWidth || columnMinWidth !== prevProps.columnMinWidth || columnCount !== prevProps.columnCount || width !== prevProps.width) {
	        if (this._registeredChild) {
	          this._registeredChild.recomputeGridSize();
	        }
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props2 = this.props,
	          children = _props2.children,
	          columnMaxWidth = _props2.columnMaxWidth,
	          columnMinWidth = _props2.columnMinWidth,
	          columnCount = _props2.columnCount,
	          width = _props2.width;
	
	
	      var safeColumnMinWidth = columnMinWidth || 1;
	
	      var safeColumnMaxWidth = columnMaxWidth ? Math.min(columnMaxWidth, width) : width;
	
	      var columnWidth = width / columnCount;
	      columnWidth = Math.max(safeColumnMinWidth, columnWidth);
	      columnWidth = Math.min(safeColumnMaxWidth, columnWidth);
	      columnWidth = Math.floor(columnWidth);
	
	      var adjustedWidth = Math.min(width, columnWidth * columnCount);
	
	      return children({
	        adjustedWidth: adjustedWidth,
	        columnWidth: columnWidth,
	        getColumnWidth: function getColumnWidth() {
	          return columnWidth;
	        },
	        registerChild: this._registerChild
	      });
	    }
	  }, {
	    key: '_registerChild',
	    value: function _registerChild(child) {
	      if (child && typeof child.recomputeGridSize !== 'function') {
	        throw Error('Unexpected child type registered; only Grid/MultiGrid children are supported.');
	      }
	
	      this._registeredChild = child;
	
	      if (this._registeredChild) {
	        this._registeredChild.recomputeGridSize();
	      }
	    }
	  }]);
	
	  return ColumnSizer;
	}(_react.PureComponent);
	
	exports.default = ColumnSizer;
	ColumnSizer.propTypes =  false ? {
	  /**
	   * Function responsible for rendering a virtualized Grid.
	   * This function should implement the following signature:
	   * ({ adjustedWidth, getColumnWidth, registerChild }) => PropTypes.element
	   *
	   * The specified :getColumnWidth function should be passed to the Grid's :columnWidth property.
	   * The :registerChild should be passed to the Grid's :ref property.
	   * The :adjustedWidth property is optional; it reflects the lesser of the overall width or the width of all columns.
	   */
	  children: _propTypes2.default.func.isRequired,
	
	  /** Optional maximum allowed column width */
	  columnMaxWidth: _propTypes2.default.number,
	
	  /** Optional minimum allowed column width */
	  columnMinWidth: _propTypes2.default.number,
	
	  /** Number of columns in Grid or Table child */
	  columnCount: _propTypes2.default.number.isRequired,
	
	  /** Width of Grid or Table child */
	  width: _propTypes2.default.number.isRequired
	} : {};

/***/ }),
/* 819 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ColumnSizer = undefined;
	
	var _ColumnSizer = __webpack_require__(818);
	
	var _ColumnSizer2 = _interopRequireDefault(_ColumnSizer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _ColumnSizer2.default;
	exports.ColumnSizer = _ColumnSizer2.default;

/***/ }),
/* 820 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _calculateSizeAndPositionDataAndUpdateScrollOffset = __webpack_require__(823);
	
	var _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);
	
	var _ScalingCellSizeAndPositionManager = __webpack_require__(196);
	
	var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);
	
	var _createCallbackMemoizer = __webpack_require__(199);
	
	var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);
	
	var _defaultOverscanIndicesGetter = __webpack_require__(337);
	
	var _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);
	
	var _updateScrollIndexHelper = __webpack_require__(824);
	
	var _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);
	
	var _defaultCellRangeRenderer = __webpack_require__(336);
	
	var _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);
	
	var _scrollbarSize = __webpack_require__(239);
	
	var _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);
	
	var _requestAnimationTimeout = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_RenderedSection = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_RenderedSection || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Scroll = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_NoContentRenderer = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_NoContentRenderer || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellSize = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellSize || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellPosition = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellPosition || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellRangeRenderer = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellRangeRenderer || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellRenderer = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellRenderer || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId = __webpack_require__(87).babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId || __webpack_require__(1).any;
	
	/**
	 * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
	 * This improves performance and makes scrolling smoother.
	 */
	var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
	
	/**
	 * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
	 * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
	 */
	var SCROLL_POSITION_CHANGE_REASONS = {
	  OBSERVED: 'observed',
	  REQUESTED: 'requested'
	};
	
	var renderNull = function renderNull() {
	  return null;
	};
	
	/**
	 * Renders tabular data with virtualization along the vertical and horizontal axes.
	 * Row heights and column widths must be known ahead of time and specified as properties.
	 */
	var Grid = function (_React$PureComponent) {
	  _inherits(Grid, _React$PureComponent);
	
	  // Invokes onSectionRendered callback only when start/stop row or column indices change
	  function Grid(props) {
	    _classCallCheck(this, Grid);
	
	    var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, props));
	
	    _this.state = {
	      isScrolling: false,
	      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
	      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
	      scrollLeft: 0,
	      scrollTop: 0
	    };
	    _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();
	    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);
	    _this._deferredInvalidateColumnIndex = null;
	    _this._deferredInvalidateRowIndex = null;
	    _this._recomputeScrollLeftFlag = false;
	    _this._recomputeScrollTopFlag = false;
	    _this._horizontalScrollBarSize = 0;
	    _this._verticalScrollBarSize = 0;
	    _this._scrollbarPresenceChanged = false;
	    _this._cellCache = {};
	    _this._styleCache = {};
	    _this._scrollbarSizeMeasured = false;
	    _this._renderedColumnStartIndex = 0;
	    _this._renderedColumnStopIndex = 0;
	    _this._renderedRowStartIndex = 0;
	    _this._renderedRowStopIndex = 0;
	
	    _this._debounceScrollEndedCallback = function () {
	      _this._disablePointerEventsTimeoutId = null;
	      _this._resetStyleCache();
	    };
	
	    _this._invokeOnGridRenderedHelper = function () {
	      var onSectionRendered = _this.props.onSectionRendered;
	
	
	      _this._onGridRenderedMemoizer({
	        callback: onSectionRendered,
	        indices: {
	          columnOverscanStartIndex: _this._columnStartIndex,
	          columnOverscanStopIndex: _this._columnStopIndex,
	          columnStartIndex: _this._renderedColumnStartIndex,
	          columnStopIndex: _this._renderedColumnStopIndex,
	          rowOverscanStartIndex: _this._rowStartIndex,
	          rowOverscanStopIndex: _this._rowStopIndex,
	          rowStartIndex: _this._renderedRowStartIndex,
	          rowStopIndex: _this._renderedRowStopIndex
	        }
	      });
	    };
	
	    _this._setScrollingContainerRef = function (ref) {
	      _this._scrollingContainer = ref;
	    };
	
	    _this._onScroll = function (event) {
	      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
	      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
	      // See issue #404 for more information.
	      if (event.target === _this._scrollingContainer) {
	        _this.handleScrollEvent(event.target);
	      }
	    };
	
	    _this._columnWidthGetter = _this._wrapSizeGetter(props.columnWidth);
	    _this._rowHeightGetter = _this._wrapSizeGetter(props.rowHeight);
	
	    var deferredMeasurementCache = props.deferredMeasurementCache;
	
	    _this._columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
	      batchAllCells: deferredMeasurementCache !== undefined && !deferredMeasurementCache.hasFixedHeight(),
	      cellCount: props.columnCount,
	      cellSizeGetter: function cellSizeGetter(params) {
	        return _this._columnWidthGetter(params);
	      },
	      estimatedCellSize: _this._getEstimatedColumnSize(props)
	    });
	    _this._rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
	      batchAllCells: deferredMeasurementCache !== undefined && !deferredMeasurementCache.hasFixedWidth(),
	      cellCount: props.rowCount,
	      cellSizeGetter: function cellSizeGetter(params) {
	        return _this._rowHeightGetter(params);
	      },
	      estimatedCellSize: _this._getEstimatedRowSize(props)
	    });
	    return _this;
	  }
	
	  /**
	   * Gets offsets for a given cell and alignment.
	   */
	
	
	  // See defaultCellRangeRenderer() for more information on the usage of these caches
	
	
	  _createClass(Grid, [{
	    key: 'getOffsetForCell',
	    value: function getOffsetForCell() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$alignment = _ref.alignment,
	          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,
	          _ref$columnIndex = _ref.columnIndex,
	          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,
	          _ref$rowIndex = _ref.rowIndex,
	          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;
	
	      var offsetProps = _extends({}, this.props, {
	        scrollToAlignment: alignment,
	        scrollToColumn: columnIndex,
	        scrollToRow: rowIndex
	      });
	
	      return {
	        scrollLeft: this._getCalculatedScrollLeft(offsetProps),
	        scrollTop: this._getCalculatedScrollTop(offsetProps)
	      };
	    }
	
	    /**
	     * This method handles a scroll event originating from an external scroll control.
	     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.
	     */
	
	  }, {
	    key: 'handleScrollEvent',
	    value: function handleScrollEvent(_ref2) {
	      var _ref2$scrollLeft = _ref2.scrollLeft,
	          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,
	          _ref2$scrollTop = _ref2.scrollTop,
	          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;
	
	      // On iOS, we can arrive at negative offsets by swiping past the start.
	      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.
	      if (scrollTopParam < 0) {
	        return;
	      }
	
	      // Prevent pointer events from interrupting a smooth scroll
	      this._debounceScrollEnded();
	
	      var _props = this.props,
	          autoHeight = _props.autoHeight,
	          autoWidth = _props.autoWidth,
	          height = _props.height,
	          width = _props.width;
	
	      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
	      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
	      // This causes a series of rapid renders that is slow for long lists.
	      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.
	
	      var scrollbarSize = this._scrollbarSize;
	      var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
	      var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
	      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);
	      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);
	
	      // Certain devices (like Apple touchpad) rapid-fire duplicate events.
	      // Don't force a re-render if this is the case.
	      // The mouse may move faster then the animation frame does.
	      // Use requestAnimationFrame to avoid over-updating.
	      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
	        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
	        // Don't change direction for an axis unless scroll offset has changed.
	        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;
	        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;
	
	        var newState = {
	          isScrolling: true,
	          scrollDirectionHorizontal: _scrollDirectionHorizontal,
	          scrollDirectionVertical: _scrollDirectionVertical,
	          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
	        };
	
	        if (!autoHeight) {
	          newState.scrollTop = scrollTop;
	        }
	
	        if (!autoWidth) {
	          newState.scrollLeft = scrollLeft;
	        }
	
	        this.setState(newState);
	      }
	
	      this._invokeOnScrollMemoizer({
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop,
	        totalColumnsWidth: totalColumnsWidth,
	        totalRowsHeight: totalRowsHeight
	      });
	    }
	
	    /**
	     * Invalidate Grid size and recompute visible cells.
	     * This is a deferred wrapper for recomputeGridSize().
	     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.
	     * This method is intended for advanced use-cases like CellMeasurer.
	     */
	    // @TODO (bvaughn) Add automated test coverage for this.
	
	  }, {
	    key: 'invalidateCellSizeAfterRender',
	    value: function invalidateCellSizeAfterRender(_ref3) {
	      var columnIndex = _ref3.columnIndex,
	          rowIndex = _ref3.rowIndex;
	
	      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
	      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
	    }
	
	    /**
	     * Pre-measure all columns and rows in a Grid.
	     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.
	     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).
	     */
	
	  }, {
	    key: 'measureAllCells',
	    value: function measureAllCells() {
	      var _props2 = this.props,
	          columnCount = _props2.columnCount,
	          rowCount = _props2.rowCount;
	
	
	      this._columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);
	      this._rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
	    }
	
	    /**
	     * Forced recompute of row heights and column widths.
	     * This function should be called if dynamic column or row sizes have changed but nothing else has.
	     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.
	     */
	
	  }, {
	    key: 'recomputeGridSize',
	    value: function recomputeGridSize() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref4$columnIndex = _ref4.columnIndex,
	          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,
	          _ref4$rowIndex = _ref4.rowIndex,
	          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;
	
	      var _props3 = this.props,
	          scrollToColumn = _props3.scrollToColumn,
	          scrollToRow = _props3.scrollToRow;
	
	
	      this._columnSizeAndPositionManager.resetCell(columnIndex);
	      this._rowSizeAndPositionManager.resetCell(rowIndex);
	
	      // Cell sizes may be determined by a function property.
	      // In this case the cDU handler can't know if they changed.
	      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.
	      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && columnIndex <= scrollToColumn;
	      this._recomputeScrollTopFlag = scrollToRow >= 0 && rowIndex <= scrollToRow;
	
	      // Clear cell cache in case we are scrolling;
	      // Invalid row heights likely mean invalid cached content as well.
	      this._cellCache = {};
	      this._styleCache = {};
	
	      this.forceUpdate();
	    }
	
	    /**
	     * Ensure column and row are visible.
	     */
	
	  }, {
	    key: 'scrollToCell',
	    value: function scrollToCell(_ref5) {
	      var columnIndex = _ref5.columnIndex,
	          rowIndex = _ref5.rowIndex;
	      var columnCount = this.props.columnCount;
	
	
	      var props = this.props;
	
	      // Don't adjust scroll offset for single-column grids (eg List, Table).
	      // This can cause a funky scroll offset because of the vertical scrollbar width.
	      if (columnCount > 1 && columnIndex !== undefined) {
	        this._updateScrollLeftForScrollToColumn(_extends({}, props, {
	          scrollToColumn: columnIndex
	        }));
	      }
	
	      if (rowIndex !== undefined) {
	        this._updateScrollTopForScrollToRow(_extends({}, props, {
	          scrollToRow: rowIndex
	        }));
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props4 = this.props,
	          getScrollbarSize = _props4.getScrollbarSize,
	          height = _props4.height,
	          scrollLeft = _props4.scrollLeft,
	          scrollToColumn = _props4.scrollToColumn,
	          scrollTop = _props4.scrollTop,
	          scrollToRow = _props4.scrollToRow,
	          width = _props4.width;
	
	      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
	      // We must do this at the start of the method as we may calculate and update scroll position below.
	
	      this._handleInvalidatedGridSize();
	
	      // If this component was first rendered server-side, scrollbar size will be undefined.
	      // In that event we need to remeasure.
	      if (!this._scrollbarSizeMeasured) {
	        this._scrollbarSize = getScrollbarSize();
	        this._scrollbarSizeMeasured = true;
	        this.setState({});
	      }
	
	      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {
	        this.scrollToPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });
	      }
	
	      // Don't update scroll offset if the size is 0; we don't render any cells in this case.
	      // Setting a state may cause us to later thing we've updated the offce when we haven't.
	      var sizeIsBiggerThanZero = height > 0 && width > 0;
	      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {
	        this._updateScrollLeftForScrollToColumn();
	      }
	      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {
	        this._updateScrollTopForScrollToRow();
	      }
	
	      // Update onRowsRendered callback
	      this._invokeOnGridRenderedHelper();
	
	      // Initialize onScroll callback
	      this._invokeOnScrollMemoizer({
	        scrollLeft: scrollLeft || 0,
	        scrollTop: scrollTop || 0,
	        totalColumnsWidth: this._columnSizeAndPositionManager.getTotalSize(),
	        totalRowsHeight: this._rowSizeAndPositionManager.getTotalSize()
	      });
	
	      this._maybeCallOnScrollbarPresenceChange();
	    }
	
	    /**
	     * @private
	     * This method updates scrollLeft/scrollTop in state for the following conditions:
	     * 1) New scroll-to-cell props have been set
	     */
	
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      var _this2 = this;
	
	      var _props5 = this.props,
	          autoHeight = _props5.autoHeight,
	          autoWidth = _props5.autoWidth,
	          columnCount = _props5.columnCount,
	          height = _props5.height,
	          rowCount = _props5.rowCount,
	          scrollToAlignment = _props5.scrollToAlignment,
	          scrollToColumn = _props5.scrollToColumn,
	          scrollToRow = _props5.scrollToRow,
	          width = _props5.width;
	      var _state = this.state,
	          scrollLeft = _state.scrollLeft,
	          scrollPositionChangeReason = _state.scrollPositionChangeReason,
	          scrollTop = _state.scrollTop;
	
	      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
	      // We must do this at the start of the method as we may calculate and update scroll position below.
	
	      this._handleInvalidatedGridSize();
	
	      // Handle edge case where column or row count has only just increased over 0.
	      // In this case we may have to restore a previously-specified scroll offset.
	      // For more info see bvaughn/react-virtualized/issues/218
	      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;
	
	      // Make sure requested changes to :scrollLeft or :scrollTop get applied.
	      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
	      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
	      // So we only set these when we require an adjustment of the scroll position.
	      // See issue #2 for more information.
	      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
	        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).
	        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.
	        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {
	          this._scrollingContainer.scrollLeft = scrollLeft;
	        }
	        if (!autoHeight && scrollTop >= 0 && (scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {
	          this._scrollingContainer.scrollTop = scrollTop;
	        }
	      }
	
	      // Special case where the previous size was 0:
	      // In this case we don't show any windowed cells at all.
	      // So we should always recalculate offset afterwards.
	      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;
	
	      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
	      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?
	      if (this._recomputeScrollLeftFlag) {
	        this._recomputeScrollLeftFlag = false;
	        this._updateScrollLeftForScrollToColumn(this.props);
	      } else {
	        (0, _updateScrollIndexHelper2.default)({
	          cellSizeAndPositionManager: this._columnSizeAndPositionManager,
	          previousCellsCount: prevProps.columnCount,
	          previousCellSize: prevProps.columnWidth,
	          previousScrollToAlignment: prevProps.scrollToAlignment,
	          previousScrollToIndex: prevProps.scrollToColumn,
	          previousSize: prevProps.width,
	          scrollOffset: scrollLeft,
	          scrollToAlignment: scrollToAlignment,
	          scrollToIndex: scrollToColumn,
	          size: width,
	          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
	          updateScrollIndexCallback: function updateScrollIndexCallback() {
	            return _this2._updateScrollLeftForScrollToColumn(_this2.props);
	          }
	        });
	      }
	
	      if (this._recomputeScrollTopFlag) {
	        this._recomputeScrollTopFlag = false;
	        this._updateScrollTopForScrollToRow(this.props);
	      } else {
	        (0, _updateScrollIndexHelper2.default)({
	          cellSizeAndPositionManager: this._rowSizeAndPositionManager,
	          previousCellsCount: prevProps.rowCount,
	          previousCellSize: prevProps.rowHeight,
	          previousScrollToAlignment: prevProps.scrollToAlignment,
	          previousScrollToIndex: prevProps.scrollToRow,
	          previousSize: prevProps.height,
	          scrollOffset: scrollTop,
	          scrollToAlignment: scrollToAlignment,
	          scrollToIndex: scrollToRow,
	          size: height,
	          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
	          updateScrollIndexCallback: function updateScrollIndexCallback() {
	            return _this2._updateScrollTopForScrollToRow(_this2.props);
	          }
	        });
	      }
	
	      // Update onRowsRendered callback if start/stop indices have changed
	      this._invokeOnGridRenderedHelper();
	
	      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners
	      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
	        var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
	        var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
	
	        this._invokeOnScrollMemoizer({
	          scrollLeft: scrollLeft,
	          scrollTop: scrollTop,
	          totalColumnsWidth: totalColumnsWidth,
	          totalRowsHeight: totalRowsHeight
	        });
	      }
	
	      this._maybeCallOnScrollbarPresenceChange();
	    }
	  }, {
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      var getScrollbarSize = this.props.getScrollbarSize;
	
	      // If this component is being rendered server-side, getScrollbarSize() will return undefined.
	      // We handle this case in componentDidMount()
	
	      this._scrollbarSize = getScrollbarSize();
	      if (this._scrollbarSize === undefined) {
	        this._scrollbarSizeMeasured = false;
	        this._scrollbarSize = 0;
	      } else {
	        this._scrollbarSizeMeasured = true;
	      }
	
	      this._calculateChildrenToRender();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      if (this._disablePointerEventsTimeoutId) {
	        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
	      }
	    }
	
	    /**
	     * @private
	     * This method updates scrollLeft/scrollTop in state for the following conditions:
	     * 1) Empty content (0 rows or columns)
	     * 2) New scroll props overriding the current state
	     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
	     */
	
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var _this3 = this;
	
	      var _state2 = this.state,
	          scrollLeft = _state2.scrollLeft,
	          scrollTop = _state2.scrollTop;
	
	
	      if (nextProps.columnCount === 0 && scrollLeft !== 0 || nextProps.rowCount === 0 && scrollTop !== 0) {
	        this.scrollToPosition({
	          scrollLeft: 0,
	          scrollTop: 0
	        });
	      } else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
	        var newState = {};
	
	        if (nextProps.scrollLeft != null) {
	          newState.scrollLeft = nextProps.scrollLeft;
	        }
	        if (nextProps.scrollTop != null) {
	          newState.scrollTop = nextProps.scrollTop;
	        }
	
	        this.scrollToPosition(newState);
	      }
	
	      if (nextProps.columnWidth !== this.props.columnWidth || nextProps.rowHeight !== this.props.rowHeight) {
	        this._styleCache = {};
	      }
	
	      this._columnWidthGetter = this._wrapSizeGetter(nextProps.columnWidth);
	      this._rowHeightGetter = this._wrapSizeGetter(nextProps.rowHeight);
	
	      this._columnSizeAndPositionManager.configure({
	        cellCount: nextProps.columnCount,
	        estimatedCellSize: this._getEstimatedColumnSize(nextProps)
	      });
	      this._rowSizeAndPositionManager.configure({
	        cellCount: nextProps.rowCount,
	        estimatedCellSize: this._getEstimatedRowSize(nextProps)
	      });
	
	      var _props6 = this.props,
	          columnCount = _props6.columnCount,
	          rowCount = _props6.rowCount;
	
	      // Special case when either cols or rows were 0
	      // This would prevent any cells from rendering
	      // So we need to reset row scroll if cols changed from 0 (and vice versa)
	
	      if (columnCount === 0 || rowCount === 0) {
	        columnCount = 0;
	        rowCount = 0;
	      }
	
	      // If scrolling is controlled outside this component, clear cache when scrolling stops
	      if (nextProps.autoHeight && nextProps.isScrolling === false && this.props.isScrolling === true) {
	        this._resetStyleCache();
	      }
	
	      // Update scroll offsets if the size or number of cells have changed, invalidating the previous value
	      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
	        cellCount: columnCount,
	        cellSize: typeof this.props.columnWidth === 'number' ? this.props.columnWidth : null,
	        computeMetadataCallback: function computeMetadataCallback() {
	          return _this3._columnSizeAndPositionManager.resetCell(0);
	        },
	        computeMetadataCallbackProps: nextProps,
	        nextCellsCount: nextProps.columnCount,
	        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,
	        nextScrollToIndex: nextProps.scrollToColumn,
	        scrollToIndex: this.props.scrollToColumn,
	        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
	          return _this3._updateScrollLeftForScrollToColumn(nextProps, _this3.state);
	        }
	      });
	      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
	        cellCount: rowCount,
	        cellSize: typeof this.props.rowHeight === 'number' ? this.props.rowHeight : null,
	        computeMetadataCallback: function computeMetadataCallback() {
	          return _this3._rowSizeAndPositionManager.resetCell(0);
	        },
	        computeMetadataCallbackProps: nextProps,
	        nextCellsCount: nextProps.rowCount,
	        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,
	        nextScrollToIndex: nextProps.scrollToRow,
	        scrollToIndex: this.props.scrollToRow,
	        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
	          return _this3._updateScrollTopForScrollToRow(nextProps, _this3.state);
	        }
	      });
	    }
	  }, {
	    key: 'componentWillUpdate',
	    value: function componentWillUpdate(nextProps, nextState) {
	      this._calculateChildrenToRender(nextProps, nextState);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props7 = this.props,
	          autoContainerWidth = _props7.autoContainerWidth,
	          autoHeight = _props7.autoHeight,
	          autoWidth = _props7.autoWidth,
	          className = _props7.className,
	          containerProps = _props7.containerProps,
	          containerRole = _props7.containerRole,
	          containerStyle = _props7.containerStyle,
	          height = _props7.height,
	          id = _props7.id,
	          noContentRenderer = _props7.noContentRenderer,
	          role = _props7.role,
	          style = _props7.style,
	          tabIndex = _props7.tabIndex,
	          width = _props7.width;
	
	
	      var isScrolling = this._isScrolling();
	
	      var gridStyle = {
	        boxSizing: 'border-box',
	        direction: 'ltr',
	        height: autoHeight ? 'auto' : height,
	        position: 'relative',
	        width: autoWidth ? 'auto' : width,
	        WebkitOverflowScrolling: 'touch',
	        willChange: 'transform'
	      };
	
	      var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
	      var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
	
	      // Force browser to hide scrollbars when we know they aren't necessary.
	      // Otherwise once scrollbars appear they may not disappear again.
	      // For more info see issue #116
	      var verticalScrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0;
	      var horizontalScrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;
	
	      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {
	        this._horizontalScrollBarSize = horizontalScrollBarSize;
	        this._verticalScrollBarSize = verticalScrollBarSize;
	        this._scrollbarPresenceChanged = true;
	      }
	
	      // Also explicitly init styles to 'auto' if scrollbars are required.
	      // This works around an obscure edge case where external CSS styles have not yet been loaded,
	      // But an initial scroll index of offset is set as an external prop.
	      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
	      // This was originally reported via clauderic/react-infinite-calendar/issues/23
	      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
	      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';
	
	      var childrenToDisplay = this._childrenToDisplay;
	
	      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;
	
	      return _react2.default.createElement(
	        'div',
	        _extends({
	          ref: this._setScrollingContainerRef
	        }, containerProps, {
	          'aria-label': this.props['aria-label'],
	          'aria-readonly': this.props['aria-readonly'],
	          className: (0, _classnames2.default)('ReactVirtualized__Grid', className),
	          id: id,
	          onScroll: this._onScroll,
	          role: role,
	          style: _extends({}, gridStyle, style),
	          tabIndex: tabIndex }),
	        childrenToDisplay.length > 0 && _react2.default.createElement(
	          'div',
	          {
	            className: 'ReactVirtualized__Grid__innerScrollContainer',
	            role: containerRole,
	            style: _extends({
	              width: autoContainerWidth ? 'auto' : totalColumnsWidth,
	              height: totalRowsHeight,
	              maxWidth: totalColumnsWidth,
	              maxHeight: totalRowsHeight,
	              overflow: 'hidden',
	              pointerEvents: isScrolling ? 'none' : '',
	              position: 'relative'
	            }, containerStyle) },
	          childrenToDisplay
	        ),
	        showNoContentRenderer && noContentRenderer()
	      );
	    }
	
	    /* ---------------------------- Helper methods ---------------------------- */
	
	  }, {
	    key: '_calculateChildrenToRender',
	    value: function _calculateChildrenToRender() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	      var cellRenderer = props.cellRenderer,
	          cellRangeRenderer = props.cellRangeRenderer,
	          columnCount = props.columnCount,
	          deferredMeasurementCache = props.deferredMeasurementCache,
	          height = props.height,
	          overscanColumnCount = props.overscanColumnCount,
	          overscanIndicesGetter = props.overscanIndicesGetter,
	          overscanRowCount = props.overscanRowCount,
	          rowCount = props.rowCount,
	          width = props.width;
	      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,
	          scrollDirectionVertical = state.scrollDirectionVertical,
	          scrollLeft = state.scrollLeft,
	          scrollTop = state.scrollTop;
	
	
	      var isScrolling = this._isScrolling(props, state);
	
	      this._childrenToDisplay = [];
	
	      // Render only enough columns and rows to cover the visible area of the grid.
	      if (height > 0 && width > 0) {
	        var visibleColumnIndices = this._columnSizeAndPositionManager.getVisibleCellRange({
	          containerSize: width,
	          offset: scrollLeft
	        });
	        var visibleRowIndices = this._rowSizeAndPositionManager.getVisibleCellRange({
	          containerSize: height,
	          offset: scrollTop
	        });
	
	        var horizontalOffsetAdjustment = this._columnSizeAndPositionManager.getOffsetAdjustment({
	          containerSize: width,
	          offset: scrollLeft
	        });
	        var verticalOffsetAdjustment = this._rowSizeAndPositionManager.getOffsetAdjustment({
	          containerSize: height,
	          offset: scrollTop
	        });
	
	        // Store for _invokeOnGridRenderedHelper()
	        this._renderedColumnStartIndex = visibleColumnIndices.start;
	        this._renderedColumnStopIndex = visibleColumnIndices.stop;
	        this._renderedRowStartIndex = visibleRowIndices.start;
	        this._renderedRowStopIndex = visibleRowIndices.stop;
	
	        var overscanColumnIndices = overscanIndicesGetter({
	          direction: 'horizontal',
	          cellCount: columnCount,
	          overscanCellsCount: overscanColumnCount,
	          scrollDirection: scrollDirectionHorizontal,
	          startIndex: typeof this._renderedColumnStartIndex === 'number' ? this._renderedColumnStartIndex : 0,
	          stopIndex: typeof this._renderedColumnStopIndex === 'number' ? this._renderedColumnStopIndex : -1
	        });
	
	        var overscanRowIndices = overscanIndicesGetter({
	          direction: 'vertical',
	          cellCount: rowCount,
	          overscanCellsCount: overscanRowCount,
	          scrollDirection: scrollDirectionVertical,
	          startIndex: typeof this._renderedRowStartIndex === 'number' ? this._renderedRowStartIndex : 0,
	          stopIndex: typeof this._renderedRowStopIndex === 'number' ? this._renderedRowStopIndex : -1
	          // stopIndex: this._renderedRowStopIndex
	        });
	
	        // Store for _invokeOnGridRenderedHelper()
	        this._columnStartIndex = overscanColumnIndices.overscanStartIndex;
	        this._columnStopIndex = overscanColumnIndices.overscanStopIndex;
	        this._rowStartIndex = overscanRowIndices.overscanStartIndex;
	        this._rowStopIndex = overscanRowIndices.overscanStopIndex;
	
	        this._childrenToDisplay = cellRangeRenderer({
	          cellCache: this._cellCache,
	          cellRenderer: cellRenderer,
	          columnSizeAndPositionManager: this._columnSizeAndPositionManager,
	          columnStartIndex: this._columnStartIndex,
	          columnStopIndex: this._columnStopIndex,
	          deferredMeasurementCache: deferredMeasurementCache,
	          horizontalOffsetAdjustment: horizontalOffsetAdjustment,
	          isScrolling: isScrolling,
	          parent: this,
	          rowSizeAndPositionManager: this._rowSizeAndPositionManager,
	          rowStartIndex: this._rowStartIndex,
	          rowStopIndex: this._rowStopIndex,
	          scrollLeft: scrollLeft,
	          scrollTop: scrollTop,
	          styleCache: this._styleCache,
	          verticalOffsetAdjustment: verticalOffsetAdjustment,
	          visibleColumnIndices: visibleColumnIndices,
	          visibleRowIndices: visibleRowIndices
	        });
	      }
	    }
	
	    /**
	     * Sets an :isScrolling flag for a small window of time.
	     * This flag is used to disable pointer events on the scrollable portion of the Grid.
	     * This prevents jerky/stuttery mouse-wheel scrolling.
	     */
	
	  }, {
	    key: '_debounceScrollEnded',
	    value: function _debounceScrollEnded() {
	      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
	
	
	      if (this._disablePointerEventsTimeoutId) {
	        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
	      }
	
	      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
	    }
	  }, {
	    key: '_getEstimatedColumnSize',
	    value: function _getEstimatedColumnSize(props) {
	      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;
	    }
	  }, {
	    key: '_getEstimatedRowSize',
	    value: function _getEstimatedRowSize(props) {
	      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;
	    }
	
	    /**
	     * Check for batched CellMeasurer size invalidations.
	     * This will occur the first time one or more previously unmeasured cells are rendered.
	     */
	
	  }, {
	    key: '_handleInvalidatedGridSize',
	    value: function _handleInvalidatedGridSize() {
	      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {
	        var columnIndex = this._deferredInvalidateColumnIndex;
	        var rowIndex = this._deferredInvalidateRowIndex;
	
	        this._deferredInvalidateColumnIndex = null;
	        this._deferredInvalidateRowIndex = null;
	
	        this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });
	      }
	    }
	  }, {
	    key: '_invokeOnScrollMemoizer',
	    value: function _invokeOnScrollMemoizer(_ref6) {
	      var _this4 = this;
	
	      var scrollLeft = _ref6.scrollLeft,
	          scrollTop = _ref6.scrollTop,
	          totalColumnsWidth = _ref6.totalColumnsWidth,
	          totalRowsHeight = _ref6.totalRowsHeight;
	
	      this._onScrollMemoizer({
	        callback: function callback(_ref7) {
	          var scrollLeft = _ref7.scrollLeft,
	              scrollTop = _ref7.scrollTop;
	          var _props8 = _this4.props,
	              height = _props8.height,
	              onScroll = _props8.onScroll,
	              width = _props8.width;
	
	
	          onScroll({
	            clientHeight: height,
	            clientWidth: width,
	            scrollHeight: totalRowsHeight,
	            scrollLeft: scrollLeft,
	            scrollTop: scrollTop,
	            scrollWidth: totalColumnsWidth
	          });
	        },
	        indices: {
	          scrollLeft: scrollLeft,
	          scrollTop: scrollTop
	        }
	      });
	    }
	  }, {
	    key: '_isScrolling',
	    value: function _isScrolling() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	
	      // If isScrolling is defined in props, use it to override the value in state
	      // This is a performance optimization for WindowScroller + Grid
	      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
	    }
	  }, {
	    key: '_maybeCallOnScrollbarPresenceChange',
	    value: function _maybeCallOnScrollbarPresenceChange() {
	      if (this._scrollbarPresenceChanged) {
	        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
	
	
	        this._scrollbarPresenceChanged = false;
	
	        _onScrollbarPresenceChange({
	          horizontal: this._horizontalScrollBarSize > 0,
	          size: this._scrollbarSize,
	          vertical: this._verticalScrollBarSize > 0
	        });
	      }
	    }
	  }, {
	    key: 'scrollToPosition',
	
	
	    /**
	     * Scroll to the specified offset(s).
	     * Useful for animating position changes.
	     */
	    value: function scrollToPosition(_ref8) {
	      var scrollLeft = _ref8.scrollLeft,
	          scrollTop = _ref8.scrollTop;
	
	      var newState = {
	        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
	      };
	
	      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {
	        newState.scrollDirectionHorizontal = scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
	        newState.scrollLeft = scrollLeft;
	      }
	
	      if (typeof scrollTop === 'number' && scrollTop >= 0) {
	        newState.scrollDirectionVertical = scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
	        newState.scrollTop = scrollTop;
	      }
	
	      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
	        this.setState(newState);
	      }
	    }
	  }, {
	    key: '_wrapSizeGetter',
	    value: function _wrapSizeGetter(value) {
	      return typeof value === 'function' ? value : function () {
	        return value;
	      };
	    }
	  }, {
	    key: '_getCalculatedScrollLeft',
	    value: function _getCalculatedScrollLeft() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	      var columnCount = props.columnCount,
	          height = props.height,
	          scrollToAlignment = props.scrollToAlignment,
	          scrollToColumn = props.scrollToColumn,
	          width = props.width;
	      var scrollLeft = state.scrollLeft;
	
	
	      if (columnCount > 0) {
	        var finalColumn = columnCount - 1;
	        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);
	        var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
	        var scrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0;
	
	        return this._columnSizeAndPositionManager.getUpdatedOffsetForIndex({
	          align: scrollToAlignment,
	          containerSize: width - scrollBarSize,
	          currentOffset: scrollLeft,
	          targetIndex: targetIndex
	        });
	      }
	    }
	  }, {
	    key: '_updateScrollLeftForScrollToColumn',
	    value: function _updateScrollLeftForScrollToColumn() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	      var scrollLeft = state.scrollLeft;
	
	      var calculatedScrollLeft = this._getCalculatedScrollLeft(props, state);
	
	      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {
	        this.scrollToPosition({
	          scrollLeft: calculatedScrollLeft,
	          scrollTop: -1
	        });
	      }
	    }
	  }, {
	    key: '_getCalculatedScrollTop',
	    value: function _getCalculatedScrollTop() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	      var height = props.height,
	          rowCount = props.rowCount,
	          scrollToAlignment = props.scrollToAlignment,
	          scrollToRow = props.scrollToRow,
	          width = props.width;
	      var scrollTop = state.scrollTop;
	
	
	      if (rowCount > 0) {
	        var finalRow = rowCount - 1;
	        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);
	        var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
	        var scrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;
	
	        return this._rowSizeAndPositionManager.getUpdatedOffsetForIndex({
	          align: scrollToAlignment,
	          containerSize: height - scrollBarSize,
	          currentOffset: scrollTop,
	          targetIndex: targetIndex
	        });
	      }
	    }
	  }, {
	    key: '_resetStyleCache',
	    value: function _resetStyleCache() {
	      var styleCache = this._styleCache;
	
	      // Reset cell and style caches once scrolling stops.
	      // This makes Grid simpler to use (since cells commonly change).
	      // And it keeps the caches from growing too large.
	      // Performance is most sensitive when a user is scrolling.
	      this._cellCache = {};
	      this._styleCache = {};
	
	      // Copy over the visible cell styles so avoid unnecessary re-render.
	      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
	        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
	          var key = rowIndex + '-' + columnIndex;
	          this._styleCache[key] = styleCache[key];
	        }
	      }
	
	      this.setState({
	        isScrolling: false
	      });
	    }
	  }, {
	    key: '_updateScrollTopForScrollToRow',
	    value: function _updateScrollTopForScrollToRow() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
	      var scrollTop = state.scrollTop;
	
	      var calculatedScrollTop = this._getCalculatedScrollTop(props, state);
	
	      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {
	        this.scrollToPosition({
	          scrollLeft: -1,
	          scrollTop: calculatedScrollTop
	        });
	      }
	    }
	  }]);
	
	  return Grid;
	}(_react2.default.PureComponent);
	
	Grid.defaultProps = {
	  'aria-label': 'grid',
	  'aria-readonly': true,
	  autoContainerWidth: false,
	  autoHeight: false,
	  autoWidth: false,
	  cellRangeRenderer: _defaultCellRangeRenderer2.default,
	  containerRole: 'rowgroup',
	  containerStyle: {},
	  estimatedColumnSize: 100,
	  estimatedRowSize: 30,
	  getScrollbarSize: _scrollbarSize2.default,
	  noContentRenderer: renderNull,
	  onScroll: function onScroll(_ref9) {
	    _objectDestructuringEmpty(_ref9);
	  },
	  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},
	  onSectionRendered: function onSectionRendered(_ref10) {
	    _objectDestructuringEmpty(_ref10);
	  },
	  overscanColumnCount: 0,
	  overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,
	  overscanRowCount: 10,
	  role: 'grid',
	  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
	  scrollToAlignment: 'auto',
	  scrollToColumn: -1,
	  scrollToRow: -1,
	  style: {},
	  tabIndex: 0
	};
	Grid.propTypes = {
	  "aria-label": __webpack_require__(1).string.isRequired,
	  "aria-readonly": __webpack_require__(1).bool,
	  autoContainerWidth: __webpack_require__(1).bool.isRequired,
	  autoHeight: __webpack_require__(1).bool.isRequired,
	  autoWidth: __webpack_require__(1).bool.isRequired,
	  cellRenderer: typeof babelPluginFlowReactPropTypes_proptype_CellRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRenderer : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_CellRenderer).isRequired,
	  cellRangeRenderer: typeof babelPluginFlowReactPropTypes_proptype_CellRangeRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRangeRenderer : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_CellRangeRenderer).isRequired,
	  className: __webpack_require__(1).string,
	  columnCount: __webpack_require__(1).number.isRequired,
	  columnWidth: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
	  containerProps: __webpack_require__(1).object,
	  containerRole: __webpack_require__(1).string.isRequired,
	  containerStyle: __webpack_require__(1).object.isRequired,
	  deferredMeasurementCache: __webpack_require__(1).object,
	  estimatedColumnSize: __webpack_require__(1).number.isRequired,
	  estimatedRowSize: __webpack_require__(1).number.isRequired,
	  getScrollbarSize: __webpack_require__(1).func.isRequired,
	  height: __webpack_require__(1).number.isRequired,
	  id: __webpack_require__(1).string,
	  isScrolling: __webpack_require__(1).bool,
	  noContentRenderer: typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,
	  onScroll: __webpack_require__(1).func.isRequired,
	  onScrollbarPresenceChange: __webpack_require__(1).func.isRequired,
	  onSectionRendered: __webpack_require__(1).func.isRequired,
	  overscanColumnCount: __webpack_require__(1).number.isRequired,
	  overscanIndicesGetter: typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter === 'function' ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,
	  overscanRowCount: __webpack_require__(1).number.isRequired,
	  role: __webpack_require__(1).string.isRequired,
	  rowHeight: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
	  rowCount: __webpack_require__(1).number.isRequired,
	  scrollingResetTimeInterval: __webpack_require__(1).number.isRequired,
	  scrollLeft: __webpack_require__(1).number,
	  scrollToAlignment: typeof babelPluginFlowReactPropTypes_proptype_Alignment === 'function' ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,
	  scrollToColumn: __webpack_require__(1).number.isRequired,
	  scrollTop: __webpack_require__(1).number,
	  scrollToRow: __webpack_require__(1).number.isRequired,
	  style: __webpack_require__(1).object.isRequired,
	  tabIndex: __webpack_require__(1).number,
	  width: __webpack_require__(1).number.isRequired
	};
	exports.default = Grid;

/***/ }),
/* 821 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultOverscanIndicesGetter;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndices = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_OverscanIndices || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || __webpack_require__(1).any;
	
	var SCROLL_DIRECTION_BACKWARD = exports.SCROLL_DIRECTION_BACKWARD = -1;
	var SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_FORWARD = 1;
	
	var SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
	var SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_VERTICAL = 'vertical';
	
	/**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
	
	function defaultOverscanIndicesGetter(_ref) {
	  var cellCount = _ref.cellCount,
	      overscanCellsCount = _ref.overscanCellsCount,
	      scrollDirection = _ref.scrollDirection,
	      startIndex = _ref.startIndex,
	      stopIndex = _ref.stopIndex;
	
	  // Make sure we render at least 1 cell extra before and after (except near boundaries)
	  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases
	  // For more info see issues #625
	  overscanCellsCount = Math.max(1, overscanCellsCount);
	
	  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
	    return {
	      overscanStartIndex: Math.max(0, startIndex - 1),
	      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
	    };
	  } else {
	    return {
	      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
	      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
	    };
	  }
	}

/***/ }),
/* 822 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var babelPluginFlowReactPropTypes_proptype_VisibleCellRange = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_VisibleCellRange || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(1).any;
	
	/**
	 * Just-in-time calculates and caches size and position information for a collection of cells.
	 */
	
	var CellSizeAndPositionManager = function () {
	
	  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
	  function CellSizeAndPositionManager(_ref) {
	    var _ref$batchAllCells = _ref.batchAllCells,
	        batchAllCells = _ref$batchAllCells === undefined ? false : _ref$batchAllCells,
	        cellCount = _ref.cellCount,
	        cellSizeGetter = _ref.cellSizeGetter,
	        estimatedCellSize = _ref.estimatedCellSize;
	
	    _classCallCheck(this, CellSizeAndPositionManager);
	
	    this._cellSizeAndPositionData = {};
	    this._lastMeasuredIndex = -1;
	    this._lastBatchedIndex = -1;
	
	    this._batchAllCells = batchAllCells;
	    this._cellSizeGetter = cellSizeGetter;
	    this._cellCount = cellCount;
	    this._estimatedCellSize = estimatedCellSize;
	  }
	
	  // Used in deferred mode to track which cells have been queued for measurement.
	
	  // Cache of size and position data for cells, mapped by cell index.
	  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
	
	
	  _createClass(CellSizeAndPositionManager, [{
	    key: 'areOffsetsAdjusted',
	    value: function areOffsetsAdjusted() {
	      return false;
	    }
	  }, {
	    key: 'configure',
	    value: function configure(_ref2) {
	      var cellCount = _ref2.cellCount,
	          estimatedCellSize = _ref2.estimatedCellSize;
	
	      this._cellCount = cellCount;
	      this._estimatedCellSize = estimatedCellSize;
	    }
	  }, {
	    key: 'getCellCount',
	    value: function getCellCount() {
	      return this._cellCount;
	    }
	  }, {
	    key: 'getEstimatedCellSize',
	    value: function getEstimatedCellSize() {
	      return this._estimatedCellSize;
	    }
	  }, {
	    key: 'getLastMeasuredIndex',
	    value: function getLastMeasuredIndex() {
	      return this._lastMeasuredIndex;
	    }
	  }, {
	    key: 'getOffsetAdjustment',
	    value: function getOffsetAdjustment() {
	      return 0;
	    }
	
	    /**
	     * This method returns the size and position for the cell at the specified index.
	     * It just-in-time calculates (or used cached values) for cells leading up to the index.
	     */
	
	  }, {
	    key: 'getSizeAndPositionOfCell',
	    value: function getSizeAndPositionOfCell(index) {
	      if (index < 0 || index >= this._cellCount) {
	        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);
	      }
	
	      if (index > this._lastMeasuredIndex) {
	        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
	        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
	
	        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {
	          var _size = this._cellSizeGetter({ index: i });
	
	          // undefined or NaN probably means a logic error in the size getter.
	          // null means we're using CellMeasurer and haven't yet measured a given index.
	          if (_size === undefined || isNaN(_size)) {
	            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);
	          } else if (_size === null) {
	            this._cellSizeAndPositionData[i] = {
	              offset: _offset,
	              size: 0
	            };
	
	            this._lastBatchedIndex = index;
	          } else {
	            this._cellSizeAndPositionData[i] = {
	              offset: _offset,
	              size: _size
	            };
	
	            _offset += _size;
	
	            this._lastMeasuredIndex = index;
	          }
	        }
	      }
	
	      return this._cellSizeAndPositionData[index];
	    }
	  }, {
	    key: 'getSizeAndPositionOfLastMeasuredCell',
	    value: function getSizeAndPositionOfLastMeasuredCell() {
	      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
	        offset: 0,
	        size: 0
	      };
	    }
	
	    /**
	     * Total size of all cells being measured.
	     * This value will be completely estimated initially.
	     * As cells are measured, the estimate will be updated.
	     */
	
	  }, {
	    key: 'getTotalSize',
	    value: function getTotalSize() {
	      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
	      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
	      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
	      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
	      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
	    }
	
	    /**
	     * Determines a new offset that ensures a certain cell is visible, given the current offset.
	     * If the cell is already visible then the current offset will be returned.
	     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
	     *
	     * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
	     * @param containerSize Size (width or height) of the container viewport
	     * @param currentOffset Container's current (x or y) offset
	     * @param totalSize Total size (width or height) of all cells
	     * @return Offset to use to ensure the specified cell is visible
	     */
	
	  }, {
	    key: 'getUpdatedOffsetForIndex',
	    value: function getUpdatedOffsetForIndex(_ref3) {
	      var _ref3$align = _ref3.align,
	          align = _ref3$align === undefined ? 'auto' : _ref3$align,
	          containerSize = _ref3.containerSize,
	          currentOffset = _ref3.currentOffset,
	          targetIndex = _ref3.targetIndex;
	
	      if (containerSize <= 0) {
	        return 0;
	      }
	
	      var datum = this.getSizeAndPositionOfCell(targetIndex);
	      var maxOffset = datum.offset;
	      var minOffset = maxOffset - containerSize + datum.size;
	
	      var idealOffset = void 0;
	
	      switch (align) {
	        case 'start':
	          idealOffset = maxOffset;
	          break;
	        case 'end':
	          idealOffset = minOffset;
	          break;
	        case 'center':
	          idealOffset = maxOffset - (containerSize - datum.size) / 2;
	          break;
	        default:
	          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
	          break;
	      }
	
	      var totalSize = this.getTotalSize();
	
	      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
	    }
	  }, {
	    key: 'getVisibleCellRange',
	    value: function getVisibleCellRange(params) {
	      // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.
	      // eg we can't know a row's height without measuring the height of all columns within that row.
	      if (this._batchAllCells) {
	        return {
	          start: 0,
	          stop: this._cellCount - 1
	        };
	      }
	
	      var containerSize = params.containerSize,
	          offset = params.offset;
	
	
	      var totalSize = this.getTotalSize();
	
	      if (totalSize === 0) {
	        return {};
	      }
	
	      var maxOffset = offset + containerSize;
	      var start = this._findNearestCell(offset);
	
	      var datum = this.getSizeAndPositionOfCell(start);
	      offset = datum.offset + datum.size;
	
	      var stop = start;
	
	      while (offset < maxOffset && stop < this._cellCount - 1) {
	        stop++;
	
	        offset += this.getSizeAndPositionOfCell(stop).size;
	      }
	
	      return {
	        start: start,
	        stop: stop
	      };
	    }
	
	    /**
	     * Clear all cached values for cells after the specified index.
	     * This method should be called for any cell that has changed its size.
	     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.
	     */
	
	  }, {
	    key: 'resetCell',
	    value: function resetCell(index) {
	      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
	    }
	  }, {
	    key: '_binarySearch',
	    value: function _binarySearch(high, low, offset) {
	      while (low <= high) {
	        var middle = low + Math.floor((high - low) / 2);
	        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;
	
	        if (_currentOffset === offset) {
	          return middle;
	        } else if (_currentOffset < offset) {
	          low = middle + 1;
	        } else if (_currentOffset > offset) {
	          high = middle - 1;
	        }
	      }
	
	      if (low > 0) {
	        return low - 1;
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: '_exponentialSearch',
	    value: function _exponentialSearch(index, offset) {
	      var interval = 1;
	
	      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {
	        index += interval;
	        interval *= 2;
	      }
	
	      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
	    }
	
	    /**
	     * Searches for the cell (index) nearest the specified offset.
	     *
	     * If no exact match is found the next lowest cell index will be returned.
	     * This allows partially visible cells (with offsets just before/above the fold) to be visible.
	     */
	
	  }, {
	    key: '_findNearestCell',
	    value: function _findNearestCell(offset) {
	      if (isNaN(offset)) {
	        throw Error('Invalid offset ' + offset + ' specified');
	      }
	
	      // Our search algorithms find the nearest match at or below the specified offset.
	      // So make sure the offset is at least 0 or no match will be found.
	      offset = Math.max(0, offset);
	
	      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
	      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
	
	      if (lastMeasuredCellSizeAndPosition.offset >= offset) {
	        // If we've already measured cells within this range just use a binary search as it's faster.
	        return this._binarySearch(lastMeasuredIndex, 0, offset);
	      } else {
	        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
	        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.
	        // The overall complexity for this approach is O(log n).
	        return this._exponentialSearch(lastMeasuredIndex, offset);
	      }
	    }
	  }]);
	
	  return CellSizeAndPositionManager;
	}();
	
	exports.default = CellSizeAndPositionManager;

/***/ }),
/* 823 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;
	function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
	  var cellCount = _ref.cellCount,
	      cellSize = _ref.cellSize,
	      computeMetadataCallback = _ref.computeMetadataCallback,
	      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,
	      nextCellsCount = _ref.nextCellsCount,
	      nextCellSize = _ref.nextCellSize,
	      nextScrollToIndex = _ref.nextScrollToIndex,
	      scrollToIndex = _ref.scrollToIndex,
	      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
	
	  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
	  // In that event users should use the manual recompute methods to inform of changes.
	  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {
	    computeMetadataCallback(computeMetadataCallbackProps);
	
	    // Updated cell metadata may have hidden the previous scrolled-to item.
	    // In this case we should also update the scrollTop to ensure it stays visible.
	    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {
	      updateScrollOffsetForScrollToIndex();
	    }
	  }
	}
	
	/**
	 * Helper method that determines when to recalculate row or column metadata.
	 */

/***/ }),
/* 824 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = updateScrollIndexHelper;
	
	var _ScalingCellSizeAndPositionManager = __webpack_require__(196);
	
	var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var babelPluginFlowReactPropTypes_proptype_CellSize = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_CellSize || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(10).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(1).any;
	
	/**
	 * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.
	 * This function also ensures that the scroll ofset isn't past the last column/row of cells.
	 */
	
	function updateScrollIndexHelper(_ref) {
	  var cellSize = _ref.cellSize,
	      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,
	      previousCellsCount = _ref.previousCellsCount,
	      previousCellSize = _ref.previousCellSize,
	      previousScrollToAlignment = _ref.previousScrollToAlignment,
	      previousScrollToIndex = _ref.previousScrollToIndex,
	      previousSize = _ref.previousSize,
	      scrollOffset = _ref.scrollOffset,
	      scrollToAlignment = _ref.scrollToAlignment,
	      scrollToIndex = _ref.scrollToIndex,
	      size = _ref.size,
	      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,
	      updateScrollIndexCallback = _ref.updateScrollIndexCallback;
	
	  var cellCount = cellSizeAndPositionManager.getCellCount();
	  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
	  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;
	
	  // If we have a new scroll target OR if height/row-height has changed,
	  // We should ensure that the scroll target is visible.
	  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {
	    updateScrollIndexCallback(scrollToIndex);
	
	    // If we don't have a selected item but list size or number of children have decreased,
	    // Make sure we aren't scrolled too far past the current content.
	  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {
	    // We need to ensure that the current scroll offset is still within the collection's range.
	    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.
	    // Just check to make sure we're still okay.
	    // Only adjust the scroll position if we've scrolled below the last set of rows.
	    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {
	      updateScrollIndexCallback(cellCount - 1);
	    }
	  }
	}

/***/ }),
/* 825 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.isRangeVisible = isRangeVisible;
	exports.scanForUnloadedRanges = scanForUnloadedRanges;
	exports.forceUpdateReactVirtualizedComponent = forceUpdateReactVirtualizedComponent;
	
	var _react = __webpack_require__(2);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _createCallbackMemoizer = __webpack_require__(199);
	
	var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Higher-order component that manages lazy-loading for "infinite" data.
	 * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.
	 * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.
	 */
	var InfiniteLoader = function (_PureComponent) {
	  _inherits(InfiniteLoader, _PureComponent);
	
	  function InfiniteLoader(props, context) {
	    _classCallCheck(this, InfiniteLoader);
	
	    var _this = _possibleConstructorReturn(this, (InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call(this, props, context));
	
	    _this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();
	
	    _this._onRowsRendered = _this._onRowsRendered.bind(_this);
	    _this._registerChild = _this._registerChild.bind(_this);
	    return _this;
	  }
	
	  _createClass(InfiniteLoader, [{
	    key: 'resetLoadMoreRowsCache',
	    value: function resetLoadMoreRowsCache(autoReload) {
	      this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();
	
	      if (autoReload) {
	        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var children = this.props.children;
	
	
	      return children({
	        onRowsRendered: this._onRowsRendered,
	        registerChild: this._registerChild
	      });
	    }
	  }, {
	    key: '_loadUnloadedRanges',
	    value: function _loadUnloadedRanges(unloadedRanges) {
	      var _this2 = this;
	
	      var loadMoreRows = this.props.loadMoreRows;
	
	
	      unloadedRanges.forEach(function (unloadedRange) {
	        var promise = loadMoreRows(unloadedRange);
	        if (promise) {
	          promise.then(function () {
	            // Refresh the visible rows if any of them have just been loaded.
	            // Otherwise they will remain in their unloaded visual state.
	            if (isRangeVisible({
	              lastRenderedStartIndex: _this2._lastRenderedStartIndex,
	              lastRenderedStopIndex: _this2._lastRenderedStopIndex,
	              startIndex: unloadedRange.startIndex,
	              stopIndex: unloadedRange.stopIndex
	            })) {
	              if (_this2._registeredChild) {
	                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);
	              }
	            }
	          });
	        }
	      });
	    }
	  }, {
	    key: '_onRowsRendered',
	    value: function _onRowsRendered(_ref) {
	      var startIndex = _ref.startIndex,
	          stopIndex = _ref.stopIndex;
	
	      this._lastRenderedStartIndex = startIndex;
	      this._lastRenderedStopIndex = stopIndex;
	
	      this._doStuff(startIndex, stopIndex);
	    }
	  }, {
	    key: '_doStuff',
	    value: function _doStuff(startIndex, stopIndex) {
	      var _this3 = this;
	
	      var _props = this.props,
	          isRowLoaded = _props.isRowLoaded,
	          minimumBatchSize = _props.minimumBatchSize,
	          rowCount = _props.rowCount,
	          threshold = _props.threshold;
	
	
	      var unloadedRanges = scanForUnloadedRanges({
	        isRowLoaded: isRowLoaded,
	        minimumBatchSize: minimumBatchSize,
	        rowCount: rowCount,
	        startIndex: Math.max(0, startIndex - threshold),
	        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)
	      });
	
	      // For memoize comparison
	      var squashedUnloadedRanges = unloadedRanges.reduce(function (reduced, unloadedRange) {
	        return reduced.concat([unloadedRange.startIndex, unloadedRange.stopIndex]);
	      }, []);
	
	      this._loadMoreRowsMemoizer({
	        callback: function callback() {
	          _this3._loadUnloadedRanges(unloadedRanges);
	        },
	        indices: { squashedUnloadedRanges: squashedUnloadedRanges }
	      });
	    }
	  }, {
	    key: '_registerChild',
	    value: function _registerChild(registeredChild) {
	      this._registeredChild = registeredChild;
	    }
	  }]);
	
	  return InfiniteLoader;
	}(_react.PureComponent);
	
	/**
	 * Determines if the specified start/stop range is visible based on the most recently rendered range.
	 */
	
	
	InfiniteLoader.defaultProps = {
	  minimumBatchSize: 10,
	  rowCount: 0,
	  threshold: 15
	};
	exports.default = InfiniteLoader;
	InfiniteLoader.propTypes =  false ? {
	  /**
	   * Function responsible for rendering a virtualized component.
	   * This function should implement the following signature:
	   * ({ onRowsRendered, registerChild }) => PropTypes.element
	   *
	   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.
	   * The :registerChild callback should be set as the virtualized component's :ref.
	   */
	  children: _propTypes2.default.func.isRequired,
	
	  /**
	   * Function responsible for tracking the loaded state of each row.
	   * It should implement the following signature: ({ index: number }): boolean
	   */
	  isRowLoaded: _propTypes2.default.func.isRequired,
	
	  /**
	   * Callback to be invoked when more rows must be loaded.
	   * It should implement the following signature: ({ startIndex, stopIndex }): Promise
	   * The returned Promise should be resolved once row data has finished loading.
	   * It will be used to determine when to refresh the list with the newly-loaded data.
	   * This callback may be called multiple times in reaction to a single scroll event.
	   */
	  loadMoreRows: _propTypes2.default.func.isRequired,
	
	  /**
	   * Minimum number of rows to be loaded at a time.
	   * This property can be used to batch requests to reduce HTTP requests.
	   */
	  minimumBatchSize: _propTypes2.default.number.isRequired,
	
	  /**
	   * Number of rows in list; can be arbitrary high number if actual number is unknown.
	   */
	  rowCount: _propTypes2.default.number.isRequired,
	
	  /**
	   * Threshold at which to pre-fetch data.
	   * A threshold X means that data will start loading when a user scrolls within X rows.
	   * This value defaults to 15.
	   */
	  threshold: _propTypes2.default.number.isRequired
	} : {};
	function isRangeVisible(_ref2) {
	  var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,
	      lastRenderedStopIndex = _ref2.lastRenderedStopIndex,
	      startIndex = _ref2.startIndex,
	      stopIndex = _ref2.stopIndex;
	
	  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);
	}
	
	/**
	 * Returns all of the ranges within a larger range that contain unloaded rows.
	 */
	function scanForUnloadedRanges(_ref3) {
	  var isRowLoaded = _ref3.isRowLoaded,
	      minimumBatchSize = _ref3.minimumBatchSize,
	      rowCount = _ref3.rowCount,
	      startIndex = _ref3.startIndex,
	      stopIndex = _ref3.stopIndex;
	
	  var unloadedRanges = [];
	
	  var rangeStartIndex = null;
	  var rangeStopIndex = null;
	
	  for (var index = startIndex; index <= stopIndex; index++) {
	    var loaded = isRowLoaded({ index: index });
	
	    if (!loaded) {
	      rangeStopIndex = index;
	      if (rangeStartIndex === null) {
	        rangeStartIndex = index;
	      }
	    } else if (rangeStopIndex !== null) {
	      unloadedRanges.push({
	        startIndex: rangeStartIndex,
	        stopIndex: rangeStopIndex
	      });
	
	      rangeStartIndex = rangeStopIndex = null;
	    }
	  }
	
	  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.
	  // Scan forward to try filling our :minimumBatchSize.
	  if (rangeStopIndex !== null) {
	    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);
	
	    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {
	      if (!isRowLoaded({ index: _index })) {
	        rangeStopIndex = _index;
	      } else {
	        break;
	      }
	    }
	
	    unloadedRanges.push({
	      startIndex: rangeStartIndex,
	      stopIndex: rangeStopIndex
	    });
	  }
	
	  // Check to see if our first range ended prematurely.
	  // In this case we should scan backwards to try filling our :minimumBatchSize.
	  if (unloadedRanges.length) {
	    var firstUnloadedRange = unloadedRanges[0];
	
	    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {
	      var _index2 = firstUnloadedRange.startIndex - 1;
	
	      if (!isRowLoaded({ index: _index2 })) {
	        firstUnloadedRange.startIndex = _index2;
	      } else {
	        break;
	      }
	    }
	  }
	
	  return unloadedRanges;
	}
	
	/**
	 * Since RV components use shallowCompare we need to force a render (even though props haven't changed).
	 * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.
	 * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,
	 * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.
	 * Else the inner Grid will not be re-rendered and visuals may be stale.
	 *
	 * Additionally, while a Grid is scrolling the cells can be cached,
	 * So it's important to invalidate that cache by recalculating sizes
	 * before forcing a rerender.
	 */
	function forceUpdateReactVirtualizedComponent(component) {
	  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;
	
	  if (recomputeSize) {
	    recomputeSize.call(component, currentIndex);
	  } else {
	    component.forceUpdate();
	  }
	}

/***/ }),
/* 826 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.InfiniteLoader = undefined;
	
	var _InfiniteLoader = __webpack_require__(825);
	
	var _InfiniteLoader2 = _interopRequireDefault(_InfiniteLoader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _InfiniteLoader2.default;
	exports.InfiniteLoader = _InfiniteLoader2.default;

/***/ }),
/* 827 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Grid = __webpack_require__(22);
	
	var _Grid2 = _interopRequireDefault(_Grid);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_Scroll = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellRendererParams = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_CellRendererParams || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_RenderedSection = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_RenderedSection || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellPosition = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_CellPosition || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellSize = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_CellSize || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_NoContentRenderer = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_NoContentRenderer || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_Scroll = __webpack_require__(197).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_RenderedRows = __webpack_require__(197).babelPluginFlowReactPropTypes_proptype_RenderedRows || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_RowRenderer = __webpack_require__(197).babelPluginFlowReactPropTypes_proptype_RowRenderer || __webpack_require__(1).any;
	
	/**
	 * It is inefficient to create and manage a large list of DOM elements within a scrolling container
	 * if only a few of those elements are visible. The primary purpose of this component is to improve
	 * performance by only rendering the DOM nodes that a user is able to see based on their current
	 * scroll position.
	 *
	 * This component renders a virtualized list of elements with either fixed or dynamic heights.
	 */
	
	var List = function (_React$PureComponent) {
	  _inherits(List, _React$PureComponent);
	
	  function List() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, List);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [this].concat(args))), _this), _this._cellRenderer = function (_ref2) {
	      var rowIndex = _ref2.rowIndex,
	          style = _ref2.style,
	          isScrolling = _ref2.isScrolling,
	          isVisible = _ref2.isVisible,
	          key = _ref2.key;
	      var rowRenderer = _this.props.rowRenderer;
	
	      // TRICKY The style object is sometimes cached by Grid.
	      // This prevents new style objects from bypassing shallowCompare().
	      // However as of React 16, style props are auto-frozen (at least in dev mode)
	      // Check to make sure we can still modify the style before proceeding.
	      // https://github.com/facebook/react/commit/977357765b44af8ff0cfea327866861073095c12#commitcomment-20648713
	
	      var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(style, 'width'),
	          writable = _Object$getOwnPropert.writable;
	
	      if (writable) {
	        // By default, List cells should be 100% width.
	        // This prevents them from flowing under a scrollbar (if present).
	        style.width = '100%';
	      }
	
	      return rowRenderer({
	        index: rowIndex,
	        style: style,
	        isScrolling: isScrolling,
	        isVisible: isVisible,
	        key: key,
	        parent: _this
	      });
	    }, _this._setRef = function (ref) {
	      _this.Grid = ref;
	    }, _this._onScroll = function (_ref3) {
	      var clientHeight = _ref3.clientHeight,
	          scrollHeight = _ref3.scrollHeight,
	          scrollTop = _ref3.scrollTop;
	      var onScroll = _this.props.onScroll;
	
	
	      onScroll({ clientHeight: clientHeight, scrollHeight: scrollHeight, scrollTop: scrollTop });
	    }, _this._onSectionRendered = function (_ref4) {
	      var rowOverscanStartIndex = _ref4.rowOverscanStartIndex,
	          rowOverscanStopIndex = _ref4.rowOverscanStopIndex,
	          rowStartIndex = _ref4.rowStartIndex,
	          rowStopIndex = _ref4.rowStopIndex;
	      var onRowsRendered = _this.props.onRowsRendered;
	
	
	      onRowsRendered({
	        overscanStartIndex: rowOverscanStartIndex,
	        overscanStopIndex: rowOverscanStopIndex,
	        startIndex: rowStartIndex,
	        stopIndex: rowStopIndex
	      });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(List, [{
	    key: 'forceUpdateGrid',
	    value: function forceUpdateGrid() {
	      if (this.Grid) {
	        this.Grid.forceUpdate();
	      }
	    }
	
	    /** See Grid#getOffsetForCell */
	
	  }, {
	    key: 'getOffsetForRow',
	    value: function getOffsetForRow(_ref5) {
	      var alignment = _ref5.alignment,
	          index = _ref5.index;
	
	      if (this.Grid) {
	        var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({
	          alignment: alignment,
	          rowIndex: index,
	          columnIndex: 0
	        }),
	            _scrollTop = _Grid$getOffsetForCel.scrollTop;
	
	        return _scrollTop;
	      }
	      return 0;
	    }
	
	    /** CellMeasurer compatibility */
	
	  }, {
	    key: 'invalidateCellSizeAfterRender',
	    value: function invalidateCellSizeAfterRender(_ref6) {
	      var columnIndex = _ref6.columnIndex,
	          rowIndex = _ref6.rowIndex;
	
	      if (this.Grid) {
	        this.Grid.invalidateCellSizeAfterRender({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex
	        });
	      }
	    }
	
	    /** See Grid#measureAllCells */
	
	  }, {
	    key: 'measureAllRows',
	    value: function measureAllRows() {
	      if (this.Grid) {
	        this.Grid.measureAllCells();
	      }
	    }
	
	    /** CellMeasurer compatibility */
	
	  }, {
	    key: 'recomputeGridSize',
	    value: function recomputeGridSize() {
	      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref7$columnIndex = _ref7.columnIndex,
	          columnIndex = _ref7$columnIndex === undefined ? 0 : _ref7$columnIndex,
	          _ref7$rowIndex = _ref7.rowIndex,
	          rowIndex = _ref7$rowIndex === undefined ? 0 : _ref7$rowIndex;
	
	      if (this.Grid) {
	        this.Grid.recomputeGridSize({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex
	        });
	      }
	    }
	
	    /** See Grid#recomputeGridSize */
	
	  }, {
	    key: 'recomputeRowHeights',
	    value: function recomputeRowHeights() {
	      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.recomputeGridSize({
	          rowIndex: index,
	          columnIndex: 0
	        });
	      }
	    }
	
	    /** See Grid#scrollToPosition */
	
	  }, {
	    key: 'scrollToPosition',
	    value: function scrollToPosition() {
	      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.scrollToPosition({ scrollTop: scrollTop });
	      }
	    }
	
	    /** See Grid#scrollToCell */
	
	  }, {
	    key: 'scrollToRow',
	    value: function scrollToRow() {
	      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.scrollToCell({
	          columnIndex: 0,
	          rowIndex: index
	        });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          className = _props.className,
	          noRowsRenderer = _props.noRowsRenderer,
	          scrollToIndex = _props.scrollToIndex,
	          width = _props.width;
	
	
	      var classNames = (0, _classnames2.default)('ReactVirtualized__List', className);
	
	      return _react2.default.createElement(_Grid2.default, _extends({}, this.props, {
	        autoContainerWidth: true,
	        cellRenderer: this._cellRenderer,
	        className: classNames,
	        columnWidth: width,
	        columnCount: 1,
	        noContentRenderer: noRowsRenderer,
	        onScroll: this._onScroll,
	        onSectionRendered: this._onSectionRendered,
	        ref: this._setRef,
	        scrollToRow: scrollToIndex
	      }));
	    }
	  }]);
	
	  return List;
	}(_react2.default.PureComponent);
	
	List.defaultProps = {
	  autoHeight: false,
	  estimatedRowSize: 30,
	  onScroll: function onScroll() {},
	  noRowsRenderer: function noRowsRenderer() {
	    return null;
	  },
	  onRowsRendered: function onRowsRendered() {},
	  overscanIndicesGetter: _Grid.accessibilityOverscanIndicesGetter,
	  overscanRowCount: 10,
	  scrollToAlignment: 'auto',
	  scrollToIndex: -1,
	  style: {}
	};
	List.propTypes = {
	  "aria-label": __webpack_require__(1).string,
	  autoHeight: __webpack_require__(1).bool.isRequired,
	  className: __webpack_require__(1).string,
	  estimatedRowSize: __webpack_require__(1).number.isRequired,
	  height: __webpack_require__(1).number.isRequired,
	  noRowsRenderer: typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,
	  onRowsRendered: __webpack_require__(1).func.isRequired,
	  onScroll: __webpack_require__(1).func.isRequired,
	  overscanIndicesGetter: typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter === 'function' ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,
	  overscanRowCount: __webpack_require__(1).number.isRequired,
	  rowHeight: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
	  rowRenderer: typeof babelPluginFlowReactPropTypes_proptype_RowRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_RowRenderer : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_RowRenderer).isRequired,
	  rowCount: __webpack_require__(1).number.isRequired,
	  scrollToAlignment: typeof babelPluginFlowReactPropTypes_proptype_Alignment === 'function' ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : __webpack_require__(1).shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,
	  scrollToIndex: __webpack_require__(1).number.isRequired,
	  scrollTop: __webpack_require__(1).number,
	  style: __webpack_require__(1).object.isRequired,
	  tabIndex: __webpack_require__(1).number,
	  width: __webpack_require__(1).number.isRequired
	};
	exports.default = List;

/***/ }),
/* 828 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _List = __webpack_require__(827);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_List).default;
	  }
	});
	Object.defineProperty(exports, 'List', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_List).default;
	  }
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 829 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _intervalTree = __webpack_require__(848);
	
	var _intervalTree2 = _interopRequireDefault(_intervalTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// Position cache requirements:
	//   O(log(n)) lookup of cells to render for a given viewport size
	//   O(1) lookup of shortest measured column (so we know when to enter phase 1)
	var PositionCache = function () {
	  function PositionCache() {
	    _classCallCheck(this, PositionCache);
	
	    this._columnSizeMap = {};
	    this._intervalTree = (0, _intervalTree2.default)();
	    this._leftMap = {};
	  }
	  // Tracks the height of each column
	
	
	  // Store tops and bottoms of each cell for fast intersection lookup.
	
	
	  // Maps cell index to x coordinates for quick lookup.
	
	
	  _createClass(PositionCache, [{
	    key: 'estimateTotalHeight',
	    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {
	      var unmeasuredCellCount = cellCount - this.count;
	      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;
	    }
	
	    // Render all cells visible within the viewport range defined.
	
	  }, {
	    key: 'range',
	    value: function range(scrollTop, clientHeight, renderCallback) {
	      var _this = this;
	
	      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {
	        var _ref2 = _slicedToArray(_ref, 3),
	            top = _ref2[0],
	            _ = _ref2[1],
	            index = _ref2[2];
	
	        return renderCallback(index, _this._leftMap[index], top);
	      });
	    }
	  }, {
	    key: 'setPosition',
	    value: function setPosition(index, left, top, height) {
	      this._intervalTree.insert([top, top + height, index]);
	      this._leftMap[index] = left;
	
	      var columnSizeMap = this._columnSizeMap;
	      var columnHeight = columnSizeMap[left];
	      if (columnHeight === undefined) {
	        columnSizeMap[left] = top + height;
	      } else {
	        columnSizeMap[left] = Math.max(columnHeight, top + height);
	      }
	    }
	  }, {
	    key: 'count',
	    get: function get() {
	      return this._intervalTree.count;
	    }
	  }, {
	    key: 'shortestColumnSize',
	    get: function get() {
	      var columnSizeMap = this._columnSizeMap;
	
	      var size = 0;
	
	      for (var i in columnSizeMap) {
	        var height = columnSizeMap[i];
	        size = size === 0 ? height : Math.min(size, height);
	      }
	
	      return size;
	    }
	  }, {
	    key: 'tallestColumnSize',
	    get: function get() {
	      var columnSizeMap = this._columnSizeMap;
	
	      var size = 0;
	
	      for (var i in columnSizeMap) {
	        var height = columnSizeMap[i];
	        size = Math.max(size, height);
	      }
	
	      return size;
	    }
	  }]);
	
	  return PositionCache;
	}();
	
	exports.default = PositionCache;

/***/ }),
/* 830 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createCellPositioner;
	
	var babelPluginFlowReactPropTypes_proptype_Positioner = __webpack_require__(198).babelPluginFlowReactPropTypes_proptype_Positioner || __webpack_require__(1).any;
	
	var babelPluginFlowReactPropTypes_proptype_CellMeasurerCache = __webpack_require__(198).babelPluginFlowReactPropTypes_proptype_CellMeasurerCache || __webpack_require__(1).any;
	
	function createCellPositioner(_ref) {
	  var cellMeasurerCache = _ref.cellMeasurerCache,
	      columnCount = _ref.columnCount,
	      columnWidth = _ref.columnWidth,
	      _ref$spacer = _ref.spacer,
	      spacer = _ref$spacer === undefined ? 0 : _ref$spacer;
	
	  var columnHeights = void 0;
	
	  initOrResetDerivedValues();
	
	  function cellPositioner(index) {
	    // Find the shortest column and use it.
	    var columnIndex = 0;
	    for (var i = 1; i < columnHeights.length; i++) {
	      if (columnHeights[i] < columnHeights[columnIndex]) {
	        columnIndex = i;
	      }
	    }
	
	    var left = columnIndex * (columnWidth + spacer);
	    var top = columnHeights[columnIndex] || 0;
	
	    columnHeights[columnIndex] = top + cellMeasurerCache.getHeight(index) + spacer;
	
	    return {
	      left: left,
	      top: top
	    };
	  }
	
	  function initOrResetDerivedValues() {
	    // Track the height of each column.
	    // Layout algorithm below always inserts into the shortest column.
	    columnHeights = [];
	    for (var i = 0; i < columnCount; i++) {
	      columnHeights[i] = 0;
	    }
	  }
	
	  function reset(params) {
	    columnCount = params.columnCount;
	    columnWidth = params.columnWidth;
	    spacer = params.spacer;
	
	    initOrResetDerivedValues();
	  }
	
	  cellPositioner.reset = reset;
	
	  return cellPositioner;
	}

/***/ }),
/* 831 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Masonry = exports.createCellPositioner = undefined;
	
	var _createCellPositioner = __webpack_require__(830);
	
	var _createCellPositioner2 = _interopRequireDefault(_createCellPositioner);
	
	var _Masonry = __webpack_require__(198);
	
	var _Masonry2 = _interopRequireDefault(_Masonry);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _Masonry2.default;
	exports.createCellPositioner = _createCellPositioner2.default;
	exports.Masonry = _Masonry2.default;

/***/ }),
/* 832 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _CellMeasurer = __webpack_require__(335);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Caches measurements for a given cell.
	 */
	var CellMeasurerCacheDecorator = function () {
	  function CellMeasurerCacheDecorator() {
	    var _this = this;
	
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, CellMeasurerCacheDecorator);
	
	    this.columnWidth = function (_ref) {
	      var index = _ref.index;
	
	      _this._cellMeasurerCache.columnWidth({
	        index: index + _this._columnIndexOffset
	      });
	    };
	
	    this.rowHeight = function (_ref2) {
	      var index = _ref2.index;
	
	      _this._cellMeasurerCache.rowHeight({
	        index: index + _this._rowIndexOffset
	      });
	    };
	
	    var cellMeasurerCache = params.cellMeasurerCache,
	        _params$columnIndexOf = params.columnIndexOffset,
	        columnIndexOffset = _params$columnIndexOf === undefined ? 0 : _params$columnIndexOf,
	        _params$rowIndexOffse = params.rowIndexOffset,
	        rowIndexOffset = _params$rowIndexOffse === undefined ? 0 : _params$rowIndexOffse;
	
	
	    this._cellMeasurerCache = cellMeasurerCache;
	    this._columnIndexOffset = columnIndexOffset;
	    this._rowIndexOffset = rowIndexOffset;
	  }
	
	  _createClass(CellMeasurerCacheDecorator, [{
	    key: 'clear',
	    value: function clear(rowIndex, columnIndex) {
	      this._cellMeasurerCache.clear(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
	    }
	  }, {
	    key: 'clearAll',
	    value: function clearAll() {
	      this._cellMeasurerCache.clearAll();
	    }
	  }, {
	    key: 'hasFixedHeight',
	    value: function hasFixedHeight() {
	      return this._cellMeasurerCache.hasFixedHeight();
	    }
	  }, {
	    key: 'hasFixedWidth',
	    value: function hasFixedWidth() {
	      return this._cellMeasurerCache.hasFixedWidth();
	    }
	  }, {
	    key: 'getHeight',
	    value: function getHeight(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      return this._cellMeasurerCache.getHeight(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
	    }
	  }, {
	    key: 'getWidth',
	    value: function getWidth(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      return this._cellMeasurerCache.getWidth(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
	    }
	  }, {
	    key: 'has',
	    value: function has(rowIndex) {
	      var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      return this._cellMeasurerCache.has(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
	    }
	  }, {
	    key: 'set',
	    value: function set(rowIndex, columnIndex, width, height) {
	      this._cellMeasurerCache.set(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset, width, height);
	    }
	  }, {
	    key: 'defaultHeight',
	    get: function get() {
	      return this._cellMeasurerCache.defaultHeight;
	    }
	  }, {
	    key: 'defaultWidth',
	    get: function get() {
	      return this._cellMeasurerCache.defaultWidth;
	    }
	  }]);
	
	  return CellMeasurerCacheDecorator;
	}();
	
	exports.default = CellMeasurerCacheDecorator;

/***/ }),
/* 833 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _CellMeasurerCacheDecorator = __webpack_require__(832);
	
	var _CellMeasurerCacheDecorator2 = _interopRequireDefault(_CellMeasurerCacheDecorator);
	
	var _Grid = __webpack_require__(22);
	
	var _Grid2 = _interopRequireDefault(_Grid);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SCROLLBAR_SIZE_BUFFER = 20;
	
	/**
	 * Renders 1, 2, or 4 Grids depending on configuration.
	 * A main (body) Grid will always be rendered.
	 * Optionally, 1-2 Grids for sticky header rows will also be rendered.
	 * If no sticky columns, only 1 sticky header Grid will be rendered.
	 * If sticky columns, 2 sticky header Grids will be rendered.
	 */
	
	var MultiGrid = function (_PureComponent) {
	  _inherits(MultiGrid, _PureComponent);
	
	  function MultiGrid(props, context) {
	    _classCallCheck(this, MultiGrid);
	
	    var _this = _possibleConstructorReturn(this, (MultiGrid.__proto__ || Object.getPrototypeOf(MultiGrid)).call(this, props, context));
	
	    _this.state = {
	      scrollLeft: 0,
	      scrollTop: 0,
	      scrollbarSize: 0,
	      showHorizontalScrollbar: false,
	      showVerticalScrollbar: false
	    };
	
	    _this._deferredInvalidateColumnIndex = null;
	    _this._deferredInvalidateRowIndex = null;
	
	    _this._bottomLeftGridRef = _this._bottomLeftGridRef.bind(_this);
	    _this._bottomRightGridRef = _this._bottomRightGridRef.bind(_this);
	    _this._cellRendererBottomLeftGrid = _this._cellRendererBottomLeftGrid.bind(_this);
	    _this._cellRendererBottomRightGrid = _this._cellRendererBottomRightGrid.bind(_this);
	    _this._cellRendererTopRightGrid = _this._cellRendererTopRightGrid.bind(_this);
	    _this._columnWidthRightGrid = _this._columnWidthRightGrid.bind(_this);
	    _this._onScroll = _this._onScroll.bind(_this);
	    _this._onScrollbarPresenceChange = _this._onScrollbarPresenceChange.bind(_this);
	    _this._onScrollLeft = _this._onScrollLeft.bind(_this);
	    _this._onScrollTop = _this._onScrollTop.bind(_this);
	    _this._rowHeightBottomGrid = _this._rowHeightBottomGrid.bind(_this);
	    _this._topLeftGridRef = _this._topLeftGridRef.bind(_this);
	    _this._topRightGridRef = _this._topRightGridRef.bind(_this);
	    return _this;
	  }
	
	  _createClass(MultiGrid, [{
	    key: 'forceUpdateGrids',
	    value: function forceUpdateGrids() {
	      this._bottomLeftGrid && this._bottomLeftGrid.forceUpdate();
	      this._bottomRightGrid && this._bottomRightGrid.forceUpdate();
	      this._topLeftGrid && this._topLeftGrid.forceUpdate();
	      this._topRightGrid && this._topRightGrid.forceUpdate();
	    }
	
	    /** See Grid#invalidateCellSizeAfterRender */
	
	  }, {
	    key: 'invalidateCellSizeAfterRender',
	    value: function invalidateCellSizeAfterRender() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$columnIndex = _ref.columnIndex,
	          columnIndex = _ref$columnIndex === undefined ? 0 : _ref$columnIndex,
	          _ref$rowIndex = _ref.rowIndex,
	          rowIndex = _ref$rowIndex === undefined ? 0 : _ref$rowIndex;
	
	      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
	      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
	    }
	
	    /** See Grid#measureAllCells */
	
	  }, {
	    key: 'measureAllCells',
	    value: function measureAllCells() {
	      this._bottomLeftGrid && this._bottomLeftGrid.measureAllCells();
	      this._bottomRightGrid && this._bottomRightGrid.measureAllCells();
	      this._topLeftGrid && this._topLeftGrid.measureAllCells();
	      this._topRightGrid && this._topRightGrid.measureAllCells();
	    }
	
	    /** See Grid#recomputeGridSize */
	
	  }, {
	    key: 'recomputeGridSize',
	    value: function recomputeGridSize() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$columnIndex = _ref2.columnIndex,
	          columnIndex = _ref2$columnIndex === undefined ? 0 : _ref2$columnIndex,
	          _ref2$rowIndex = _ref2.rowIndex,
	          rowIndex = _ref2$rowIndex === undefined ? 0 : _ref2$rowIndex;
	
	      var _props = this.props,
	          fixedColumnCount = _props.fixedColumnCount,
	          fixedRowCount = _props.fixedRowCount;
	
	
	      var adjustedColumnIndex = Math.max(0, columnIndex - fixedColumnCount);
	      var adjustedRowIndex = Math.max(0, rowIndex - fixedRowCount);
	
	      this._bottomLeftGrid && this._bottomLeftGrid.recomputeGridSize({
	        columnIndex: columnIndex,
	        rowIndex: adjustedRowIndex
	      });
	      this._bottomRightGrid && this._bottomRightGrid.recomputeGridSize({
	        columnIndex: adjustedColumnIndex,
	        rowIndex: adjustedRowIndex
	      });
	      this._topLeftGrid && this._topLeftGrid.recomputeGridSize({
	        columnIndex: columnIndex,
	        rowIndex: rowIndex
	      });
	      this._topRightGrid && this._topRightGrid.recomputeGridSize({
	        columnIndex: adjustedColumnIndex,
	        rowIndex: rowIndex
	      });
	
	      this._leftGridWidth = null;
	      this._topGridHeight = null;
	      this._maybeCalculateCachedStyles(null, this.props, null, this.state);
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props2 = this.props,
	          scrollLeft = _props2.scrollLeft,
	          scrollTop = _props2.scrollTop;
	
	
	      if (scrollLeft > 0 || scrollTop > 0) {
	        var newState = {};
	
	        if (scrollLeft > 0) {
	          newState.scrollLeft = scrollLeft;
	        }
	
	        if (scrollTop > 0) {
	          newState.scrollTop = scrollTop;
	        }
	
	        this.setState(newState);
	      }
	      this._handleInvalidatedGridSize();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._handleInvalidatedGridSize();
	    }
	  }, {
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      var _props3 = this.props,
	          deferredMeasurementCache = _props3.deferredMeasurementCache,
	          fixedColumnCount = _props3.fixedColumnCount,
	          fixedRowCount = _props3.fixedRowCount;
	
	
	      this._maybeCalculateCachedStyles(null, this.props, null, this.state);
	
	      if (deferredMeasurementCache) {
	        this._deferredMeasurementCacheBottomLeftGrid = fixedRowCount > 0 ? new _CellMeasurerCacheDecorator2.default({
	          cellMeasurerCache: deferredMeasurementCache,
	          columnIndexOffset: 0,
	          rowIndexOffset: fixedRowCount
	        }) : deferredMeasurementCache;
	
	        this._deferredMeasurementCacheBottomRightGrid = fixedColumnCount > 0 || fixedRowCount > 0 ? new _CellMeasurerCacheDecorator2.default({
	          cellMeasurerCache: deferredMeasurementCache,
	          columnIndexOffset: fixedColumnCount,
	          rowIndexOffset: fixedRowCount
	        }) : deferredMeasurementCache;
	
	        this._deferredMeasurementCacheTopRightGrid = fixedColumnCount > 0 ? new _CellMeasurerCacheDecorator2.default({
	          cellMeasurerCache: deferredMeasurementCache,
	          columnIndexOffset: fixedColumnCount,
	          rowIndexOffset: 0
	        }) : deferredMeasurementCache;
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps, nextState) {
	      var _props4 = this.props,
	          columnWidth = _props4.columnWidth,
	          fixedColumnCount = _props4.fixedColumnCount,
	          fixedRowCount = _props4.fixedRowCount,
	          rowHeight = _props4.rowHeight;
	
	
	      if (columnWidth !== nextProps.columnWidth || fixedColumnCount !== nextProps.fixedColumnCount) {
	        this._leftGridWidth = null;
	      }
	
	      if (fixedRowCount !== nextProps.fixedRowCount || rowHeight !== nextProps.rowHeight) {
	        this._topGridHeight = null;
	      }
	
	      if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
	        var newState = {};
	
	        if (nextProps.scrollLeft != null && nextProps.scrollLeft >= 0) {
	          newState.scrollLeft = nextProps.scrollLeft;
	        }
	
	        if (nextProps.scrollTop != null && nextProps.scrollTop >= 0) {
	          newState.scrollTop = nextProps.scrollTop;
	        }
	
	        this.setState(newState);
	      }
	
	      this._maybeCalculateCachedStyles(this.props, nextProps, this.state, nextState);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props5 = this.props,
	          onScroll = _props5.onScroll,
	          onSectionRendered = _props5.onSectionRendered,
	          scrollLeftProp = _props5.scrollLeft,
	          scrollToColumn = _props5.scrollToColumn,
	          scrollTopProp = _props5.scrollTop,
	          scrollToRow = _props5.scrollToRow,
	          rest = _objectWithoutProperties(_props5, ['onScroll', 'onSectionRendered', 'scrollLeft', 'scrollToColumn', 'scrollTop', 'scrollToRow']);
	
	      // Don't render any of our Grids if there are no cells.
	      // This mirrors what Grid does,
	      // And prevents us from recording inaccurage measurements when used with CellMeasurer.
	
	
	      if (this.props.width === 0 || this.props.height === 0) {
	        return null;
	      }
	
	      // scrollTop and scrollLeft props are explicitly filtered out and ignored
	
	      var _state = this.state,
	          scrollLeft = _state.scrollLeft,
	          scrollTop = _state.scrollTop;
	
	
	      return _react2.default.createElement(
	        'div',
	        { style: this._containerOuterStyle },
	        _react2.default.createElement(
	          'div',
	          { style: this._containerTopStyle },
	          this._renderTopLeftGrid(rest),
	          this._renderTopRightGrid(_extends({}, rest, {
	            onScroll: onScroll,
	            scrollLeft: scrollLeft
	          }))
	        ),
	        _react2.default.createElement(
	          'div',
	          { style: this._containerBottomStyle },
	          this._renderBottomLeftGrid(_extends({}, rest, {
	            onScroll: onScroll,
	            scrollTop: scrollTop
	          })),
	          this._renderBottomRightGrid(_extends({}, rest, {
	            onScroll: onScroll,
	            onSectionRendered: onSectionRendered,
	            scrollLeft: scrollLeft,
	            scrollToColumn: scrollToColumn,
	            scrollToRow: scrollToRow,
	            scrollTop: scrollTop
	          }))
	        )
	      );
	    }
	  }, {
	    key: '_bottomLeftGridRef',
	    value: function _bottomLeftGridRef(ref) {
	      this._bottomLeftGrid = ref;
	    }
	  }, {
	    key: '_bottomRightGridRef',
	    value: function _bottomRightGridRef(ref) {
	      this._bottomRightGrid = ref;
	    }
	  }, {
	    key: '_cellRendererBottomLeftGrid',
	    value: function _cellRendererBottomLeftGrid(_ref3) {
	      var rowIndex = _ref3.rowIndex,
	          rest = _objectWithoutProperties(_ref3, ['rowIndex']);
	
	      var _props6 = this.props,
	          cellRenderer = _props6.cellRenderer,
	          fixedRowCount = _props6.fixedRowCount,
	          rowCount = _props6.rowCount;
	
	
	      if (rowIndex === rowCount - fixedRowCount) {
	        return _react2.default.createElement('div', {
	          key: rest.key,
	          style: _extends({}, rest.style, {
	            height: SCROLLBAR_SIZE_BUFFER
	          })
	        });
	      } else {
	        return cellRenderer(_extends({}, rest, {
	          parent: this,
	          rowIndex: rowIndex + fixedRowCount
	        }));
	      }
	    }
	  }, {
	    key: '_cellRendererBottomRightGrid',
	    value: function _cellRendererBottomRightGrid(_ref4) {
	      var columnIndex = _ref4.columnIndex,
	          rowIndex = _ref4.rowIndex,
	          rest = _objectWithoutProperties(_ref4, ['columnIndex', 'rowIndex']);
	
	      var _props7 = this.props,
	          cellRenderer = _props7.cellRenderer,
	          fixedColumnCount = _props7.fixedColumnCount,
	          fixedRowCount = _props7.fixedRowCount;
	
	
	      return cellRenderer(_extends({}, rest, {
	        columnIndex: columnIndex + fixedColumnCount,
	        parent: this,
	        rowIndex: rowIndex + fixedRowCount
	      }));
	    }
	  }, {
	    key: '_cellRendererTopRightGrid',
	    value: function _cellRendererTopRightGrid(_ref5) {
	      var columnIndex = _ref5.columnIndex,
	          rest = _objectWithoutProperties(_ref5, ['columnIndex']);
	
	      var _props8 = this.props,
	          cellRenderer = _props8.cellRenderer,
	          columnCount = _props8.columnCount,
	          fixedColumnCount = _props8.fixedColumnCount;
	
	
	      if (columnIndex === columnCount - fixedColumnCount) {
	        return _react2.default.createElement('div', {
	          key: rest.key,
	          style: _extends({}, rest.style, {
	            width: SCROLLBAR_SIZE_BUFFER
	          })
	        });
	      } else {
	        return cellRenderer(_extends({}, rest, {
	          columnIndex: columnIndex + fixedColumnCount,
	          parent: this
	        }));
	      }
	    }
	  }, {
	    key: '_columnWidthRightGrid',
	    value: function _columnWidthRightGrid(_ref6) {
	      var index = _ref6.index;
	      var _props9 = this.props,
	          columnCount = _props9.columnCount,
	          fixedColumnCount = _props9.fixedColumnCount,
	          columnWidth = _props9.columnWidth;
	      var _state2 = this.state,
	          scrollbarSize = _state2.scrollbarSize,
	          showHorizontalScrollbar = _state2.showHorizontalScrollbar;
	
	      // An extra cell is added to the count
	      // This gives the smaller Grid extra room for offset,
	      // In case the main (bottom right) Grid has a scrollbar
	      // If no scrollbar, the extra space is overflow:hidden anyway
	
	      if (showHorizontalScrollbar && index === columnCount - fixedColumnCount) {
	        return scrollbarSize;
	      }
	
	      return typeof columnWidth === 'function' ? columnWidth({ index: index + fixedColumnCount }) : columnWidth;
	    }
	  }, {
	    key: '_getBottomGridHeight',
	    value: function _getBottomGridHeight(props) {
	      var height = props.height;
	
	
	      var topGridHeight = this._getTopGridHeight(props);
	
	      return height - topGridHeight;
	    }
	  }, {
	    key: '_getLeftGridWidth',
	    value: function _getLeftGridWidth(props) {
	      var fixedColumnCount = props.fixedColumnCount,
	          columnWidth = props.columnWidth;
	
	
	      if (this._leftGridWidth == null) {
	        if (typeof columnWidth === 'function') {
	          var leftGridWidth = 0;
	
	          for (var index = 0; index < fixedColumnCount; index++) {
	            leftGridWidth += columnWidth({ index: index });
	          }
	
	          this._leftGridWidth = leftGridWidth;
	        } else {
	          this._leftGridWidth = columnWidth * fixedColumnCount;
	        }
	      }
	
	      return this._leftGridWidth;
	    }
	  }, {
	    key: '_getRightGridWidth',
	    value: function _getRightGridWidth(props) {
	      var width = props.width;
	
	
	      var leftGridWidth = this._getLeftGridWidth(props);
	
	      return width - leftGridWidth;
	    }
	  }, {
	    key: '_getTopGridHeight',
	    value: function _getTopGridHeight(props) {
	      var fixedRowCount = props.fixedRowCount,
	          rowHeight = props.rowHeight;
	
	
	      if (this._topGridHeight == null) {
	        if (typeof rowHeight === 'function') {
	          var topGridHeight = 0;
	
	          for (var index = 0; index < fixedRowCount; index++) {
	            topGridHeight += rowHeight({ index: index });
	          }
	
	          this._topGridHeight = topGridHeight;
	        } else {
	          this._topGridHeight = rowHeight * fixedRowCount;
	        }
	      }
	
	      return this._topGridHeight;
	    }
	  }, {
	    key: '_handleInvalidatedGridSize',
	    value: function _handleInvalidatedGridSize() {
	      if (typeof this._deferredInvalidateColumnIndex === 'number') {
	        var columnIndex = this._deferredInvalidateColumnIndex;
	        var rowIndex = this._deferredInvalidateRowIndex;
	
	        this._deferredInvalidateColumnIndex = null;
	        this._deferredInvalidateRowIndex = null;
	
	        this.recomputeGridSize({
	          columnIndex: columnIndex,
	          rowIndex: rowIndex
	        });
	        this.forceUpdate();
	      }
	    }
	
	    /**
	     * Avoid recreating inline styles each render; this bypasses Grid's shallowCompare.
	     * This method recalculates styles only when specific props change.
	     */
	
	  }, {
	    key: '_maybeCalculateCachedStyles',
	    value: function _maybeCalculateCachedStyles(prevProps, props) {
	      var columnWidth = props.columnWidth,
	          enableFixedColumnScroll = props.enableFixedColumnScroll,
	          enableFixedRowScroll = props.enableFixedRowScroll,
	          height = props.height,
	          fixedColumnCount = props.fixedColumnCount,
	          fixedRowCount = props.fixedRowCount,
	          rowHeight = props.rowHeight,
	          style = props.style,
	          styleBottomLeftGrid = props.styleBottomLeftGrid,
	          styleBottomRightGrid = props.styleBottomRightGrid,
	          styleTopLeftGrid = props.styleTopLeftGrid,
	          styleTopRightGrid = props.styleTopRightGrid,
	          width = props.width;
	
	
	      var firstRender = !prevProps;
	      var sizeChange = firstRender || height !== prevProps.height || width !== prevProps.width;
	      var leftSizeChange = firstRender || columnWidth !== prevProps.columnWidth || fixedColumnCount !== prevProps.fixedColumnCount;
	      var topSizeChange = firstRender || fixedRowCount !== prevProps.fixedRowCount || rowHeight !== prevProps.rowHeight;
	
	      if (firstRender || sizeChange || style !== prevProps.style) {
	        this._containerOuterStyle = _extends({
	          height: height,
	          overflow: 'visible', // Let :focus outline show through
	          width: width
	        }, style);
	      }
	
	      if (firstRender || sizeChange || topSizeChange) {
	        this._containerTopStyle = {
	          height: this._getTopGridHeight(props),
	          position: 'relative',
	          width: width
	        };
	
	        this._containerBottomStyle = {
	          height: height - this._getTopGridHeight(props),
	          overflow: 'visible', // Let :focus outline show through
	          position: 'relative',
	          width: width
	        };
	      }
	
	      if (firstRender || styleBottomLeftGrid !== prevProps.styleBottomLeftGrid) {
	        this._bottomLeftGridStyle = _extends({
	          left: 0,
	          overflowX: 'hidden',
	          overflowY: enableFixedColumnScroll ? 'auto' : 'hidden',
	          position: 'absolute'
	        }, styleBottomLeftGrid);
	      }
	
	      if (firstRender || leftSizeChange || styleBottomRightGrid !== prevProps.styleBottomRightGrid) {
	        this._bottomRightGridStyle = _extends({
	          left: this._getLeftGridWidth(props),
	          position: 'absolute'
	        }, styleBottomRightGrid);
	      }
	
	      if (firstRender || styleTopLeftGrid !== prevProps.styleTopLeftGrid) {
	        this._topLeftGridStyle = _extends({
	          left: 0,
	          overflowX: 'hidden',
	          overflowY: 'hidden',
	          position: 'absolute',
	          top: 0
	        }, styleTopLeftGrid);
	      }
	
	      if (firstRender || leftSizeChange || styleTopRightGrid !== prevProps.styleTopRightGrid) {
	        this._topRightGridStyle = _extends({
	          left: this._getLeftGridWidth(props),
	          overflowX: enableFixedRowScroll ? 'auto' : 'hidden',
	          overflowY: 'hidden',
	          position: 'absolute',
	          top: 0
	        }, styleTopRightGrid);
	      }
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(scrollInfo) {
	      var scrollLeft = scrollInfo.scrollLeft,
	          scrollTop = scrollInfo.scrollTop;
	
	      this.setState({
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop
	      });
	      var onScroll = this.props.onScroll;
	      if (onScroll) {
	        onScroll(scrollInfo);
	      }
	    }
	  }, {
	    key: '_onScrollbarPresenceChange',
	    value: function _onScrollbarPresenceChange(_ref7) {
	      var horizontal = _ref7.horizontal,
	          size = _ref7.size,
	          vertical = _ref7.vertical;
	      var _state3 = this.state,
	          showHorizontalScrollbar = _state3.showHorizontalScrollbar,
	          showVerticalScrollbar = _state3.showVerticalScrollbar;
	
	
	      if (horizontal !== showHorizontalScrollbar || vertical !== showVerticalScrollbar) {
	        this.setState({
	          scrollbarSize: size,
	          showHorizontalScrollbar: horizontal,
	          showVerticalScrollbar: vertical
	        });
	      }
	    }
	  }, {
	    key: '_onScrollLeft',
	    value: function _onScrollLeft(scrollInfo) {
	      var scrollLeft = scrollInfo.scrollLeft;
	
	      this._onScroll({
	        scrollLeft: scrollLeft,
	        scrollTop: this.state.scrollTop
	      });
	    }
	  }, {
	    key: '_onScrollTop',
	    value: function _onScrollTop(scrollInfo) {
	      var scrollTop = scrollInfo.scrollTop;
	
	      this._onScroll({
	        scrollTop: scrollTop,
	        scrollLeft: this.state.scrollLeft
	      });
	    }
	  }, {
	    key: '_renderBottomLeftGrid',
	    value: function _renderBottomLeftGrid(props) {
	      var enableFixedColumnScroll = props.enableFixedColumnScroll,
	          fixedColumnCount = props.fixedColumnCount,
	          fixedRowCount = props.fixedRowCount,
	          rowCount = props.rowCount,
	          scrollTop = props.scrollTop;
	      var showVerticalScrollbar = this.state.showVerticalScrollbar;
	
	
	      if (!fixedColumnCount) {
	        return null;
	      }
	
	      var additionalRowCount = showVerticalScrollbar ? 1 : 0;
	
	      return _react2.default.createElement(_Grid2.default, _extends({}, props, {
	        cellRenderer: this._cellRendererBottomLeftGrid,
	        className: this.props.classNameBottomLeftGrid,
	        columnCount: fixedColumnCount,
	        deferredMeasurementCache: this._deferredMeasurementCacheBottomLeftGrid,
	        height: this._getBottomGridHeight(props),
	        onScroll: enableFixedColumnScroll ? this._onScrollTop : undefined,
	        ref: this._bottomLeftGridRef,
	        rowCount: Math.max(0, rowCount - fixedRowCount) + additionalRowCount,
	        rowHeight: this._rowHeightBottomGrid,
	        scrollTop: scrollTop,
	        style: this._bottomLeftGridStyle,
	        tabIndex: null,
	        width: this._getLeftGridWidth(props)
	      }));
	    }
	  }, {
	    key: '_renderBottomRightGrid',
	    value: function _renderBottomRightGrid(props) {
	      var columnCount = props.columnCount,
	          fixedColumnCount = props.fixedColumnCount,
	          fixedRowCount = props.fixedRowCount,
	          rowCount = props.rowCount,
	          scrollToColumn = props.scrollToColumn,
	          scrollToRow = props.scrollToRow;
	
	
	      return _react2.default.createElement(_Grid2.default, _extends({}, props, {
	        cellRenderer: this._cellRendererBottomRightGrid,
	        className: this.props.classNameBottomRightGrid,
	        columnCount: Math.max(0, columnCount - fixedColumnCount),
	        columnWidth: this._columnWidthRightGrid,
	        deferredMeasurementCache: this._deferredMeasurementCacheBottomRightGrid,
	        height: this._getBottomGridHeight(props),
	        onScroll: this._onScroll,
	        onScrollbarPresenceChange: this._onScrollbarPresenceChange,
	        ref: this._bottomRightGridRef,
	        rowCount: Math.max(0, rowCount - fixedRowCount),
	        rowHeight: this._rowHeightBottomGrid,
	        scrollToColumn: scrollToColumn - fixedColumnCount,
	        scrollToRow: scrollToRow - fixedRowCount,
	        style: this._bottomRightGridStyle,
	        width: this._getRightGridWidth(props)
	      }));
	    }
	  }, {
	    key: '_renderTopLeftGrid',
	    value: function _renderTopLeftGrid(props) {
	      var fixedColumnCount = props.fixedColumnCount,
	          fixedRowCount = props.fixedRowCount;
	
	
	      if (!fixedColumnCount || !fixedRowCount) {
	        return null;
	      }
	
	      return _react2.default.createElement(_Grid2.default, _extends({}, props, {
	        className: this.props.classNameTopLeftGrid,
	        columnCount: fixedColumnCount,
	        height: this._getTopGridHeight(props),
	        ref: this._topLeftGridRef,
	        rowCount: fixedRowCount,
	        style: this._topLeftGridStyle,
	        tabIndex: null,
	        width: this._getLeftGridWidth(props)
	      }));
	    }
	  }, {
	    key: '_renderTopRightGrid',
	    value: function _renderTopRightGrid(props) {
	      var columnCount = props.columnCount,
	          enableFixedRowScroll = props.enableFixedRowScroll,
	          fixedColumnCount = props.fixedColumnCount,
	          fixedRowCount = props.fixedRowCount,
	          scrollLeft = props.scrollLeft;
	      var showHorizontalScrollbar = this.state.showHorizontalScrollbar;
	
	
	      if (!fixedRowCount) {
	        return null;
	      }
	
	      var additionalColumnCount = showHorizontalScrollbar ? 1 : 0;
	
	      return _react2.default.createElement(_Grid2.default, _extends({}, props, {
	        cellRenderer: this._cellRendererTopRightGrid,
	        className: this.props.classNameTopRightGrid,
	        columnCount: Math.max(0, columnCount - fixedColumnCount) + additionalColumnCount,
	        columnWidth: this._columnWidthRightGrid,
	        deferredMeasurementCache: this._deferredMeasurementCacheTopRightGrid,
	        height: this._getTopGridHeight(props),
	        onScroll: enableFixedRowScroll ? this._onScrollLeft : undefined,
	        ref: this._topRightGridRef,
	        rowCount: fixedRowCount,
	        scrollLeft: scrollLeft,
	        style: this._topRightGridStyle,
	        tabIndex: null,
	        width: this._getRightGridWidth(props)
	      }));
	    }
	  }, {
	    key: '_rowHeightBottomGrid',
	    value: function _rowHeightBottomGrid(_ref8) {
	      var index = _ref8.index;
	      var _props10 = this.props,
	          fixedRowCount = _props10.fixedRowCount,
	          rowCount = _props10.rowCount,
	          rowHeight = _props10.rowHeight;
	      var _state4 = this.state,
	          scrollbarSize = _state4.scrollbarSize,
	          showVerticalScrollbar = _state4.showVerticalScrollbar;
	
	      // An extra cell is added to the count
	      // This gives the smaller Grid extra room for offset,
	      // In case the main (bottom right) Grid has a scrollbar
	      // If no scrollbar, the extra space is overflow:hidden anyway
	
	      if (showVerticalScrollbar && index === rowCount - fixedRowCount) {
	        return scrollbarSize;
	      }
	
	      return typeof rowHeight === 'function' ? rowHeight({ index: index + fixedRowCount }) : rowHeight;
	    }
	  }, {
	    key: '_topLeftGridRef',
	    value: function _topLeftGridRef(ref) {
	      this._topLeftGrid = ref;
	    }
	  }, {
	    key: '_topRightGridRef',
	    value: function _topRightGridRef(ref) {
	      this._topRightGrid = ref;
	    }
	  }]);
	
	  return MultiGrid;
	}(_react.PureComponent);
	
	MultiGrid.defaultProps = {
	  classNameBottomLeftGrid: '',
	  classNameBottomRightGrid: '',
	  classNameTopLeftGrid: '',
	  classNameTopRightGrid: '',
	  enableFixedColumnScroll: false,
	  enableFixedRowScroll: false,
	  fixedColumnCount: 0,
	  fixedRowCount: 0,
	  scrollToColumn: -1,
	  scrollToRow: -1,
	  style: {},
	  styleBottomLeftGrid: {},
	  styleBottomRightGrid: {},
	  styleTopLeftGrid: {},
	  styleTopRightGrid: {}
	};
	exports.default = MultiGrid;
	MultiGrid.propTypes =  false ? {
	  classNameBottomLeftGrid: _propTypes2.default.string.isRequired,
	  classNameBottomRightGrid: _propTypes2.default.string.isRequired,
	  classNameTopLeftGrid: _propTypes2.default.string.isRequired,
	  classNameTopRightGrid: _propTypes2.default.string.isRequired,
	  enableFixedColumnScroll: _propTypes2.default.bool.isRequired,
	  enableFixedRowScroll: _propTypes2.default.bool.isRequired,
	  fixedColumnCount: _propTypes2.default.number.isRequired,
	  fixedRowCount: _propTypes2.default.number.isRequired,
	  style: _propTypes2.default.object.isRequired,
	  styleBottomLeftGrid: _propTypes2.default.object.isRequired,
	  styleBottomRightGrid: _propTypes2.default.object.isRequired,
	  styleTopLeftGrid: _propTypes2.default.object.isRequired,
	  styleTopRightGrid: _propTypes2.default.object.isRequired
	} : {};

/***/ }),
/* 834 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MultiGrid = undefined;
	
	var _MultiGrid = __webpack_require__(833);
	
	var _MultiGrid2 = _interopRequireDefault(_MultiGrid);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _MultiGrid2.default;
	exports.MultiGrid = _MultiGrid2.default;

/***/ }),
/* 835 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * HOC that simplifies the process of synchronizing scrolling between two or more virtualized components.
	 */
	var ScrollSync = function (_PureComponent) {
	  _inherits(ScrollSync, _PureComponent);
	
	  function ScrollSync(props, context) {
	    _classCallCheck(this, ScrollSync);
	
	    var _this = _possibleConstructorReturn(this, (ScrollSync.__proto__ || Object.getPrototypeOf(ScrollSync)).call(this, props, context));
	
	    _this.state = {
	      clientHeight: 0,
	      clientWidth: 0,
	      scrollHeight: 0,
	      scrollLeft: 0,
	      scrollTop: 0,
	      scrollWidth: 0
	    };
	
	    _this._onScroll = _this._onScroll.bind(_this);
	    return _this;
	  }
	
	  _createClass(ScrollSync, [{
	    key: 'render',
	    value: function render() {
	      var children = this.props.children;
	      var _state = this.state,
	          clientHeight = _state.clientHeight,
	          clientWidth = _state.clientWidth,
	          scrollHeight = _state.scrollHeight,
	          scrollLeft = _state.scrollLeft,
	          scrollTop = _state.scrollTop,
	          scrollWidth = _state.scrollWidth;
	
	
	      return children({
	        clientHeight: clientHeight,
	        clientWidth: clientWidth,
	        onScroll: this._onScroll,
	        scrollHeight: scrollHeight,
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop,
	        scrollWidth: scrollWidth
	      });
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(_ref) {
	      var clientHeight = _ref.clientHeight,
	          clientWidth = _ref.clientWidth,
	          scrollHeight = _ref.scrollHeight,
	          scrollLeft = _ref.scrollLeft,
	          scrollTop = _ref.scrollTop,
	          scrollWidth = _ref.scrollWidth;
	
	      this.setState({
	        clientHeight: clientHeight,
	        clientWidth: clientWidth,
	        scrollHeight: scrollHeight,
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop,
	        scrollWidth: scrollWidth
	      });
	    }
	  }]);
	
	  return ScrollSync;
	}(_react.PureComponent);
	
	exports.default = ScrollSync;
	ScrollSync.propTypes =  false ? {
	  /**
	   * Function responsible for rendering 2 or more virtualized components.
	   * This function should implement the following signature:
	   * ({ onScroll, scrollLeft, scrollTop }) => PropTypes.element
	   */
	  children: _propTypes2.default.func.isRequired
	} : {};

/***/ }),
/* 836 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ScrollSync = undefined;
	
	var _ScrollSync = __webpack_require__(835);
	
	var _ScrollSync2 = _interopRequireDefault(_ScrollSync);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _ScrollSync2.default;
	exports.ScrollSync = _ScrollSync2.default;

/***/ }),
/* 837 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _classnames = __webpack_require__(13);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Column = __webpack_require__(338);
	
	var _Column2 = _interopRequireDefault(_Column);
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(36);
	
	var _Grid2 = __webpack_require__(22);
	
	var _Grid3 = _interopRequireDefault(_Grid2);
	
	var _defaultRowRenderer = __webpack_require__(344);
	
	var _defaultRowRenderer2 = _interopRequireDefault(_defaultRowRenderer);
	
	var _defaultHeaderRowRenderer = __webpack_require__(343);
	
	var _defaultHeaderRowRenderer2 = _interopRequireDefault(_defaultHeaderRowRenderer);
	
	var _SortDirection = __webpack_require__(120);
	
	var _SortDirection2 = _interopRequireDefault(_SortDirection);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var babelPluginFlowReactPropTypes_proptype_CellPosition = __webpack_require__(22).babelPluginFlowReactPropTypes_proptype_CellPosition || __webpack_require__(1).any;
	
	/**
	 * Table component with fixed headers and virtualized rows for improved performance with large data sets.
	 * This component expects explicit width, height, and padding parameters.
	 */
	var Table = function (_PureComponent) {
	  _inherits(Table, _PureComponent);
	
	  function Table(props) {
	    _classCallCheck(this, Table);
	
	    var _this = _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).call(this, props));
	
	    _this.state = {
	      scrollbarWidth: 0
	    };
	
	    _this._createColumn = _this._createColumn.bind(_this);
	    _this._createRow = _this._createRow.bind(_this);
	    _this._onScroll = _this._onScroll.bind(_this);
	    _this._onSectionRendered = _this._onSectionRendered.bind(_this);
	    _this._setRef = _this._setRef.bind(_this);
	    return _this;
	  }
	
	  _createClass(Table, [{
	    key: 'forceUpdateGrid',
	    value: function forceUpdateGrid() {
	      if (this.Grid) {
	        this.Grid.forceUpdate();
	      }
	    }
	
	    /** See Grid#getOffsetForCell */
	
	  }, {
	    key: 'getOffsetForRow',
	    value: function getOffsetForRow(_ref) {
	      var alignment = _ref.alignment,
	          index = _ref.index;
	
	      if (this.Grid) {
	        var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({
	          alignment: alignment,
	          rowIndex: index
	        }),
	            scrollTop = _Grid$getOffsetForCel.scrollTop;
	
	        return scrollTop;
	      }
	      return 0;
	    }
	
	    /** CellMeasurer compatibility */
	
	  }, {
	    key: 'invalidateCellSizeAfterRender',
	    value: function invalidateCellSizeAfterRender(_ref2) {
	      var columnIndex = _ref2.columnIndex,
	          rowIndex = _ref2.rowIndex;
	
	      if (this.Grid) {
	        this.Grid.invalidateCellSizeAfterRender({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex
	        });
	      }
	    }
	
	    /** See Grid#measureAllCells */
	
	  }, {
	    key: 'measureAllRows',
	    value: function measureAllRows() {
	      if (this.Grid) {
	        this.Grid.measureAllCells();
	      }
	    }
	
	    /** CellMeasurer compatibility */
	
	  }, {
	    key: 'recomputeGridSize',
	    value: function recomputeGridSize() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$columnIndex = _ref3.columnIndex,
	          columnIndex = _ref3$columnIndex === undefined ? 0 : _ref3$columnIndex,
	          _ref3$rowIndex = _ref3.rowIndex,
	          rowIndex = _ref3$rowIndex === undefined ? 0 : _ref3$rowIndex;
	
	      if (this.Grid) {
	        this.Grid.recomputeGridSize({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex
	        });
	      }
	    }
	
	    /** See Grid#recomputeGridSize */
	
	  }, {
	    key: 'recomputeRowHeights',
	    value: function recomputeRowHeights() {
	      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.recomputeGridSize({
	          rowIndex: index
	        });
	      }
	    }
	
	    /** See Grid#scrollToPosition */
	
	  }, {
	    key: 'scrollToPosition',
	    value: function scrollToPosition() {
	      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.scrollToPosition({ scrollTop: scrollTop });
	      }
	    }
	
	    /** See Grid#scrollToCell */
	
	  }, {
	    key: 'scrollToRow',
	    value: function scrollToRow() {
	      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      if (this.Grid) {
	        this.Grid.scrollToCell({
	          columnIndex: 0,
	          rowIndex: index
	        });
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this._setScrollbarWidth();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._setScrollbarWidth();
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var _props = this.props,
	          children = _props.children,
	          className = _props.className,
	          disableHeader = _props.disableHeader,
	          gridClassName = _props.gridClassName,
	          gridStyle = _props.gridStyle,
	          headerHeight = _props.headerHeight,
	          headerRowRenderer = _props.headerRowRenderer,
	          height = _props.height,
	          id = _props.id,
	          noRowsRenderer = _props.noRowsRenderer,
	          rowClassName = _props.rowClassName,
	          rowStyle = _props.rowStyle,
	          scrollToIndex = _props.scrollToIndex,
	          style = _props.style,
	          width = _props.width;
	      var scrollbarWidth = this.state.scrollbarWidth;
	
	
	      var availableRowsHeight = disableHeader ? height : height - headerHeight;
	
	      var rowClass = typeof rowClassName === 'function' ? rowClassName({ index: -1 }) : rowClassName;
	      var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({ index: -1 }) : rowStyle;
	
	      // Precompute and cache column styles before rendering rows and columns to speed things up
	      this._cachedColumnStyles = [];
	      _react2.default.Children.toArray(children).forEach(function (column, index) {
	        var flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);
	
	        _this2._cachedColumnStyles[index] = _extends({}, flexStyles, {
	          overflow: 'hidden'
	        });
	      });
	
	      // Note that we specify :rowCount, :scrollbarWidth, :sortBy, and :sortDirection as properties on Grid even though these have nothing to do with Grid.
	      // This is done because Grid is a pure component and won't update unless its properties or state has changed.
	      // Any property that should trigger a re-render of Grid then is specified here to avoid a stale display.
	      return _react2.default.createElement(
	        'div',
	        {
	          className: (0, _classnames2.default)('ReactVirtualized__Table', className),
	          id: id,
	          role: 'grid',
	          style: style },
	        !disableHeader && headerRowRenderer({
	          className: (0, _classnames2.default)('ReactVirtualized__Table__headerRow', rowClass),
	          columns: this._getHeaderColumns(),
	          style: _extends({}, rowStyleObject, {
	            height: headerHeight,
	            overflow: 'hidden',
	            paddingRight: scrollbarWidth,
	            width: width
	          })
	        }),
	        _react2.default.createElement(_Grid3.default, _extends({}, this.props, {
	          autoContainerWidth: true,
	          className: (0, _classnames2.default)('ReactVirtualized__Table__Grid', gridClassName),
	          cellRenderer: this._createRow,
	          columnWidth: width,
	          columnCount: 1,
	          height: availableRowsHeight,
	          id: undefined,
	          noContentRenderer: noRowsRenderer,
	          onScroll: this._onScroll,
	          onSectionRendered: this._onSectionRendered,
	          ref: this._setRef,
	          role: 'rowgroup',
	          scrollbarWidth: scrollbarWidth,
	          scrollToRow: scrollToIndex,
	          style: _extends({}, gridStyle, {
	            overflowX: 'hidden'
	          })
	        }))
	      );
	    }
	  }, {
	    key: '_createColumn',
	    value: function _createColumn(_ref4) {
	      var column = _ref4.column,
	          columnIndex = _ref4.columnIndex,
	          isScrolling = _ref4.isScrolling,
	          parent = _ref4.parent,
	          rowData = _ref4.rowData,
	          rowIndex = _ref4.rowIndex;
	      var _column$props = column.props,
	          cellDataGetter = _column$props.cellDataGetter,
	          cellRenderer = _column$props.cellRenderer,
	          className = _column$props.className,
	          columnData = _column$props.columnData,
	          dataKey = _column$props.dataKey,
	          id = _column$props.id;
	
	
	      var cellData = cellDataGetter({ columnData: columnData, dataKey: dataKey, rowData: rowData });
	      var renderedCell = cellRenderer({
	        cellData: cellData,
	        columnData: columnData,
	        columnIndex: columnIndex,
	        dataKey: dataKey,
	        isScrolling: isScrolling,
	        parent: parent,
	        rowData: rowData,
	        rowIndex: rowIndex
	      });
	
	      var style = this._cachedColumnStyles[columnIndex];
	
	      var title = typeof renderedCell === 'string' ? renderedCell : null;
	
	      var a11yProps = {
	        role: 'gridcell'
	      };
	
	      if (id) {
	        a11yProps['aria-describedby'] = id;
	      }
	
	      return _react2.default.createElement(
	        'div',
	        _extends({}, a11yProps, {
	          key: 'Row' + rowIndex + '-Col' + columnIndex,
	          className: (0, _classnames2.default)('ReactVirtualized__Table__rowColumn', className),
	          style: style,
	          title: title }),
	        renderedCell
	      );
	    }
	  }, {
	    key: '_createHeader',
	    value: function _createHeader(_ref5) {
	      var column = _ref5.column,
	          index = _ref5.index;
	      var _props2 = this.props,
	          headerClassName = _props2.headerClassName,
	          headerStyle = _props2.headerStyle,
	          onHeaderClick = _props2.onHeaderClick,
	          sort = _props2.sort,
	          sortBy = _props2.sortBy,
	          sortDirection = _props2.sortDirection;
	      var _column$props2 = column.props,
	          dataKey = _column$props2.dataKey,
	          disableSort = _column$props2.disableSort,
	          headerRenderer = _column$props2.headerRenderer,
	          id = _column$props2.id,
	          label = _column$props2.label,
	          columnData = _column$props2.columnData,
	          defaultSortDirection = _column$props2.defaultSortDirection;
	
	      var sortEnabled = !disableSort && sort;
	
	      var classNames = (0, _classnames2.default)('ReactVirtualized__Table__headerColumn', headerClassName, column.props.headerClassName, {
	        ReactVirtualized__Table__sortableHeaderColumn: sortEnabled
	      });
	      var style = this._getFlexStyleForColumn(column, _extends({}, headerStyle, column.props.headerStyle));
	
	      var renderedHeader = headerRenderer({
	        columnData: columnData,
	        dataKey: dataKey,
	        disableSort: disableSort,
	        label: label,
	        sortBy: sortBy,
	        sortDirection: sortDirection
	      });
	
	      var a11yProps = {
	        role: 'columnheader'
	      };
	
	      if (sortEnabled || onHeaderClick) {
	        // If this is a sortable header, clicking it should update the table data's sorting.
	        var isFirstTimeSort = sortBy !== dataKey;
	
	        // If this is the firstTime sort of this column, use the column default sort order.
	        // Otherwise, invert the direction of the sort.
	        var newSortDirection = isFirstTimeSort ? defaultSortDirection : sortDirection === _SortDirection2.default.DESC ? _SortDirection2.default.ASC : _SortDirection2.default.DESC;
	
	        var onClick = function onClick(event) {
	          sortEnabled && sort({
	            sortBy: dataKey,
	            sortDirection: newSortDirection
	          });
	          onHeaderClick && onHeaderClick({ columnData: columnData, dataKey: dataKey, event: event });
	        };
	
	        var onKeyDown = function onKeyDown(event) {
	          if (event.key === 'Enter' || event.key === ' ') {
	            onClick(event);
	          }
	        };
	
	        a11yProps['aria-label'] = column.props['aria-label'] || label || dataKey;
	        a11yProps.tabIndex = 0;
	        a11yProps.onClick = onClick;
	        a11yProps.onKeyDown = onKeyDown;
	      }
	
	      if (sortBy === dataKey) {
	        a11yProps['aria-sort'] = sortDirection === _SortDirection2.default.ASC ? 'ascending' : 'descending';
	      }
	
	      if (id) {
	        a11yProps.id = id;
	      }
	
	      return _react2.default.createElement(
	        'div',
	        _extends({}, a11yProps, {
	          key: 'Header-Col' + index,
	          className: classNames,
	          style: style }),
	        renderedHeader
	      );
	    }
	  }, {
	    key: '_createRow',
	    value: function _createRow(_ref6) {
	      var _this3 = this;
	
	      var index = _ref6.rowIndex,
	          isScrolling = _ref6.isScrolling,
	          key = _ref6.key,
	          parent = _ref6.parent,
	          style = _ref6.style;
	      var _props3 = this.props,
	          children = _props3.children,
	          onRowClick = _props3.onRowClick,
	          onRowDoubleClick = _props3.onRowDoubleClick,
	          onRowRightClick = _props3.onRowRightClick,
	          onRowMouseOver = _props3.onRowMouseOver,
	          onRowMouseOut = _props3.onRowMouseOut,
	          rowClassName = _props3.rowClassName,
	          rowGetter = _props3.rowGetter,
	          rowRenderer = _props3.rowRenderer,
	          rowStyle = _props3.rowStyle;
	      var scrollbarWidth = this.state.scrollbarWidth;
	
	
	      var rowClass = typeof rowClassName === 'function' ? rowClassName({ index: index }) : rowClassName;
	      var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({ index: index }) : rowStyle;
	      var rowData = rowGetter({ index: index });
	
	      var columns = _react2.default.Children.toArray(children).map(function (column, columnIndex) {
	        return _this3._createColumn({
	          column: column,
	          columnIndex: columnIndex,
	          isScrolling: isScrolling,
	          parent: parent,
	          rowData: rowData,
	          rowIndex: index,
	          scrollbarWidth: scrollbarWidth
	        });
	      });
	
	      var className = (0, _classnames2.default)('ReactVirtualized__Table__row', rowClass);
	      var flattenedStyle = _extends({}, style, rowStyleObject, {
	        height: this._getRowHeight(index),
	        overflow: 'hidden',
	        paddingRight: scrollbarWidth
	      });
	
	      return rowRenderer({
	        className: className,
	        columns: columns,
	        index: index,
	        isScrolling: isScrolling,
	        key: key,
	        onRowClick: onRowClick,
	        onRowDoubleClick: onRowDoubleClick,
	        onRowRightClick: onRowRightClick,
	        onRowMouseOver: onRowMouseOver,
	        onRowMouseOut: onRowMouseOut,
	        rowData: rowData,
	        style: flattenedStyle
	      });
	    }
	
	    /**
	     * Determines the flex-shrink, flex-grow, and width values for a cell (header or column).
	     */
	
	  }, {
	    key: '_getFlexStyleForColumn',
	    value: function _getFlexStyleForColumn(column) {
	      var customStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      var flexValue = column.props.flexGrow + ' ' + column.props.flexShrink + ' ' + column.props.width + 'px';
	
	      var style = _extends({}, customStyle, {
	        flex: flexValue,
	        msFlex: flexValue,
	        WebkitFlex: flexValue
	      });
	
	      if (column.props.maxWidth) {
	        style.maxWidth = column.props.maxWidth;
	      }
	
	      if (column.props.minWidth) {
	        style.minWidth = column.props.minWidth;
	      }
	
	      return style;
	    }
	  }, {
	    key: '_getHeaderColumns',
	    value: function _getHeaderColumns() {
	      var _this4 = this;
	
	      var _props4 = this.props,
	          children = _props4.children,
	          disableHeader = _props4.disableHeader;
	
	      var items = disableHeader ? [] : _react2.default.Children.toArray(children);
	
	      return items.map(function (column, index) {
	        return _this4._createHeader({ column: column, index: index });
	      });
	    }
	  }, {
	    key: '_getRowHeight',
	    value: function _getRowHeight(rowIndex) {
	      var rowHeight = this.props.rowHeight;
	
	
	      return typeof rowHeight === 'function' ? rowHeight({ index: rowIndex }) : rowHeight;
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(_ref7) {
	      var clientHeight = _ref7.clientHeight,
	          scrollHeight = _ref7.scrollHeight,
	          scrollTop = _ref7.scrollTop;
	      var onScroll = this.props.onScroll;
	
	
	      onScroll({ clientHeight: clientHeight, scrollHeight: scrollHeight, scrollTop: scrollTop });
	    }
	  }, {
	    key: '_onSectionRendered',
	    value: function _onSectionRendered(_ref8) {
	      var rowOverscanStartIndex = _ref8.rowOverscanStartIndex,
	          rowOverscanStopIndex = _ref8.rowOverscanStopIndex,
	          rowStartIndex = _ref8.rowStartIndex,
	          rowStopIndex = _ref8.rowStopIndex;
	      var onRowsRendered = this.props.onRowsRendered;
	
	
	      onRowsRendered({
	        overscanStartIndex: rowOverscanStartIndex,
	        overscanStopIndex: rowOverscanStopIndex,
	        startIndex: rowStartIndex,
	        stopIndex: rowStopIndex
	      });
	    }
	  }, {
	    key: '_setRef',
	    value: function _setRef(ref) {
	      this.Grid = ref;
	    }
	  }, {
	    key: '_setScrollbarWidth',
	    value: function _setScrollbarWidth() {
	      if (this.Grid) {
	        var _Grid = (0, _reactDom.findDOMNode)(this.Grid);
	        var clientWidth = _Grid.clientWidth || 0;
	        var offsetWidth = _Grid.offsetWidth || 0;
	        var scrollbarWidth = offsetWidth - clientWidth;
	
	        this.setState({ scrollbarWidth: scrollbarWidth });
	      }
	    }
	  }]);
	
	  return Table;
	}(_react.PureComponent);
	
	Table.defaultProps = {
	  disableHeader: false,
	  estimatedRowSize: 30,
	  headerHeight: 0,
	  headerStyle: {},
	  noRowsRenderer: function noRowsRenderer() {
	    return null;
	  },
	  onRowsRendered: function onRowsRendered() {
	    return null;
	  },
	  onScroll: function onScroll() {
	    return null;
	  },
	  overscanIndicesGetter: _Grid2.accessibilityOverscanIndicesGetter,
	  overscanRowCount: 10,
	  rowRenderer: _defaultRowRenderer2.default,
	  headerRowRenderer: _defaultHeaderRowRenderer2.default,
	  rowStyle: {},
	  scrollToAlignment: 'auto',
	  scrollToIndex: -1,
	  style: {}
	};
	exports.default = Table;
	Table.propTypes =  false ? {
	  'aria-label': _propTypes2.default.string,
	
	  /**
	   * Removes fixed height from the scrollingContainer so that the total height
	   * of rows can stretch the window. Intended for use with WindowScroller
	   */
	  autoHeight: _propTypes2.default.bool,
	
	  /** One or more Columns describing the data displayed in this row */
	  children: function children(props) {
	    var children = _react2.default.Children.toArray(props.children);
	    for (var i = 0; i < children.length; i++) {
	      var childType = children[i].type;
	      if (childType !== _Column2.default && !(childType.prototype instanceof _Column2.default)) {
	        return new Error('Table only accepts children of type Column');
	      }
	    }
	  },
	
	  /** Optional CSS class name */
	  className: _propTypes2.default.string,
	
	  /** Disable rendering the header at all */
	  disableHeader: _propTypes2.default.bool,
	
	  /**
	   * Used to estimate the total height of a Table before all of its rows have actually been measured.
	   * The estimated total height is adjusted as rows are rendered.
	   */
	  estimatedRowSize: _propTypes2.default.number.isRequired,
	
	  /** Optional custom CSS class name to attach to inner Grid element. */
	  gridClassName: _propTypes2.default.string,
	
	  /** Optional inline style to attach to inner Grid element. */
	  gridStyle: _propTypes2.default.object,
	
	  /** Optional CSS class to apply to all column headers */
	  headerClassName: _propTypes2.default.string,
	
	  /** Fixed height of header row */
	  headerHeight: _propTypes2.default.number.isRequired,
	
	  /**
	   * Responsible for rendering a table row given an array of columns:
	   * Should implement the following interface: ({
	   *   className: string,
	   *   columns: any[],
	   *   style: any
	   * }): PropTypes.node
	   */
	  headerRowRenderer: _propTypes2.default.func,
	
	  /** Optional custom inline style to attach to table header columns. */
	  headerStyle: _propTypes2.default.object,
	
	  /** Fixed/available height for out DOM element */
	  height: _propTypes2.default.number.isRequired,
	
	  /** Optional id */
	  id: _propTypes2.default.string,
	
	  /** Optional renderer to be used in place of table body rows when rowCount is 0 */
	  noRowsRenderer: _propTypes2.default.func,
	
	  /**
	  * Optional callback when a column's header is clicked.
	  * ({ columnData: any, dataKey: string }): void
	  */
	  onHeaderClick: _propTypes2.default.func,
	
	  /**
	   * Callback invoked when a user clicks on a table row.
	   * ({ index: number }): void
	   */
	  onRowClick: _propTypes2.default.func,
	
	  /**
	   * Callback invoked when a user double-clicks on a table row.
	   * ({ index: number }): void
	   */
	  onRowDoubleClick: _propTypes2.default.func,
	
	  /**
	   * Callback invoked when the mouse leaves a table row.
	   * ({ index: number }): void
	   */
	  onRowMouseOut: _propTypes2.default.func,
	
	  /**
	   * Callback invoked when a user moves the mouse over a table row.
	   * ({ index: number }): void
	   */
	  onRowMouseOver: _propTypes2.default.func,
	
	  /**
	   * Callback invoked when a user right-clicks on a table row.
	   * ({ index: number }): void
	   */
	  onRowRightClick: _propTypes2.default.func,
	
	  /**
	   * Callback invoked with information about the slice of rows that were just rendered.
	   * ({ startIndex, stopIndex }): void
	   */
	  onRowsRendered: _propTypes2.default.func,
	
	  /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   * ({ clientHeight, scrollHeight, scrollTop }): void
	   */
	  onScroll: _propTypes2.default.func.isRequired,
	
	  /** See Grid#overscanIndicesGetter */
	  overscanIndicesGetter: _propTypes2.default.func.isRequired,
	
	  /**
	   * Number of rows to render above/below the visible bounds of the list.
	   * These rows can help for smoother scrolling on touch devices.
	   */
	  overscanRowCount: _propTypes2.default.number.isRequired,
	
	  /**
	   * Optional CSS class to apply to all table rows (including the header row).
	   * This property can be a CSS class name (string) or a function that returns a class name.
	   * If a function is provided its signature should be: ({ index: number }): string
	   */
	  rowClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
	
	  /**
	   * Callback responsible for returning a data row given an index.
	   * ({ index: number }): any
	   */
	  rowGetter: _propTypes2.default.func.isRequired,
	
	  /**
	   * Either a fixed row height (number) or a function that returns the height of a row given its index.
	   * ({ index: number }): number
	   */
	  rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]).isRequired,
	
	  /** Number of rows in table. */
	  rowCount: _propTypes2.default.number.isRequired,
	
	  /**
	   * Responsible for rendering a table row given an array of columns:
	   * Should implement the following interface: ({
	   *   className: string,
	   *   columns: Array,
	   *   index: number,
	   *   isScrolling: boolean,
	   *   onRowClick: ?Function,
	   *   onRowDoubleClick: ?Function,
	   *   onRowMouseOver: ?Function,
	   *   onRowMouseOut: ?Function,
	   *   rowData: any,
	   *   style: any
	   * }): PropTypes.node
	   */
	  rowRenderer: _propTypes2.default.func,
	
	  /** Optional custom inline style to attach to table rows. */
	  rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]).isRequired,
	
	  /** See Grid#scrollToAlignment */
	  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,
	
	  /** Row index to ensure visible (by forcefully scrolling if necessary) */
	  scrollToIndex: _propTypes2.default.number.isRequired,
	
	  /** Vertical offset. */
	  scrollTop: _propTypes2.default.number,
	
	  /**
	   * Sort function to be called if a sortable header is clicked.
	   * ({ sortBy: string, sortDirection: SortDirection }): void
	   */
	  sort: _propTypes2.default.func,
	
	  /** Table data is currently sorted by this :dataKey (if it is sorted at all) */
	  sortBy: _propTypes2.default.string,
	
	  /** Table data is currently sorted in this direction (if it is sorted at all) */
	  sortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC]),
	
	  /** Optional inline style */
	  style: _propTypes2.default.object,
	
	  /** Tab index for focus */
	  tabIndex: _propTypes2.default.number,
	
	  /** Width of list */
	  width: _propTypes2.default.number.isRequired
	} : {};

/***/ }),
/* 838 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Table = exports.SortIndicator = exports.SortDirection = exports.Column = exports.defaultRowRenderer = exports.defaultHeaderRenderer = exports.defaultHeaderRowRenderer = exports.defaultCellRenderer = exports.defaultCellDataGetter = undefined;
	
	var _defaultCellDataGetter = __webpack_require__(340);
	
	var _defaultCellDataGetter2 = _interopRequireDefault(_defaultCellDataGetter);
	
	var _defaultCellRenderer = __webpack_require__(341);
	
	var _defaultCellRenderer2 = _interopRequireDefault(_defaultCellRenderer);
	
	var _defaultHeaderRowRenderer = __webpack_require__(343);
	
	var _defaultHeaderRowRenderer2 = _interopRequireDefault(_defaultHeaderRowRenderer);
	
	var _defaultHeaderRenderer = __webpack_require__(342);
	
	var _defaultHeaderRenderer2 = _interopRequireDefault(_defaultHeaderRenderer);
	
	var _defaultRowRenderer = __webpack_require__(344);
	
	var _defaultRowRenderer2 = _interopRequireDefault(_defaultRowRenderer);
	
	var _Column = __webpack_require__(338);
	
	var _Column2 = _interopRequireDefault(_Column);
	
	var _SortDirection = __webpack_require__(120);
	
	var _SortDirection2 = _interopRequireDefault(_SortDirection);
	
	var _SortIndicator = __webpack_require__(339);
	
	var _SortIndicator2 = _interopRequireDefault(_SortIndicator);
	
	var _Table = __webpack_require__(837);
	
	var _Table2 = _interopRequireDefault(_Table);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _Table2.default;
	exports.defaultCellDataGetter = _defaultCellDataGetter2.default;
	exports.defaultCellRenderer = _defaultCellRenderer2.default;
	exports.defaultHeaderRowRenderer = _defaultHeaderRowRenderer2.default;
	exports.defaultHeaderRenderer = _defaultHeaderRenderer2.default;
	exports.defaultRowRenderer = _defaultRowRenderer2.default;
	exports.Column = _Column2.default;
	exports.SortDirection = _SortDirection2.default;
	exports.SortIndicator = _SortIndicator2.default;
	exports.Table = _Table2.default;

/***/ }),
/* 839 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IS_SCROLLING_TIMEOUT = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(1);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _reactDom = __webpack_require__(36);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _onScroll = __webpack_require__(842);
	
	var _dimensions = __webpack_require__(841);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
	 * This improves performance and makes scrolling smoother.
	 */
	var IS_SCROLLING_TIMEOUT = exports.IS_SCROLLING_TIMEOUT = 150;
	
	var WindowScroller = function (_PureComponent) {
	  _inherits(WindowScroller, _PureComponent);
	
	  function WindowScroller(props) {
	    _classCallCheck(this, WindowScroller);
	
	    // Handle server-side rendering case
	    var _this = _possibleConstructorReturn(this, (WindowScroller.__proto__ || Object.getPrototypeOf(WindowScroller)).call(this, props));
	
	    var _ref = typeof window !== 'undefined' ? (0, _dimensions.getDimensions)(props.scrollElement || window) : { width: 0, height: 0 },
	        width = _ref.width,
	        height = _ref.height;
	
	    _this.state = {
	      height: height,
	      width: width,
	      isScrolling: false,
	      scrollLeft: 0,
	      scrollTop: 0
	    };
	
	    _this._onResize = _this._onResize.bind(_this);
	    _this._onChildScroll = _this._onChildScroll.bind(_this);
	    _this.__handleWindowScrollEvent = _this.__handleWindowScrollEvent.bind(_this);
	    _this.__resetIsScrolling = _this.__resetIsScrolling.bind(_this);
	    return _this;
	  }
	
	  // Can’t use defaultProps for scrollElement without breaking server-side rendering
	
	
	  _createClass(WindowScroller, [{
	    key: 'updatePosition',
	    value: function updatePosition(scrollElement) {
	      var onResize = this.props.onResize;
	      var _state = this.state,
	          height = _state.height,
	          width = _state.width;
	
	
	      scrollElement = scrollElement || this.props.scrollElement || window;
	      var offset = (0, _dimensions.getPositionOffset)(_reactDom2.default.findDOMNode(this), scrollElement);
	      this._positionFromTop = offset.top;
	      this._positionFromLeft = offset.left;
	
	      var dimensions = (0, _dimensions.getDimensions)(scrollElement);
	      if (height !== dimensions.height || width !== dimensions.width) {
	        this.setState({
	          height: dimensions.height,
	          width: dimensions.width
	        });
	        onResize({
	          height: dimensions.height,
	          width: dimensions.width
	        });
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var scrollElement = this.props.scrollElement || window;
	
	      this.updatePosition(scrollElement);
	
	      (0, _onScroll.registerScrollListener)(this, scrollElement);
	
	      window.addEventListener('resize', this._onResize, false);
	
	      this._isMounted = true;
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var scrollElement = this.props.scrollElement || window;
	      var nextScrollElement = nextProps.scrollElement || window;
	
	      if (scrollElement !== nextScrollElement) {
	        this.updatePosition(nextScrollElement);
	
	        (0, _onScroll.unregisterScrollListener)(this, scrollElement);
	        (0, _onScroll.registerScrollListener)(this, nextScrollElement);
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      (0, _onScroll.unregisterScrollListener)(this, this.props.scrollElement || window);
	      window.removeEventListener('resize', this._onResize, false);
	
	      this._isMounted = false;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var children = this.props.children;
	      var _state2 = this.state,
	          isScrolling = _state2.isScrolling,
	          scrollTop = _state2.scrollTop,
	          scrollLeft = _state2.scrollLeft,
	          height = _state2.height,
	          width = _state2.width;
	
	
	      return children({
	        onChildScroll: this._onChildScroll,
	        height: height,
	        isScrolling: isScrolling,
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop,
	        width: width
	      });
	    }
	  }, {
	    key: '_onChildScroll',
	    value: function _onChildScroll(_ref2) {
	      var scrollTop = _ref2.scrollTop;
	
	      if (this.state.scrollTop === scrollTop) {
	        return;
	      }
	
	      var scrollElement = this.scrollElement;
	
	      if (typeof scrollElement.scrollTo === 'function') {
	        scrollElement.scrollTo(0, scrollTop + this._positionFromTop);
	      } else {
	        scrollElement.scrollTop = scrollTop + this._positionFromTop;
	      }
	    }
	  }, {
	    key: '_onResize',
	    value: function _onResize() {
	      this.updatePosition();
	    }
	
	    // Referenced by utils/onScroll
	
	  }, {
	    key: '__handleWindowScrollEvent',
	    value: function __handleWindowScrollEvent() {
	      if (!this._isMounted) {
	        return;
	      }
	
	      var onScroll = this.props.onScroll;
	
	
	      var scrollElement = this.props.scrollElement || window;
	      var scrollOffset = (0, _dimensions.getScrollOffset)(scrollElement);
	      var scrollLeft = Math.max(0, scrollOffset.left - this._positionFromLeft);
	      var scrollTop = Math.max(0, scrollOffset.top - this._positionFromTop);
	
	      this.setState({
	        isScrolling: true,
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop
	      });
	
	      onScroll({
	        scrollLeft: scrollLeft,
	        scrollTop: scrollTop
	      });
	    }
	
	    // Referenced by utils/onScroll
	
	  }, {
	    key: '__resetIsScrolling',
	    value: function __resetIsScrolling() {
	      this.setState({
	        isScrolling: false
	      });
	    }
	  }, {
	    key: 'scrollElement',
	    get: function get() {
	      return this.props.scrollElement || window;
	    }
	  }]);
	
	  return WindowScroller;
	}(_react.PureComponent);
	
	WindowScroller.defaultProps = {
	  onResize: function onResize() {},
	  onScroll: function onScroll() {},
	  scrollingResetTimeInterval: IS_SCROLLING_TIMEOUT
	};
	exports.default = WindowScroller;
	WindowScroller.propTypes =  false ? {
	  /**
	   * Function responsible for rendering children.
	   * This function should implement the following signature:
	   * ({ height, isScrolling, scrollLeft, scrollTop, width }) => PropTypes.element
	   */
	  children: _propTypes2.default.func.isRequired,
	
	  /** Callback to be invoked on-resize: ({ height, width }) */
	  onResize: _propTypes2.default.func.isRequired,
	
	  /** Callback to be invoked on-scroll: ({ scrollLeft, scrollTop }) */
	  onScroll: _propTypes2.default.func.isRequired,
	
	  /** Element to attach scroll event listeners. Defaults to window. */
	  scrollElement: _propTypes2.default.any,
	
	  /**
	   * Wait this amount of time after the last scroll event before resetting child `pointer-events`.
	   */
	  scrollingResetTimeInterval: _propTypes2.default.number.isRequired
	} : {};

/***/ }),
/* 840 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IS_SCROLLING_TIMEOUT = exports.WindowScroller = undefined;
	
	var _WindowScroller = __webpack_require__(839);
	
	var _WindowScroller2 = _interopRequireDefault(_WindowScroller);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _WindowScroller2.default;
	exports.WindowScroller = _WindowScroller2.default;
	exports.IS_SCROLLING_TIMEOUT = _WindowScroller.IS_SCROLLING_TIMEOUT;

/***/ }),
/* 841 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getDimensions = getDimensions;
	exports.getPositionOffset = getPositionOffset;
	exports.getScrollOffset = getScrollOffset;
	/**
	 * Gets the dimensions of the element, accounting for API differences between
	 * `window` and other DOM elements.
	 */
	
	function getDimensions(element) {
	  if (element === window) {
	    return {
	      height: typeof window.innerHeight === 'number' ? window.innerHeight : 0,
	      width: typeof window.innerWidth === 'number' ? window.innerWidth : 0
	    };
	  }
	
	  var _element$getBoundingC = element.getBoundingClientRect(),
	      width = _element$getBoundingC.width,
	      height = _element$getBoundingC.height;
	
	  return { width: width, height: height };
	}
	
	/**
	 * Gets the vertical and horizontal position of an element within its scroll container.
	 * Elements that have been “scrolled past” return negative values.
	 * Handles edge-case where a user is navigating back (history) from an already-scrolled page.
	 * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).
	 */
	function getPositionOffset(element, container) {
	  var scrollOffset = container === window ? { top: 0, left: 0 } : getScrollOffset(container);
	  var containerElement = container === window ? document.documentElement : container;
	  var elementRect = element.getBoundingClientRect();
	  var containerRect = containerElement.getBoundingClientRect();
	  return {
	    top: elementRect.top + scrollOffset.top - containerRect.top,
	    left: elementRect.left + scrollOffset.left - containerRect.left
	  };
	}
	
	/**
	 * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility
	 * and API differences between `window` and other DOM elements.
	 */
	function getScrollOffset(element) {
	  if (element === window) {
	    return {
	      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,
	      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft
	    };
	  } else {
	    return {
	      top: element.scrollTop,
	      left: element.scrollLeft
	    };
	  }
	}

/***/ }),
/* 842 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.registerScrollListener = registerScrollListener;
	exports.unregisterScrollListener = unregisterScrollListener;
	
	var _requestAnimationTimeout = __webpack_require__(87);
	
	var mountedInstances = [];
	var originalBodyPointerEvents = null;
	var disablePointerEventsTimeoutId = null;
	
	function enablePointerEventsIfDisabled() {
	  if (disablePointerEventsTimeoutId) {
	    disablePointerEventsTimeoutId = null;
	
	    document.body.style.pointerEvents = originalBodyPointerEvents;
	
	    originalBodyPointerEvents = null;
	  }
	}
	
	function enablePointerEventsAfterDelayCallback() {
	  enablePointerEventsIfDisabled();
	  mountedInstances.forEach(function (instance) {
	    return instance.__resetIsScrolling();
	  });
	}
	
	function enablePointerEventsAfterDelay() {
	  if (disablePointerEventsTimeoutId) {
	    (0, _requestAnimationTimeout.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
	  }
	
	  var maximumTimeout = 0;
	  mountedInstances.forEach(function (instance) {
	    maximumTimeout = Math.max(maximumTimeout, instance.props.scrollingResetTimeInterval);
	  });
	
	  disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(enablePointerEventsAfterDelayCallback, maximumTimeout);
	}
	
	function onScrollWindow(event) {
	  if (event.currentTarget === window && originalBodyPointerEvents == null) {
	    originalBodyPointerEvents = document.body.style.pointerEvents;
	
	    document.body.style.pointerEvents = 'none';
	  }
	  enablePointerEventsAfterDelay();
	  mountedInstances.forEach(function (instance) {
	    if (instance.scrollElement === event.currentTarget) {
	      instance.__handleWindowScrollEvent(event);
	    }
	  });
	}
	
	function registerScrollListener(component, element) {
	  if (!mountedInstances.some(function (instance) {
	    return instance.scrollElement === element;
	  })) {
	    element.addEventListener('scroll', onScrollWindow);
	  }
	  mountedInstances.push(component);
	}
	
	function unregisterScrollListener(component, element) {
	  mountedInstances = mountedInstances.filter(function (instance) {
	    return instance !== component;
	  });
	  if (!mountedInstances.length) {
	    element.removeEventListener('scroll', onScrollWindow);
	    if (disablePointerEventsTimeoutId) {
	      (0, _requestAnimationTimeout.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
	      enablePointerEventsIfDisabled();
	    }
	  }
	}

/***/ }),
/* 843 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ArrowKeyStepper = __webpack_require__(806);
	
	Object.defineProperty(exports, 'ArrowKeyStepper', {
	  enumerable: true,
	  get: function get() {
	    return _ArrowKeyStepper.ArrowKeyStepper;
	  }
	});
	
	var _AutoSizer = __webpack_require__(809);
	
	Object.defineProperty(exports, 'AutoSizer', {
	  enumerable: true,
	  get: function get() {
	    return _AutoSizer.AutoSizer;
	  }
	});
	
	var _CellMeasurer = __webpack_require__(335);
	
	Object.defineProperty(exports, 'CellMeasurer', {
	  enumerable: true,
	  get: function get() {
	    return _CellMeasurer.CellMeasurer;
	  }
	});
	Object.defineProperty(exports, 'CellMeasurerCache', {
	  enumerable: true,
	  get: function get() {
	    return _CellMeasurer.CellMeasurerCache;
	  }
	});
	
	var _Collection = __webpack_require__(816);
	
	Object.defineProperty(exports, 'Collection', {
	  enumerable: true,
	  get: function get() {
	    return _Collection.Collection;
	  }
	});
	
	var _ColumnSizer = __webpack_require__(819);
	
	Object.defineProperty(exports, 'ColumnSizer', {
	  enumerable: true,
	  get: function get() {
	    return _ColumnSizer.ColumnSizer;
	  }
	});
	
	var _Grid = __webpack_require__(22);
	
	Object.defineProperty(exports, 'accessibilityOverscanIndicesGetter', {
	  enumerable: true,
	  get: function get() {
	    return _Grid.accessibilityOverscanIndicesGetter;
	  }
	});
	Object.defineProperty(exports, 'defaultCellRangeRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _Grid.defaultCellRangeRenderer;
	  }
	});
	Object.defineProperty(exports, 'defaultOverscanIndicesGetter', {
	  enumerable: true,
	  get: function get() {
	    return _Grid.defaultOverscanIndicesGetter;
	  }
	});
	Object.defineProperty(exports, 'Grid', {
	  enumerable: true,
	  get: function get() {
	    return _Grid.Grid;
	  }
	});
	
	var _InfiniteLoader = __webpack_require__(826);
	
	Object.defineProperty(exports, 'InfiniteLoader', {
	  enumerable: true,
	  get: function get() {
	    return _InfiniteLoader.InfiniteLoader;
	  }
	});
	
	var _List = __webpack_require__(828);
	
	Object.defineProperty(exports, 'List', {
	  enumerable: true,
	  get: function get() {
	    return _List.List;
	  }
	});
	
	var _Masonry = __webpack_require__(831);
	
	Object.defineProperty(exports, 'createMasonryCellPositioner', {
	  enumerable: true,
	  get: function get() {
	    return _Masonry.createCellPositioner;
	  }
	});
	Object.defineProperty(exports, 'Masonry', {
	  enumerable: true,
	  get: function get() {
	    return _Masonry.Masonry;
	  }
	});
	
	var _MultiGrid = __webpack_require__(834);
	
	Object.defineProperty(exports, 'MultiGrid', {
	  enumerable: true,
	  get: function get() {
	    return _MultiGrid.MultiGrid;
	  }
	});
	
	var _ScrollSync = __webpack_require__(836);
	
	Object.defineProperty(exports, 'ScrollSync', {
	  enumerable: true,
	  get: function get() {
	    return _ScrollSync.ScrollSync;
	  }
	});
	
	var _Table = __webpack_require__(838);
	
	Object.defineProperty(exports, 'defaultTableCellDataGetter', {
	  enumerable: true,
	  get: function get() {
	    return _Table.defaultCellDataGetter;
	  }
	});
	Object.defineProperty(exports, 'defaultTableCellRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _Table.defaultCellRenderer;
	  }
	});
	Object.defineProperty(exports, 'defaultTableHeaderRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _Table.defaultHeaderRenderer;
	  }
	});
	Object.defineProperty(exports, 'defaultTableHeaderRowRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _Table.defaultHeaderRowRenderer;
	  }
	});
	Object.defineProperty(exports, 'defaultTableRowRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _Table.defaultRowRenderer;
	  }
	});
	Object.defineProperty(exports, 'Table', {
	  enumerable: true,
	  get: function get() {
	    return _Table.Table;
	  }
	});
	Object.defineProperty(exports, 'Column', {
	  enumerable: true,
	  get: function get() {
	    return _Table.Column;
	  }
	});
	Object.defineProperty(exports, 'SortDirection', {
	  enumerable: true,
	  get: function get() {
	    return _Table.SortDirection;
	  }
	});
	Object.defineProperty(exports, 'SortIndicator', {
	  enumerable: true,
	  get: function get() {
	    return _Table.SortIndicator;
	  }
	});
	
	var _WindowScroller = __webpack_require__(840);
	
	Object.defineProperty(exports, 'WindowScroller', {
	  enumerable: true,
	  get: function get() {
	    return _WindowScroller.WindowScroller;
	  }
	});

/***/ }),
/* 844 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	
	// Properly handle server-side rendering.
	var win = void 0;
	
	if (typeof window !== 'undefined') {
	  win = window;
	} else if (typeof self !== 'undefined') {
	  win = self;
	} else {
	  win = {};
	}
	
	// requestAnimationFrame() shim by Paul Irish
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {
	  return win.setTimeout(callback, 1000 / 60);
	};
	
	var cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function (id) {
	  win.clearTimeout(id);
	};
	
	var raf = exports.raf = request;
	var caf = exports.caf = cancel;

/***/ }),
/* 845 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getUpdatedOffsetForIndex;
	/**
	 * Determines a new offset that ensures a certain cell is visible, given the current offset.
	 * If the cell is already visible then the current offset will be returned.
	 * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
	 *
	 * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
	 * @param cellOffset Offset (x or y) position for cell
	 * @param cellSize Size (width or height) of cell
	 * @param containerSize Total size (width or height) of the container
	 * @param currentOffset Container's current (x or y) offset
	 * @return Offset to use to ensure the specified cell is visible
	 */
	function getUpdatedOffsetForIndex(_ref) {
	  var _ref$align = _ref.align,
	      align = _ref$align === undefined ? 'auto' : _ref$align,
	      cellOffset = _ref.cellOffset,
	      cellSize = _ref.cellSize,
	      containerSize = _ref.containerSize,
	      currentOffset = _ref.currentOffset;
	
	  var maxOffset = cellOffset;
	  var minOffset = maxOffset - containerSize + cellSize;
	
	  switch (align) {
	    case 'start':
	      return maxOffset;
	    case 'end':
	      return minOffset;
	    case 'center':
	      return maxOffset - (containerSize - cellSize) / 2;
	    default:
	      return Math.max(minOffset, Math.min(maxOffset, currentOffset));
	  }
	}

/***/ }),
/* 846 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Binary Search Bounds
	 * https://github.com/mikolalysenko/binary-search-bounds
	 * Mikola Lysenko
	 *
	 * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax.
	 * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
	 **/
	
	function _GEA(a, l, h, y) {
	  var i = h + 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (x >= y) {
	      i = m;
	      h = m - 1;
	    } else {
	      l = m + 1;
	    }
	  }
	  return i;
	}
	function _GEP(a, l, h, y, c) {
	  var i = h + 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (c(x, y) >= 0) {
	      i = m;
	      h = m - 1;
	    } else {
	      l = m + 1;
	    }
	  }
	  return i;
	}
	function dispatchBsearchGE(a, y, c, l, h) {
	  if (typeof c === 'function') {
	    return _GEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
	  } else {
	    return _GEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
	  }
	}
	
	function _GTA(a, l, h, y) {
	  var i = h + 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (x > y) {
	      i = m;
	      h = m - 1;
	    } else {
	      l = m + 1;
	    }
	  }
	  return i;
	}
	function _GTP(a, l, h, y, c) {
	  var i = h + 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (c(x, y) > 0) {
	      i = m;
	      h = m - 1;
	    } else {
	      l = m + 1;
	    }
	  }
	  return i;
	}
	function dispatchBsearchGT(a, y, c, l, h) {
	  if (typeof c === 'function') {
	    return _GTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
	  } else {
	    return _GTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
	  }
	}
	
	function _LTA(a, l, h, y) {
	  var i = l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (x < y) {
	      i = m;
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return i;
	}
	function _LTP(a, l, h, y, c) {
	  var i = l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (c(x, y) < 0) {
	      i = m;
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return i;
	}
	function dispatchBsearchLT(a, y, c, l, h) {
	  if (typeof c === 'function') {
	    return _LTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
	  } else {
	    return _LTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
	  }
	}
	
	function _LEA(a, l, h, y) {
	  var i = l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (x <= y) {
	      i = m;
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return i;
	}
	function _LEP(a, l, h, y, c) {
	  var i = l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (c(x, y) <= 0) {
	      i = m;
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return i;
	}
	function dispatchBsearchLE(a, y, c, l, h) {
	  if (typeof c === 'function') {
	    return _LEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
	  } else {
	    return _LEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
	  }
	}
	
	function _EQA(a, l, h, y) {
	  l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    if (x === y) {
	      return m;
	    } else if (x <= y) {
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return -1;
	}
	function _EQP(a, l, h, y, c) {
	  l - 1;
	  while (l <= h) {
	    var m = l + h >>> 1,
	        x = a[m];
	    var p = c(x, y);
	    if (p === 0) {
	      return m;
	    } else if (p <= 0) {
	      l = m + 1;
	    } else {
	      h = m - 1;
	    }
	  }
	  return -1;
	}
	function dispatchBsearchEQ(a, y, c, l, h) {
	  if (typeof c === 'function') {
	    return _EQP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
	  } else {
	    return _EQA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
	  }
	}
	
	exports.default = {
	  ge: dispatchBsearchGE,
	  gt: dispatchBsearchGT,
	  lt: dispatchBsearchLT,
	  le: dispatchBsearchLE,
	  eq: dispatchBsearchEQ
	};

/***/ }),
/* 847 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createDetectElementResize;
	/**
	 * Detect Element Resize.
	 * https://github.com/sdecima/javascript-detect-element-resize
	 * Sebastian Decima
	 *
	 * Forked from version 0.5.3; includes the following modifications:
	 * 1) Guard against unsafe 'window' and 'document' references (to support SSR).
	 * 2) Defer initialization code via a top-level function wrapper (to support SSR).
	 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
	 * 4) Add nonce for style element.
	 **/
	
	function createDetectElementResize(nonce) {
	  // Check `document` and `window` in case of server-side rendering
	  var _window;
	  if (typeof window !== 'undefined') {
	    _window = window;
	  } else if (typeof self !== 'undefined') {
	    _window = self;
	  } else {
	    _window = this;
	  }
	
	  var attachEvent = typeof document !== 'undefined' && document.attachEvent;
	
	  if (!attachEvent) {
	    var requestFrame = function () {
	      var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function (fn) {
	        return _window.setTimeout(fn, 20);
	      };
	      return function (fn) {
	        return raf(fn);
	      };
	    }();
	
	    var cancelFrame = function () {
	      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
	      return function (id) {
	        return cancel(id);
	      };
	    }();
	
	    var resetTriggers = function resetTriggers(element) {
	      var triggers = element.__resizeTriggers__,
	          expand = triggers.firstElementChild,
	          contract = triggers.lastElementChild,
	          expandChild = expand.firstElementChild;
	      contract.scrollLeft = contract.scrollWidth;
	      contract.scrollTop = contract.scrollHeight;
	      expandChild.style.width = expand.offsetWidth + 1 + 'px';
	      expandChild.style.height = expand.offsetHeight + 1 + 'px';
	      expand.scrollLeft = expand.scrollWidth;
	      expand.scrollTop = expand.scrollHeight;
	    };
	
	    var checkTriggers = function checkTriggers(element) {
	      return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
	    };
	
	    var scrollListener = function scrollListener(e) {
	      // Don't measure (which forces) reflow for scrolls that happen inside of children!
	      if (e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {
	        return;
	      }
	
	      var element = this;
	      resetTriggers(this);
	      if (this.__resizeRAF__) {
	        cancelFrame(this.__resizeRAF__);
	      }
	      this.__resizeRAF__ = requestFrame(function () {
	        if (checkTriggers(element)) {
	          element.__resizeLast__.width = element.offsetWidth;
	          element.__resizeLast__.height = element.offsetHeight;
	          element.__resizeListeners__.forEach(function (fn) {
	            fn.call(element, e);
	          });
	        }
	      });
	    };
	
	    /* Detect CSS Animations support to detect element display/re-attach */
	    var animation = false,
	        keyframeprefix = '',
	        animationstartevent = 'animationstart',
	        domPrefixes = 'Webkit Moz O ms'.split(' '),
	        startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
	        pfx = '';
	    {
	      var elm = document.createElement('fakeelement');
	      if (elm.style.animationName !== undefined) {
	        animation = true;
	      }
	
	      if (animation === false) {
	        for (var i = 0; i < domPrefixes.length; i++) {
	          if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
	            pfx = domPrefixes[i];
	            keyframeprefix = '-' + pfx.toLowerCase() + '-';
	            animationstartevent = startEvents[i];
	            animation = true;
	            break;
	          }
	        }
	      }
	    }
	
	    var animationName = 'resizeanim';
	    var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
	    var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
	  }
	
	  var createStyles = function createStyles() {
	    if (!document.getElementById('detectElementResize')) {
	      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
	      var css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
	          head = document.head || document.getElementsByTagName('head')[0],
	          style = document.createElement('style');
	
	      style.id = 'detectElementResize';
	      style.type = 'text/css';
	
	      if (nonce != null) {
	        style.setAttribute('nonce', nonce);
	      }
	
	      if (style.styleSheet) {
	        style.styleSheet.cssText = css;
	      } else {
	        style.appendChild(document.createTextNode(css));
	      }
	
	      head.appendChild(style);
	    }
	  };
	
	  var addResizeListener = function addResizeListener(element, fn) {
	    if (attachEvent) {
	      element.attachEvent('onresize', fn);
	    } else {
	      if (!element.__resizeTriggers__) {
	        var elementStyle = _window.getComputedStyle(element);
	        if (elementStyle && elementStyle.position == 'static') {
	          element.style.position = 'relative';
	        }
	        createStyles();
	        element.__resizeLast__ = {};
	        element.__resizeListeners__ = [];
	        (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
	        element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';
	        element.appendChild(element.__resizeTriggers__);
	        resetTriggers(element);
	        element.addEventListener('scroll', scrollListener, true);
	
	        /* Listen for a css animation to detect element display/re-attach */
	        if (animationstartevent) {
	          element.__resizeTriggers__.__animationListener__ = function animationListener(e) {
	            if (e.animationName == animationName) {
	              resetTriggers(element);
	            }
	          };
	          element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
	        }
	      }
	      element.__resizeListeners__.push(fn);
	    }
	  };
	
	  var removeResizeListener = function removeResizeListener(element, fn) {
	    if (attachEvent) {
	      element.detachEvent('onresize', fn);
	    } else {
	      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
	      if (!element.__resizeListeners__.length) {
	        element.removeEventListener('scroll', scrollListener, true);
	        if (element.__resizeTriggers__.__animationListener__) {
	          element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
	          element.__resizeTriggers__.__animationListener__ = null;
	        }
	        try {
	          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
	        } catch (e) {
	          // Preact compat; see developit/preact-compat/issues/228
	        }
	      }
	    }
	  };
	
	  return {
	    addResizeListener: addResizeListener,
	    removeResizeListener: removeResizeListener
	  };
	}

/***/ }),
/* 848 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createWrapper;
	
	var _binarySearchBounds = __webpack_require__(846);
	
	var _binarySearchBounds2 = _interopRequireDefault(_binarySearchBounds);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NOT_FOUND = 0; /**
	                    * Binary Search Bounds
	                    * https://github.com/mikolalysenko/interval-tree-1d
	                    * Mikola Lysenko
	                    *
	                    * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax in an upstream dependency.
	                    * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
	                    **/
	
	var SUCCESS = 1;
	var EMPTY = 2;
	
	function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
	  this.mid = mid;
	  this.left = left;
	  this.right = right;
	  this.leftPoints = leftPoints;
	  this.rightPoints = rightPoints;
	  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
	}
	
	var proto = IntervalTreeNode.prototype;
	
	function copy(a, b) {
	  a.mid = b.mid;
	  a.left = b.left;
	  a.right = b.right;
	  a.leftPoints = b.leftPoints;
	  a.rightPoints = b.rightPoints;
	  a.count = b.count;
	}
	
	function rebuild(node, intervals) {
	  var ntree = createIntervalTree(intervals);
	  node.mid = ntree.mid;
	  node.left = ntree.left;
	  node.right = ntree.right;
	  node.leftPoints = ntree.leftPoints;
	  node.rightPoints = ntree.rightPoints;
	  node.count = ntree.count;
	}
	
	function rebuildWithInterval(node, interval) {
	  var intervals = node.intervals([]);
	  intervals.push(interval);
	  rebuild(node, intervals);
	}
	
	function rebuildWithoutInterval(node, interval) {
	  var intervals = node.intervals([]);
	  var idx = intervals.indexOf(interval);
	  if (idx < 0) {
	    return NOT_FOUND;
	  }
	  intervals.splice(idx, 1);
	  rebuild(node, intervals);
	  return SUCCESS;
	}
	
	proto.intervals = function (result) {
	  result.push.apply(result, this.leftPoints);
	  if (this.left) {
	    this.left.intervals(result);
	  }
	  if (this.right) {
	    this.right.intervals(result);
	  }
	  return result;
	};
	
	proto.insert = function (interval) {
	  var weight = this.count - this.leftPoints.length;
	  this.count += 1;
	  if (interval[1] < this.mid) {
	    if (this.left) {
	      if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
	        rebuildWithInterval(this, interval);
	      } else {
	        this.left.insert(interval);
	      }
	    } else {
	      this.left = createIntervalTree([interval]);
	    }
	  } else if (interval[0] > this.mid) {
	    if (this.right) {
	      if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
	        rebuildWithInterval(this, interval);
	      } else {
	        this.right.insert(interval);
	      }
	    } else {
	      this.right = createIntervalTree([interval]);
	    }
	  } else {
	    var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin);
	    var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd);
	    this.leftPoints.splice(l, 0, interval);
	    this.rightPoints.splice(r, 0, interval);
	  }
	};
	
	proto.remove = function (interval) {
	  var weight = this.count - this.leftPoints;
	  if (interval[1] < this.mid) {
	    if (!this.left) {
	      return NOT_FOUND;
	    }
	    var rw = this.right ? this.right.count : 0;
	    if (4 * rw > 3 * (weight - 1)) {
	      return rebuildWithoutInterval(this, interval);
	    }
	    var r = this.left.remove(interval);
	    if (r === EMPTY) {
	      this.left = null;
	      this.count -= 1;
	      return SUCCESS;
	    } else if (r === SUCCESS) {
	      this.count -= 1;
	    }
	    return r;
	  } else if (interval[0] > this.mid) {
	    if (!this.right) {
	      return NOT_FOUND;
	    }
	    var lw = this.left ? this.left.count : 0;
	    if (4 * lw > 3 * (weight - 1)) {
	      return rebuildWithoutInterval(this, interval);
	    }
	    var r = this.right.remove(interval);
	    if (r === EMPTY) {
	      this.right = null;
	      this.count -= 1;
	      return SUCCESS;
	    } else if (r === SUCCESS) {
	      this.count -= 1;
	    }
	    return r;
	  } else {
	    if (this.count === 1) {
	      if (this.leftPoints[0] === interval) {
	        return EMPTY;
	      } else {
	        return NOT_FOUND;
	      }
	    }
	    if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
	      if (this.left && this.right) {
	        var p = this;
	        var n = this.left;
	        while (n.right) {
	          p = n;
	          n = n.right;
	        }
	        if (p === this) {
	          n.right = this.right;
	        } else {
	          var l = this.left;
	          var r = this.right;
	          p.count -= n.count;
	          p.right = n.left;
	          n.left = l;
	          n.right = r;
	        }
	        copy(this, n);
	        this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
	      } else if (this.left) {
	        copy(this, this.left);
	      } else {
	        copy(this, this.right);
	      }
	      return SUCCESS;
	    }
	    for (var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
	      if (this.leftPoints[l][0] !== interval[0]) {
	        break;
	      }
	      if (this.leftPoints[l] === interval) {
	        this.count -= 1;
	        this.leftPoints.splice(l, 1);
	        for (var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
	          if (this.rightPoints[r][1] !== interval[1]) {
	            break;
	          } else if (this.rightPoints[r] === interval) {
	            this.rightPoints.splice(r, 1);
	            return SUCCESS;
	          }
	        }
	      }
	    }
	    return NOT_FOUND;
	  }
	};
	
	function reportLeftRange(arr, hi, cb) {
	  for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
	    var r = cb(arr[i]);
	    if (r) {
	      return r;
	    }
	  }
	}
	
	function reportRightRange(arr, lo, cb) {
	  for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
	    var r = cb(arr[i]);
	    if (r) {
	      return r;
	    }
	  }
	}
	
	function reportRange(arr, cb) {
	  for (var i = 0; i < arr.length; ++i) {
	    var r = cb(arr[i]);
	    if (r) {
	      return r;
	    }
	  }
	}
	
	proto.queryPoint = function (x, cb) {
	  if (x < this.mid) {
	    if (this.left) {
	      var r = this.left.queryPoint(x, cb);
	      if (r) {
	        return r;
	      }
	    }
	    return reportLeftRange(this.leftPoints, x, cb);
	  } else if (x > this.mid) {
	    if (this.right) {
	      var r = this.right.queryPoint(x, cb);
	      if (r) {
	        return r;
	      }
	    }
	    return reportRightRange(this.rightPoints, x, cb);
	  } else {
	    return reportRange(this.leftPoints, cb);
	  }
	};
	
	proto.queryInterval = function (lo, hi, cb) {
	  if (lo < this.mid && this.left) {
	    var r = this.left.queryInterval(lo, hi, cb);
	    if (r) {
	      return r;
	    }
	  }
	  if (hi > this.mid && this.right) {
	    var r = this.right.queryInterval(lo, hi, cb);
	    if (r) {
	      return r;
	    }
	  }
	  if (hi < this.mid) {
	    return reportLeftRange(this.leftPoints, hi, cb);
	  } else if (lo > this.mid) {
	    return reportRightRange(this.rightPoints, lo, cb);
	  } else {
	    return reportRange(this.leftPoints, cb);
	  }
	};
	
	function compareNumbers(a, b) {
	  return a - b;
	}
	
	function compareBegin(a, b) {
	  var d = a[0] - b[0];
	  if (d) {
	    return d;
	  }
	  return a[1] - b[1];
	}
	
	function compareEnd(a, b) {
	  var d = a[1] - b[1];
	  if (d) {
	    return d;
	  }
	  return a[0] - b[0];
	}
	
	function createIntervalTree(intervals) {
	  if (intervals.length === 0) {
	    return null;
	  }
	  var pts = [];
	  for (var i = 0; i < intervals.length; ++i) {
	    pts.push(intervals[i][0], intervals[i][1]);
	  }
	  pts.sort(compareNumbers);
	
	  var mid = pts[pts.length >> 1];
	
	  var leftIntervals = [];
	  var rightIntervals = [];
	  var centerIntervals = [];
	  for (var i = 0; i < intervals.length; ++i) {
	    var s = intervals[i];
	    if (s[1] < mid) {
	      leftIntervals.push(s);
	    } else if (mid < s[0]) {
	      rightIntervals.push(s);
	    } else {
	      centerIntervals.push(s);
	    }
	  }
	
	  //Split center intervals
	  var leftPoints = centerIntervals;
	  var rightPoints = centerIntervals.slice();
	  leftPoints.sort(compareBegin);
	  rightPoints.sort(compareEnd);
	
	  return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
	}
	
	//User friendly wrapper that makes it possible to support empty trees
	function IntervalTree(root) {
	  this.root = root;
	}
	
	var tproto = IntervalTree.prototype;
	
	tproto.insert = function (interval) {
	  if (this.root) {
	    this.root.insert(interval);
	  } else {
	    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
	  }
	};
	
	tproto.remove = function (interval) {
	  if (this.root) {
	    var r = this.root.remove(interval);
	    if (r === EMPTY) {
	      this.root = null;
	    }
	    return r !== NOT_FOUND;
	  }
	  return false;
	};
	
	tproto.queryPoint = function (p, cb) {
	  if (this.root) {
	    return this.root.queryPoint(p, cb);
	  }
	};
	
	tproto.queryInterval = function (lo, hi, cb) {
	  if (lo <= hi && this.root) {
	    return this.root.queryInterval(lo, hi, cb);
	  }
	};
	
	Object.defineProperty(tproto, 'count', {
	  get: function get() {
	    if (this.root) {
	      return this.root.count;
	    }
	    return 0;
	  }
	});
	
	Object.defineProperty(tproto, 'intervals', {
	  get: function get() {
	    if (this.root) {
	      return this.root.intervals([]);
	    }
	    return [];
	  }
	});
	
	function createWrapper(intervals) {
	  if (!intervals || intervals.length === 0) {
	    return new IntervalTree(null);
	  }
	  return new IntervalTree(createIntervalTree(intervals));
	}

/***/ }),
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/* global window */
	
	var restore = capture();
	
	/* istanbul ignore next - Don't allow Prism to run on page load in browser. */
	var ctx = typeof window === 'undefined' ? {} : window;
	
	ctx.Prism = {manual: true};
	
	/* Load all stuff in `prism.js` itself, except for
	 * `prism-file-highlight.js`.
	 * The wrapped non-leaky grammars are loaded instead of
	 * Prism’s originals. */
	var h = __webpack_require__(629);
	var Prism = __webpack_require__(674);
	var markup = __webpack_require__(925);
	var css = __webpack_require__(885);
	var clike = __webpack_require__(880);
	var js = __webpack_require__(911);
	
	restore();
	
	var own = {}.hasOwnProperty;
	
	/* Inherit. */
	function Refractor() {}
	
	Refractor.prototype = Prism;
	
	/* Construct. */
	var refract = new Refractor();
	
	/* Expose. */
	module.exports = refract;
	
	/* Create. */
	refract.highlight = highlight;
	refract.register = register;
	refract.registered = registered;
	
	/* Register bundled grammars. */
	register(markup);
	register(css);
	register(clike);
	register(js);
	
	refract.util.encode = encode;
	refract.Token.stringify = stringify;
	
	function register(grammar) {
	  if (typeof grammar !== 'function' || !grammar.displayName) {
	    throw new Error('Expected `function` for `grammar`, got `' + grammar + '`');
	  }
	
	  /* Do not duplicate registrations. */
	  if (refract.languages[grammar.displayName] === undefined) {
	    grammar(refract);
	  }
	}
	
	function highlight(value, name, language) {
	  var sup = Prism.highlight;
	  var syntax;
	
	  if (typeof value !== 'string') {
	    throw new Error('Expected `string` for `value`, got `' + value + '`');
	  }
	
	  if (typeof name !== 'string') {
	    throw new Error('Expected `string` for `name`, got `' + name + '`');
	  }
	
	  if (!own.call(refract.languages, name)) {
	    throw new Error('Unknown language: `' + name + '` is not registered');
	  }
	
	  syntax = refract.languages[name];
	
	  return sup.call(this, value, syntax, language);
	}
	
	function registered(language) {
	  if (typeof language !== 'string') {
	    throw new Error('Expected `string` for `language`, got `' + language + '`');
	  }
	
	  return own.call(refract.languages, language);
	}
	
	function stringify(value, language, parent) {
	  var env;
	
	  if (typeof value === 'string') {
	    return {type: 'text', value: value};
	  }
	
	  if (refract.util.type(value) === 'Array') {
	    return stringifyAll(value, language);
	  }
	
	  env = {
	    type: value.type,
	    content: refract.Token.stringify(value.content, language, parent),
	    tag: 'span',
	    classes: ['token', value.type],
	    attributes: {},
	    language: language,
	    parent: parent
	  };
	
	  if (value.alias) {
	    env.classes = env.classes.concat(value.alias);
	  }
	
	  refract.hooks.run('wrap', env);
	
	  return h(
	    env.tag + '.' + env.classes.join('.'),
	    env.attributes,
	    env.content
	  );
	}
	
	function stringifyAll(values, language) {
	  var result = [];
	  var length = values.length;
	  var index = -1;
	  var value;
	
	  while (++index < length) {
	    value = values[index];
	
	    if (value !== '' && value !== null && value !== undefined) {
	      result.push(value);
	    }
	  }
	
	  index = -1;
	  length = result.length;
	
	  while (++index < length) {
	    value = result[index];
	    result[index] = refract.Token.stringify(value, language, result);
	  }
	
	  return result;
	}
	
	function encode(tokens) {
	  return tokens;
	}
	
	function capture() {
	  var defined = 'Prism' in global;
	  /* istanbul ignore next */
	  var current = defined ? global.Prism : undefined;
	
	  return restore;
	
	  function restore() {
	    /* istanbul ignore else - Clean leaks after Prism. */
	    if (defined) {
	      global.Prism = current;
	    } else {
	      delete global.Prism;
	    }
	
	    defined = undefined;
	    current = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 862 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var refractor = __webpack_require__(861);
	
	module.exports = refractor;
	
	refractor.register(__webpack_require__(863));
	refractor.register(__webpack_require__(864));
	refractor.register(__webpack_require__(865));
	refractor.register(__webpack_require__(866));
	refractor.register(__webpack_require__(867));
	refractor.register(__webpack_require__(868));
	refractor.register(__webpack_require__(869));
	refractor.register(__webpack_require__(870));
	refractor.register(__webpack_require__(871));
	refractor.register(__webpack_require__(872));
	refractor.register(__webpack_require__(873));
	refractor.register(__webpack_require__(874));
	refractor.register(__webpack_require__(875));
	refractor.register(__webpack_require__(876));
	refractor.register(__webpack_require__(877));
	refractor.register(__webpack_require__(878));
	refractor.register(__webpack_require__(879));
	refractor.register(__webpack_require__(68));
	refractor.register(__webpack_require__(881));
	refractor.register(__webpack_require__(350));
	refractor.register(__webpack_require__(882));
	refractor.register(__webpack_require__(883));
	refractor.register(__webpack_require__(884));
	refractor.register(__webpack_require__(886));
	refractor.register(__webpack_require__(887));
	refractor.register(__webpack_require__(888));
	refractor.register(__webpack_require__(889));
	refractor.register(__webpack_require__(890));
	refractor.register(__webpack_require__(891));
	refractor.register(__webpack_require__(892));
	refractor.register(__webpack_require__(893));
	refractor.register(__webpack_require__(894));
	refractor.register(__webpack_require__(895));
	refractor.register(__webpack_require__(896));
	refractor.register(__webpack_require__(897));
	refractor.register(__webpack_require__(898));
	refractor.register(__webpack_require__(899));
	refractor.register(__webpack_require__(900));
	refractor.register(__webpack_require__(901));
	refractor.register(__webpack_require__(902));
	refractor.register(__webpack_require__(903));
	refractor.register(__webpack_require__(904));
	refractor.register(__webpack_require__(905));
	refractor.register(__webpack_require__(906));
	refractor.register(__webpack_require__(907));
	refractor.register(__webpack_require__(908));
	refractor.register(__webpack_require__(909));
	refractor.register(__webpack_require__(910));
	refractor.register(__webpack_require__(351));
	refractor.register(__webpack_require__(912));
	refractor.register(__webpack_require__(913));
	refractor.register(__webpack_require__(914));
	refractor.register(__webpack_require__(915));
	refractor.register(__webpack_require__(916));
	refractor.register(__webpack_require__(917));
	refractor.register(__webpack_require__(918));
	refractor.register(__webpack_require__(919));
	refractor.register(__webpack_require__(920));
	refractor.register(__webpack_require__(921));
	refractor.register(__webpack_require__(922));
	refractor.register(__webpack_require__(923));
	refractor.register(__webpack_require__(924));
	refractor.register(__webpack_require__(926));
	refractor.register(__webpack_require__(927));
	refractor.register(__webpack_require__(928));
	refractor.register(__webpack_require__(929));
	refractor.register(__webpack_require__(930));
	refractor.register(__webpack_require__(931));
	refractor.register(__webpack_require__(932));
	refractor.register(__webpack_require__(933));
	refractor.register(__webpack_require__(934));
	refractor.register(__webpack_require__(935));
	refractor.register(__webpack_require__(936));
	refractor.register(__webpack_require__(937));
	refractor.register(__webpack_require__(938));
	refractor.register(__webpack_require__(939));
	refractor.register(__webpack_require__(940));
	refractor.register(__webpack_require__(941));
	refractor.register(__webpack_require__(942));
	refractor.register(__webpack_require__(943));
	refractor.register(__webpack_require__(944));
	refractor.register(__webpack_require__(945));
	refractor.register(__webpack_require__(946));
	refractor.register(__webpack_require__(947));
	refractor.register(__webpack_require__(948));
	refractor.register(__webpack_require__(949));
	refractor.register(__webpack_require__(950));
	refractor.register(__webpack_require__(951));
	refractor.register(__webpack_require__(952));
	refractor.register(__webpack_require__(953));
	refractor.register(__webpack_require__(954));
	refractor.register(__webpack_require__(955));
	refractor.register(__webpack_require__(956));
	refractor.register(__webpack_require__(957));
	refractor.register(__webpack_require__(958));
	refractor.register(__webpack_require__(959));
	refractor.register(__webpack_require__(960));
	refractor.register(__webpack_require__(961));
	refractor.register(__webpack_require__(962));
	refractor.register(__webpack_require__(352));
	refractor.register(__webpack_require__(963));
	refractor.register(__webpack_require__(964));
	refractor.register(__webpack_require__(965));
	refractor.register(__webpack_require__(966));
	refractor.register(__webpack_require__(967));
	refractor.register(__webpack_require__(968));
	refractor.register(__webpack_require__(969));
	refractor.register(__webpack_require__(970));
	refractor.register(__webpack_require__(971));
	refractor.register(__webpack_require__(972));
	refractor.register(__webpack_require__(973));
	refractor.register(__webpack_require__(974));
	refractor.register(__webpack_require__(975));
	refractor.register(__webpack_require__(976));
	refractor.register(__webpack_require__(977));
	refractor.register(__webpack_require__(978));
	refractor.register(__webpack_require__(979));
	refractor.register(__webpack_require__(980));
	refractor.register(__webpack_require__(981));
	refractor.register(__webpack_require__(982));
	refractor.register(__webpack_require__(983));
	refractor.register(__webpack_require__(984));


/***/ }),
/* 863 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = abap;
	abap.displayName = 'abap';
	abap.aliases = [];
	function abap(Prism) {
	  Prism.languages.abap = {
	    comment: /^\*.*/m,
	    string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/m,
	    'string-template': {
	      pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    /* End Of Line comments should not interfere with strings when the
	quote character occurs within them. We assume a string being highlighted
	inside an EOL comment is more acceptable than the opposite.
	*/
	    'eol-comment': {
	      pattern: /(^|\s)".*/m,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    keyword: {
	      pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|SELECTOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
	      lookbehind: true
	    },
	    /* Numbers can be only integers. Decimal or Hex appear only as strings */
	    number: /\b\d+\b/,
	    /* Operators must always be surrounded by whitespace, they cannot be put
	adjacent to operands.
	*/
	    operator: {
	      pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
	      lookbehind: true
	    },
	    'string-operator': {
	      pattern: /(\s)&&?(?=\s)/,
	      lookbehind: true,
	      /* The official editor highlights */
	      alias: 'keyword'
	    },
	    'token-operator': [
	      {
	        /* Special operators used to access structure components, class methods/attributes, etc. */
	        pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      {
	        /* Special tokens used do delimit string templates */
	        pattern: /[|{}]/,
	        alias: 'punctuation'
	      }
	    ],
	    punctuation: /[,.:()]/
	  };
	}


/***/ }),
/* 864 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = actionscript;
	actionscript.displayName = 'actionscript';
	actionscript.aliases = [];
	function actionscript(Prism) {
	  Prism.languages.actionscript = Prism.languages.extend('javascript', {
	    keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|else|extends|finally|for|function|if|implements|import|in|instanceof|interface|internal|is|native|new|null|package|private|protected|public|return|super|switch|this|throw|try|typeof|use|var|void|while|with|dynamic|each|final|get|include|namespace|native|override|set|static)\b/,
	    operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
	  });
	  Prism.languages.actionscript['class-name'].alias = 'function';
	  if (Prism.languages.markup) {
	    Prism.languages.insertBefore('actionscript', 'string', {
	      xml: {
	        pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.markup
	        }
	      }
	    });
	  }
	}


/***/ }),
/* 865 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = ada;
	ada.displayName = 'ada';
	ada.aliases = [];
	function ada(Prism) {
	  Prism.languages.ada = {
	    comment: /--.*/,
	    string: /"(?:""|[^"\r\f\n])*"/i,
	    number: [
	      {
	        pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
	      },
	      {
	        pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
	      }
	    ],
	    'attr-name': /\b'\w+/i,
	    keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|new|return|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
	    boolean: /\b(?:true|false)\b/i,
	    operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
	    punctuation: /\.\.?|[,;():]/,
	    char: /'.'/,
	    variable: /\b[a-z](?:[_a-z\d])*\b/i
	  };
	}


/***/ }),
/* 866 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = apacheconf;
	apacheconf.displayName = 'apacheconf';
	apacheconf.aliases = [];
	function apacheconf(Prism) {
	  Prism.languages.apacheconf = {
	    comment: /#.*/,
	    'directive-inline': {
	      pattern: /^(\s*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|AddAlt|AddAltByEncoding|AddAltByType|AddCharset|AddDefaultCharset|AddDescription|AddEncoding|AddHandler|AddIcon|AddIconByEncoding|AddIconByType|AddInputFilter|AddLanguage|AddModuleInfo|AddOutputFilter|AddOutputFilterByType|AddType|Alias|AliasMatch|Allow|AllowCONNECT|AllowEncodedSlashes|AllowMethods|AllowOverride|AllowOverrideList|Anonymous|Anonymous_LogEmail|Anonymous_MustGiveEmail|Anonymous_NoUserID|Anonymous_VerifyEmail|AsyncRequestWorkerFactor|AuthBasicAuthoritative|AuthBasicFake|AuthBasicProvider|AuthBasicUseDigestAlgorithm|AuthDBDUserPWQuery|AuthDBDUserRealmQuery|AuthDBMGroupFile|AuthDBMType|AuthDBMUserFile|AuthDigestAlgorithm|AuthDigestDomain|AuthDigestNonceLifetime|AuthDigestProvider|AuthDigestQop|AuthDigestShmemSize|AuthFormAuthoritative|AuthFormBody|AuthFormDisableNoStore|AuthFormFakeBasicAuth|AuthFormLocation|AuthFormLoginRequiredLocation|AuthFormLoginSuccessLocation|AuthFormLogoutLocation|AuthFormMethod|AuthFormMimetype|AuthFormPassword|AuthFormProvider|AuthFormSitePassphrase|AuthFormSize|AuthFormUsername|AuthGroupFile|AuthLDAPAuthorizePrefix|AuthLDAPBindAuthoritative|AuthLDAPBindDN|AuthLDAPBindPassword|AuthLDAPCharsetConfig|AuthLDAPCompareAsUser|AuthLDAPCompareDNOnServer|AuthLDAPDereferenceAliases|AuthLDAPGroupAttribute|AuthLDAPGroupAttributeIsDN|AuthLDAPInitialBindAsUser|AuthLDAPInitialBindPattern|AuthLDAPMaxSubGroupDepth|AuthLDAPRemoteUserAttribute|AuthLDAPRemoteUserIsDN|AuthLDAPSearchAsUser|AuthLDAPSubGroupAttribute|AuthLDAPSubGroupClass|AuthLDAPUrl|AuthMerging|AuthName|AuthnCacheContext|AuthnCacheEnable|AuthnCacheProvideFor|AuthnCacheSOCache|AuthnCacheTimeout|AuthnzFcgiCheckAuthnProvider|AuthnzFcgiDefineProvider|AuthType|AuthUserFile|AuthzDBDLoginToReferer|AuthzDBDQuery|AuthzDBDRedirectQuery|AuthzDBMType|AuthzSendForbiddenOnFailure|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|CacheDefaultExpire|CacheDetailHeader|CacheDirLength|CacheDirLevels|CacheDisable|CacheEnable|CacheFile|CacheHeader|CacheIgnoreCacheControl|CacheIgnoreHeaders|CacheIgnoreNoLastMod|CacheIgnoreQueryString|CacheIgnoreURLSessionIdentifiers|CacheKeyBaseURL|CacheLastModifiedFactor|CacheLock|CacheLockMaxAge|CacheLockPath|CacheMaxExpire|CacheMaxFileSize|CacheMinExpire|CacheMinFileSize|CacheNegotiatedDocs|CacheQuickHandler|CacheReadSize|CacheReadTime|CacheRoot|CacheSocache|CacheSocacheMaxSize|CacheSocacheMaxTime|CacheSocacheMinTime|CacheSocacheReadSize|CacheSocacheReadTime|CacheStaleOnError|CacheStoreExpired|CacheStoreNoStore|CacheStorePrivate|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|DeflateBufferSize|DeflateCompressionLevel|DeflateFilterNote|DeflateInflateLimitRequestBody|DeflateInflateRatioBurst|DeflateInflateRatioLimit|DeflateMemLevel|DeflateWindowSize|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|HeartbeatAddress|HeartbeatListen|HeartbeatMaxServers|HeartbeatStorage|HeartbeatStorage|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|IndexHeadInsert|IndexIgnore|IndexIgnoreReset|IndexOptions|IndexOrderDefault|IndexStyleSheet|InputSed|ISAPIAppendLogToErrors|ISAPIAppendLogToQuery|ISAPICacheFile|ISAPIFakeAsync|ISAPILogNotSupported|ISAPIReadAheadBuffer|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAPCacheEntries|LDAPCacheTTL|LDAPConnectionPoolTTL|LDAPConnectionTimeout|LDAPLibraryDebug|LDAPOpCacheEntries|LDAPOpCacheTTL|LDAPReferralHopLimit|LDAPReferrals|LDAPRetries|LDAPRetryDelay|LDAPSharedCacheFile|LDAPSharedCacheSize|LDAPTimeout|LDAPTrustedClientCert|LDAPTrustedGlobalCert|LDAPTrustedMode|LDAPVerifyServerCert|LimitInternalRecursion|LimitRequestBody|LimitRequestFields|LimitRequestFieldSize|LimitRequestLine|LimitXMLRequestBody|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|LuaHookAccessChecker|LuaHookAuthChecker|LuaHookCheckUserID|LuaHookFixups|LuaHookInsertFilter|LuaHookLog|LuaHookMapToStorage|LuaHookTranslateName|LuaHookTypeChecker|LuaInherit|LuaInputFilter|LuaMapHandler|LuaOutputFilter|LuaPackageCPath|LuaPackagePath|LuaQuickHandler|LuaRoot|LuaScope|MaxConnectionsPerChild|MaxKeepAliveRequests|MaxMemFree|MaxRangeOverlaps|MaxRangeReversals|MaxRanges|MaxRequestWorkers|MaxSpareServers|MaxSpareThreads|MaxThreads|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|ProxyAddHeaders|ProxyBadHeader|ProxyBlock|ProxyDomain|ProxyErrorOverride|ProxyExpressDBMFile|ProxyExpressDBMType|ProxyExpressEnable|ProxyFtpDirCharset|ProxyFtpEscapeWildcards|ProxyFtpListOnWildcard|ProxyHTMLBufSize|ProxyHTMLCharsetOut|ProxyHTMLDocType|ProxyHTMLEnable|ProxyHTMLEvents|ProxyHTMLExtended|ProxyHTMLFixups|ProxyHTMLInterp|ProxyHTMLLinks|ProxyHTMLMeta|ProxyHTMLStripComments|ProxyHTMLURLMap|ProxyIOBufferSize|ProxyMaxForwards|ProxyPass|ProxyPassInherit|ProxyPassInterpolateEnv|ProxyPassMatch|ProxyPassReverse|ProxyPassReverseCookieDomain|ProxyPassReverseCookiePath|ProxyPreserveHost|ProxyReceiveBufferSize|ProxyRemote|ProxyRemoteMatch|ProxyRequests|ProxySCGIInternalRedirect|ProxySCGISendfile|ProxySet|ProxySourceAddress|ProxyStatus|ProxyTimeout|ProxyVia|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIPHeader|RemoteIPInternalProxy|RemoteIPInternalProxyList|RemoteIPProxiesHeader|RemoteIPTrustedProxy|RemoteIPTrustedProxyList|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|RewriteBase|RewriteCond|RewriteEngine|RewriteMap|RewriteOptions|RewriteRule|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script|ScriptAlias|ScriptAliasMatch|ScriptInterpreterSource|ScriptLog|ScriptLogBuffer|ScriptLogLength|ScriptSock|SecureListen|SeeRequestTail|SendBufferSize|ServerAdmin|ServerAlias|ServerLimit|ServerName|ServerPath|ServerRoot|ServerSignature|ServerTokens|Session|SessionCookieName|SessionCookieName2|SessionCookieRemove|SessionCryptoCipher|SessionCryptoDriver|SessionCryptoPassphrase|SessionCryptoPassphraseFile|SessionDBDCookieName|SessionDBDCookieName2|SessionDBDCookieRemove|SessionDBDDeleteLabel|SessionDBDInsertLabel|SessionDBDPerUser|SessionDBDSelectLabel|SessionDBDUpdateLabel|SessionEnv|SessionExclude|SessionHeader|SessionInclude|SessionMaxAge|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSLCACertificateFile|SSLCACertificatePath|SSLCADNRequestFile|SSLCADNRequestPath|SSLCARevocationCheck|SSLCARevocationFile|SSLCARevocationPath|SSLCertificateChainFile|SSLCertificateFile|SSLCertificateKeyFile|SSLCipherSuite|SSLCompression|SSLCryptoDevice|SSLEngine|SSLFIPS|SSLHonorCipherOrder|SSLInsecureRenegotiation|SSLOCSPDefaultResponder|SSLOCSPEnable|SSLOCSPOverrideResponder|SSLOCSPResponderTimeout|SSLOCSPResponseMaxAge|SSLOCSPResponseTimeSkew|SSLOCSPUseRequestNonce|SSLOpenSSLConfCmd|SSLOptions|SSLPassPhraseDialog|SSLProtocol|SSLProxyCACertificateFile|SSLProxyCACertificatePath|SSLProxyCARevocationCheck|SSLProxyCARevocationFile|SSLProxyCARevocationPath|SSLProxyCheckPeerCN|SSLProxyCheckPeerExpire|SSLProxyCheckPeerName|SSLProxyCipherSuite|SSLProxyEngine|SSLProxyMachineCertificateChainFile|SSLProxyMachineCertificateFile|SSLProxyMachineCertificatePath|SSLProxyProtocol|SSLProxyVerify|SSLProxyVerifyDepth|SSLRandomSeed|SSLRenegBufferSize|SSLRequire|SSLRequireSSL|SSLSessionCache|SSLSessionCacheTimeout|SSLSessionTicketKeyFile|SSLSRPUnknownUserSeed|SSLSRPVerifierFile|SSLStaplingCache|SSLStaplingErrorCacheTimeout|SSLStaplingFakeTryLater|SSLStaplingForceURL|SSLStaplingResponderTimeout|SSLStaplingResponseMaxAge|SSLStaplingResponseTimeSkew|SSLStaplingReturnResponderErrors|SSLStaplingStandardCacheTimeout|SSLStrictSNIVHostCheck|SSLUserName|SSLUseStapling|SSLVerifyClient|SSLVerifyDepth|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|VirtualDocumentRoot|VirtualDocumentRootIP|VirtualScriptAlias|VirtualScriptAliasIP|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
	      lookbehind: true,
	      alias: 'property'
	    },
	    'directive-block': {
	      pattern: /<\/?\b(?:AuthnProviderAlias|AuthzProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|RequireAll|RequireAny|RequireNone|VirtualHost)\b *.*>/i,
	      inside: {
	        'directive-block': {
	          pattern: /^<\/?\w+/,
	          inside: {
	            punctuation: /^<\/?/
	          },
	          alias: 'tag'
	        },
	        'directive-block-parameter': {
	          pattern: /.*[^>]/,
	          inside: {
	            punctuation: /:/,
	            string: {
	              pattern: /("|').*\1/,
	              inside: {
	                variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
	              }
	            }
	          },
	          alias: 'attr-value'
	        },
	        punctuation: />/
	      },
	      alias: 'tag'
	    },
	    'directive-flags': {
	      pattern: /\[(?:\w,?)+\]/,
	      alias: 'keyword'
	    },
	    string: {
	      pattern: /("|').*\1/,
	      inside: {
	        variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
	      }
	    },
	    variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
	    regex: /\^?.*\$|\^.*\$?/
	  };
	}


/***/ }),
/* 867 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = apl;
	apl.displayName = 'apl';
	apl.aliases = [];
	function apl(Prism) {
	  Prism.languages.apl = {
	    comment: /(?:⍝|#[! ]).*$/m,
	    string: {
	      pattern: /'(?:[^'\r\n]|'')*'/,
	      greedy: true
	    },
	    number: /¯?(?:\d*\.?\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:\d*\.?\d+(?:e[+¯]?\d+)?|¯|∞))?/i,
	    statement: /:[A-Z][a-z][A-Za-z]*\b/,
	    'system-function': {
	      pattern: /⎕[A-Z]+/i,
	      alias: 'function'
	    },
	    constant: /[⍬⌾#⎕⍞]/,
	    function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
	    'monadic-operator': {
	      pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
	      alias: 'operator'
	    },
	    'dyadic-operator': {
	      pattern: /[.⍣⍠⍤∘⌸@⌺]/,
	      alias: 'operator'
	    },
	    assignment: {
	      pattern: /←/,
	      alias: 'keyword'
	    },
	    punctuation: /[\[;\]()◇⋄]/,
	    dfn: {
	      pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
	      alias: 'builtin'
	    }
	  };
	}


/***/ }),
/* 868 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = applescript;
	applescript.displayName = 'applescript';
	applescript.aliases = [];
	function applescript(Prism) {
	  Prism.languages.applescript = {
	    comment: [
	      // Allow one level of nesting
	      /\(\*(?:\(\*[\s\S]*?\*\)|[\s\S])*?\*\)/,
	      /--.+/,
	      /#.+/
	    ],
	    string: /"(?:\\.|[^"\\\r\n])*"/,
	    number: /\b-?\d*\.?\d+([Ee]-?\d+)?\b/,
	    operator: [
	      /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
	      /\b(?:(?:start|begin|end)s? with|(?:(?:does not|doesn't) contain|contains?)|(?:is|isn't|is not) (?:in|contained by)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:(?:does not|doesn't) come|comes) (?:before|after)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equals|equal to|isn't|is not)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|or|div|mod|as|not))\b/
	    ],
	    keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
	    class: {
	      pattern: /\b(?:alias|application|boolean|class|constant|date|file|integer|list|number|POSIX file|real|record|reference|RGB color|script|text|centimetres|centimeters|feet|inches|kilometres|kilometers|metres|meters|miles|yards|square feet|square kilometres|square kilometers|square metres|square meters|square miles|square yards|cubic centimetres|cubic centimeters|cubic feet|cubic inches|cubic metres|cubic meters|cubic yards|gallons|litres|liters|quarts|grams|kilograms|ounces|pounds|degrees Celsius|degrees Fahrenheit|degrees Kelvin)\b/,
	      alias: 'builtin'
	    },
	    punctuation: /[{}():,¬«»《》]/
	  };
	}


/***/ }),
/* 869 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var cpp = __webpack_require__(350);
	module.exports = arduino;
	arduino.displayName = 'arduino';
	arduino.aliases = [];
	function arduino(Prism) {
	  Prism.register(cpp);
	  Prism.languages.arduino = Prism.languages.extend('cpp', {
	    keyword: /\b(?:setup|if|else|while|do|for|return|in|instanceof|default|function|loop|goto|switch|case|new|try|throw|catch|finally|null|break|continue|boolean|bool|void|byte|word|string|String|array|int|long|integer|double)\b/,
	    builtin: /\b(?:KeyboardController|MouseController|SoftwareSerial|EthernetServer|EthernetClient|LiquidCrystal|LiquidCrystal_I2C|RobotControl|GSMVoiceCall|EthernetUDP|EsploraTFT|HttpClient|RobotMotor|WiFiClient|GSMScanner|FileSystem|Scheduler|GSMServer|YunClient|YunServer|IPAddress|GSMClient|GSMModem|Keyboard|Ethernet|Console|GSMBand|Esplora|Stepper|Process|WiFiUDP|GSM_SMS|Mailbox|USBHost|Firmata|PImage|Client|Server|GSMPIN|FileIO|Bridge|Serial|EEPROM|Stream|Mouse|Audio|Servo|File|Task|GPRS|WiFi|Wire|TFT|GSM|SPI|SD|runShellCommandAsynchronously|analogWriteResolution|retrieveCallingNumber|printFirmwareVersion|analogReadResolution|sendDigitalPortPair|noListenOnLocalhost|readJoystickButton|setFirmwareVersion|readJoystickSwitch|scrollDisplayRight|getVoiceCallStatus|scrollDisplayLeft|writeMicroseconds|delayMicroseconds|beginTransmission|getSignalStrength|runAsynchronously|getAsynchronously|listenOnLocalhost|getCurrentCarrier|readAccelerometer|messageAvailable|sendDigitalPorts|lineFollowConfig|countryNameWrite|runShellCommand|readStringUntil|rewindDirectory|readTemperature|setClockDivider|readLightSensor|endTransmission|analogReference|detachInterrupt|countryNameRead|attachInterrupt|encryptionType|readBytesUntil|robotNameWrite|readMicrophone|robotNameRead|cityNameWrite|userNameWrite|readJoystickY|readJoystickX|mouseReleased|openNextFile|scanNetworks|noInterrupts|digitalWrite|beginSpeaker|mousePressed|isActionDone|mouseDragged|displayLogos|noAutoscroll|addParameter|remoteNumber|getModifiers|keyboardRead|userNameRead|waitContinue|processInput|parseCommand|printVersion|readNetworks|writeMessage|blinkVersion|cityNameRead|readMessage|setDataMode|parsePacket|isListening|setBitOrder|beginPacket|isDirectory|motorsWrite|drawCompass|digitalRead|clearScreen|serialEvent|rightToLeft|setTextSize|leftToRight|requestFrom|keyReleased|compassRead|analogWrite|interrupts|WiFiServer|disconnect|playMelody|parseFloat|autoscroll|getPINUsed|setPINUsed|setTimeout|sendAnalog|readSlider|analogRead|beginWrite|createChar|motorsStop|keyPressed|tempoWrite|readButton|subnetMask|debugPrint|macAddress|writeGreen|randomSeed|attachGPRS|readString|sendString|remotePort|releaseAll|mouseMoved|background|getXChange|getYChange|answerCall|getResult|voiceCall|endPacket|constrain|getSocket|writeJSON|getButton|available|connected|findUntil|readBytes|exitValue|readGreen|writeBlue|startLoop|IPAddress|isPressed|sendSysex|pauseMode|gatewayIP|setCursor|getOemKey|tuneWrite|noDisplay|loadImage|switchPIN|onRequest|onReceive|changePIN|playFile|noBuffer|parseInt|overflow|checkPIN|knobRead|beginTFT|bitClear|updateIR|bitWrite|position|writeRGB|highByte|writeRed|setSpeed|readBlue|noStroke|remoteIP|transfer|shutdown|hangCall|beginSMS|endWrite|attached|maintain|noCursor|checkReg|checkPUK|shiftOut|isValid|shiftIn|pulseIn|connect|println|localIP|pinMode|getIMEI|display|noBlink|process|getBand|running|beginSD|drawBMP|lowByte|setBand|release|bitRead|prepare|pointTo|readRed|setMode|noFill|remove|listen|stroke|detach|attach|noTone|exists|buffer|height|bitSet|circle|config|cursor|random|IRread|setDNS|endSMS|getKey|micros|millis|begin|print|write|ready|flush|width|isPIN|blink|clear|press|mkdir|rmdir|close|point|yield|image|BSSID|click|delay|read|text|move|peek|beep|rect|line|open|seek|fill|size|turn|stop|home|find|step|tone|sqrt|RSSI|SSID|end|bit|tan|cos|sin|pow|map|abs|max|min|get|run|put)\b/,
	    constant: /\b(?:DIGITAL_MESSAGE|FIRMATA_STRING|ANALOG_MESSAGE|REPORT_DIGITAL|REPORT_ANALOG|INPUT_PULLUP|SET_PIN_MODE|INTERNAL2V56|SYSTEM_RESET|LED_BUILTIN|INTERNAL1V1|SYSEX_START|INTERNAL|EXTERNAL|DEFAULT|OUTPUT|INPUT|HIGH|LOW)\b/
	  });
	}


/***/ }),
/* 870 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = asciidoc;
	asciidoc.displayName = 'asciidoc';
	asciidoc.aliases = [];
	function asciidoc(Prism) {
	  (function(Prism) {
	    var attributes = {
	      pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\]\\]|\\.)*\]|[^\]\\]|\\.)*\]/m,
	      lookbehind: true,
	      inside: {
	        quoted: {
	          pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
	          inside: {
	            punctuation: /^[$`]|[$`]$/
	          }
	        },
	        interpreted: {
	          pattern: /'(?:[^'\\]|\\.)*'/,
	          inside: {
	            punctuation: /^'|'$/
	            // See rest below
	          }
	        },
	        string: /"(?:[^"\\]|\\.)*"/,
	        variable: /\w+(?==)/,
	        punctuation: /^\[|\]$|,/,
	        operator: /=/,
	        // The negative look-ahead prevents blank matches
	        'attr-value': /(?!^\s+$).+/
	      }
	    };
	    Prism.languages.asciidoc = {
	      'comment-block': {
	        pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
	        alias: 'comment'
	      },
	      table: {
	        pattern: /^\|={3,}(?:(?:\r?\n|\r).*)*?(?:\r?\n|\r)\|={3,}$/m,
	        inside: {
	          specifiers: {
	            pattern: /(?!\|)(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*])?(?:[<^>](?:\.[<^>])?|\.[<^>])?[a-z]*)(?=\|)/,
	            alias: 'attr-value'
	          },
	          punctuation: {
	            pattern: /(^|[^\\])[|!]=*/,
	            lookbehind: true
	          }
	          // See rest below
	        }
	      },
	      'passthrough-block': {
	        pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
	        inside: {
	          punctuation: /^\++|\++$/
	          // See rest below
	        }
	      },
	      // Literal blocks and listing blocks
	      'literal-block': {
	        pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
	        inside: {
	          punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
	          // See rest below
	        }
	      },
	      // Sidebar blocks, quote blocks, example blocks and open blocks
	      'other-block': {
	        pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
	        inside: {
	          punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
	          // See rest below
	        }
	      },
	      // list-punctuation and list-label must appear before indented-block
	      'list-punctuation': {
	        pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      'list-label': {
	        pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
	        lookbehind: true,
	        alias: 'symbol'
	      },
	      'indented-block': {
	        pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
	        lookbehind: true
	      },
	      comment: /^\/\/.*/m,
	      title: {
	        pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} +.+|^\.(?![\s.]).*/m,
	        alias: 'important',
	        inside: {
	          punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
	          // See rest below
	        }
	      },
	      'attribute-entry': {
	        pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
	        alias: 'tag'
	      },
	      attributes: attributes,
	      hr: {
	        pattern: /^'{3,}$/m,
	        alias: 'punctuation'
	      },
	      'page-break': {
	        pattern: /^<{3,}$/m,
	        alias: 'punctuation'
	      },
	      admonition: {
	        pattern: /^(?:TIP|NOTE|IMPORTANT|WARNING|CAUTION):/m,
	        alias: 'keyword'
	      },
	      callout: [
	        {
	          pattern: /(^[ \t]*)<?\d*>/m,
	          lookbehind: true,
	          alias: 'symbol'
	        },
	        {
	          pattern: /<\d+>/,
	          alias: 'symbol'
	        }
	      ],
	      macro: {
	        pattern: /\b[a-z\d][a-z\d-]*::?(?:(?:\S+)??\[(?:[^\]\\"]|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
	        inside: {
	          function: /^[a-z\d-]+(?=:)/,
	          punctuation: /^::?/,
	          attributes: {
	            pattern: /(?:\[(?:[^\]\\"]|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
	            inside: attributes.inside
	          }
	        }
	      },
	      inline: {
	        /*
	The initial look-behind prevents the highlighting of escaped quoted text.
	Quoted text can be multi-line but cannot span an empty line.
	All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
	First, we handle the constrained quotes.
	Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
	They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
	Then we handle the unconstrained quotes.
	Those do not have the restrictions of the constrained quotes.
	They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
	*/
	        pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"]|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?: ['`]|.)+?(?:(?:\r?\n|\r)(?: ['`]|.)+?)*['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"]|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
	        lookbehind: true,
	        inside: {
	          attributes: attributes,
	          url: {
	            pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
	            inside: {
	              punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
	            }
	          },
	          'attribute-ref': {
	            pattern: /^\{.+\}$/,
	            inside: {
	              variable: {
	                pattern: /(^\{)[a-z\d,+_-]+/,
	                lookbehind: true
	              },
	              operator: /^[=?!#%@$]|!(?=[:}])/,
	              punctuation: /^\{|\}$|::?/
	            }
	          },
	          italic: {
	            pattern: /^(['_])[\s\S]+\1$/,
	            inside: {
	              punctuation: /^(?:''?|__?)|(?:''?|__?)$/
	            }
	          },
	          bold: {
	            pattern: /^\*[\s\S]+\*$/,
	            inside: {
	              punctuation: /^\*\*?|\*\*?$/
	            }
	          },
	          punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
	        }
	      },
	      replacement: {
	        pattern: /\((?:C|TM|R)\)/,
	        alias: 'builtin'
	      },
	      entity: /&#?[\da-z]{1,8};/i,
	      'line-continuation': {
	        pattern: /(^| )\+$/m,
	        lookbehind: true,
	        alias: 'punctuation'
	      }
	    };
	    // Allow some nesting. There is no recursion though, so cloning should not be needed.
	    attributes.inside['interpreted'].inside.rest = {
	      macro: Prism.languages.asciidoc['macro'],
	      inline: Prism.languages.asciidoc['inline'],
	      replacement: Prism.languages.asciidoc['replacement'],
	      entity: Prism.languages.asciidoc['entity']
	    };
	    Prism.languages.asciidoc['passthrough-block'].inside.rest = {
	      macro: Prism.languages.asciidoc['macro']
	    };
	    Prism.languages.asciidoc['literal-block'].inside.rest = {
	      callout: Prism.languages.asciidoc['callout']
	    };
	    Prism.languages.asciidoc['table'].inside.rest = {
	      'comment-block': Prism.languages.asciidoc['comment-block'],
	      'passthrough-block': Prism.languages.asciidoc['passthrough-block'],
	      'literal-block': Prism.languages.asciidoc['literal-block'],
	      'other-block': Prism.languages.asciidoc['other-block'],
	      'list-punctuation': Prism.languages.asciidoc['list-punctuation'],
	      'indented-block': Prism.languages.asciidoc['indented-block'],
	      comment: Prism.languages.asciidoc['comment'],
	      title: Prism.languages.asciidoc['title'],
	      'attribute-entry': Prism.languages.asciidoc['attribute-entry'],
	      attributes: Prism.languages.asciidoc['attributes'],
	      hr: Prism.languages.asciidoc['hr'],
	      'page-break': Prism.languages.asciidoc['page-break'],
	      admonition: Prism.languages.asciidoc['admonition'],
	      'list-label': Prism.languages.asciidoc['list-label'],
	      callout: Prism.languages.asciidoc['callout'],
	      macro: Prism.languages.asciidoc['macro'],
	      inline: Prism.languages.asciidoc['inline'],
	      replacement: Prism.languages.asciidoc['replacement'],
	      entity: Prism.languages.asciidoc['entity'],
	      'line-continuation': Prism.languages.asciidoc['line-continuation']
	    };
	    Prism.languages.asciidoc['other-block'].inside.rest = {
	      table: Prism.languages.asciidoc['table'],
	      'list-punctuation': Prism.languages.asciidoc['list-punctuation'],
	      'indented-block': Prism.languages.asciidoc['indented-block'],
	      comment: Prism.languages.asciidoc['comment'],
	      'attribute-entry': Prism.languages.asciidoc['attribute-entry'],
	      attributes: Prism.languages.asciidoc['attributes'],
	      hr: Prism.languages.asciidoc['hr'],
	      'page-break': Prism.languages.asciidoc['page-break'],
	      admonition: Prism.languages.asciidoc['admonition'],
	      'list-label': Prism.languages.asciidoc['list-label'],
	      macro: Prism.languages.asciidoc['macro'],
	      inline: Prism.languages.asciidoc['inline'],
	      replacement: Prism.languages.asciidoc['replacement'],
	      entity: Prism.languages.asciidoc['entity'],
	      'line-continuation': Prism.languages.asciidoc['line-continuation']
	    };
	    Prism.languages.asciidoc['title'].inside.rest = {
	      macro: Prism.languages.asciidoc['macro'],
	      inline: Prism.languages.asciidoc['inline'],
	      replacement: Prism.languages.asciidoc['replacement'],
	      entity: Prism.languages.asciidoc['entity']
	    };
	    // Plugin to make entity title show the real entity, idea by Roman Komarov
	    Prism.hooks.add('wrap', function(env) {
	      if (env.type === 'entity') {
	        env.attributes['title'] = env.content.replace(/&amp;/, '&');
	      }
	    });
	  })(Prism);
	}


/***/ }),
/* 871 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = aspnet;
	aspnet.displayName = 'aspnet';
	aspnet.aliases = [];
	function aspnet(Prism) {
	  Prism.languages.aspnet = Prism.languages.extend('markup', {
	    'page-directive tag': {
	      pattern: /<%\s*@.*%>/i,
	      inside: {
	        'page-directive tag': /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
	        rest: Prism.languages.markup.tag.inside
	      }
	    },
	    'directive tag': {
	      pattern: /<%.*%>/i,
	      inside: {
	        'directive tag': /<%\s*?[$=%#:]{0,2}|%>/i,
	        rest: Prism.languages.csharp
	      }
	    }
	  });
	  // Regexp copied from prism-markup, with a negative look-ahead added
	  Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
	  // match directives of attribute value foo="<% Bar %>"
	  Prism.languages.insertBefore(
	    'inside',
	    'punctuation',
	    {
	      'directive tag': Prism.languages.aspnet['directive tag']
	    },
	    Prism.languages.aspnet.tag.inside['attr-value']
	  );
	  Prism.languages.insertBefore('aspnet', 'comment', {
	    'asp comment': /<%--[\s\S]*?--%>/
	  });
	  // script runat="server" contains csharp, not javascript
	  Prism.languages.insertBefore(
	    'aspnet',
	    Prism.languages.javascript ? 'script' : 'tag',
	    {
	      'asp script': {
	        pattern: /(<script(?=.*runat=['"]?server['"]?)[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
	        lookbehind: true,
	        inside: Prism.languages.csharp || {}
	      }
	    }
	  );
	}


/***/ }),
/* 872 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = autohotkey;
	autohotkey.displayName = 'autohotkey';
	autohotkey.aliases = [];
	function autohotkey(Prism) {
	  // NOTES - follows first-first highlight method, block is locked after highlight, different from SyntaxHl
	  Prism.languages.autohotkey = {
	    comment: {
	      pattern: /(^[^";\n]*("[^"\n]*?"[^"\n]*?)*)(?:;.*$|^\s*\/\*[\s\S]*\n\*\/)/m,
	      lookbehind: true
	    },
	    string: /"(?:[^"\n\r]|"")*"/m,
	    function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+?(?=\()/m, //function - don't use .*\) in the end bcoz string locks it
	    tag: /^[ \t]*[^\s:]+?(?=:(?:[^:]|$))/m, //labels
	    variable: /%\w+%/,
	    number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,
	    operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
	    punctuation: /[{}[\]():,]/,
	    boolean: /\b(?:true|false)\b/,
	    selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
	    constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_formatfloat|a_formatinteger|a_gui|a_guievent|a_guicontrol|a_guicontrolevent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|programfiles|a_programfiles|a_programs|a_programscommon|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel)\b/i,
	    builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|cos|dllcall|exp|fileexist|Fileopen|floor|il_add|il_create|il_destroy|instr|substr|isfunc|islabel|IsObject|ln|log|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|onmessage|numget|numput|registercallback|regexmatch|regexreplace|round|sin|tan|sqrt|strlen|sb_seticon|sb_setparts|sb_settext|strsplit|tv_add|tv_delete|tv_getchild|tv_getcount|tv_getnext|tv_get|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__New|__Call|__Get|__Set)\b/i,
	    symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
	    important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InstallKeybdHook|InstallMouseHook|KeyHistory|LTrim|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|WinActivateForce)\b/i,
	    keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Region|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|TryAgain|Type|UnCheck|underline|Unicode|Unlock|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i
	  };
	}


/***/ }),
/* 873 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = autoit;
	autoit.displayName = 'autoit';
	autoit.aliases = [];
	function autoit(Prism) {
	  Prism.languages.autoit = {
	    comment: [
	      /;.*/,
	      {
	        // The multi-line comments delimiters can actually be commented out with ";"
	        pattern: /(^\s*)#(?:comments-start|cs)[\s\S]*?^\s*#(?:comments-end|ce)/m,
	        lookbehind: true
	      }
	    ],
	    url: {
	      pattern: /(^\s*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
	      lookbehind: true
	    },
	    string: {
	      pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
	      greedy: true,
	      inside: {
	        variable: /([%$@])\w+\1/
	      }
	    },
	    directive: {
	      pattern: /(^\s*)#\w+/m,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    function: /\b\w+(?=\()/,
	    // Variables and macros
	    variable: /[$@]\w+/,
	    keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
	    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
	    boolean: /\b(?:True|False)\b/i,
	    operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Or|Not)\b/i,
	    punctuation: /[\[\]().,:]/
	  };
	}


/***/ }),
/* 874 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = bash;
	bash.displayName = 'bash';
	bash.aliases = [];
	function bash(Prism) {
	  (function(Prism) {
	    var insideString = {
	      variable: [
	        // Arithmetic Environment
	        {
	          pattern: /\$?\(\([\s\S]+?\)\)/,
	          inside: {
	            // If there is a $ sign at the beginning highlight $(( and )) as variable
	            variable: [
	              {
	                pattern: /(^\$\(\([\s\S]+)\)\)/,
	                lookbehind: true
	              },
	              /^\$\(\(/
	            ],
	            number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,
	            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
	            operator: /--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,
	            // If there is no $ sign at the beginning highlight (( and )) as punctuation
	            punctuation: /\(\(?|\)\)?|,|;/
	          }
	        },
	        // Command Substitution
	        {
	          pattern: /\$\([^)]+\)|`[^`]+`/,
	          inside: {
	            variable: /^\$\(|^`|\)$|`$/
	          }
	        },
	        /\$(?:[\w#?*!@]+|\{[^}]+\})/i
	      ]
	    };
	    Prism.languages.bash = {
	      shebang: {
	        pattern: /^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,
	        alias: 'important'
	      },
	      comment: {
	        pattern: /(^|[^"{\\])#.*/,
	        lookbehind: true
	      },
	      string: [
	        //Support for Here-Documents https://en.wikipedia.org/wiki/Here_document
	        {
	          pattern: /((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/,
	          lookbehind: true,
	          greedy: true,
	          inside: insideString
	        },
	        {
	          pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	          greedy: true,
	          inside: insideString
	        }
	      ],
	      variable: insideString.variable,
	      // Originally based on http://ss64.com/bash/
	      function: {
	        pattern: /(^|[\s;|&])(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|[\s;|&])/,
	        lookbehind: true
	      },
	      keyword: {
	        pattern: /(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/,
	        lookbehind: true
	      },
	      boolean: {
	        pattern: /(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/,
	        lookbehind: true
	      },
	      operator: /&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,
	      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];]/
	    };
	    var inside = insideString.variable[1].inside;
	    inside['function'] = Prism.languages.bash['function'];
	    inside.keyword = Prism.languages.bash.keyword;
	    inside.boolean = Prism.languages.bash.boolean;
	    inside.operator = Prism.languages.bash.operator;
	    inside.punctuation = Prism.languages.bash.punctuation;
	  })(Prism);
	}


/***/ }),
/* 875 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = basic;
	basic.displayName = 'basic';
	basic.aliases = [];
	function basic(Prism) {
	  Prism.languages.basic = {
	    string: /"(?:""|[!#$%&'()*,\/:;<=>?^_ +\-.A-Z\d])*"/i,
	    comment: {
	      pattern: /(?:!|REM\b).+/i,
	      inside: {
	        keyword: /^REM/i
	      }
	    },
	    number: /(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i,
	    keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SHARED|SINGLE|SELECT CASE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
	    function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
	    operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
	    punctuation: /[,;:()]/
	  };
	}


/***/ }),
/* 876 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = batch;
	batch.displayName = 'batch';
	batch.aliases = [];
	function batch(Prism) {
	  (function(Prism) {
	    var variable = /%%?[~:\w]+%?|!\S+!/;
	    var parameter = {
	      pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
	      alias: 'attr-name',
	      inside: {
	        punctuation: /:/
	      }
	    };
	    var string = /"[^"]*"/;
	    var number = /(?:\b|-)\d+\b/;
	    Prism.languages.batch = {
	      comment: [
	        /^::.*/m,
	        {
	          pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
	          lookbehind: true
	        }
	      ],
	      label: {
	        pattern: /^:.*/m,
	        alias: 'property'
	      },
	      command: [
	        {
	          // FOR command
	          pattern: /((?:^|[&(])[ \t]*)for(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* \S+ in \([^)]+\) do/im,
	          lookbehind: true,
	          inside: {
	            keyword: /^for\b|\b(?:in|do)\b/i,
	            string: string,
	            parameter: parameter,
	            variable: variable,
	            number: number,
	            punctuation: /[()',]/
	          }
	        },
	        {
	          // IF command
	          pattern: /((?:^|[&(])[ \t]*)if(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|\S+)?(?:==| (?:equ|neq|lss|leq|gtr|geq) )(?:"[^"]*"|\S+))/im,
	          lookbehind: true,
	          inside: {
	            keyword: /^if\b|\b(?:not|cmdextversion|defined|errorlevel|exist)\b/i,
	            string: string,
	            parameter: parameter,
	            variable: variable,
	            number: number,
	            operator: /\^|==|\b(?:equ|neq|lss|leq|gtr|geq)\b/i
	          }
	        },
	        {
	          // ELSE command
	          pattern: /((?:^|[&()])[ \t]*)else\b/im,
	          lookbehind: true,
	          inside: {
	            keyword: /^else\b/i
	          }
	        },
	        {
	          // SET command
	          pattern: /((?:^|[&(])[ \t]*)set(?: ?\/[a-z](?:[ :](?:"[^"]*"|\S+))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
	          lookbehind: true,
	          inside: {
	            keyword: /^set\b/i,
	            string: string,
	            parameter: parameter,
	            variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
	            number: number,
	            operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
	            punctuation: /[()',]/
	          }
	        },
	        {
	          // Other commands
	          pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
	          lookbehind: true,
	          inside: {
	            keyword: /^\w+\b/i,
	            string: string,
	            parameter: parameter,
	            label: {
	              pattern: /(^\s*):\S+/m,
	              lookbehind: true,
	              alias: 'property'
	            },
	            variable: variable,
	            number: number,
	            operator: /\^/
	          }
	        }
	      ],
	      operator: /[&@]/,
	      punctuation: /[()']/
	    };
	  })(Prism);
	}


/***/ }),
/* 877 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var c = __webpack_require__(68);
	module.exports = bison;
	bison.displayName = 'bison';
	bison.aliases = [];
	function bison(Prism) {
	  Prism.register(c);
	  Prism.languages.bison = Prism.languages.extend('c', {});
	  Prism.languages.insertBefore('bison', 'comment', {
	    bison: {
	      // This should match all the beginning of the file
	      // including the prologue(s), the bison declarations and
	      // the grammar rules.
	      pattern: /^[\s\S]*?%%[\s\S]*?%%/,
	      inside: {
	        c: {
	          // Allow for one level of nested braces
	          pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
	          inside: {
	            delimiter: {
	              pattern: /^%?\{|%?\}$/,
	              alias: 'punctuation'
	            },
	            'bison-variable': {
	              pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
	              alias: 'variable',
	              inside: {
	                punctuation: /<|>/
	              }
	            },
	            rest: Prism.languages.c
	          }
	        },
	        comment: Prism.languages.c.comment,
	        string: Prism.languages.c.string,
	        property: /\S+(?=:)/,
	        keyword: /%\w+/,
	        number: {
	          pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
	          lookbehind: true
	        },
	        punctuation: /%[%?]|[|:;\[\]<>]/
	      }
	    }
	  });
	}


/***/ }),
/* 878 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = brainfuck;
	brainfuck.displayName = 'brainfuck';
	brainfuck.aliases = [];
	function brainfuck(Prism) {
	  Prism.languages.brainfuck = {
	    pointer: {
	      pattern: /<|>/,
	      alias: 'keyword'
	    },
	    increment: {
	      pattern: /\+/,
	      alias: 'inserted'
	    },
	    decrement: {
	      pattern: /-/,
	      alias: 'deleted'
	    },
	    branching: {
	      pattern: /\[|\]/,
	      alias: 'important'
	    },
	    operator: /[.,]/,
	    comment: /\S+/
	  };
	}


/***/ }),
/* 879 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = bro;
	bro.displayName = 'bro';
	bro.aliases = [];
	function bro(Prism) {
	  Prism.languages.bro = {
	    comment: {
	      pattern: /(^|[^\\$])#.*/,
	      lookbehind: true,
	      inside: {
	        italic: /\b(?:TODO|FIXME|XXX)\b/
	      }
	    },
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    boolean: /\b[TF]\b/,
	    function: {
	      pattern: /(?:function|hook|event) \w+(?:::\w+)?/,
	      inside: {
	        keyword: /^(?:function|hook|event)/
	      }
	    },
	    variable: {
	      pattern: /(?:global|local) \w+/i,
	      inside: {
	        keyword: /(?:global|local)/
	      }
	    },
	    builtin: /(?:@(?:load(?:-(?:sigs|plugin))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:redef|priority|log|optional|default|add_func|delete_func|expire_func|read_expire|write_expire|create_expire|synchronized|persistent|rotate_interval|rotate_size|encrypt|raw_output|mergeable|group|error_handler|type_column))/,
	    constant: {
	      pattern: /const \w+/i,
	      inside: {
	        keyword: /const/
	      }
	    },
	    keyword: /\b(?:break|next|continue|alarm|using|of|add|delete|export|print|return|schedule|when|timeout|addr|any|bool|count|double|enum|file|int|interval|pattern|opaque|port|record|set|string|subnet|table|time|vector|for|if|else|in|module|function)\b/,
	    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
	    number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 880 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = clike;
	clike.displayName = 'clike';
	clike.aliases = [];
	function clike(Prism) {
	  Prism.languages.clike = {
	    comment: [
	      {
	        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true
	      }
	    ],
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    'class-name': {
	      pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
	      lookbehind: true,
	      inside: {
	        punctuation: /[.\\]/
	      }
	    },
	    keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	    boolean: /\b(?:true|false)\b/,
	    function: /[a-z0-9_]+(?=\()/i,
	    number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 881 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = coffeescript;
	coffeescript.displayName = 'coffeescript';
	coffeescript.aliases = [];
	function coffeescript(Prism) {
	  (function(Prism) {
	    // Ignore comments starting with { to privilege string interpolation highlighting
	    var comment = /#(?!\{).+/,
	      interpolation = {
	        pattern: /#\{[^}]+\}/,
	        alias: 'variable'
	      };
	    Prism.languages.coffeescript = Prism.languages.extend('javascript', {
	      comment: comment,
	      string: [
	        // Strings are multiline
	        {
	          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
	          greedy: true
	        },
	        {
	          // Strings are multiline
	          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        }
	      ],
	      keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
	      'class-member': {
	        pattern: /@(?!\d)\w+/,
	        alias: 'variable'
	      }
	    });
	    Prism.languages.insertBefore('coffeescript', 'comment', {
	      'multiline-comment': {
	        pattern: /###[\s\S]+?###/,
	        alias: 'comment'
	      },
	      // Block regexp can contain comments and interpolation
	      'block-regex': {
	        pattern: /\/{3}[\s\S]*?\/{3}/,
	        alias: 'regex',
	        inside: {
	          comment: comment,
	          interpolation: interpolation
	        }
	      }
	    });
	    Prism.languages.insertBefore('coffeescript', 'string', {
	      'inline-javascript': {
	        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
	        inside: {
	          delimiter: {
	            pattern: /^`|`$/,
	            alias: 'punctuation'
	          },
	          rest: Prism.languages.javascript
	        }
	      },
	      // Block strings
	      'multiline-string': [
	        {
	          pattern: /'''[\s\S]*?'''/,
	          greedy: true,
	          alias: 'string'
	        },
	        {
	          pattern: /"""[\s\S]*?"""/,
	          greedy: true,
	          alias: 'string',
	          inside: {
	            interpolation: interpolation
	          }
	        }
	      ]
	    });
	    Prism.languages.insertBefore('coffeescript', 'keyword', {
	      // Object property
	      property: /(?!\d)\w+(?=\s*:(?!:))/
	    });
	    delete Prism.languages.coffeescript['template-string'];
	  })(Prism);
	}


/***/ }),
/* 882 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ruby = __webpack_require__(352);
	module.exports = crystal;
	crystal.displayName = 'crystal';
	crystal.aliases = [];
	function crystal(Prism) {
	  Prism.register(ruby);
	  (function(Prism) {
	    Prism.languages.crystal = Prism.languages.extend('ruby', {
	      keyword: [
	        /\b(?:abstract|alias|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|rescue|return|require|select|self|sizeof|struct|super|then|type|typeof|uninitialized|union|unless|until|when|while|with|yield|__DIR__|__END_LINE__|__FILE__|__LINE__)\b/,
	        {
	          pattern: /(\.\s*)(?:is_a|responds_to)\?/,
	          lookbehind: true
	        }
	      ],
	      number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[0-9a-fA-F_]*[0-9a-fA-F]|(?:\d(?:[0-9_]*\d)?)(?:\.[0-9_]*\d)?(?:[eE][+-]?[0-9_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/
	    });
	    var rest = Prism.util.clone(Prism.languages.crystal);
	    Prism.languages.insertBefore('crystal', 'string', {
	      attribute: {
	        pattern: /@\[.+?\]/,
	        alias: 'attr-name',
	        inside: {
	          delimiter: {
	            pattern: /^@\[|\]$/,
	            alias: 'tag'
	          },
	          rest: rest
	        }
	      },
	      expansion: [
	        {
	          pattern: /\{\{.+?\}\}/,
	          inside: {
	            delimiter: {
	              pattern: /^\{\{|\}\}$/,
	              alias: 'tag'
	            },
	            rest: rest
	          }
	        },
	        {
	          pattern: /\{%.+?%\}/,
	          inside: {
	            delimiter: {
	              pattern: /^\{%|%\}$/,
	              alias: 'tag'
	            },
	            rest: rest
	          }
	        }
	      ]
	    });
	  })(Prism);
	}


/***/ }),
/* 883 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = csharp;
	csharp.displayName = 'csharp';
	csharp.aliases = [];
	function csharp(Prism) {
	  Prism.languages.csharp = Prism.languages.extend('clike', {
	    keyword: /\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/,
	    string: [
	      {
	        pattern: /@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,
	        greedy: true
	      },
	      {
	        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,
	        greedy: true
	      }
	    ],
	    number: /\b-?(?:0x[\da-f]+|\d*\.?\d+f?)\b/i
	  });
	  Prism.languages.insertBefore('csharp', 'keyword', {
	    'generic-method': {
	      pattern: /[a-z0-9_]+\s*<[^>\r\n]+?>\s*(?=\()/i,
	      alias: 'function',
	      inside: {
	        keyword: Prism.languages.csharp.keyword,
	        punctuation: /[<>(),.:]/
	      }
	    },
	    preprocessor: {
	      pattern: /(^\s*)#.*/m,
	      lookbehind: true,
	      alias: 'property',
	      inside: {
	        // highlight preprocessor directives as keywords
	        directive: {
	          pattern: /(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,
	          lookbehind: true,
	          alias: 'keyword'
	        }
	      }
	    }
	  });
	}


/***/ }),
/* 884 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = cssExtras;
	cssExtras.displayName = 'cssExtras';
	cssExtras.aliases = [];
	function cssExtras(Prism) {
	  Prism.languages.css.selector = {
	    pattern: /[^{}\s][^{}]*(?=\s*\{)/,
	    inside: {
	      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
	      'pseudo-class': /:[-\w]+(?:\(.*\))?/,
	      class: /\.[-:.\w]+/,
	      id: /#[-:.\w]+/,
	      attribute: /\[[^\]]+\]/
	    }
	  };
	  Prism.languages.insertBefore('css', 'function', {
	    hexcode: /#[\da-f]{3,8}/i,
	    entity: /\\[\da-f]{1,8}/i,
	    number: /[\d%.]+/
	  });
	}


/***/ }),
/* 885 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = css;
	css.displayName = 'css';
	css.aliases = [];
	function css(Prism) {
	  Prism.languages.css = {
	    comment: /\/\*[\s\S]*?\*\//,
	    atrule: {
	      pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
	      inside: {
	        rule: /@[\w-]+/
	        // See rest below
	      }
	    },
	    url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	    selector: /[^{}\s][^{};]*?(?=\s*\{)/,
	    string: {
	      pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    property: /[\w-]+(?=\s*:)/i,
	    important: /\B!important\b/i,
	    function: /[-a-z0-9]+(?=\()/i,
	    punctuation: /[(){};:]/
	  };
	  Prism.languages.css['atrule'].inside.rest = Prism.util.clone(
	    Prism.languages.css
	  );
	  if (Prism.languages.markup) {
	    Prism.languages.insertBefore('markup', 'tag', {
	      style: {
	        pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
	        lookbehind: true,
	        inside: Prism.languages.css,
	        alias: 'language-css'
	      }
	    });
	
	    Prism.languages.insertBefore(
	      'inside',
	      'attr-value',
	      {
	        'style-attr': {
	          pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
	          inside: {
	            'attr-name': {
	              pattern: /^\s*style/i,
	              inside: Prism.languages.markup.tag.inside
	            },
	            punctuation: /^\s*=\s*['"]|['"]\s*$/,
	            'attr-value': {
	              pattern: /.+/i,
	              inside: Prism.languages.css
	            }
	          },
	          alias: 'language-css'
	        }
	      },
	      Prism.languages.markup.tag
	    );
	  }
	}


/***/ }),
/* 886 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = d;
	d.displayName = 'd';
	d.aliases = [];
	function d(Prism) {
	  Prism.languages.d = Prism.languages.extend('clike', {
	    string: [
	      // r"", x""
	      /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/,
	      // q"[]", q"()", q"<>", q"{}"
	      /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/,
	      // q"IDENT
	      // ...
	      // IDENT"
	      /\bq"([_a-zA-Z][_a-zA-Z\d]*)(?:\r?\n|\r)[\s\S]*?(?:\r?\n|\r)\1"/,
	      // q"//", q"||", etc.
	      /\bq"(.)[\s\S]*?\1"/,
	      // Characters
	      /'(?:\\'|\\?[^']+)'/,
	      /(["`])(?:\\[\s\S]|(?!\1)[^\\])*\1[cwd]?/
	    ],
	    number: [
	      // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
	      // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
	      /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]*/i,
	      {
	        pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]*/i,
	        lookbehind: true
	      }
	    ],
	    // In order: $, keywords and special tokens, globally defined symbols
	    keyword: /\$|\b(?:abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|public|pure|real|ref|return|scope|shared|short|static|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|__(?:(?:FILE|MODULE|LINE|FUNCTION|PRETTY_FUNCTION|DATE|EOF|TIME|TIMESTAMP|VENDOR|VERSION)__|gshared|traits|vector|parameters)|string|wstring|dstring|size_t|ptrdiff_t)\b/,
	    operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
	  });
	  Prism.languages.d.comment = [
	    // Shebang
	    /^\s*#!.+/,
	    // /+ +/
	    {
	      // Allow one level of nesting
	      pattern: /(^|[^\\])\/\+(?:\/\+[\s\S]*?\+\/|[\s\S])*?\+\//,
	      lookbehind: true
	    }
	  ].concat(Prism.languages.d.comment);
	  Prism.languages.insertBefore('d', 'comment', {
	    'token-string': {
	      // Allow one level of nesting
	      pattern: /\bq\{(?:\{[^}]*\}|[^}])*\}/,
	      alias: 'string'
	    }
	  });
	  Prism.languages.insertBefore('d', 'keyword', {
	    property: /\B@\w*/
	  });
	  Prism.languages.insertBefore('d', 'function', {
	    register: {
	      // Iasm registers
	      pattern: /\b(?:[ABCD][LHX]|E[ABCD]X|E?(?:BP|SP|DI|SI)|[ECSDGF]S|CR[0234]|DR[012367]|TR[3-7]|X?MM[0-7]|R[ABCD]X|[BS]PL|R[BS]P|[DS]IL|R[DS]I|R(?:[89]|1[0-5])[BWD]?|XMM(?:[89]|1[0-5])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
	      alias: 'variable'
	    }
	  });
	}


/***/ }),
/* 887 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = dart;
	dart.displayName = 'dart';
	dart.aliases = [];
	function dart(Prism) {
	  Prism.languages.dart = Prism.languages.extend('clike', {
	    string: [
	      {
	        pattern: /r?("""|''')[\s\S]*?\1/,
	        greedy: true
	      },
	      {
	        pattern: /r?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      }
	    ],
	    keyword: [
	      /\b(?:async|sync|yield)\*/,
	      /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|default|deferred|do|dynamic|else|enum|export|external|extends|factory|final|finally|for|get|if|implements|import|in|library|new|null|operator|part|rethrow|return|set|static|super|switch|this|throw|try|typedef|var|void|while|with|yield)\b/
	    ],
	    operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
	  });
	  Prism.languages.insertBefore('dart', 'function', {
	    metadata: {
	      pattern: /@\w+/,
	      alias: 'symbol'
	    }
	  });
	}


/***/ }),
/* 888 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = diff;
	diff.displayName = 'diff';
	diff.aliases = [];
	function diff(Prism) {
	  Prism.languages.diff = {
	    coord: [
	      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
	      /^(?:\*{3}|-{3}|\+{3}).*$/m,
	      // Match "@@ ... @@" coord lines in unified diff.
	      /^@@.*@@$/m,
	      // Match coord lines in normal diff (starts with a number).
	      /^\d+.*$/m
	    ],
	    // Match inserted and deleted lines. Support both +/- and >/< styles.
	    deleted: /^[-<].*$/m,
	    inserted: /^[+>].*$/m,
	    // Match "different" lines (prefixed with "!") in context diff.
	    diff: {
	      pattern: /^!(?!!).+$/m,
	      alias: 'important'
	    }
	  };
	}


/***/ }),
/* 889 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = django;
	django.displayName = 'django';
	django.aliases = ['jinja2'];
	function django(Prism) {
	  // Django/Jinja2 syntax definition for Prism.js <http://prismjs.com> syntax highlighter.
	  // Mostly it works OK but can paint code incorrectly on complex html/template tag combinations.
	  var _django_template = {
	    property: {
	      pattern: /(?:{{|{%)[\s\S]*?(?:%}|}})/g,
	      greedy: true,
	      inside: {
	        string: {
	          pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	          greedy: true
	        },
	        keyword: /\b(?:\||load|verbatim|widthratio|ssi|firstof|for|url|ifchanged|csrf_token|lorem|ifnotequal|autoescape|now|templatetag|debug|cycle|ifequal|regroup|comment|filter|endfilter|if|spaceless|with|extends|block|include|else|empty|endif|endfor|as|endblock|endautoescape|endverbatim|trans|endtrans|[Tt]rue|[Ff]alse|[Nn]one|in|is|static|macro|endmacro|call|endcall|set|endset|raw|endraw)\b/,
	        operator: /[-+=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
	        function: /\b(?:_|abs|add|addslashes|attr|batch|callable|capfirst|capitalize|center|count|cut|d|date|default|default_if_none|defined|dictsort|dictsortreversed|divisibleby|e|equalto|escape|escaped|escapejs|even|filesizeformat|first|float|floatformat|force_escape|forceescape|format|get_digit|groupby|indent|int|iriencode|iterable|join|last|length|length_is|linebreaks|linebreaksbr|linenumbers|list|ljust|lower|make_list|map|mapping|number|odd|phone2numeric|pluralize|pprint|random|reject|rejectattr|removetags|replace|reverse|rjust|round|safe|safeseq|sameas|select|selectattr|sequence|slice|slugify|sort|string|stringformat|striptags|sum|time|timesince|timeuntil|title|trim|truncate|truncatechars|truncatechars_html|truncatewords|truncatewords_html|undefined|unordered_list|upper|urlencode|urlize|urlizetrunc|wordcount|wordwrap|xmlattr|yesno)\b/,
	        important: /\b-?\d+(?:\.\d+)?\b/,
	        variable: /\b\w+?\b/,
	        punctuation: /[[\];(),.:]/
	      }
	    }
	  };
	  Prism.languages.django = Prism.languages.extend('markup', {
	    comment: /(?:<!--|{#)[\s\S]*?(?:#}|-->)/
	  });
	  // Updated html tag pattern to allow template tags inside html tags
	  Prism.languages.django.tag.pattern = /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^>=]+))?)*\s*\/?>/i;
	  Prism.languages.insertBefore('django', 'entity', _django_template);
	  Prism.languages.insertBefore(
	    'inside',
	    'tag',
	    _django_template,
	    Prism.languages.django.tag
	  );
	  if (Prism.languages.javascript) {
	    // Combine js code and template tags painting inside <script> blocks
	    Prism.languages.insertBefore(
	      'inside',
	      'string',
	      _django_template,
	      Prism.languages.django.script
	    );
	    Prism.languages.django.script.inside.string.inside = _django_template;
	  }
	  if (Prism.languages.css) {
	    // Combine css code and template tags painting inside <style> blocks
	    Prism.languages.insertBefore(
	      'inside',
	      'atrule',
	      {tag: _django_template.property},
	      Prism.languages.django.style
	    );
	    Prism.languages.django.style.inside.string.inside = _django_template;
	  }
	  // Add an Jinja2 alias
	  Prism.languages.jinja2 = Prism.languages.django;
	}


/***/ }),
/* 890 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = docker;
	docker.displayName = 'docker';
	docker.aliases = ['dockerfile'];
	function docker(Prism) {
	  Prism.languages.docker = {
	    keyword: {
	      pattern: /(^\s*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)/im,
	      lookbehind: true
	    },
	    string: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
	    comment: /#.*/,
	    punctuation: /---|\.\.\.|[:[\]{}\-,|>?]/
	  };
	  Prism.languages.dockerfile = Prism.languages.docker;
	}


/***/ }),
/* 891 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = eiffel;
	eiffel.displayName = 'eiffel';
	eiffel.aliases = [];
	function eiffel(Prism) {
	  Prism.languages.eiffel = {
	    comment: /--.*/,
	    string: [
	      // Aligned-verbatim-strings
	      {
	        pattern: /"([^[]*)\[[\s\S]+?\]\1"/,
	        greedy: true
	      },
	      // Non-aligned-verbatim-strings
	      {
	        pattern: /"([^{]*)\{[\s\S]+?\}\1"/,
	        greedy: true
	      },
	      // Single-line string
	      {
	        pattern: /"(?:%\s+%|%.|[^%"\r\n])*"/,
	        greedy: true
	      }
	    ],
	    // normal char | special char | char code
	    char: /'(?:%.|[^%'\r\n])+'/,
	    keyword: /\b(?:across|agent|alias|all|and|attached|as|assign|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
	    boolean: /\b(?:True|False)\b/i,
	    // Convention: class-names are always all upper-case characters
	    'class-name': {
	      pattern: /\b[A-Z][\dA-Z_]*\b/,
	      alias: 'builtin'
	    },
	    number: [
	      // hexa | octal | bin
	      /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
	      // Decimal
	      /(?:\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?[eE][+-]?)?\d(?:_*\d)*|\d(?:_*\d)*\.?/
	    ],
	    punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
	    operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
	  };
	}


/***/ }),
/* 892 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = elixir;
	elixir.displayName = 'elixir';
	elixir.aliases = [];
	function elixir(Prism) {
	  Prism.languages.elixir = {
	    // Negative look-ahead is needed for string interpolation
	    // Negative look-behind is needed to avoid highlighting markdown headers in
	    // multi-line doc strings
	    comment: {
	      pattern: /(^|[^#])#(?![{#]).*/m,
	      lookbehind: true
	    },
	    // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
	    regex: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
	    string: [
	      {
	        // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
	        pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      },
	      {
	        pattern: /("""|''')[\s\S]*?\1/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      },
	      {
	        // Multi-line strings are allowed
	        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      }
	    ],
	    atom: {
	      // Look-behind prevents bad highlighting of the :: operator
	      pattern: /(^|[^:]):\w+/,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    // Look-ahead prevents bad highlighting of the :: operator
	    'attr-name': /\w+:(?!:)/,
	    capture: {
	      // Look-behind prevents bad highlighting of the && operator
	      pattern: /(^|[^&])&(?:[^&\s\d()][^\s()]*|(?=\())/,
	      lookbehind: true,
	      alias: 'function'
	    },
	    argument: {
	      // Look-behind prevents bad highlighting of the && operator
	      pattern: /(^|[^&])&\d+/,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    attribute: {
	      pattern: /@[\S]+/,
	      alias: 'variable'
	    },
	    number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
	    keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\b/,
	    boolean: /\b(?:true|false|nil)\b/,
	    operator: [
	      /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
	      {
	        // We don't want to match <<
	        pattern: /([^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /([^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /<<|>>|[.,%\[\]{}()]/
	  };
	  Prism.languages.elixir.string.forEach(function(o) {
	    o.inside = {
	      interpolation: {
	        pattern: /#\{[^}]+\}/,
	        inside: {
	          delimiter: {
	            pattern: /^#\{|\}$/,
	            alias: 'punctuation'
	          },
	          rest: Prism.util.clone(Prism.languages.elixir)
	        }
	      }
	    };
	  });
	}


/***/ }),
/* 893 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = erlang;
	erlang.displayName = 'erlang';
	erlang.aliases = [];
	function erlang(Prism) {
	  Prism.languages.erlang = {
	    comment: /%.+/,
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    'quoted-function': {
	      pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
	      alias: 'function'
	    },
	    'quoted-atom': {
	      pattern: /'(?:\\.|[^\\'\r\n])+'/,
	      alias: 'atom'
	    },
	    boolean: /\b(?:true|false)\b/,
	    keyword: /\b(?:fun|when|case|of|end|if|receive|after|try|catch)\b/,
	    number: [/\$\\?./, /\d+#[a-z0-9]+/i, /(?:\b|-)\d*\.?\d+([Ee][+-]?\d+)?\b/],
	    function: /\b[a-z][\w@]*(?=\()/,
	    variable: {
	      // Look-behind is used to prevent wrong highlighting of atoms containing "@"
	      pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
	      lookbehind: true
	    },
	    operator: [
	      /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:bnot|div|rem|band|bor|bxor|bsl|bsr|not|and|or|xor|orelse|andalso)\b/,
	      {
	        // We don't want to match <<
	        pattern: /(^|[^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /(^|[^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    atom: /\b[a-z][\w@]*/,
	    punctuation: /[()[\]{}:;,.#|]|<<|>>/
	  };
	}


/***/ }),
/* 894 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = fortran;
	fortran.displayName = 'fortran';
	fortran.aliases = [];
	function fortran(Prism) {
	  Prism.languages.fortran = {
	    'quoted-number': {
	      pattern: /[BOZ](['"])[A-F0-9]+\1/i,
	      alias: 'number'
	    },
	    string: {
	      pattern: /(?:\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:\s*!.+(?:\r\n?|\n))?|(?!\1).)*(?:\1|&)/,
	      inside: {
	        comment: {
	          pattern: /(&(?:\r\n?|\n)\s*)!.*/,
	          lookbehind: true
	        }
	      }
	    },
	    comment: /!.*/,
	    boolean: /\.(?:TRUE|FALSE)\.(?:_\w+)?/i,
	    number: /(?:\b|[+-])(?:\d+(?:\.\d*)?|\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
	    keyword: [
	      // Types
	      /\b(?:INTEGER|REAL|DOUBLE ?PRECISION|COMPLEX|CHARACTER|LOGICAL)\b/i,
	      // END statements
	      /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
	      // Statements
	      /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
	      // Others
	      /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEWHERE|ELSEIF|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
	    ],
	    operator: [
	      /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.(?:EQ|NE|LT|LE|GT|GE|NOT|AND|OR|EQV|NEQV)\.|\.[A-Z]+\./i,
	      {
	        // Use lookbehind to prevent confusion with (/ /)
	        pattern: /(^|(?!\().)\/(?!\))/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /\(\/|\/\)|[(),;:&]/
	  };
	}


/***/ }),
/* 895 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = fsharp;
	fsharp.displayName = 'fsharp';
	fsharp.aliases = [];
	function fsharp(Prism) {
	  Prism.languages.fsharp = Prism.languages.extend('clike', {
	    comment: [
	      {
	        pattern: /(^|[^\\])\(\*[\s\S]*?\*\)/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true
	      }
	    ],
	    keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(abstract|and|as|assert|base|begin|class|default|delegate|do|done|downcast|downto|elif|else|end|exception|extern|false|finally|for|fun|function|global|if|in|inherit|inline|interface|internal|lazy|match|member|module|mutable|namespace|new|not|null|of|open|or|override|private|public|rec|select|static|struct|then|to|true|try|type|upcast|val|void|when|while|with|asr|land|lor|lsl|lsr|lxor|mod|sig|atomic|break|checked|component|const|constraint|constructor|continue|eager|event|external|fixed|functor|include|method|mixin|object|parallel|process|protected|pure|sealed|tailcall|trait|virtual|volatile)\b/,
	    string: {
	      pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1)B?/,
	      greedy: true
	    },
	    number: [
	      /\b-?0x[\da-fA-F]+(?:un|lf|LF)?\b/,
	      /\b-?0b[01]+(?:y|uy)?\b/,
	      /\b-?(?:\d*\.?\d+|\d+\.)(?:[fFmM]|[eE][+-]?\d+)?\b/,
	      /\b-?\d+(?:y|uy|s|us|l|u|ul|L|UL|I)?\b/
	    ]
	  });
	  Prism.languages.insertBefore('fsharp', 'keyword', {
	    preprocessor: {
	      pattern: /^[^\r\n\S]*#.*/m,
	      alias: 'property',
	      inside: {
	        directive: {
	          pattern: /(\s*#)\b(?:else|endif|if|light|line|nowarn)\b/,
	          lookbehind: true,
	          alias: 'keyword'
	        }
	      }
	    }
	  });
	}


/***/ }),
/* 896 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = gherkin;
	gherkin.displayName = 'gherkin';
	gherkin.aliases = [];
	function gherkin(Prism) {
	  Prism.languages.gherkin = {
	    pystring: {
	      pattern: /("""|''')[\s\S]+?\1/,
	      alias: 'string'
	    },
	    comment: {
	      pattern: /((?:^|\r?\n|\r)[ \t]*)#.*/,
	      lookbehind: true
	    },
	    tag: {
	      pattern: /((?:^|\r?\n|\r)[ \t]*)@\S*/,
	      lookbehind: true
	    },
	    feature: {
	      pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|laH|Lastnost|Mak|Mogucnost|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|perbogh|poQbogh malja'|Potrzeba biznesowa|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:]+(?:\r?\n|\r|$))*/,
	      lookbehind: true,
	      inside: {
	        important: {
	          pattern: /(:)[^\r\n]+/,
	          lookbehind: true
	        },
	        keyword: /[^:\r\n]+:/
	      }
	    },
	    scenario: {
	      pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram senaryo|Dyagram Senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|Examples|EXAMPLZ|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|ghantoH|Grundlage|Hannergrond|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut|lut chovnatlh|lutmey|Lýsing Atburðarásar|Lýsing Dæma|Menggariskan Senario|MISHUN|MISHUN SRSLY|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan senaryo|Plan Senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo|Senaryo deskripsyon|Senaryo Deskripsyon|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie|Situasie Uiteensetting|Skenario|Skenario konsep|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa|Swa hwaer swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo\-ho\-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/,
	      lookbehind: true,
	      inside: {
	        important: {
	          pattern: /(:)[^\r\n]*/,
	          lookbehind: true
	        },
	        keyword: /[^:\r\n]+:/
	      }
	    },
	    'table-body': {
	      // Look-behind is used to skip the table head, which has the same format as any table row
	      pattern: /((?:\r?\n|\r)[ \t]*\|.+\|[^\r\n]*)+/,
	      lookbehind: true,
	      inside: {
	        outline: {
	          pattern: /<[^>]+?>/,
	          alias: 'variable'
	        },
	        td: {
	          pattern: /\s*[^\s|][^|]*/,
	          alias: 'string'
	        },
	        punctuation: /\|/
	      }
	    },
	    'table-head': {
	      pattern: /(?:\r?\n|\r)[ \t]*\|.+\|[^\r\n]*/,
	      inside: {
	        th: {
	          pattern: /\s*[^\s|][^|]*/,
	          alias: 'variable'
	        },
	        punctuation: /\|/
	      }
	    },
	    atrule: {
	      pattern: /((?:\r?\n|\r)[ \t]+)(?:'ach|'a|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cando|Cand|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|Dato|DEN|Den youse gotta|Dengan|De|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|Entonces|En|Epi|E|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kadar|Kada|Kad|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Majd|Maka|Manawa|Mas|Ma|Menawa|Men|Mutta|Nalikaning|Nalika|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Og|Och|Oletetaan|Onda|Ond|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|qaSDI'|Quando|Quand|Quan|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|ugeholl|Und|Un|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadani|Zadano|Zadan|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t]+)/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
	      inside: {
	        outline: {
	          pattern: /<[^>]+?>/,
	          alias: 'variable'
	        }
	      }
	    },
	    outline: {
	      pattern: /<[^>]+?>/,
	      alias: 'variable'
	    }
	  };
	}


/***/ }),
/* 897 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = git;
	git.displayName = 'git';
	git.aliases = [];
	function git(Prism) {
	  Prism.languages.git = {
	    /*
	* A simple one line comment like in a git status command
	* For instance:
	* $ git status
	* # On branch infinite-scroll
	* # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
	* # and have 1 and 2 different commits each, respectively.
	* nothing to commit (working directory clean)
	*/
	    comment: /^#.*/m,
	    /*
	* Regexp to match the changed lines in a git diff output. Check the example below.
	*/
	    deleted: /^[-–].*/m,
	    inserted: /^\+.*/m,
	    /*
	* a string (double and simple quote)
	*/
	    string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m,
	    /*
	* a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
	* For instance:
	* $ git add file.txt
	*/
	    command: {
	      pattern: /^.*\$ git .*$/m,
	      inside: {
	        /*
	* A git command can contain a parameter starting by a single or a double dash followed by a string
	* For instance:
	* $ git diff --cached
	* $ git log -p
	*/
	        parameter: /\s--?\w+/m
	      }
	    },
	    /*
	* Coordinates displayed in a git diff command
	* For instance:
	* $ git diff
	* diff --git file.txt file.txt
	* index 6214953..1d54a52 100644
	* --- file.txt
	* +++ file.txt
	* @@ -1 +1,2 @@
	* -Here's my tetx file
	* +Here's my text file
	* +And this is the second line
	*/
	    coord: /^@@.*@@$/m,
	    /*
	* Match a "commit [SHA1]" line in a git log output.
	* For instance:
	* $ git log
	* commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
	* Author: lgiraudel
	* Date:   Mon Feb 17 11:18:34 2014 +0100
	*
	*     Add of a new line
	*/
	    commit_sha1: /^commit \w{40}$/m
	  };
	}


/***/ }),
/* 898 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = glsl;
	glsl.displayName = 'glsl';
	glsl.aliases = [];
	function glsl(Prism) {
	  Prism.languages.glsl = Prism.languages.extend('clike', {
	    comment: [/\/\*[\s\S]*?\*\//, /\/\/(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/],
	    number: /\b(?:0x[\da-f]+|(?:\.\d+|\d+\.?\d*)(?:e[+-]?\d+)?)[ulf]*\b/i,
	    keyword: /\b(?:attribute|const|uniform|varying|buffer|shared|coherent|volatile|restrict|readonly|writeonly|atomic_uint|layout|centroid|flat|smooth|noperspective|patch|sample|break|continue|do|for|while|switch|case|default|if|else|subroutine|in|out|inout|float|double|int|void|bool|true|false|invariant|precise|discard|return|d?mat[234](?:x[234])?|[ibdu]?vec[234]|uint|lowp|mediump|highp|precision|[iu]?sampler[123]D|[iu]?samplerCube|sampler[12]DShadow|samplerCubeShadow|[iu]?sampler[12]DArray|sampler[12]DArrayShadow|[iu]?sampler2DRect|sampler2DRectShadow|[iu]?samplerBuffer|[iu]?sampler2DMS(?:Array)?|[iu]?samplerCubeArray|samplerCubeArrayShadow|[iu]?image[123]D|[iu]?image2DRect|[iu]?imageCube|[iu]?imageBuffer|[iu]?image[12]DArray|[iu]?imageCubeArray|[iu]?image2DMS(?:Array)?|struct|common|partition|active|asm|class|union|enum|typedef|template|this|resource|goto|inline|noinline|public|static|extern|external|interface|long|short|half|fixed|unsigned|superp|input|output|hvec[234]|fvec[234]|sampler3DRect|filter|sizeof|cast|namespace|using)\b/
	  });
	  Prism.languages.insertBefore('glsl', 'comment', {
	    preprocessor: {
	      pattern: /(^[ \t]*)#(?:(?:define|undef|if|ifdef|ifndef|else|elif|endif|error|pragma|extension|version|line)\b)?/m,
	      lookbehind: true,
	      alias: 'builtin'
	    }
	  });
	}


/***/ }),
/* 899 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = go;
	go.displayName = 'go';
	go.aliases = [];
	function go(Prism) {
	  Prism.languages.go = Prism.languages.extend('clike', {
	    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
	    builtin: /\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/,
	    boolean: /\b(?:_|iota|nil|true|false)\b/,
	    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
	    number: /\b(-?(0x[a-f\d]+|(\d+\.?\d*|\.\d+)(e[-+]?\d+)?)i?)\b/i,
	    string: {
	      pattern: /(["'`])(\\[\s\S]|(?!\1)[^\\])*\1/,
	      greedy: true
	    }
	  });
	  delete Prism.languages.go['class-name'];
	}


/***/ }),
/* 900 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = graphql;
	graphql.displayName = 'graphql';
	graphql.aliases = [];
	function graphql(Prism) {
	  Prism.languages.graphql = {
	    comment: /#.*/,
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    number: /(?:\B-|\b)\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b/,
	    boolean: /\b(?:true|false)\b/,
	    variable: /\$[a-z_]\w*/i,
	    directive: {
	      pattern: /@[a-z_]\w*/i,
	      alias: 'function'
	    },
	    'attr-name': /[a-z_]\w*(?=\s*:)/i,
	    keyword: [
	      {
	        pattern: /(fragment\s+(?!on)[a-z_]\w*\s+|\.{3}\s*)on\b/,
	        lookbehind: true
	      },
	      /\b(?:query|fragment|mutation)\b/
	    ],
	    operator: /!|=|\.{3}/,
	    punctuation: /[!(){}\[\]:=,]/
	  };
	}


/***/ }),
/* 901 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = groovy;
	groovy.displayName = 'groovy';
	groovy.aliases = [];
	function groovy(Prism) {
	  Prism.languages.groovy = Prism.languages.extend('clike', {
	    keyword: /\b(?:as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
	    string: [
	      {
	        pattern: /("""|''')[\s\S]*?\1|(?:\$\/)(?:\$\/\$|[\s\S])*?\/\$/,
	        greedy: true
	      },
	      {
	        pattern: /(["'\/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      }
	    ],
	    number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?[\d]+)?)[glidf]?\b/i,
	    operator: {
	      pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.{1,2}(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
	      lookbehind: true
	    },
	    punctuation: /\.+|[{}[\];(),:$]/
	  });
	  Prism.languages.insertBefore('groovy', 'string', {
	    shebang: {
	      pattern: /#!.+/,
	      alias: 'comment'
	    }
	  });
	  Prism.languages.insertBefore('groovy', 'punctuation', {
	    'spock-block': /\b(?:setup|given|when|then|and|cleanup|expect|where):/
	  });
	  Prism.languages.insertBefore('groovy', 'function', {
	    annotation: {
	      alias: 'punctuation',
	      pattern: /(^|[^.])@\w+/,
	      lookbehind: true
	    }
	  });
	  // Handle string interpolation
	  Prism.hooks.add('wrap', function(env) {
	    if (env.language === 'groovy' && env.type === 'string') {
	      var delimiter = env.content[0];
	      if (delimiter != "'") {
	        var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
	        if (delimiter === '$') {
	          pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
	        }
	        // To prevent double HTML-encoding we have to decode env.content first
	        env.content = env.content.replace(/&lt;/g, '<').replace(/&amp;/g, '&');
	        env.content = Prism.highlight(env.content, {
	          expression: {
	            pattern: pattern,
	            lookbehind: true,
	            inside: Prism.languages.groovy
	          }
	        });
	        env.classes.push(delimiter === '/' ? 'regex' : 'gstring');
	      }
	    }
	  });
	}


/***/ }),
/* 902 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = haml;
	haml.displayName = 'haml';
	haml.aliases = [];
	function haml(Prism) {
	  /* TODO
	Handle multiline code after tag
	%foo= some |
	multiline |
	code |
	*/
	  (function(Prism) {
	    Prism.languages.haml = {
	      // Multiline stuff should appear before the rest
	      'multiline-comment': {
	        pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ]+.+)*/,
	        lookbehind: true,
	        alias: 'comment'
	      },
	      'multiline-code': [
	        {
	          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ]+.*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ]+.+)/,
	          lookbehind: true,
	          inside: {
	            rest: Prism.languages.ruby
	          }
	        },
	        {
	          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ]+.*\|[\t ]*)*/,
	          lookbehind: true,
	          inside: {
	            rest: Prism.languages.ruby
	          }
	        }
	      ],
	      // See at the end of the file for known filters
	      filter: {
	        pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/,
	        lookbehind: true,
	        inside: {
	          'filter-name': {
	            pattern: /^:[\w-]+/,
	            alias: 'variable'
	          }
	        }
	      },
	      markup: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.markup
	        }
	      },
	      doctype: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
	        lookbehind: true
	      },
	      tag: {
	        // Allows for one nested group of braces
	        pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^}])+\}|\[[^\]]+\])*[\/<>]*/,
	        lookbehind: true,
	        inside: {
	          attributes: [
	            {
	              // Lookbehind tries to prevent interpolations from breaking it all
	              // Allows for one nested group of braces
	              pattern: /(^|[^#])\{(?:\{[^}]+\}|[^}])+\}/,
	              lookbehind: true,
	              inside: {
	                rest: Prism.languages.ruby
	              }
	            },
	            {
	              pattern: /\([^)]+\)/,
	              inside: {
	                'attr-value': {
	                  pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
	                  lookbehind: true
	                },
	                'attr-name': /[\w:-]+(?=\s*!?=|\s*[,)])/,
	                punctuation: /[=(),]/
	              }
	            },
	            {
	              pattern: /\[[^\]]+\]/,
	              inside: {
	                rest: Prism.languages.ruby
	              }
	            }
	          ],
	          punctuation: /[<>]/
	        }
	      },
	      code: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.ruby
	        }
	      },
	      // Interpolations in plain text
	      interpolation: {
	        pattern: /#\{[^}]+\}/,
	        inside: {
	          delimiter: {
	            pattern: /^#\{|\}$/,
	            alias: 'punctuation'
	          },
	          rest: Prism.languages.ruby
	        }
	      },
	      punctuation: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
	        lookbehind: true
	      }
	    };
	    var filter_pattern =
	      '((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ]+.+|\\s*?(?=\\r?\\n|\\r)))+';
	    // Non exhaustive list of available filters and associated languages
	    var filters = [
	      'css',
	      {filter: 'coffee', language: 'coffeescript'},
	      'erb',
	      'javascript',
	      'less',
	      'markdown',
	      'ruby',
	      'scss',
	      'textile'
	    ];
	    var all_filters = {};
	    for (var i = 0, l = filters.length; i < l; i++) {
	      var filter = filters[i];
	      filter =
	        typeof filter === 'string'
	          ? {filter: filter, language: filter}
	          : filter;
	      if (Prism.languages[filter.language]) {
	        all_filters['filter-' + filter.filter] = {
	          pattern: RegExp(
	            filter_pattern.replace('{{filter_name}}', filter.filter)
	          ),
	          lookbehind: true,
	          inside: {
	            'filter-name': {
	              pattern: /^:[\w-]+/,
	              alias: 'variable'
	            },
	            rest: Prism.languages[filter.language]
	          }
	        };
	      }
	    }
	    Prism.languages.insertBefore('haml', 'filter', all_filters);
	  })(Prism);
	}


/***/ }),
/* 903 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = handlebars;
	handlebars.displayName = 'handlebars';
	handlebars.aliases = [];
	function handlebars(Prism) {
	  (function(Prism) {
	    var handlebars_pattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/;
	    Prism.languages.handlebars = Prism.languages.extend('markup', {
	      handlebars: {
	        pattern: handlebars_pattern,
	        inside: {
	          delimiter: {
	            pattern: /^\{\{\{?|\}\}\}?$/i,
	            alias: 'punctuation'
	          },
	          string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	          number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][+-]?\d+)?)\b/,
	          boolean: /\b(?:true|false)\b/,
	          block: {
	            pattern: /^(\s*~?\s*)[#\/]\S+?(?=\s*~?\s*$|\s)/i,
	            lookbehind: true,
	            alias: 'keyword'
	          },
	          brackets: {
	            pattern: /\[[^\]]+\]/,
	            inside: {
	              punctuation: /\[|\]/,
	              variable: /[\s\S]+/
	            }
	          },
	          punctuation: /[!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~]/,
	          variable: /[^!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~\s]+/
	        }
	      }
	    });
	    // Comments are inserted at top so that they can
	    // surround markup
	    Prism.languages.insertBefore('handlebars', 'tag', {
	      'handlebars-comment': {
	        pattern: /\{\{![\s\S]*?\}\}/,
	        alias: ['handlebars', 'comment']
	      }
	    });
	    // Tokenize all inline Handlebars expressions that are wrapped in {{ }} or {{{ }}}
	    // This allows for easy Handlebars + markup highlighting
	    Prism.hooks.add('before-highlight', function(env) {
	      if (env.language !== 'handlebars') {
	        return;
	      }
	      env.tokenStack = [];
	      env.backupCode = env.code;
	      env.code = env.code.replace(handlebars_pattern, function(match) {
	        var i = env.tokenStack.length;
	        // Check for existing strings
	        while (env.backupCode.indexOf('___HANDLEBARS' + i + '___') !== -1) ++i;
	        // Create a sparse array
	        env.tokenStack[i] = match;
	        return '___HANDLEBARS' + i + '___';
	      });
	    });
	    // Restore env.code for other plugins (e.g. line-numbers)
	    Prism.hooks.add('before-insert', function(env) {
	      if (env.language === 'handlebars') {
	        env.code = env.backupCode;
	        delete env.backupCode;
	      }
	    });
	    // Re-insert the tokens after highlighting
	    // and highlight them with defined grammar
	    Prism.hooks.add('after-highlight', function(env) {
	      if (env.language !== 'handlebars') {
	        return;
	      }
	      for (
	        var i = 0, keys = Object.keys(env.tokenStack);
	        i < keys.length;
	        ++i
	      ) {
	        var k = keys[i];
	        var t = env.tokenStack[k];
	        // The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
	        env.highlightedCode = env.highlightedCode.replace(
	          '___HANDLEBARS' + k + '___',
	          Prism.highlight(t, env.grammar, 'handlebars').replace(/\$/g, '$$$$')
	        );
	      }
	      env.element.innerHTML = env.highlightedCode;
	    });
	  })(Prism);
	}


/***/ }),
/* 904 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = haskell;
	haskell.displayName = 'haskell';
	haskell.aliases = [];
	function haskell(Prism) {
	  Prism.languages.haskell = {
	    comment: {
	      pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--[^-!#$%*+=?&@|~.:<>^\\\/].*|{-[\s\S]*?-})/m,
	      lookbehind: true
	    },
	    char: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
	    string: {
	      pattern: /"(?:[^\\"]|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\d+|o[0-7]+|x[0-9a-fA-F]+)|\\\s+\\)*"/,
	      greedy: true
	    },
	    keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
	    import_statement: {
	      // The imported or hidden names are not included in this import
	      // statement. This is because we want to highlight those exactly like
	      // we do for the names in the program.
	      pattern: /((?:\r?\n|\r|^)\s*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][_a-zA-Z0-9']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
	      lookbehind: true,
	      inside: {
	        keyword: /\b(?:import|qualified|as|hiding)\b/
	      }
	    },
	    // These are builtin variables only. Constructors are highlighted later as a constant.
	    builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
	    // decimal integers and floating point numbers | octal integers | hexadecimal integers
	    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
	    // Most of this is needed because of the meaning of a single '.'.
	    // If it stands alone freely, it is the function composition.
	    // It may also be a separator between a module name and an identifier => no
	    // operator. If it comes together with other special characters it is an
	    // operator too.
	    operator: /\s\.\s|[-!#$%*+=?&@|~.:<>^\\\/]*\.[-!#$%*+=?&@|~.:<>^\\\/]+|[-!#$%*+=?&@|~.:<>^\\\/]+\.[-!#$%*+=?&@|~.:<>^\\\/]*|[-!#$%*+=?&@|~:<>^\\\/]+|`([A-Z][\w']*\.)*[_a-z][\w']*`/,
	    // In Haskell, nearly everything is a variable, do not highlight these.
	    hvariable: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*\b/,
	    constant: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*\b/,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 905 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = haxe;
	haxe.displayName = 'haxe';
	haxe.aliases = [];
	function haxe(Prism) {
	  Prism.languages.haxe = Prism.languages.extend('clike', {
	    // Strings can be multi-line
	    string: {
	      pattern: /(["'])(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /(^|[^\\])\$(?:\w+|\{[^}]+\})/,
	          lookbehind: true,
	          inside: {
	            interpolation: {
	              pattern: /^\$\w*/,
	              alias: 'variable'
	            }
	            // See rest below
	          }
	        }
	      }
	    },
	    // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
	    keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|from|for|function|if|implements|import|in|inline|interface|macro|new|null|override|public|private|return|static|super|switch|throw|to|try|typedef|using|var|while)(?!\.)\b/,
	    operator: /\.{3}|\+\+?|-[->]?|[=!]=?|&&?|\|\|?|<[<=]?|>[>=]?|[*\/%~^]/
	  });
	  Prism.languages.insertBefore('haxe', 'class-name', {
	    regex: {
	      pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[igmsu]*/,
	      greedy: true
	    }
	  });
	  Prism.languages.insertBefore('haxe', 'keyword', {
	    preprocessor: {
	      pattern: /#\w+/,
	      alias: 'builtin'
	    },
	    metadata: {
	      pattern: /@:?\w+/,
	      alias: 'symbol'
	    },
	    reification: {
	      pattern: /\$(?:\w+|(?=\{))/,
	      alias: 'variable'
	    }
	  });
	  Prism.languages.haxe['string'].inside[
	    'interpolation'
	  ].inside.rest = Prism.util.clone(Prism.languages.haxe);
	  delete Prism.languages.haxe['class-name'];
	}


/***/ }),
/* 906 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = http;
	http.displayName = 'http';
	http.aliases = [];
	function http(Prism) {
	  Prism.languages.http = {
	    'request-line': {
	      pattern: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\shttps?:\/\/\S+\sHTTP\/[0-9.]+/m,
	      inside: {
	        // HTTP Verb
	        property: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b/,
	        // Path or query argument
	        'attr-name': /:\w+/
	      }
	    },
	    'response-status': {
	      pattern: /^HTTP\/1.[01] \d+.*/m,
	      inside: {
	        // Status, e.g. 200 OK
	        property: {
	          pattern: /(^HTTP\/1.[01] )\d+.*/i,
	          lookbehind: true
	        }
	      }
	    },
	    // HTTP header name
	    'header-name': {
	      pattern: /^[\w-]+:(?=.)/m,
	      alias: 'keyword'
	    }
	  };
	  // Create a mapping of Content-Type headers to language definitions
	  var httpLanguages = {
	    'application/json': Prism.languages.javascript,
	    'application/xml': Prism.languages.markup,
	    'text/xml': Prism.languages.markup,
	    'text/html': Prism.languages.markup
	  };
	  // Insert each content type parser that has its associated language
	  // currently loaded.
	  for (var contentType in httpLanguages) {
	    if (httpLanguages[contentType]) {
	      var options = {};
	      options[contentType] = {
	        pattern: new RegExp(
	          '(content-type:\\s*' +
	            contentType +
	            '[\\w\\W]*?)(?:\\r?\\n|\\r){2}[\\w\\W]*',
	          'i'
	        ),
	        lookbehind: true,
	        inside: {
	          rest: httpLanguages[contentType]
	        }
	      };
	      Prism.languages.insertBefore('http', 'header-name', options);
	    }
	  }
	}


/***/ }),
/* 907 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = icon;
	icon.displayName = 'icon';
	icon.aliases = [];
	function icon(Prism) {
	  Prism.languages.icon = {
	    comment: /#.*/,
	    string: {
	      pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
	      greedy: true
	    },
	    number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
	    'builtin-keyword': {
	      pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
	      alias: 'variable'
	    },
	    directive: {
	      pattern: /\$\w+/,
	      alias: 'builtin'
	    },
	    keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
	    function: /(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
	    operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
	    punctuation: /[\[\](){},;]/
	  };
	}


/***/ }),
/* 908 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = inform7;
	inform7.displayName = 'inform7';
	inform7.aliases = [];
	function inform7(Prism) {
	  Prism.languages.inform7 = {
	    string: {
	      pattern: /"[^"]*"/,
	      inside: {
	        substitution: {
	          pattern: /\[[^\]]+\]/,
	          inside: {
	            delimiter: {
	              pattern: /\[|\]/,
	              alias: 'punctuation'
	            }
	            // See rest below
	          }
	        }
	      }
	    },
	    comment: {
	      pattern: /\[[^\]]+\]/,
	      greedy: true
	    },
	    title: {
	      pattern: /^[ \t]*(?:volume|book|part(?! of)|chapter|section|table)\b.+/im,
	      alias: 'important'
	    },
	    number: {
	      pattern: /(^|[^-])(?:(?:\b|-)\d+(?:\.\d+)?(?:\^\d+)?\w*|\b(?:one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve))\b(?!-)/i,
	      lookbehind: true
	    },
	    verb: {
	      pattern: /(^|[^-])\b(?:applying to|are|attacking|answering|asking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:s|ing)?|consulting|contain(?:s|ing)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:ve|s|ving)|hold(?:s|ing)?|impl(?:y|ies)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:s|ing)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:s|ing)?|setting|showing|singing|sleeping|smelling|squeezing|switching|support(?:s|ing)?|swearing|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:s|ing)?|var(?:y|ies|ying)|waiting|waking|waving|wear(?:s|ing)?)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    keyword: {
	      pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|unless|the story)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
	      lookbehind: true
	    },
	    property: {
	      pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: on| off)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    position: {
	      pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    type: {
	      pattern: /(^|[^-])\b(?:actions?|activit(?:y|ies)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    punctuation: /[.,:;(){}]/
	  };
	  Prism.languages.inform7['string'].inside[
	    'substitution'
	  ].inside.rest = Prism.util.clone(Prism.languages.inform7);
	  // We don't want the remaining text in the substitution to be highlighted as the string.
	  Prism.languages.inform7['string'].inside['substitution'].inside.rest.text = {
	    pattern: /\S(?:\s*\S)*/,
	    alias: 'comment'
	  };
	}


/***/ }),
/* 909 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = ini;
	ini.displayName = 'ini';
	ini.aliases = [];
	function ini(Prism) {
	  Prism.languages.ini = {
	    comment: /^[ \t]*;.*$/m,
	    selector: /^[ \t]*\[.*?\]/m,
	    constant: /^[ \t]*[^\s=]+?(?=[ \t]*=)/m,
	    'attr-value': {
	      pattern: /=.*/,
	      inside: {
	        punctuation: /^[=]/
	      }
	    }
	  };
	}


/***/ }),
/* 910 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = j;
	j.displayName = 'j';
	j.aliases = [];
	function j(Prism) {
	  Prism.languages.j = {
	    comment: /\bNB\..*/,
	    string: {
	      pattern: /'(?:''|[^'\r\n])*'/,
	      greedy: true
	    },
	    keyword: /\b(?:(?:adverb|conjunction|CR|def|define|dyad|LF|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
	    verb: {
	      // Negative look-ahead prevents bad highlighting
	      // of ^: ;. =. =: !. !:
	      pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
	      alias: 'keyword'
	    },
	    number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:[ejpx]|ad|ar)_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_(?!\.))/,
	    adverb: {
	      pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
	      alias: 'builtin'
	    },
	    operator: /[=a][.:]|_\./,
	    conjunction: {
	      pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
	      alias: 'variable'
	    },
	    punctuation: /[()]/
	  };
	}


/***/ }),
/* 911 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = javascript;
	javascript.displayName = 'javascript';
	javascript.aliases = ['js'];
	function javascript(Prism) {
	  Prism.languages.javascript = Prism.languages.extend('clike', {
	    keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	    number: /\b-?(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|\d*\.?\d+(?:[Ee][+-]?\d+)?|NaN|Infinity)\b/,
	    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	    function: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\s*\()/i,
	    operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
	  });
	  Prism.languages.insertBefore('javascript', 'keyword', {
	    regex: {
	      pattern: /(^|[^/])\/(?!\/)(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
	      lookbehind: true,
	      greedy: true
	    },
	    // This must be declared before keyword because we use "function" inside the look-forward
	    'function-variable': {
	      pattern: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)\s*=>))/i,
	      alias: 'function'
	    }
	  });
	  Prism.languages.insertBefore('javascript', 'string', {
	    'template-string': {
	      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /\$\{[^}]+\}/,
	          inside: {
	            'interpolation-punctuation': {
	              pattern: /^\$\{|\}$/,
	              alias: 'punctuation'
	            },
	            rest: Prism.languages.javascript
	          }
	        },
	        string: /[\s\S]+/
	      }
	    }
	  });
	  if (Prism.languages.markup) {
	    Prism.languages.insertBefore('markup', 'tag', {
	      script: {
	        pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
	        lookbehind: true,
	        inside: Prism.languages.javascript,
	        alias: 'language-javascript'
	      }
	    });
	  }
	  Prism.languages.js = Prism.languages.javascript;
	}


/***/ }),
/* 912 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = jolie;
	jolie.displayName = 'jolie';
	jolie.aliases = [];
	function jolie(Prism) {
	  Prism.languages.jolie = Prism.languages.extend('clike', {
	    keyword: /\b(?:include|define|is_defined|undef|main|init|outputPort|inputPort|Location|Protocol|Interfaces|RequestResponse|OneWay|type|interface|extender|throws|cset|csets|forward|Aggregates|Redirects|embedded|courier|execution|sequential|concurrent|single|scope|install|throw|comp|cH|default|global|linkIn|linkOut|synchronized|this|new|for|if|else|while|in|Jolie|Java|Javascript|nullProcess|spawn|constants|with|provide|until|exit|foreach|instanceof|over|service)\b/,
	    builtin: /\b(?:undefined|string|int|void|long|Byte|bool|double|float|char|any)\b/,
	    number: /\b\d*\.?\d+(?:e[+-]?\d+)?l?\b/i,
	    operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[:?\/%^]/,
	    symbol: /[|;@]/,
	    punctuation: /[,.]/,
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    }
	  });
	  delete Prism.languages.jolie['class-name'];
	  delete Prism.languages.jolie['function'];
	  Prism.languages.insertBefore('jolie', 'keyword', {
	    function: {
	      pattern: /((?:\b(?:outputPort|inputPort|in|service|courier)\b|@)\s*)\w+/,
	      lookbehind: true
	    },
	    aggregates: {
	      pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
	      lookbehind: true,
	      inside: {
	        withExtension: {
	          pattern: /\bwith\s+\w+/,
	          inside: {
	            keyword: /\bwith\b/
	          }
	        },
	        function: {
	          pattern: /\w+/
	        },
	        punctuation: {
	          pattern: /,/
	        }
	      }
	    },
	    redirects: {
	      pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
	      lookbehind: true,
	      inside: {
	        punctuation: {
	          pattern: /,/
	        },
	        function: {
	          pattern: /\w+/
	        },
	        symbol: {
	          pattern: /=>/
	        }
	      }
	    }
	  });
	}


/***/ }),
/* 913 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = json;
	json.displayName = 'json';
	json.aliases = ['jsonp'];
	function json(Prism) {
	  Prism.languages.json = {
	    property: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
	      greedy: true
	    },
	    number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][+-]?\d+)?)\b/,
	    punctuation: /[{}[\]);,]/,
	    operator: /:/g,
	    boolean: /\b(?:true|false)\b/i,
	    null: /\bnull\b/i
	  };
	  Prism.languages.jsonp = Prism.languages.json;
	}


/***/ }),
/* 914 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = jsx;
	jsx.displayName = 'jsx';
	jsx.aliases = [];
	function jsx(Prism) {
	  (function(Prism) {
	    var javascript = Prism.util.clone(Prism.languages.javascript);
	    Prism.languages.jsx = Prism.languages.extend('markup', javascript);
	    Prism.languages.jsx.tag.pattern = /<\/?[\w.:-]+\s*(?:\s+(?:[\w\.:-]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+|(?:\{[^}]*\})))?|\{\.{3}\w+\}))*\s*\/?>/i;
	    Prism.languages.jsx.tag.inside[
	      'attr-value'
	    ].pattern = /=(?!\{)(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">]+)/i;
	    Prism.languages.insertBefore(
	      'inside',
	      'attr-name',
	      {
	        spread: {
	          pattern: /\{\.{3}\w+\}/,
	          inside: {
	            punctuation: /[{}]|\.{3}/,
	            'attr-value': /\w+/
	          }
	        }
	      },
	      Prism.languages.jsx.tag
	    );
	    var jsxExpression = Prism.util.clone(Prism.languages.jsx);
	    delete jsxExpression.punctuation;
	    jsxExpression = Prism.languages.insertBefore(
	      'jsx',
	      'operator',
	      {
	        punctuation: /=(?={)|[{}[\];(),.:]/
	      },
	      {jsx: jsxExpression}
	    );
	    Prism.languages.insertBefore(
	      'inside',
	      'attr-value',
	      {
	        script: {
	          // Allow for one level of nesting
	          pattern: /=(\{(?:\{[^}]*\}|[^}])+\})/i,
	          inside: jsxExpression,
	          alias: 'language-javascript'
	        }
	      },
	      Prism.languages.jsx.tag
	    );
	  })(Prism);
	}


/***/ }),
/* 915 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = julia;
	julia.displayName = 'julia';
	julia.aliases = [];
	function julia(Prism) {
	  Prism.languages.julia = {
	    comment: {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true
	    },
	    string: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2/,
	    keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|let|local|macro|module|print|println|quote|return|try|type|typealias|using|while)\b/,
	    boolean: /\b(?:true|false)\b/,
	    number: /\b-?(?:0[box])?(?:[\da-f]+\.?\d*|\.\d+)(?:[efp][+-]?\d+)?j?\b/i,
	    operator: /[-+*^%÷&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥]/,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 916 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = keyman;
	keyman.displayName = 'keyman';
	keyman.aliases = [];
	function keyman(Prism) {
	  Prism.languages.keyman = {
	    comment: /\bc\s.*/i,
	    function: /\[\s*(?:(?:CTRL|SHIFT|ALT|LCTRL|RCTRL|LALT|RALT|CAPS|NCAPS)\s+)*(?:[TKU]_[\w?]+|".+?"|'.+?')\s*\]/i, // virtual key
	    string: /("|').*?\1/,
	    bold: [
	      // header statements, system stores and variable system stores
	      /&(?:baselayout|bitmap|capsononly|capsalwaysoff|shiftfreescaps|copyright|ethnologuecode|hotkey|includecodes|keyboardversion|kmw_embedcss|kmw_embedjs|kmw_helpfile|kmw_helptext|kmw_rtl|language|layer|layoutfile|message|mnemoniclayout|name|oldcharposmatching|platform|targets|version|visualkeyboard|windowslanguages)\b/i,
	      /\b(?:bitmap|bitmaps|caps on only|caps always off|shift frees caps|copyright|hotkey|language|layout|message|name|version)\b/i
	    ],
	    keyword: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|return|reset|save|set|store|use)\b/i, // rule keywords
	    atrule: /\b(?:ansi|begin|unicode|group|using keys|match|nomatch)\b/i, // structural keywords
	    number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i, // U+####, x###, d### characters and numbers
	    operator: /[+>\\,()]/,
	    tag: /\$(?:keyman|kmfl|weaver|keymanweb|keymanonly):/i // prefixes
	  };
	}


/***/ }),
/* 917 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = kotlin;
	kotlin.displayName = 'kotlin';
	kotlin.aliases = [];
	function kotlin(Prism) {
	  (function(Prism) {
	    Prism.languages.kotlin = Prism.languages.extend('clike', {
	      keyword: {
	        // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
	        pattern: /(^|[^.])\b(?:abstract|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|else|enum|final|finally|for|fun|get|if|import|in|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|out|override|package|private|protected|public|reified|return|sealed|set|super|tailrec|this|throw|to|try|val|var|when|where|while)\b/,
	        lookbehind: true
	      },
	      function: [
	        /\w+(?=\s*\()/,
	        {
	          pattern: /(\.)\w+(?=\s*\{)/,
	          lookbehind: true
	        }
	      ],
	      number: /\b(?:0[bx][\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?[fFL]?)\b/,
	      operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
	    });
	    delete Prism.languages.kotlin['class-name'];
	    Prism.languages.insertBefore('kotlin', 'string', {
	      'raw-string': {
	        pattern: /("""|''')[\s\S]*?\1/,
	        alias: 'string'
	        // See interpolation below
	      }
	    });
	    Prism.languages.insertBefore('kotlin', 'keyword', {
	      annotation: {
	        pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
	        alias: 'builtin'
	      }
	    });
	    Prism.languages.insertBefore('kotlin', 'function', {
	      label: {
	        pattern: /\w+@|@\w+/,
	        alias: 'symbol'
	      }
	    });
	    var interpolation = [
	      {
	        pattern: /\$\{[^}]+\}/,
	        inside: {
	          delimiter: {
	            pattern: /^\$\{|\}$/,
	            alias: 'variable'
	          },
	          rest: Prism.util.clone(Prism.languages.kotlin)
	        }
	      },
	      {
	        pattern: /\$\w+/,
	        alias: 'variable'
	      }
	    ];
	    Prism.languages.kotlin['string'].inside = Prism.languages.kotlin[
	      'raw-string'
	    ].inside = {
	      interpolation: interpolation
	    };
	  })(Prism);
	}


/***/ }),
/* 918 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = latex;
	latex.displayName = 'latex';
	latex.aliases = [];
	function latex(Prism) {
	  (function(Prism) {
	    var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i,
	      insideEqu = {
	        'equation-command': {
	          pattern: funcPattern,
	          alias: 'regex'
	        }
	      };
	    Prism.languages.latex = {
	      comment: /%.*/m,
	      // the verbatim environment prints whitespace to the document
	      cdata: {
	        pattern: /(\\begin\{((?:verbatim|lstlisting)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
	        lookbehind: true
	      },
	      /*
	* equations can be between $ $ or \( \) or \[ \]
	* (all are multiline)
	*/
	      equation: [
	        {
	          pattern: /\$(?:\\[\s\S]|[^\\$])*\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
	          inside: insideEqu,
	          alias: 'string'
	        },
	        {
	          pattern: /(\\begin\{((?:equation|math|eqnarray|align|multline|gather)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
	          lookbehind: true,
	          inside: insideEqu,
	          alias: 'string'
	        }
	      ],
	      /*
	* arguments which are keywords or references are highlighted
	* as keywords
	*/
	      keyword: {
	        pattern: /(\\(?:begin|end|ref|cite|label|usepackage|documentclass)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
	        lookbehind: true
	      },
	      url: {
	        pattern: /(\\url\{)[^}]+(?=\})/,
	        lookbehind: true
	      },
	      /*
	* section or chapter headlines are highlighted as bold so that
	* they stand out more
	*/
	      headline: {
	        pattern: /(\\(?:part|chapter|section|subsection|frametitle|subsubsection|paragraph|subparagraph|subsubparagraph|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\}(?:\[[^\]]+\])?)/,
	        lookbehind: true,
	        alias: 'class-name'
	      },
	      function: {
	        pattern: funcPattern,
	        alias: 'selector'
	      },
	      punctuation: /[[\]{}&]/
	    };
	  })(Prism);
	}


/***/ }),
/* 919 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = less;
	less.displayName = 'less';
	less.aliases = [];
	function less(Prism) {
	  /* FIXME :
	:extend() is not handled specifically : its highlighting is buggy.
	Mixin usage must be inside a ruleset to be highlighted.
	At-rules (e.g. import) containing interpolations are buggy.
	Detached rulesets are highlighted as at-rules.
	A comment before a mixin usage prevents the latter to be properly highlighted.
	*/
	  Prism.languages.less = Prism.languages.extend('css', {
	    comment: [
	      /\/\*[\s\S]*?\*\//,
	      {
	        pattern: /(^|[^\\])\/\/.*/,
	        lookbehind: true
	      }
	    ],
	    atrule: {
	      pattern: /@[\w-]+?(?:\([^{}]+\)|[^(){};])*?(?=\s*\{)/i,
	      inside: {
	        punctuation: /[:()]/
	      }
	    },
	    // selectors and mixins are considered the same
	    selector: {
	      pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\([^{}]*\)|[^{};@])*?(?=\s*\{)/,
	      inside: {
	        // mixin parameters
	        variable: /@+[\w-]+/
	      }
	    },
	    property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/i,
	    punctuation: /[{}();:,]/,
	    operator: /[+\-*\/]/
	  });
	  // Invert function and punctuation positions
	  Prism.languages.insertBefore('less', 'punctuation', {
	    function: Prism.languages.less.function
	  });
	  Prism.languages.insertBefore('less', 'property', {
	    variable: [
	      // Variable declaration (the colon must be consumed!)
	      {
	        pattern: /@[\w-]+\s*:/,
	        inside: {
	          punctuation: /:/
	        }
	      },
	      // Variable usage
	      /@@?[\w-]+/
	    ],
	    'mixin-usage': {
	      pattern: /([{;]\s*)[.#](?!\d)[\w-]+.*?(?=[(;])/,
	      lookbehind: true,
	      alias: 'function'
	    }
	  });
	}


/***/ }),
/* 920 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = livescript;
	livescript.displayName = 'livescript';
	livescript.aliases = [];
	function livescript(Prism) {
	  Prism.languages.livescript = {
	    comment: [
	      {
	        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\])#.*/,
	        lookbehind: true
	      }
	    ],
	    'interpolated-string': {
	      /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
	* forcing it to match """-quoted string when it would otherwise match "-quoted first. */
	      pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        variable: {
	          pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
	          lookbehind: true
	        },
	        interpolation: {
	          pattern: /(^|[^\\])#\{[^}]+\}/m,
	          lookbehind: true,
	          inside: {
	            'interpolation-punctuation': {
	              pattern: /^#\{|\}$/,
	              alias: 'variable'
	            }
	            // See rest below
	          }
	        },
	        string: /[\s\S]+/
	      }
	    },
	    string: [
	      {
	        pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	        greedy: true
	      },
	      {
	        pattern: /<\[[\s\S]*?\]>/,
	        greedy: true
	      },
	      /\\[^\s,;\])}]+/
	    ],
	    regex: [
	      {
	        pattern: /\/\/(\[.+?]|\\.|(?!\/\/)[^\\])+\/\/[gimyu]{0,5}/,
	        greedy: true,
	        inside: {
	          comment: {
	            pattern: /(^|[^\\])#.*/,
	            lookbehind: true
	          }
	        }
	      },
	      {
	        pattern: /\/(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}/,
	        greedy: true
	      }
	    ],
	    keyword: {
	      pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
	      lookbehind: true
	    },
	    'keyword-operator': {
	      pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?:nt| not)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    boolean: {
	      pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
	      lookbehind: true
	    },
	    argument: {
	      // Don't match .&. nor &&
	      pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
	    identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
	    operator: [
	      // Spaced .
	      {
	        pattern: /( )\.(?= )/,
	        lookbehind: true
	      },
	      // Full list, in order:
	      // .= .~ .. ...
	      // .&. .^. .<<. .>>. .>>>.
	      // := :: ::=
	      // &&
	      // || |>
	      // < << <<< <<<<
	      // <- <-- <-! <--!
	      // <~ <~~ <~! <~~!
	      // <| <= <?
	      // > >> >= >?
	      // - -- -> -->
	      // + ++
	      // @ @@
	      // % %%
	      // * **
	      // ! != !~=
	      // !~> !~~>
	      // !-> !-->
	      // ~ ~> ~~> ~=
	      // = ==
	      // ^ ^^
	      // / ?
	      /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
	    ],
	    punctuation: /[(){}\[\]|.,:;`]/
	  };
	  Prism.languages.livescript['interpolated-string'].inside[
	    'interpolation'
	  ].inside.rest =
	    Prism.languages.livescript;
	}


/***/ }),
/* 921 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = lolcode;
	lolcode.displayName = 'lolcode';
	lolcode.aliases = [];
	function lolcode(Prism) {
	  Prism.languages.lolcode = {
	    comment: [/\bOBTW\s+[\s\S]*?\s+TLDR\b/, /\bBTW.+/],
	    string: {
	      pattern: /"(?::.|[^"])*"/,
	      inside: {
	        variable: /:\{[^}]+\}/,
	        symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
	      },
	      greedy: true
	    },
	    number: /(?:-|\b)\d*\.?\d+/,
	    symbol: {
	      pattern: /(^|\s)(?:A )?(?:YARN|NUMBR|NUMBAR|TROOF|BUKKIT|NOOB)(?=\s|,|$)/,
	      lookbehind: true,
	      inside: {
	        keyword: /A(?=\s)/
	      }
	    },
	    label: {
	      pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    function: {
	      pattern: /((?:^|\s)(?:I IZ|HOW IZ I|IZ) )[a-zA-Z]\w*/,
	      lookbehind: true
	    },
	    keyword: [
	      {
	        pattern: /(^|\s)(?:O HAI IM|KTHX|HAI|KTHXBYE|I HAS A|ITZ(?: A)?|R|AN|MKAY|SMOOSH|MAEK|IS NOW(?: A)?|VISIBLE|GIMMEH|O RLY\?|YA RLY|NO WAI|OIC|MEBBE|WTF\?|OMG|OMGWTF|GTFO|IM IN YR|IM OUTTA YR|FOUND YR|YR|TIL|WILE|UPPIN|NERFIN|I IZ|HOW IZ I|IF U SAY SO|SRS|HAS A|LIEK(?: A)?|IZ)(?=\s|,|$)/,
	        lookbehind: true
	      },
	      /'Z(?=\s|,|$)/
	    ],
	    boolean: {
	      pattern: /(^|\s)(?:WIN|FAIL)(?=\s|,|$)/,
	      lookbehind: true
	    },
	    variable: {
	      pattern: /(^|\s)IT(?=\s|,|$)/,
	      lookbehind: true
	    },
	    operator: {
	      pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:SUM|DIFF|PRODUKT|QUOSHUNT|MOD|BIGGR|SMALLR|BOTH|EITHER|WON|ALL|ANY) OF)(?=\s|,|$)/,
	      lookbehind: true
	    },
	    punctuation: /\.{3}|…|,|!/
	  };
	}


/***/ }),
/* 922 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = lua;
	lua.displayName = 'lua';
	lua.aliases = [];
	function lua(Prism) {
	  Prism.languages.lua = {
	    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
	    // \z may be used to skip the following space
	    string: {
	      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[\s\S]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
	      greedy: true
	    },
	    number: /\b0x[a-f\d]+\.?[a-f\d]*(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|\.?\d*(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
	    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
	    function: /(?!\d)\w+(?=\s*(?:[({]))/,
	    operator: [
	      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
	      {
	        // Match ".." but don't break "..."
	        pattern: /(^|[^.])\.\.(?!\.)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /[\[\](){},;]|\.+|:+/
	  };
	}


/***/ }),
/* 923 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = makefile;
	makefile.displayName = 'makefile';
	makefile.aliases = [];
	function makefile(Prism) {
	  Prism.languages.makefile = {
	    comment: {
	      pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    // Built-in target names
	    builtin: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
	    // Targets
	    symbol: {
	      pattern: /^[^:=\r\n]+(?=\s*:(?!=))/m,
	      inside: {
	        variable: /\$+(?:[^(){}:#=\s]+|(?=[({]))/
	      }
	    },
	    variable: /\$+(?:[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
	    keyword: [
	      // Directives
	      /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
	      // Functions
	      {
	        pattern: /(\()(?:addsuffix|abspath|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:s|list)?)(?=[ \t])/,
	        lookbehind: true
	      }
	    ],
	    operator: /(?:::|[?:+!])?=|[|@]/,
	    punctuation: /[:;(){}]/
	  };
	}


/***/ }),
/* 924 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = markdown;
	markdown.displayName = 'markdown';
	markdown.aliases = [];
	function markdown(Prism) {
	  Prism.languages.markdown = Prism.languages.extend('markup', {});
	  Prism.languages.insertBefore('markdown', 'prolog', {
	    blockquote: {
	      // > ...
	      pattern: /^>(?:[\t ]*>)*/m,
	      alias: 'punctuation'
	    },
	    code: [
	      {
	        // Prefixed by 4 spaces or 1 tab
	        pattern: /^(?: {4}|\t).+/m,
	        alias: 'keyword'
	      },
	      {
	        // `code`
	        // ``code``
	        pattern: /``.+?``|`[^`\n]+`/,
	        alias: 'keyword'
	      }
	    ],
	    title: [
	      {
	        // title 1
	        // =======
	        // title 2
	        // -------
	        pattern: /\w+.*(?:\r?\n|\r)(?:==+|--+)/,
	        alias: 'important',
	        inside: {
	          punctuation: /==+$|--+$/
	        }
	      },
	      {
	        // # title 1
	        // ###### title 6
	        pattern: /(^\s*)#+.+/m,
	        lookbehind: true,
	        alias: 'important',
	        inside: {
	          punctuation: /^#+|#+$/
	        }
	      }
	    ],
	    hr: {
	      // ***
	      // ---
	      // * * *
	      // -----------
	      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    list: {
	      // * item
	      // + item
	      // - item
	      // 1. item
	      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    'url-reference': {
	      // [id]: http://example.com "Optional title"
	      // [id]: http://example.com 'Optional title'
	      // [id]: http://example.com (Optional title)
	      // [id]: <http://example.com> "Optional title"
	      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
	      inside: {
	        variable: {
	          pattern: /^(!?\[)[^\]]+/,
	          lookbehind: true
	        },
	        string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
	        punctuation: /^[\[\]!:]|[<>]/
	      },
	      alias: 'url'
	    },
	    bold: {
	      // **strong**
	      // __strong__
	      // Allow only one line break
	      pattern: /(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,
	      lookbehind: true,
	      inside: {
	        punctuation: /^\*\*|^__|\*\*$|__$/
	      }
	    },
	    italic: {
	      // *em*
	      // _em_
	      // Allow only one line break
	      pattern: /(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,
	      lookbehind: true,
	      inside: {
	        punctuation: /^[*_]|[*_]$/
	      }
	    },
	    url: {
	      // [example](http://example.com "Optional title")
	      // [example] [id]
	      pattern: /!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/,
	      inside: {
	        variable: {
	          pattern: /(!?\[)[^\]]+(?=\]$)/,
	          lookbehind: true
	        },
	        string: {
	          pattern: /"(?:\\.|[^"\\])*"(?=\)$)/
	        }
	      }
	    }
	  });
	  Prism.languages.markdown['bold'].inside['url'] = Prism.util.clone(
	    Prism.languages.markdown['url']
	  );
	  Prism.languages.markdown['italic'].inside['url'] = Prism.util.clone(
	    Prism.languages.markdown['url']
	  );
	  Prism.languages.markdown['bold'].inside['italic'] = Prism.util.clone(
	    Prism.languages.markdown['italic']
	  );
	  Prism.languages.markdown['italic'].inside['bold'] = Prism.util.clone(
	    Prism.languages.markdown['bold']
	  );
	}


/***/ }),
/* 925 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = markup;
	markup.displayName = 'markup';
	markup.aliases = ['xml', 'html', 'mathml', 'svg'];
	function markup(Prism) {
	  Prism.languages.markup = {
	    comment: /<!--[\s\S]*?-->/,
	    prolog: /<\?[\s\S]+?\?>/,
	    doctype: /<!DOCTYPE[\s\S]+?>/i,
	    cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
	    tag: {
	      pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
	      inside: {
	        tag: {
	          pattern: /^<\/?[^\s>\/]+/i,
	          inside: {
	            punctuation: /^<\/?/,
	            namespace: /^[^\s>\/:]+:/
	          }
	        },
	        'attr-value': {
	          pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
	          inside: {
	            punctuation: [
	              /^=/,
	              {
	                pattern: /(^|[^\\])["']/,
	                lookbehind: true
	              }
	            ]
	          }
	        },
	        punctuation: /\/?>/,
	        'attr-name': {
	          pattern: /[^\s>\/]+/,
	          inside: {
	            namespace: /^[^\s>\/:]+:/
	          }
	        }
	      }
	    },
	    entity: /&#?[\da-z]{1,8};/i
	  };
	  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	    Prism.languages.markup['entity'];
	  // Plugin to make entity title show the real entity, idea by Roman Komarov
	  Prism.hooks.add('wrap', function(env) {
	    if (env.type === 'entity') {
	      env.attributes['title'] = env.content.replace(/&amp;/, '&');
	    }
	  });
	  Prism.languages.xml = Prism.languages.markup;
	  Prism.languages.html = Prism.languages.markup;
	  Prism.languages.mathml = Prism.languages.markup;
	  Prism.languages.svg = Prism.languages.markup;
	}


/***/ }),
/* 926 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = matlab;
	matlab.displayName = 'matlab';
	matlab.aliases = [];
	function matlab(Prism) {
	  Prism.languages.matlab = {
	    comment: [/%\{[\s\S]*?\}%/, /%.+/],
	    string: {
	      pattern: /\B'(?:''|[^'\r\n])*'/,
	      greedy: true
	    },
	    // FIXME We could handle imaginary numbers as a whole
	    number: /\b-?(?:\d*\.?\d+(?:[eE][+-]?\d+)?(?:[ij])?|[ij])\b/,
	    keyword: /\b(?:break|case|catch|continue|else|elseif|end|for|function|if|inf|NaN|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
	    function: /(?!\d)\w+(?=\s*\()/,
	    operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
	    punctuation: /\.{3}|[.,;\[\](){}!]/
	  };
	}


/***/ }),
/* 927 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = mel;
	mel.displayName = 'mel';
	mel.aliases = [];
	function mel(Prism) {
	  Prism.languages.mel = {
	    comment: /\/\/.*/,
	    code: {
	      pattern: /`(?:\\.|[^\\`\r\n])*`/,
	      greedy: true,
	      alias: 'italic',
	      inside: {
	        delimiter: {
	          pattern: /^`|`$/,
	          alias: 'punctuation'
	        }
	        // See rest below
	      }
	    },
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    variable: /\$\w+/,
	    number: /(?:\b|-)(?:0x[\da-fA-F]+|\d+\.?\d*)/,
	    flag: {
	      pattern: /-[^\d\W]\w*/,
	      alias: 'operator'
	    },
	    keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
	    function: /\w+(?=\()|\b(?:about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|CBG|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|Mayatomr|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
	
	    operator: [
	      /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
	      {
	        // We don't want to match <<
	        pattern: /(^|[^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /(^|[^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /<<|>>|[.,:;?\[\](){}]/
	  };
	  Prism.languages.mel['code'].inside.rest = Prism.util.clone(
	    Prism.languages.mel
	  );
	}


/***/ }),
/* 928 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = mizar;
	mizar.displayName = 'mizar';
	mizar.aliases = [];
	function mizar(Prism) {
	  Prism.languages.mizar = {
	    comment: /::.+/,
	    keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|equals|end|environ|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:y|ies)|when|where|with|wrt)\b/,
	    parameter: {
	      pattern: /\$(?:10|\d)/,
	      alias: 'variable'
	    },
	    variable: /\w+(?=:)/,
	    number: /(?:\b|-)\d+\b/,
	    operator: /\.\.\.|->|&|\.?=/,
	    punctuation: /\(#|#\)|[,:;\[\](){}]/
	  };
	}


/***/ }),
/* 929 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = monkey;
	monkey.displayName = 'monkey';
	monkey.aliases = [];
	function monkey(Prism) {
	  Prism.languages.monkey = {
	    string: /"[^"\r\n]*"/,
	    comment: [/^#Rem\s+[\s\S]*?^#End/im, /'.+/],
	    preprocessor: {
	      pattern: /(^[ \t]*)#.+/m,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    function: /\w+(?=\()/,
	    'type-char': {
	      pattern: /(\w)[?%#$]/,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    number: {
	      pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
	      lookbehind: true
	    },
	    keyword: /\b(?:Void|Strict|Public|Private|Property|Bool|Int|Float|String|Array|Object|Continue|Exit|Import|Extern|New|Self|Super|Try|Catch|Eachin|True|False|Extends|Abstract|Final|Select|Case|Default|Const|Local|Global|Field|Method|Function|Class|End|If|Then|Else|ElseIf|EndIf|While|Wend|Repeat|Until|Forever|For|To|Step|Next|Return|Module|Interface|Implements|Inline|Throw|Null)\b/i,
	    operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
	    punctuation: /[.,:;()\[\]]/
	  };
	}


/***/ }),
/* 930 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = n4js;
	n4js.displayName = 'n4js';
	n4js.aliases = [];
	function n4js(Prism) {
	  Prism.languages.n4js = Prism.languages.extend('javascript', {
	    // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
	    keyword: /\b(?:any|Array|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
	  });
	  Prism.languages.insertBefore('n4js', 'function', {
	    // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
	    annotation: {
	      pattern: /@+\w+/,
	      alias: 'operator'
	    }
	  });
	  Prism.languages.n4jsd = Prism.languages.n4js;
	}


/***/ }),
/* 931 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = nasm;
	nasm.displayName = 'nasm';
	nasm.aliases = [];
	function nasm(Prism) {
	  Prism.languages.nasm = {
	    comment: /;.*$/m,
	    string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	    label: {
	      pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
	      lookbehind: true,
	      alias: 'function'
	    },
	    keyword: [
	      /\[?BITS (?:16|32|64)\]?/,
	      {
	        pattern: /(^\s*)section\s*[a-zA-Z.]+:?/im,
	        lookbehind: true
	      },
	      /(?:extern|global)[^;\r\n]*/i,
	      /(?:CPU|FLOAT|DEFAULT).*$/m
	    ],
	    register: {
	      pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\b/i,
	      alias: 'variable'
	    },
	    number: /(?:\b|-|(?=\$))(?:0[hx][\da-f]*\.?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(?:\.?e[+-]?\d+)?[dt]?)\b/i,
	    operator: /[\[\]*+\-\/%<>=&|$!]/
	  };
	}


/***/ }),
/* 932 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = nginx;
	nginx.displayName = 'nginx';
	nginx.aliases = [];
	function nginx(Prism) {
	  Prism.languages.nginx = Prism.languages.extend('clike', {
	    comment: {
	      pattern: /(^|[^"{\\])#.*/,
	      lookbehind: true
	    },
	    keyword: /\b(?:CONTENT_|DOCUMENT_|GATEWAY_|HTTP_|HTTPS|if_not_empty|PATH_|QUERY_|REDIRECT_|REMOTE_|REQUEST_|SCGI|SCRIPT_|SERVER_|http|events|accept_mutex|accept_mutex_delay|access_log|add_after_body|add_before_body|add_header|addition_types|aio|alias|allow|ancient_browser|ancient_browser_value|auth|auth_basic|auth_basic_user_file|auth_http|auth_http_header|auth_http_timeout|autoindex|autoindex_exact_size|autoindex_localtime|break|charset|charset_map|charset_types|chunked_transfer_encoding|client_body_buffer_size|client_body_in_file_only|client_body_in_single_buffer|client_body_temp_path|client_body_timeout|client_header_buffer_size|client_header_timeout|client_max_body_size|connection_pool_size|create_full_put_path|daemon|dav_access|dav_methods|debug_connection|debug_points|default_type|deny|devpoll_changes|devpoll_events|directio|directio_alignment|disable_symlinks|empty_gif|env|epoll_events|error_log|error_page|expires|fastcgi_buffer_size|fastcgi_buffers|fastcgi_busy_buffers_size|fastcgi_cache|fastcgi_cache_bypass|fastcgi_cache_key|fastcgi_cache_lock|fastcgi_cache_lock_timeout|fastcgi_cache_methods|fastcgi_cache_min_uses|fastcgi_cache_path|fastcgi_cache_purge|fastcgi_cache_use_stale|fastcgi_cache_valid|fastcgi_connect_timeout|fastcgi_hide_header|fastcgi_ignore_client_abort|fastcgi_ignore_headers|fastcgi_index|fastcgi_intercept_errors|fastcgi_keep_conn|fastcgi_max_temp_file_size|fastcgi_next_upstream|fastcgi_no_cache|fastcgi_param|fastcgi_pass|fastcgi_pass_header|fastcgi_read_timeout|fastcgi_redirect_errors|fastcgi_send_timeout|fastcgi_split_path_info|fastcgi_store|fastcgi_store_access|fastcgi_temp_file_write_size|fastcgi_temp_path|flv|geo|geoip_city|geoip_country|google_perftools_profiles|gzip|gzip_buffers|gzip_comp_level|gzip_disable|gzip_http_version|gzip_min_length|gzip_proxied|gzip_static|gzip_types|gzip_vary|if|if_modified_since|ignore_invalid_headers|image_filter|image_filter_buffer|image_filter_jpeg_quality|image_filter_sharpen|image_filter_transparency|imap_capabilities|imap_client_buffer|include|index|internal|ip_hash|keepalive|keepalive_disable|keepalive_requests|keepalive_timeout|kqueue_changes|kqueue_events|large_client_header_buffers|limit_conn|limit_conn_log_level|limit_conn_zone|limit_except|limit_rate|limit_rate_after|limit_req|limit_req_log_level|limit_req_zone|limit_zone|lingering_close|lingering_time|lingering_timeout|listen|location|lock_file|log_format|log_format_combined|log_not_found|log_subrequest|map|map_hash_bucket_size|map_hash_max_size|master_process|max_ranges|memcached_buffer_size|memcached_connect_timeout|memcached_next_upstream|memcached_pass|memcached_read_timeout|memcached_send_timeout|merge_slashes|min_delete_depth|modern_browser|modern_browser_value|mp4|mp4_buffer_size|mp4_max_buffer_size|msie_padding|msie_refresh|multi_accept|open_file_cache|open_file_cache_errors|open_file_cache_min_uses|open_file_cache_valid|open_log_file_cache|optimize_server_names|override_charset|pcre_jit|perl|perl_modules|perl_require|perl_set|pid|pop3_auth|pop3_capabilities|port_in_redirect|post_action|postpone_output|protocol|proxy|proxy_buffer|proxy_buffer_size|proxy_buffering|proxy_buffers|proxy_busy_buffers_size|proxy_cache|proxy_cache_bypass|proxy_cache_key|proxy_cache_lock|proxy_cache_lock_timeout|proxy_cache_methods|proxy_cache_min_uses|proxy_cache_path|proxy_cache_use_stale|proxy_cache_valid|proxy_connect_timeout|proxy_cookie_domain|proxy_cookie_path|proxy_headers_hash_bucket_size|proxy_headers_hash_max_size|proxy_hide_header|proxy_http_version|proxy_ignore_client_abort|proxy_ignore_headers|proxy_intercept_errors|proxy_max_temp_file_size|proxy_method|proxy_next_upstream|proxy_no_cache|proxy_pass|proxy_pass_error_message|proxy_pass_header|proxy_pass_request_body|proxy_pass_request_headers|proxy_read_timeout|proxy_redirect|proxy_redirect_errors|proxy_send_lowat|proxy_send_timeout|proxy_set_body|proxy_set_header|proxy_ssl_session_reuse|proxy_store|proxy_store_access|proxy_temp_file_write_size|proxy_temp_path|proxy_timeout|proxy_upstream_fail_timeout|proxy_upstream_max_fails|random_index|read_ahead|real_ip_header|recursive_error_pages|request_pool_size|reset_timedout_connection|resolver|resolver_timeout|return|rewrite|root|rtsig_overflow_events|rtsig_overflow_test|rtsig_overflow_threshold|rtsig_signo|satisfy|satisfy_any|secure_link_secret|send_lowat|send_timeout|sendfile|sendfile_max_chunk|server|server_name|server_name_in_redirect|server_names_hash_bucket_size|server_names_hash_max_size|server_tokens|set|set_real_ip_from|smtp_auth|smtp_capabilities|so_keepalive|source_charset|split_clients|ssi|ssi_silent_errors|ssi_types|ssi_value_length|ssl|ssl_certificate|ssl_certificate_key|ssl_ciphers|ssl_client_certificate|ssl_crl|ssl_dhparam|ssl_engine|ssl_prefer_server_ciphers|ssl_protocols|ssl_session_cache|ssl_session_timeout|ssl_verify_client|ssl_verify_depth|starttls|stub_status|sub_filter|sub_filter_once|sub_filter_types|tcp_nodelay|tcp_nopush|timeout|timer_resolution|try_files|types|types_hash_bucket_size|types_hash_max_size|underscores_in_headers|uninitialized_variable_warn|upstream|use|user|userid|userid_domain|userid_expires|userid_name|userid_p3p|userid_path|userid_service|valid_referers|variables_hash_bucket_size|variables_hash_max_size|worker_connections|worker_cpu_affinity|worker_priority|worker_processes|worker_rlimit_core|worker_rlimit_nofile|worker_rlimit_sigpending|working_directory|xclient|xml_entities|xslt_entities|xslt_stylesheet|xslt_types)\b/i
	  });
	  Prism.languages.insertBefore('nginx', 'keyword', {
	    variable: /\$[a-z_]+/i
	  });
	}


/***/ }),
/* 933 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = nim;
	nim.displayName = 'nim';
	nim.aliases = [];
	function nim(Prism) {
	  Prism.languages.nim = {
	    comment: /#.*/,
	    // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
	    // Character literals are handled specifically to prevent issues with numeric type suffixes
	    string: {
	      pattern: /(?:(?:\b(?!\d)(?:\w|\\x[8-9a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")|'(?:\\(?:\d+|x[\da-fA-F]{2}|.)|[^'])')/,
	      greedy: true
	    },
	    // The negative look ahead prevents wrong highlighting of the .. operator
	    number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
	    keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
	    function: {
	      pattern: /(?:(?!\d)(?:\w|\\x[8-9a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
	      inside: {
	        operator: /\*$/
	      }
	    },
	    // We don't want to highlight operators inside backticks
	    ignore: {
	      pattern: /`[^`\r\n]+`/,
	      inside: {
	        punctuation: /`/
	      }
	    },
	    operator: {
	      // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
	      // but allow the slice operator .. to take precedence over them
	      // One can define his own operators in Nim so all combination of operators might be an operator.
	      pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|of|or|in|is|isnot|mod|not|notin|shl|shr|xor)\b)/m,
	      lookbehind: true
	    },
	    punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
	  };
	}


/***/ }),
/* 934 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = nix;
	nix.displayName = 'nix';
	nix.aliases = [];
	function nix(Prism) {
	  Prism.languages.nix = {
	    comment: /\/\*[\s\S]*?\*\/|#.*/,
	    string: {
	      pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          // The lookbehind ensures the ${} is not preceded by \ or ''
	          pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^}]|\{[^}]*\})*}/,
	          lookbehind: true,
	          inside: {
	            antiquotation: {
	              pattern: /^\$(?=\{)/,
	              alias: 'variable'
	            }
	            // See rest below
	          }
	        }
	      }
	    },
	    url: [
	      /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
	      {
	        pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
	        lookbehind: true
	      }
	    ],
	    antiquotation: {
	      pattern: /\$(?=\{)/,
	      alias: 'variable'
	    },
	    number: /\b\d+\b/,
	    keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
	    function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:url|Tarball)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
	    boolean: /\b(?:true|false)\b/,
	    operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
	    punctuation: /[{}()[\].,:;]/
	  };
	  Prism.languages.nix.string.inside.interpolation.inside.rest = Prism.util.clone(
	    Prism.languages.nix
	  );
	}


/***/ }),
/* 935 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = nsis;
	nsis.displayName = 'nsis';
	nsis.aliases = [];
	function nsis(Prism) {
	  /**
	   * Original by Jan T. Sott (http://github.com/idleberg)
	   *
	   * Includes all commands and plug-ins shipped with NSIS 3.02
	   */
	  Prism.languages.nsis = {
	    comment: {
	      pattern: /(^|[^\\])(\/\*[\s\S]*?\*\/|[#;].*)/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    keyword: {
	      pattern: /(^\s*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|Banner|BG(?:Font|Gradient|Image)|BrandingText|BringToFront|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|WriteUTF16LE|Seek|Write|WriteByte|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DlgItem|DLLVersion(?:Local)?|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Int(?:CmpU?|Fmt|Op)|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|Name|Nop|ns(?:Dialogs|Exec)|NSISdl|OutFile|Page(?:Callbacks)?|Pop|Push|Quit|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|Unicode|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UninstPage|UnRegDLL|UserInfo|Var|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle)\b/m,
	      lookbehind: true
	    },
	    property: /\b(?:admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user|ARCHIVE|FILE_(ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK((CR|CU|LM)(32|64)?|DD|PD|U)|HKEY_(CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY)\b/,
	    constant: /\${[\w\.:\^-]+}|\$\([\w\.:\^-]+\)/i,
	    variable: /\$\w+/i,
	    number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,
	    operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
	    punctuation: /[{}[\];(),.:]/,
	    important: {
	      pattern: /(^\s*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversionsystem|ifdef|ifmacrodef|ifmacrondef|ifndef|if|include|insertmacro|macroend|macro|makensis|packhdr|pragma|searchparse|searchreplace|tempfile|undef|verbose|warning)\b/im,
	      lookbehind: true
	    }
	  };
	}


/***/ }),
/* 936 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var c = __webpack_require__(68);
	module.exports = objectivec;
	objectivec.displayName = 'objectivec';
	objectivec.aliases = [];
	function objectivec(Prism) {
	  Prism.register(c);
	  Prism.languages.objectivec = Prism.languages.extend('c', {
	    keyword: /\b(?:asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|in|self|super)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
	    string: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|@"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
	    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
	  });
	}


/***/ }),
/* 937 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = ocaml;
	ocaml.displayName = 'ocaml';
	ocaml.aliases = [];
	function ocaml(Prism) {
	  Prism.languages.ocaml = {
	    comment: /\(\*[\s\S]*?\*\)/,
	    string: [
	      {
	        pattern: /"(?:\\.|[^\\\r\n"])*"/,
	        greedy: true
	      },
	      {
	        pattern: /(['`])(?:\\(?:\d+|x[\da-f]+|.)|(?!\1)[^\\\r\n])\1/i,
	        greedy: true
	      }
	    ],
	    number: /\b-?(?:0x[\da-f][\da-f_]+|(?:0[bo])?\d[\d_]*\.?[\d_]*(?:e[+-]?[\d_]+)?)/i,
	    type: {
	      pattern: /\B['`]\w*/,
	      alias: 'variable'
	    },
	    directive: {
	      pattern: /\B#\w+/,
	      alias: 'function'
	    },
	    keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|object|of|open|prefix|private|rec|then|sig|struct|to|try|type|val|value|virtual|where|while|with)\b/,
	    boolean: /\b(?:false|true)\b/,
	    // Custom operators are allowed
	    operator: /:=|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lxor|lsl|lsr|mod|nor|or)\b/,
	    punctuation: /[(){}\[\]|_.,:;]/
	  };
	}


/***/ }),
/* 938 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var c = __webpack_require__(68);
	module.exports = opencl;
	opencl.displayName = 'opencl';
	opencl.aliases = [];
	function opencl(Prism) {
	  Prism.register(c);
	  (function(Prism) {
	    /* OpenCL kernel language */
	    Prism.languages.opencl = Prism.languages.extend('c', {
	      // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
	      keyword: /\b(?:__attribute__|(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|auto|break|case|cl_(?:image_format|mem_fence_flags)|clk_event_t|complex|const|continue|default|do|(?:float|double)(?:16(?:x(?:1|16|2|4|8))?|1x(?:1|16|2|4|8)|2(?:x(?:1|16|2|4|8))?|3|4(?:x(?:1|16|2|4|8))?|8(?:x(?:1|16|2|4|8))?)?|else|enum|event_t|extern|for|goto|(?:u?(?:char|short|int|long)|half|quad|bool)(?:2|3|4|8|16)?|if|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|imaginary|inline|intptr_t|ndrange_t|packed|pipe|ptrdiff_t|queue_t|register|reserve_id_t|restrict|return|sampler_t|signed|size_t|sizeof|static|struct|switch|typedef|uintptr_t|uniform|union|unsigned|void|volatile|while)\b/,
	      // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (global-vars, opencl-dev)
	      'function-opencl-kernel': {
	        pattern: /\b(?:abs(?:_diff)?|a?(?:cos|sin)(?:h|pi)?|add_sat|aligned|all|and|any|async(?:_work_group_copy|_work_group_strided_copy)?|atan(?:2?(?:pi)?|h)?|atom_(?:add|and|cmpxchg|dec|inc|max|min|or|sub|xchg|xor)|barrier|bitselect|cbrt|ceil|clamp|clz|copies|copysign|cross|degrees|distance|dot|endian|erf|erfc|exp(?:2|10)?|expm1|fabs|fast_(?:distance|length|normalize)|fdim|floor|fma|fmax|fmin|fract|frexp|fro|from|get_(?:global_(?:id|offset|size)|group_id|image_(?:channel_data_type|channel_order|depth|dim|height|width)|local(?:_id|_size)|num_groups|work_dim)|hadd|(?:half|native)_(?:cos|divide|exp(?:2|10)?|log(?:2|10)?|powr|recip|r?sqrt|sin|tan)|hypot|ilogb|is(?:equal|finite|greater(?:equal)?|inf|less(?:equal|greater)?|nan|normal|notequal|(?:un)?ordered)|ldexp|length|lgamma|lgamma_r|log(?:b|1p|2|10)?|mad(?:24|_hi|_sat)?|max|mem(?:_fence)?|min|mix|modf|mul24|mul_hi|nan|nextafter|normalize|pow[nr]?|prefetch|radians|read_(?:image)(?:f|h|u?i)|read_mem_fence|remainder|remquo|reqd_work_group_size|rhadd|rint|rootn|rotate|round|rsqrt|select|shuffle2?|sign|signbit|sincos|smoothstep|sqrt|step|sub_sat|tan|tanh|tanpi|tgamma|to|trunc|upsample|vec_(?:step|type_hint)|v(?:load|store)(?:_half)?(?:2|3|4|8|16)?|v(?:loada_half|storea?(?:_half)?)(?:2|3|4|8|16)?(?:_(?:rte|rtn|rtp|rtz))?|wait_group_events|work_group_size_hint|write_image(?:f|h|u?i)|write_mem_fence)\b/,
	        alias: 'function'
	      },
	      // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
	      'constant-opencl-kernel': {
	        pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:LOCAL|GLOBAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT)_(?:DIG|EPSILON|MANT_DIG|(?:MIN|MAX)(?:(?:_10)?_EXP)?)|FLT_RADIX|HUGE_VALF|INFINITY|(?:INT|LONG|SCHAR|SHRT|UCHAR|UINT|ULONG)_(?:MAX|MIN)|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:10|2)E?|PI[24]?|SQRT(?:1_2|2))|NAN)\b/,
	        alias: 'constant'
	      }
	    });
	    var attributes = {
	      // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
	      'type-opencl-host': {
	        pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|short|int|long)|float|double)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
	        alias: 'keyword'
	      },
	      'boolean-opencl-host': {
	        pattern: /\bCL_(?:TRUE|FALSE)\b/,
	        alias: 'boolean'
	      },
	      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
	      'constant-opencl-host': {
	        pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:16|24|8|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
	        alias: 'constant'
	      },
	      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
	      'function-opencl-host': {
	        pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|Kernel|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
	        alias: 'function'
	      }
	    };
	    /* OpenCL host API */
	    Prism.languages.insertBefore('c', 'keyword', attributes);
	    // Extracted from doxygen class list http://github.khronos.org/OpenCL-CLHPP/annotated.html
	    attributes['type-opencl-host-c++'] = {
	      pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|Sampler|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|UserEvent)\b/,
	      alias: 'keyword'
	    };
	    // C++ includes everything from the OpenCL C host API plus the classes defined in cl2.h
	    Prism.languages.insertBefore('cpp', 'keyword', attributes);
	  })(Prism);
	}


/***/ }),
/* 939 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = oz;
	oz.displayName = 'oz';
	oz.aliases = [];
	function oz(Prism) {
	  Prism.languages.oz = {
	    comment: /\/\*[\s\S]*?\*\/|%.*/,
	    string: {
	      pattern: /"(?:[^"\\]|\\[\s\S])*"/,
	      greedy: true
	    },
	    atom: {
	      pattern: /'(?:[^'\\]|\\[\s\S])*'/,
	      greedy: true,
	      alias: 'builtin'
	    },
	    keyword: /[$_]|\[\]|\b(?:at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
	    function: [
	      /[a-z][A-Za-z\d]*(?=\()/,
	      {
	        pattern: /(\{)[A-Z][A-Za-z\d]*/,
	        lookbehind: true
	      }
	    ],
	    number: /\b(?:0[bx][\da-f]+|\d+\.?\d*(?:e~?\d+)?\b)|&(?:[^\\]|\\(?:\d{3}|.))/i,
	    variable: /\b[A-Z][A-Za-z\d]*|`(?:[^`\\]|\\.)+`/,
	    'attr-name': /\w+(?=:)/,
	    operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
	    punctuation: /[\[\](){}.:;?]/
	  };
	}


/***/ }),
/* 940 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = parigp;
	parigp.displayName = 'parigp';
	parigp.aliases = [];
	function parigp(Prism) {
	  Prism.languages.parigp = {
	    comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\.)*"/,
	      greedy: true
	    },
	    // PARI/GP does not care about white spaces at all
	    // so let's process the keywords to build an appropriate regexp
	    // (e.g. "b *r *e *a *k", etc.)
	    keyword: (function() {
	      var keywords = [
	        'breakpoint',
	        'break',
	        'dbg_down',
	        'dbg_err',
	        'dbg_up',
	        'dbg_x',
	        'forcomposite',
	        'fordiv',
	        'forell',
	        'forpart',
	        'forprime',
	        'forstep',
	        'forsubgroup',
	        'forvec',
	        'for',
	        'iferr',
	        'if',
	        'local',
	        'my',
	        'next',
	        'return',
	        'until',
	        'while'
	      ];
	      keywords = keywords
	        .map(function(keyword) {
	          return keyword.split('').join(' *');
	        })
	        .join('|');
	      return RegExp('\\b(?:' + keywords + ')\\b');
	    })(),
	    function: /\w[\w ]*?(?= *\()/,
	    number: {
	      // The lookbehind and the negative lookahead prevent from breaking the .. operator
	      pattern: /((?:\. *\. *)?)(?:\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *[+-]? *\d(?: *\d)*)?/i,
	      lookbehind: true
	    },
	    operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
	    punctuation: /[\[\]{}().,:;|]/
	  };
	}


/***/ }),
/* 941 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = parser;
	parser.displayName = 'parser';
	parser.aliases = [];
	function parser(Prism) {
	  Prism.languages.parser = Prism.languages.extend('markup', {
	    keyword: {
	      pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
	      lookbehind: true
	    },
	    variable: {
	      pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
	      lookbehind: true,
	      inside: {
	        punctuation: /\.|:+/
	      }
	    },
	    function: {
	      pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
	      lookbehind: true,
	      inside: {
	        keyword: {
	          pattern: /(^@)(?:GET_|SET_)/,
	          lookbehind: true
	        },
	        punctuation: /\.|:+/
	      }
	    },
	    escape: {
	      pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
	      alias: 'builtin'
	    },
	    punctuation: /[\[\](){};]/
	  });
	  Prism.languages.insertBefore('parser', 'keyword', {
	    'parser-comment': {
	      pattern: /(\s)#.*/,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    expression: {
	      // Allow for 3 levels of depth
	      pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
	      greedy: true,
	      lookbehind: true,
	      inside: {
	        string: {
	          pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
	          lookbehind: true
	        },
	        keyword: Prism.languages.parser.keyword,
	        variable: Prism.languages.parser.variable,
	        function: Prism.languages.parser.function,
	        boolean: /\b(?:true|false)\b/,
	        number: /\b(?:0x[a-f\d]+|\d+\.?\d*(?:e[+-]?\d+)?)\b/i,
	        escape: Prism.languages.parser.escape,
	        operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
	        punctuation: Prism.languages.parser.punctuation
	      }
	    }
	  });
	  Prism.languages.insertBefore(
	    'inside',
	    'punctuation',
	    {
	      expression: Prism.languages.parser.expression,
	      keyword: Prism.languages.parser.keyword,
	      variable: Prism.languages.parser.variable,
	      function: Prism.languages.parser.function,
	      escape: Prism.languages.parser.escape,
	      'parser-punctuation': {
	        pattern: Prism.languages.parser.punctuation,
	        alias: 'punctuation'
	      }
	    },
	    Prism.languages.parser['tag'].inside['attr-value']
	  );
	}


/***/ }),
/* 942 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = pascal;
	pascal.displayName = 'pascal';
	pascal.aliases = [];
	function pascal(Prism) {
	  // Based on Free Pascal
	  /* TODO
	Support inline asm ?
	*/
	  Prism.languages.pascal = {
	    comment: [/\(\*[\s\S]+?\*\)/, /\{[\s\S]+?\}/, /\/\/.*/],
	    string: {
	      pattern: /(?:'(?:''|[^'\r\n])*'|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
	      greedy: true
	    },
	    keyword: [
	      {
	        // Turbo Pascal
	        pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
	        lookbehind: true
	      },
	      {
	        // Free Pascal
	        pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
	        lookbehind: true
	      },
	      {
	        // Object Pascal
	        pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
	        lookbehind: true
	      },
	      {
	        // Modifiers
	        pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
	        lookbehind: true
	      }
	    ],
	    number: [
	      // Hexadecimal, octal and binary
	      /[+-]?(?:[&%]\d+|\$[a-f\d]+)/i,
	      // Decimal
	      /([+-]|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
	    ],
	    operator: [
	      /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/i,
	      {
	        pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /\(\.|\.\)|[()\[\]:;,.]/
	  };
	}


/***/ }),
/* 943 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = perl;
	perl.displayName = 'perl';
	perl.aliases = [];
	function perl(Prism) {
	  Prism.languages.perl = {
	    comment: [
	      {
	        // POD
	        pattern: /(^\s*)=\w+[\s\S]*?=cut.*/m,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\$])#.*/,
	        lookbehind: true
	      }
	    ],
	    // TODO Could be nice to handle Heredoc too.
	    string: [
	      // q/.../
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	        greedy: true
	      },
	
	      // q a...a
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s+([a-zA-Z0-9])(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	        greedy: true
	      },
	
	      // q(...)
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s*\((?:[^()\\]|\\[\s\S])*\)/,
	        greedy: true
	      },
	
	      // q{...}
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s*\{(?:[^{}\\]|\\[\s\S])*\}/,
	        greedy: true
	      },
	
	      // q[...]
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s*\[(?:[^[\]\\]|\\[\s\S])*\]/,
	        greedy: true
	      },
	
	      // q<...>
	      {
	        pattern: /\b(?:q|qq|qx|qw)\s*<(?:[^<>\\]|\\[\s\S])*>/,
	        greedy: true
	      },
	      // "...", `...`
	      {
	        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	        greedy: true
	      },
	      // '...'
	      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
	      {
	        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
	        greedy: true
	      }
	    ],
	    regex: [
	      // m/.../
	      {
	        pattern: /\b(?:m|qr)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1[msixpodualngc]*/,
	        greedy: true
	      },
	
	      // m a...a
	      {
	        pattern: /\b(?:m|qr)\s+([a-zA-Z0-9])(?:(?!\1)[^\\]|\\[\s\S])*\1[msixpodualngc]*/,
	        greedy: true
	      },
	
	      // m(...)
	      {
	        pattern: /\b(?:m|qr)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngc]*/,
	        greedy: true
	      },
	
	      // m{...}
	      {
	        pattern: /\b(?:m|qr)\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngc]*/,
	        greedy: true
	      },
	
	      // m[...]
	      {
	        pattern: /\b(?:m|qr)\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngc]*/,
	        greedy: true
	      },
	
	      // m<...>
	      {
	        pattern: /\b(?:m|qr)\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngc]*/,
	        greedy: true
	      },
	      // The lookbehinds prevent -s from breaking
	      // FIXME We don't handle change of separator like s(...)[...]
	      // s/.../.../
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2[msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // s a...a...a
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s+([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2[msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // s(...)(...)
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s*\((?:[^()\\]|\\[\s\S])*\)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // s{...}{...}
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s*\{(?:[^{}\\]|\\[\s\S])*\}\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // s[...][...]
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s*\[(?:[^[\]\\]|\\[\s\S])*\]\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // s<...><...>
	      {
	        pattern: /(^|[^-]\b)(?:s|tr|y)\s*<(?:[^<>\\]|\\[\s\S])*>\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngcer]*/,
	        lookbehind: true,
	        greedy: true
	      },
	
	      // /.../
	      // The look-ahead tries to prevent two divisions on
	      // the same line from being highlighted as regex.
	      // This does not support multi-line regex.
	      {
	        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\b))/,
	        greedy: true
	      }
	    ],
	    // FIXME Not sure about the handling of ::, ', and #
	    variable: [
	      // ${^POSTMATCH}
	      /[&*$@%]\{\^[A-Z]+\}/,
	      // $^V
	      /[&*$@%]\^[A-Z_]/,
	      // ${...}
	      /[&*$@%]#?(?=\{)/,
	      // $foo
	      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+)+(?:::)*/i,
	      // $1
	      /[&*$@%]\d+/,
	      // $_, @_, %!
	      // The negative lookahead prevents from breaking the %= operator
	      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
	    ],
	    filehandle: {
	      // <>, <FOO>, _
	      pattern: /<(?![<=])\S*>|\b_\b/,
	      alias: 'symbol'
	    },
	    vstring: {
	      // v1.2, 1.2.3
	      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
	      alias: 'string'
	    },
	    function: {
	      pattern: /sub [a-z0-9_]+/i,
	      inside: {
	        keyword: /sub/
	      }
	    },
	    keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
	    number: /\b-?(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
	    operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:lt|gt|le|ge|eq|ne|cmp|not|and|or|xor)\b/,
	    punctuation: /[{}[\];(),:]/
	  };
	}


/***/ }),
/* 944 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = phpExtras;
	phpExtras.displayName = 'phpExtras';
	phpExtras.aliases = [];
	function phpExtras(Prism) {
	  Prism.languages.insertBefore('php', 'variable', {
	    this: /\$this\b/,
	    global: /\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)\b/,
	    scope: {
	      pattern: /\b[\w\\]+::/,
	      inside: {
	        keyword: /static|self|parent/,
	        punctuation: /::|\\/
	      }
	    }
	  });
	}


/***/ }),
/* 945 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = php;
	php.displayName = 'php';
	php.aliases = [];
	function php(Prism) {
	  /**
	   * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
	   * Modified by Miles Johnson: http://milesj.me
	   *
	   * Supports the following:
	   *      - Extends clike syntax
	   *      - Support for PHP 5.3+ (namespaces, traits, generators, etc)
	   *      - Smarter constant and function matching
	   *
	   * Adds the following new token classes:
	   *      constant, delimiter, variable, function, package
	   */
	  Prism.languages.php = Prism.languages.extend('clike', {
	    keyword: /\b(?:and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
	    constant: /\b[A-Z0-9_]{2,}\b/,
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	      lookbehind: true
	    }
	  });
	  // Shell-like comments are matched after strings, because they are less
	  // common than strings containing hashes...
	  Prism.languages.insertBefore('php', 'class-name', {
	    'shell-comment': {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true,
	      alias: 'comment'
	    }
	  });
	  Prism.languages.insertBefore('php', 'keyword', {
	    delimiter: {
	      pattern: /\?>|<\?(?:php|=)?/i,
	      alias: 'important'
	    },
	    variable: /\$\w+\b/i,
	    package: {
	      pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
	      lookbehind: true,
	      inside: {
	        punctuation: /\\/
	      }
	    }
	  });
	  // Must be defined after the function pattern
	  Prism.languages.insertBefore('php', 'operator', {
	    property: {
	      pattern: /(->)[\w]+/,
	      lookbehind: true
	    }
	  });
	  // Add HTML support if the markup language exists
	  if (Prism.languages.markup) {
	    // Tokenize all inline PHP blocks that are wrapped in <?php ?>
	    // This allows for easy PHP + markup highlighting
	    Prism.hooks.add('before-highlight', function(env) {
	      if (env.language !== 'php' || !/(?:<\?php|<\?)/gi.test(env.code)) {
	        return;
	      }
	      env.tokenStack = [];
	      env.backupCode = env.code;
	      env.code = env.code.replace(/(?:<\?php|<\?)[\s\S]*?(?:\?>|$)/gi, function(
	        match
	      ) {
	        var i = env.tokenStack.length;
	        // Check for existing strings
	        while (env.backupCode.indexOf('___PHP' + i + '___') !== -1) ++i;
	        // Create a sparse array
	        env.tokenStack[i] = match;
	        return '___PHP' + i + '___';
	      });
	      // Switch the grammar to markup
	      env.grammar = Prism.languages.markup;
	    });
	    // Restore env.code for other plugins (e.g. line-numbers)
	    Prism.hooks.add('before-insert', function(env) {
	      if (env.language === 'php' && env.backupCode) {
	        env.code = env.backupCode;
	        delete env.backupCode;
	      }
	    });
	    // Re-insert the tokens after highlighting
	    Prism.hooks.add('after-highlight', function(env) {
	      if (env.language !== 'php' || !env.tokenStack) {
	        return;
	      }
	      // Switch the grammar back
	      env.grammar = Prism.languages.php;
	      for (
	        var i = 0, keys = Object.keys(env.tokenStack);
	        i < keys.length;
	        ++i
	      ) {
	        var k = keys[i];
	        var t = env.tokenStack[k];
	        // The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
	        env.highlightedCode = env.highlightedCode.replace(
	          '___PHP' + k + '___',
	          '<span class="token php language-php">' +
	            Prism.highlight(t, env.grammar, 'php').replace(/\$/g, '$$$$') +
	            '</span>'
	        );
	      }
	      env.element.innerHTML = env.highlightedCode;
	    });
	  }
	}


/***/ }),
/* 946 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = powershell;
	powershell.displayName = 'powershell';
	powershell.aliases = [];
	function powershell(Prism) {
	  Prism.languages.powershell = {
	    comment: [
	      {
	        pattern: /(^|[^`])<#[\s\S]*?#>/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^`])#.*/,
	        lookbehind: true
	      }
	    ],
	    string: [
	      {
	        pattern: /"(?:`[\s\S]|[^`"])*"/,
	        greedy: true,
	        inside: {
	          function: {
	            pattern: /[^`]\$\(.*?\)/,
	            // Populated at end of file
	            inside: {}
	          }
	        }
	      },
	      {
	        pattern: /'(?:[^']|'')*'/,
	        greedy: true
	      }
	    ],
	    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
	    namespace: /\[[a-z][\s\S]*?\]/i,
	    boolean: /\$(?:true|false)\b/i,
	    variable: /\$\w+\b/i,
	    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
	    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
	    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
	    function: [
	      /\b(?:Add-(?:Computer|Content|History|Member|PSSnapin|Type)|Checkpoint-Computer|Clear-(?:Content|EventLog|History|Item|ItemProperty|Variable)|Compare-Object|Complete-Transaction|Connect-PSSession|ConvertFrom-(?:Csv|Json|StringData)|Convert-Path|ConvertTo-(?:Csv|Html|Json|Xml)|Copy-(?:Item|ItemProperty)|Debug-Process|Disable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Disconnect-PSSession|Enable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Enter-PSSession|Exit-PSSession|Export-(?:Alias|Clixml|Console|Csv|FormatData|ModuleMember|PSSession)|ForEach-Object|Format-(?:Custom|List|Table|Wide)|Get-(?:Alias|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Culture|Date|Event|EventLog|EventSubscriber|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|WmiObject)|Group-Object|Import-(?:Alias|Clixml|Csv|LocalizedData|Module|PSSession)|Invoke-(?:Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)|Join-Path|Limit-EventLog|Measure-(?:Command|Object)|Move-(?:Item|ItemProperty)|New-(?:Alias|Event|EventLog|Item|ItemProperty|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy)|Out-(?:Default|File|GridView|Host|Null|Printer|String)|Pop-Location|Push-Location|Read-Host|Receive-(?:Job|PSSession)|Register-(?:EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)|Remove-(?:Computer|Event|EventLog|Item|ItemProperty|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)|Rename-(?:Computer|Item|ItemProperty)|Reset-ComputerMachinePassword|Resolve-Path|Restart-(?:Computer|Service)|Restore-Computer|Resume-(?:Job|Service)|Save-Help|Select-(?:Object|String|Xml)|Send-MailMessage|Set-(?:Alias|Content|Date|Item|ItemProperty|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)|Show-(?:Command|ControlPanelItem|EventLog)|Sort-Object|Split-Path|Start-(?:Job|Process|Service|Sleep|Transaction)|Stop-(?:Computer|Job|Process|Service)|Suspend-(?:Job|Service)|Tee-Object|Test-(?:ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)|Trace-Command|Unblock-File|Undo-Transaction|Unregister-(?:Event|PSSessionConfiguration)|Update-(?:FormatData|Help|List|TypeData)|Use-Transaction|Wait-(?:Event|Job|Process)|Where-Object|Write-(?:Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning))\b/i,
	      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
	    ],
	    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
	    keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
	    operator: {
	      pattern: /(\W?)(?:!|-(eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
	      lookbehind: true
	    },
	    punctuation: /[|{}[\];(),.]/
	  };
	  // Variable interpolation inside strings, and nested expressions
	  Prism.languages.powershell.string[0].inside.boolean =
	    Prism.languages.powershell.boolean;
	  Prism.languages.powershell.string[0].inside.variable =
	    Prism.languages.powershell.variable;
	  Prism.languages.powershell.string[0].inside.function.inside = Prism.util.clone(
	    Prism.languages.powershell
	  );
	}


/***/ }),
/* 947 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = processing;
	processing.displayName = 'processing';
	processing.aliases = [];
	function processing(Prism) {
	  Prism.languages.processing = Prism.languages.extend('clike', {
	    keyword: /\b(?:break|catch|case|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
	    operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
	  });
	  Prism.languages.insertBefore('processing', 'number', {
	    // Special case: XML is a type
	    constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
	    type: {
	      pattern: /\b(?:boolean|byte|char|color|double|float|int|XML|[A-Z]\w*)\b/,
	      alias: 'variable'
	    }
	  });
	  // Spaces are allowed between function name and parenthesis
	  Prism.languages.processing['function'].pattern = /\w+(?=\s*\()/;
	  // Class-names is not styled by default
	  Prism.languages.processing['class-name'].alias = 'variable';
	}


/***/ }),
/* 948 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = prolog;
	prolog.displayName = 'prolog';
	prolog.aliases = [];
	function prolog(Prism) {
	  Prism.languages.prolog = {
	    // Syntax depends on the implementation
	    comment: [/%.+/, /\/\*[\s\S]*?\*\//],
	    // Depending on the implementation, strings may allow escaped newlines and quote-escape
	    string: {
	      pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
	    variable: /\b[A-Z_]\w*/,
	    // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
	    function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
	    number: /\b\d+\.?\d*/,
	    // Custom operators are allowed
	    operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
	    punctuation: /[(){}\[\],]/
	  };
	}


/***/ }),
/* 949 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = properties;
	properties.displayName = 'properties';
	properties.aliases = [];
	function properties(Prism) {
	  Prism.languages.properties = {
	    comment: /^[ \t]*[#!].*$/m,
	    'attr-value': {
	      pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+?(?: *[=:] *| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
	      lookbehind: true
	    },
	    'attr-name': /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+?(?= *[=:] *| )/m,
	    punctuation: /[=:]/
	  };
	}


/***/ }),
/* 950 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = protobuf;
	protobuf.displayName = 'protobuf';
	protobuf.aliases = [];
	function protobuf(Prism) {
	  Prism.languages.protobuf = Prism.languages.extend('clike', {
	    keyword: /\b(?:package|import|message|enum)\b/,
	    builtin: /\b(?:required|repeated|optional|reserved)\b/,
	    primitive: {
	      pattern: /\b(?:double|float|int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string|bytes)\b/,
	      alias: 'symbol'
	    }
	  });
	}


/***/ }),
/* 951 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = pug;
	pug.displayName = 'pug';
	pug.aliases = [];
	function pug(Prism) {
	  (function(Prism) {
	    // TODO:
	    // - Add CSS highlighting inside <style> tags
	    // - Add support for multi-line code blocks
	    // - Add support for interpolation #{} and !{}
	    // - Add support for tag interpolation #[]
	    // - Add explicit support for plain text using |
	    // - Add support for markup embedded in plain text
	    Prism.languages.pug = {
	      // Multiline stuff should appear before the rest
	      // This handles both single-line and multi-line comments
	      comment: {
	        pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ]+.+)*/m,
	        lookbehind: true
	      },
	      // All the tag-related part is in lookbehind
	      // so that it can be highlighted by the "tag" pattern
	      'multiline-script': {
	        pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.javascript
	        }
	      },
	      // See at the end of the file for known filters
	      filter: {
	        pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true,
	        inside: {
	          'filter-name': {
	            pattern: /^:[\w-]+/,
	            alias: 'variable'
	          }
	        }
	      },
	      'multiline-plain-text': {
	        pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true
	      },
	      markup: {
	        pattern: /(^[\t ]*)<.+/m,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.markup
	        }
	      },
	      doctype: {
	        pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
	        lookbehind: true
	      },
	      // This handle all conditional and loop keywords
	      'flow-control': {
	        pattern: /(^[\t ]*)(?:if|unless|else|case|when|default|each|while)\b(?: .+)?/m,
	        lookbehind: true,
	        inside: {
	          each: {
	            pattern: /^each .+? in\b/,
	            inside: {
	              keyword: /\b(?:each|in)\b/,
	              punctuation: /,/
	            }
	          },
	          branch: {
	            pattern: /^(?:if|unless|else|case|when|default|while)\b/,
	            alias: 'keyword'
	          },
	          rest: Prism.languages.javascript
	        }
	      },
	      keyword: {
	        pattern: /(^[\t ]*)(?:block|extends|include|append|prepend)\b.+/m,
	        lookbehind: true
	      },
	      mixin: [
	        // Declaration
	        {
	          pattern: /(^[\t ]*)mixin .+/m,
	          lookbehind: true,
	          inside: {
	            keyword: /^mixin/,
	            function: /\w+(?=\s*\(|\s*$)/,
	            punctuation: /[(),.]/
	          }
	        },
	        // Usage
	        {
	          pattern: /(^[\t ]*)\+.+/m,
	          lookbehind: true,
	          inside: {
	            name: {
	              pattern: /^\+\w+/,
	              alias: 'function'
	            },
	            rest: Prism.languages.javascript
	          }
	        }
	      ],
	      script: {
	        pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]+).+/m,
	        lookbehind: true,
	        inside: {
	          rest: Prism.languages.javascript
	        }
	      },
	      'plain-text': {
	        pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]+).+/m,
	        lookbehind: true
	      },
	      tag: {
	        pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
	        lookbehind: true,
	        inside: {
	          attributes: [
	            {
	              pattern: /&[^(]+\([^)]+\)/,
	              inside: {
	                rest: Prism.languages.javascript
	              }
	            },
	            {
	              pattern: /\([^)]+\)/,
	              inside: {
	                'attr-value': {
	                  pattern: /(=\s*)(?:\{[^}]*\}|[^,)\r\n]+)/,
	                  lookbehind: true,
	                  inside: {
	                    rest: Prism.languages.javascript
	                  }
	                },
	                'attr-name': /[\w-]+(?=\s*!?=|\s*[,)])/,
	                punctuation: /[!=(),]+/
	              }
	            }
	          ],
	          punctuation: /:/
	        }
	      },
	      code: [
	        {
	          pattern: /(^[\t ]*(?:-|!?=)).+/m,
	          lookbehind: true,
	          inside: {
	            rest: Prism.languages.javascript
	          }
	        }
	      ],
	      punctuation: /[.\-!=|]+/
	    };
	    var filter_pattern =
	      '(^([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ]+.+|\\s*?(?=\\r?\\n|\\r)))+';
	    // Non exhaustive list of available filters and associated languages
	    var filters = [
	      {filter: 'atpl', language: 'twig'},
	      {filter: 'coffee', language: 'coffeescript'},
	      'ejs',
	      'handlebars',
	      'hogan',
	      'less',
	      'livescript',
	      'markdown',
	      'mustache',
	      'plates',
	      {filter: 'sass', language: 'scss'},
	      'stylus',
	      'swig'
	    ];
	    var all_filters = {};
	    for (var i = 0, l = filters.length; i < l; i++) {
	      var filter = filters[i];
	      filter =
	        typeof filter === 'string'
	          ? {filter: filter, language: filter}
	          : filter;
	      if (Prism.languages[filter.language]) {
	        all_filters['filter-' + filter.filter] = {
	          pattern: RegExp(
	            filter_pattern.replace('{{filter_name}}', filter.filter),
	            'm'
	          ),
	          lookbehind: true,
	          inside: {
	            'filter-name': {
	              pattern: /^:[\w-]+/,
	              alias: 'variable'
	            },
	            rest: Prism.languages[filter.language]
	          }
	        };
	      }
	    }
	    Prism.languages.insertBefore('pug', 'filter', all_filters);
	  })(Prism);
	}


/***/ }),
/* 952 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = puppet;
	puppet.displayName = 'puppet';
	puppet.aliases = [];
	function puppet(Prism) {
	  (function(Prism) {
	    Prism.languages.puppet = {
	      heredoc: [
	        // Matches the content of a quoted heredoc string (subject to interpolation)
	        {
	          pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r))*?[ \t]*\|?[ \t]*-?[ \t]*\2/,
	          lookbehind: true,
	          alias: 'string',
	          inside: {
	            // Matches the end tag
	            punctuation: /(?=\S).*\S(?= *$)/
	            // See interpolation below
	          }
	        },
	        // Matches the content of an unquoted heredoc string (no interpolation)
	        {
	          pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r))*?[ \t]*\|?[ \t]*-?[ \t]*\2/,
	          lookbehind: true,
	          alias: 'string',
	          inside: {
	            // Matches the end tag
	            punctuation: /(?=\S).*\S(?= *$)/
	          }
	        },
	        // Matches the start tag of heredoc strings
	        {
	          pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
	          alias: 'string',
	          inside: {
	            punctuation: {
	              pattern: /(\().+?(?=\))/,
	              lookbehind: true
	            }
	          }
	        }
	      ],
	      'multiline-comment': {
	        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	        lookbehind: true,
	        alias: 'comment'
	      },
	      regex: {
	        // Must be prefixed with the keyword "node" or a non-word char
	        pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
	        lookbehind: true,
	        inside: {
	          // Extended regexes must have the x flag. They can contain single-line comments.
	          'extended-regex': {
	            pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
	            inside: {
	              comment: /#.*/
	            }
	          }
	        }
	      },
	      comment: {
	        pattern: /(^|[^\\])#.*/,
	        lookbehind: true
	      },
	      string: {
	        // Allow for one nested level of double quotes inside interpolation
	        pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|(?!\1)[^\\]|\\[\s\S])*\1/,
	        inside: {
	          'double-quoted': {
	            pattern: /^"[\s\S]*"$/,
	            inside: {
	              // See interpolation below
	            }
	          }
	        }
	      },
	      variable: {
	        pattern: /\$(?:::)?\w+(?:::\w+)*/,
	        inside: {
	          punctuation: /::/
	        }
	      },
	      'attr-name': /(?:\w+|\*)(?=\s*=>)/,
	      function: [
	        {
	          pattern: /(\.)(?!\d)\w+/,
	          lookbehind: true
	        },
	        /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
	      ],
	      number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
	      boolean: /\b(?:true|false)\b/,
	      // Includes words reserved for future use
	      keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
	      datatype: {
	        pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
	        alias: 'symbol'
	      },
	      operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
	      punctuation: /[\[\]{}().,;]|:+/
	    };
	    var interpolation = [
	      {
	        // Allow for one nested level of braces inside interpolation
	        pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
	        lookbehind: true,
	        inside: {
	          'short-variable': {
	            // Negative look-ahead prevent wrong highlighting of functions
	            pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
	            lookbehind: true,
	            alias: 'variable',
	            inside: {
	              punctuation: /::/
	            }
	          },
	          delimiter: {
	            pattern: /^\$/,
	            alias: 'variable'
	          },
	          rest: Prism.util.clone(Prism.languages.puppet)
	        }
	      },
	      {
	        pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
	        lookbehind: true,
	        alias: 'variable',
	        inside: {
	          punctuation: /::/
	        }
	      }
	    ];
	    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;
	    Prism.languages.puppet['string'].inside[
	      'double-quoted'
	    ].inside.interpolation = interpolation;
	  })(Prism);
	}


/***/ }),
/* 953 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var c = __webpack_require__(68);
	module.exports = pure;
	pure.displayName = 'pure';
	pure.aliases = [];
	function pure(Prism) {
	  Prism.register(c);
	  (function(Prism) {
	    Prism.languages.pure = {
	      comment: [
	        {
	          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	          lookbehind: true
	        },
	        {
	          pattern: /(^|[^\\:])\/\/.*/,
	          lookbehind: true
	        },
	        /#!.+/
	      ],
	      'inline-lang': {
	        pattern: /%<[\s\S]+?%>/,
	        greedy: true,
	        inside: {
	          lang: {
	            pattern: /(^%< *)-\*-.+?-\*-/,
	            lookbehind: true,
	            alias: 'comment'
	          },
	          delimiter: {
	            pattern: /^%<.*|%>$/,
	            alias: 'punctuation'
	          }
	        }
	      },
	      string: {
	        pattern: /"(?:\\.|[^"\\\r\n])*"/,
	        greedy: true
	      },
	      number: {
	        // The look-behind prevents wrong highlighting of the .. operator
	        pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d)?|\B\.\d)\d*(?:e[+-]?\d+)?L?)/i,
	        lookbehind: true
	      },
	      keyword: /\b(?:ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|NULL|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
	      function: /\b(?:abs|add_(?:(?:fundef|interface|macdef|typedef)(?:_at)?|addr|constdef|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_(?:matrix|pointer)|byte_c?string(?:_pointer)?|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|short|sentry|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
	      special: {
	        pattern: /\b__[a-z]+__\b/i,
	        alias: 'builtin'
	      },
	      // Any combination of operator chars can be an operator
	      operator: /(?=\b_|[^_])[!"#$%&'*+,\-.\/:<=>?@\\^_`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]+|\b(?:and|div|mod|not|or)\b/,
	      // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
	      punctuation: /[(){}\[\];,|]/
	    };
	    var inlineLanguages = [
	      'c',
	      {lang: 'c++', alias: 'cpp'},
	      'fortran',
	      'ats',
	      'dsp'
	    ];
	    var inlineLanguageRe = '%< *-\\*- *{lang}\\d* *-\\*-[\\s\\S]+?%>';
	    inlineLanguages.forEach(function(lang) {
	      var alias = lang;
	      if (typeof lang !== 'string') {
	        alias = lang.alias;
	        lang = lang.lang;
	      }
	      if (Prism.languages[alias]) {
	        var o = {};
	        o['inline-lang-' + alias] = {
	          pattern: RegExp(
	            inlineLanguageRe.replace(
	              '{lang}',
	              lang.replace(/([.+*?\/\\(){}\[\]])/g, '\\$1')
	            ),
	            'i'
	          ),
	          inside: Prism.util.clone(Prism.languages.pure['inline-lang'].inside)
	        };
	        o['inline-lang-' + alias].inside.rest = Prism.util.clone(
	          Prism.languages[alias]
	        );
	        Prism.languages.insertBefore('pure', 'inline-lang', o);
	      }
	    });
	    // C is the default inline language
	    if (Prism.languages.c) {
	      Prism.languages.pure['inline-lang'].inside.rest = Prism.util.clone(
	        Prism.languages.c
	      );
	    }
	  })(Prism);
	}


/***/ }),
/* 954 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = python;
	python.displayName = 'python';
	python.aliases = [];
	function python(Prism) {
	  Prism.languages.python = {
	    comment: {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true
	    },
	    'triple-quoted-string': {
	      pattern: /("""|''')[\s\S]+?\1/,
	      greedy: true,
	      alias: 'string'
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    function: {
	      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
	      lookbehind: true
	    },
	    'class-name': {
	      pattern: /(\bclass\s+)\w+/i,
	      lookbehind: true
	    },
	    keyword: /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|pass|print|raise|return|try|while|with|yield)\b/,
	    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
	    boolean: /\b(?:True|False|None)\b/,
	    number: /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
	    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 955 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = q;
	q.displayName = 'q';
	q.aliases = [];
	function q(Prism) {
	  Prism.languages.q = {
	    string: /"(?:\\.|[^"\\\r\n])*"/,
	    comment: [
	      // From http://code.kx.com/wiki/Reference/Slash:
	      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
	      {
	        pattern: /([\t )\]}])\/.*/,
	        lookbehind: true
	      },
	      // From http://code.kx.com/wiki/Reference/Slash:
	      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
	      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
	      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
	      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
	      {
	        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
	        lookbehind: true
	      },
	      // From http://code.kx.com/wiki/Reference/Slash:
	      // A \ on a line by itself with no preceding matching / will comment to end of file.
	      /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
	      /^#!.+/m
	    ],
	    symbol: /`(?::\S+|[\w.]*)/,
	    datetime: {
	      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
	      alias: 'number'
	    },
	    // The negative look-ahead prevents bad highlighting
	    // of verbs 0: and 1:
	    number: /\b-?(?![01]:)(?:0[wn]|0W[hj]?|0N[hje]?|0x[\da-fA-F]+|\d+\.?\d*(?:e[+-]?\d+)?[hjfeb]?)/,
	    keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
	    adverb: {
	      pattern: /['\/\\]:?|\beach\b/,
	      alias: 'function'
	    },
	    verb: {
	      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?_~=|$&#@^]):?/,
	      alias: 'operator'
	    },
	    punctuation: /[(){}\[\];.]/
	  };
	}


/***/ }),
/* 956 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = qore;
	qore.displayName = 'qore';
	qore.aliases = [];
	function qore(Prism) {
	  Prism.languages.qore = Prism.languages.extend('clike', {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
	      lookbehind: true
	    },
	    // Overridden to allow unescaped multi-line strings
	    string: {
	      pattern: /("|')(\\[\s\S]|(?!\1)[^\\])*\1/,
	      greedy: true
	    },
	    variable: /\$(?!\d)\w+\b/,
	    keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:int|float|number|bool|string|date|list)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
	    number: /\b(?:0b[01]+|0x[\da-f]*\.?[\da-fp\-]+|\d*\.?\d+e?\d*[df]|\d*\.?\d+)\b/i,
	    boolean: /\b(?:true|false)\b/i,
	    operator: {
	      pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
	      lookbehind: true
	    },
	    function: /\$?\b(?!\d)\w+(?=\()/
	  });
	}


/***/ }),
/* 957 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = r;
	r.displayName = 'r';
	r.aliases = [];
	function r(Prism) {
	  Prism.languages.r = {
	    comment: /#.*/,
	    string: {
	      pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    'percent-operator': {
	      // Includes user-defined operators
	      // and %%, %*%, %/%, %in%, %o%, %x%
	      pattern: /%[^%\s]*%/,
	      alias: 'operator'
	    },
	    boolean: /\b(?:TRUE|FALSE)\b/,
	    ellipsis: /\.\.(?:\.|\d+)/,
	    number: [
	      /\b(?:NaN|Inf)\b/,
	      /\b(?:0x[\dA-Fa-f]+(?:\.\d*)?|\d*\.?\d+)(?:[EePp][+-]?\d+)?[iL]?\b/
	    ],
	    keyword: /\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\b/,
	    operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
	    punctuation: /[(){}\[\],;]/
	  };
	}


/***/ }),
/* 958 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = reason;
	reason.displayName = 'reason';
	reason.aliases = [];
	function reason(Prism) {
	  Prism.languages.reason = Prism.languages.extend('clike', {
	    comment: {
	      pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	      lookbehind: true
	    },
	    string: {
	      pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
	      greedy: true
	    },
	    // 'class-name' must be matched *after* 'constructor' defined below
	    'class-name': /\b[A-Z]\w*/,
	    keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
	    operator: /\.{3}|:[:=]|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:mod|land|lor|lxor|lsl|lsr|asr)\b/
	  });
	  Prism.languages.insertBefore('reason', 'class-name', {
	    character: {
	      pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
	      alias: 'string'
	    },
	    constructor: {
	      // Negative look-ahead prevents from matching things like String.capitalize
	      pattern: /\b[A-Z]\w*\b(?!\s*\.)/,
	      alias: 'variable'
	    },
	    label: {
	      pattern: /\b[a-z]\w*(?=::)/,
	      alias: 'symbol'
	    }
	  });
	  // We can't match functions property, so let's not even try.
	  delete Prism.languages.reason.function;
	}


/***/ }),
/* 959 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = renpy;
	renpy.displayName = 'renpy';
	renpy.aliases = [];
	function renpy(Prism) {
	  Prism.languages.renpy = {
	    // TODO Write tests.
	    comment: {
	      pattern: /(^|[^\\])#.+/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2|(?:^#?(?:(?:[0-9a-fA-F]{2}){3}|(?:[0-9a-fA-F]){3})$)/m,
	      greedy: true
	    },
	    function: /[a-z_]\w*(?=\()/i,
	    property: /\b(?:insensitive|idle|hover|selected_idle|selected_hover|background|position|alt|xpos|ypos|pos|xanchor|yanchor|anchor|xalign|yalign|align|xcenter|ycenter|xofsset|yoffset|ymaximum|maximum|xmaximum|xminimum|yminimum|minimum|xsize|ysizexysize|xfill|yfill|area|antialias|black_color|bold|caret|color|first_indent|font|size|italic|justify|kerning|language|layout|line_leading|line_overlap_split|line_spacing|min_width|newline_indent|outlines|rest_indent|ruby_style|slow_cps|slow_cps_multiplier|strikethrough|text_align|underline|hyperlink_functions|vertical|hinting|foreground|left_margin|xmargin|top_margin|bottom_margin|ymargin|left_padding|right_padding|xpadding|top_padding|bottom_padding|ypadding|size_group|child|hover_sound|activate_sound|mouse|focus_mask|keyboard_focus|bar_vertical|bar_invert|bar_resizing|left_gutter|right_gutter|top_gutter|bottom_gutter|left_bar|right_bar|top_bar|bottom_bar|thumb|thumb_shadow|thumb_offset|unscrollable|spacing|first_spacing|box_reverse|box_wrap|order_reverse|fit_first|ysize|thumbnail_width|thumbnail_height|help|text_ypos|text_xpos|idle_color|hover_color|selected_idle_color|selected_hover_color|insensitive_color|alpha|insensitive_background|hover_background|zorder|value|width|xadjustment|xanchoraround|xaround|xinitial|xoffset|xzoom|yadjustment|yanchoraround|yaround|yinitial|yzoom|zoom|ground|height|text_style|text_y_fudge|selected_insensitive|has_sound|has_music|has_voice|focus|hovered|image_style|length|minwidth|mousewheel|offset|prefix|radius|range|right_margin|rotate|rotate_pad|developer|screen_width|screen_height|window_title|name|version|windows_icon|default_fullscreen|default_text_cps|default_afm_time|main_menu_music|sample_sound|enter_sound|exit_sound|save_directory|enter_transition|exit_transition|intra_transition|main_game_transition|game_main_transition|end_splash_transition|end_game_transition|after_load_transition|window_show_transition|window_hide_transition|adv_nvl_transition|nvl_adv_transition|enter_yesno_transition|exit_yesno_transition|enter_replay_transition|exit_replay_transition|say_attribute_transition|directory_name|executable_name|include_update|window_icon|modal|google_play_key|google_play_salt|drag_name|drag_handle|draggable|dragged|droppable|dropped|narrator_menu|action|default_afm_enable|version_name|version_tuple|inside|fadeout|fadein|layers|layer_clipping|linear|scrollbars|side_xpos|side_ypos|side_spacing|edgescroll|drag_joined|drag_raise|drop_shadow|drop_shadow_color|subpixel|easein|easeout|time|crop|auto|update|get_installed_packages|can_update|UpdateVersion|Update|overlay_functions|translations|window_left_padding|show_side_image|show_two_window)\b/,
	    tag: /\b(?:label|image|menu|[hv]box|frame|text|imagemap|imagebutton|bar|vbar|screen|textbutton|buttoscreenn|fixed|grid|input|key|mousearea|side|timer|viewport|window|hotspot|hotbar|self|button|drag|draggroup|tag|mm_menu_frame|nvl|block|parallel)\b|\$/,
	    keyword: /\b(?:as|assert|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|yield|adjustment|alignaround|allow|angle|around|box_layout|cache|changed|child_size|clicked|clipping|corner1|corner2|default|delay|exclude|scope|slow|slow_abortable|slow_done|sound|style_group|substitute|suffix|transform_anchor|transpose|unhovered|config|theme|mm_root|gm_root|rounded_window|build|disabled_text|disabled|widget_selected|widget_text|widget_hover|widget|updater|behind|call|expression|hide|init|jump|onlayer|python|renpy|scene|set|show|transform|play|queue|stop|pause|define|window|repeat|contains|choice|on|function|event|animation|clockwise|counterclockwise|circles|knot|null|None|random|has|add|use|fade|dissolve|style|store|id|voice|center|left|right|less_rounded|music|movie|clear|persistent|ui)\b/,
	    boolean: /\b(?:[Tt]rue|[Ff]alse)\b/,
	    number: /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
	    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not|with|at)\b/,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 960 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = rest;
	rest.displayName = 'rest';
	rest.aliases = [];
	function rest(Prism) {
	  Prism.languages.rest = {
	    table: [
	      {
	        pattern: /(\s*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1(?:[+|].+)+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\||(?:\+[=-]+)+\+/
	        }
	      },
	      {
	        pattern: /(\s*)(?:=+ +)+=+(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1(?:=+ +)+=+(?=(?:\r?\n|\r){2}|\s*$)/,
	        lookbehind: true,
	        inside: {
	          punctuation: /[=-]+/
	        }
	      }
	    ],
	    // Directive-like patterns
	    'substitution-def': {
	      pattern: /(^\s*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
	      lookbehind: true,
	      inside: {
	        substitution: {
	          pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
	          alias: 'attr-value',
	          inside: {
	            punctuation: /^\||\|$/
	          }
	        },
	        directive: {
	          pattern: /( +)[^:]+::/,
	          lookbehind: true,
	          alias: 'function',
	          inside: {
	            punctuation: /::$/
	          }
	        }
	      }
	    },
	    'link-target': [
	      {
	        pattern: /(^\s*\.\. )\[[^\]]+\]/m,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          punctuation: /^\[|\]$/
	        }
	      },
	      {
	        pattern: /(^\s*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          punctuation: /^_|:$/
	        }
	      }
	    ],
	    directive: {
	      pattern: /(^\s*\.\. )[^:]+::/m,
	      lookbehind: true,
	      alias: 'function',
	      inside: {
	        punctuation: /::$/
	      }
	    },
	    comment: {
	      // The two alternatives try to prevent highlighting of blank comments
	      pattern: /(^\s*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
	      lookbehind: true
	    },
	    title: [
	      // Overlined and underlined
	      {
	        pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
	        inside: {
	          punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
	          important: /.+/
	        }
	      },
	      // Underlined only
	      {
	        pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
	        lookbehind: true,
	        inside: {
	          punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
	          important: /.+/
	        }
	      }
	    ],
	    hr: {
	      pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    field: {
	      pattern: /(^\s*):[^:\r\n]+:(?= )/m,
	      lookbehind: true,
	      alias: 'attr-name'
	    },
	    'command-line-option': {
	      pattern: /(^\s*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    'literal-block': {
	      pattern: /::(?:\r?\n|\r){2}([ \t]+).+(?:(?:\r?\n|\r)\1.+)*/,
	      inside: {
	        'literal-block-punctuation': {
	          pattern: /^::/,
	          alias: 'punctuation'
	        }
	      }
	    },
	    'quoted-literal-block': {
	      pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
	      inside: {
	        'literal-block-punctuation': {
	          pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
	          alias: 'punctuation'
	        }
	      }
	    },
	    'list-bullet': {
	      pattern: /(^\s*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    'doctest-block': {
	      pattern: /(^\s*)>>> .+(?:(?:\r?\n|\r).+)*/m,
	      lookbehind: true,
	      inside: {
	        punctuation: /^>>>/
	      }
	    },
	    inline: [
	      {
	        pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s).*?[^\s]\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
	        lookbehind: true,
	        inside: {
	          bold: {
	            pattern: /(^\*\*).+(?=\*\*$)/,
	            lookbehind: true
	          },
	          italic: {
	            pattern: /(^\*).+(?=\*$)/,
	            lookbehind: true
	          },
	          'inline-literal': {
	            pattern: /(^``).+(?=``$)/,
	            lookbehind: true,
	            alias: 'symbol'
	          },
	          role: {
	            pattern: /^:[^:]+:|:[^:]+:$/,
	            alias: 'function',
	            inside: {
	              punctuation: /^:|:$/
	            }
	          },
	          'interpreted-text': {
	            pattern: /(^`).+(?=`$)/,
	            lookbehind: true,
	            alias: 'attr-value'
	          },
	          substitution: {
	            pattern: /(^\|).+(?=\|$)/,
	            lookbehind: true,
	            alias: 'attr-value'
	          },
	          punctuation: /\*\*?|``?|\|/
	        }
	      }
	    ],
	    link: [
	      {
	        pattern: /\[[^\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
	        alias: 'string',
	        inside: {
	          punctuation: /^\[|\]_$/
	        }
	      },
	      {
	        pattern: /(?:\b[a-z\d](?:[_.:+]?[a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
	        alias: 'string',
	        inside: {
	          punctuation: /^_?`|`$|`?_?_$/
	        }
	      }
	    ],
	    // Line block start,
	    // quote attribution,
	    // explicit markup start,
	    // and anonymous hyperlink target shortcut (__)
	    punctuation: {
	      pattern: /(^\s*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
	      lookbehind: true
	    }
	  };
	}


/***/ }),
/* 961 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = rip;
	rip.displayName = 'rip';
	rip.aliases = [];
	function rip(Prism) {
	  Prism.languages.rip = {
	    comment: /#.*/,
	    keyword: /(?:=>|->)|\b(?:class|if|else|switch|case|return|exit|try|catch|finally|raise)\b/,
	    builtin: /@|\bSystem\b/,
	    boolean: /\b(?:true|false)\b/,
	    date: /\b\d{4}-\d{2}-\d{2}\b/,
	    time: /\b\d{2}:\d{2}:\d{2}\b/,
	    datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
	    character: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
	    regex: {
	      pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/(?=\s*($|[\r\n,.;})]))/,
	      lookbehind: true,
	      greedy: true
	    },
	    symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    number: /[+-]?(?:(?:\d+\.\d+)|(?:\d+))/,
	    punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
	    reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
	  };
	}


/***/ }),
/* 962 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = roboconf;
	roboconf.displayName = 'roboconf';
	roboconf.aliases = [];
	function roboconf(Prism) {
	  Prism.languages.roboconf = {
	    comment: /#.*/,
	    keyword: {
	      pattern: /(^|\s)(?:(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{)|(?:external|import)\b)/,
	      lookbehind: true
	    },
	    component: {
	      pattern: /[\w-]+(?=[ \t]*\{)/,
	      alias: 'variable'
	    },
	    property: /[\w.-]+(?=[ \t]*:)/,
	    value: {
	      pattern: /(=[ \t]*)[^,;]+/,
	      lookbehind: true,
	      alias: 'attr-value'
	    },
	    optional: {
	      pattern: /\(optional\)/,
	      alias: 'builtin'
	    },
	    wildcard: {
	      pattern: /(\.)\*/,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    punctuation: /[{},.;:=]/
	  };
	}


/***/ }),
/* 963 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = rust;
	rust.displayName = 'rust';
	rust.aliases = [];
	function rust(Prism) {
	  /* TODO
	Add support for Markdown notation inside doc comments
	Add support for nested block comments...
	Match closure params even when not followed by dash or brace
	Add better support for macro definition
	*/
	  Prism.languages.rust = {
	    comment: [
	      {
	        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true
	      }
	    ],
	    string: [
	      {
	        pattern: /b?r(#*)"(?:\\.|(?!"\1)[^\\\r\n])*"\1/,
	        greedy: true
	      },
	      {
	        pattern: /b?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      }
	    ],
	    keyword: /\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,
	    attribute: {
	      pattern: /#!?\[.+?\]/,
	      greedy: true,
	      alias: 'attr-name'
	    },
	    function: [
	      /\w+(?=\s*\()/,
	      // Macros can use parens or brackets
	      /\w+!(?=\s*\(|\[)/
	    ],
	    'macro-rules': {
	      pattern: /\w+!/,
	      alias: 'function'
	    },
	    // Hex, oct, bin, dec numbers with visual separators and type suffix
	    number: /\b-?(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,
	    // Closure params should not be confused with bitwise OR |
	    'closure-params': {
	      pattern: /\|[^|]*\|(?=\s*[{-])/,
	      inside: {
	        punctuation: /[|:,]/,
	        operator: /[&*]/
	      }
	    },
	    punctuation: /[{}[\];(),:]|\.+|->/,
	    operator: /[-+*\/%!^=]=?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/
	  };
	}


/***/ }),
/* 964 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = sas;
	sas.displayName = 'sas';
	sas.aliases = [];
	function sas(Prism) {
	  Prism.languages.sas = {
	    datalines: {
	      pattern: /^\s*(?:(?:data)?lines|cards);[\s\S]+?(?:\r?\n|\r);/im,
	      alias: 'string',
	      inside: {
	        keyword: {
	          pattern: /^(\s*)(?:(?:data)?lines|cards)/i,
	          lookbehind: true
	        },
	        punctuation: /;/
	      }
	    },
	    comment: [
	      {
	        pattern: /(^\s*|;\s*)\*.*;/m,
	        lookbehind: true
	      },
	      /\/\*[\s\S]+?\*\//
	    ],
	    datetime: {
	      // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
	      pattern: /'[^']+'(?:dt?|t)\b/i,
	      alias: 'number'
	    },
	    string: {
	      pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
	      greedy: true
	    },
	    keyword: /\b(?:data|else|format|if|input|proc\s\w+|quit|run|then)\b/i,
	    // Decimal (1.2e23), hexadecimal (0c1x)
	    number: /(?:\B-|\b)(?:[\da-f]+x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)/i,
	    operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?|\b(?:eq|ne|gt|lt|ge|le|in|not)\b/i,
	    punctuation: /[$%@.(){}\[\];,\\]/
	  };
	}


/***/ }),
/* 965 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = sass;
	sass.displayName = 'sass';
	sass.aliases = [];
	function sass(Prism) {
	  (function(Prism) {
	    Prism.languages.sass = Prism.languages.extend('css', {
	      // Sass comments don't need to be closed, only indented
	      comment: {
	        pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,
	        lookbehind: true
	      }
	    });
	    Prism.languages.insertBefore('sass', 'atrule', {
	      // We want to consume the whole line
	      'atrule-line': {
	        // Includes support for = and + shortcuts
	        pattern: /^(?:[ \t]*)[@+=].+/m,
	        inside: {
	          atrule: /(?:@[\w-]+|[+=])/m
	        }
	      }
	    });
	    delete Prism.languages.sass.atrule;
	    var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
	    var operator = [
	      /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,
	      {
	        pattern: /(\s+)-(?=\s)/,
	        lookbehind: true
	      }
	    ];
	    Prism.languages.insertBefore('sass', 'property', {
	      // We want to consume the whole line
	      'variable-line': {
	        pattern: /^[ \t]*\$.+/m,
	        inside: {
	          punctuation: /:/,
	          variable: variable,
	          operator: operator
	        }
	      },
	      // We want to consume the whole line
	      'property-line': {
	        pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,
	        inside: {
	          property: [
	            /[^:\s]+(?=\s*:)/,
	            {
	              pattern: /(:)[^:\s]+/,
	              lookbehind: true
	            }
	          ],
	          punctuation: /:/,
	          variable: variable,
	          operator: operator,
	          important: Prism.languages.sass.important
	        }
	      }
	    });
	    delete Prism.languages.sass.property;
	    delete Prism.languages.sass.important;
	    // Now that whole lines for other patterns are consumed,
	    // what's left should be selectors
	    delete Prism.languages.sass.selector;
	    Prism.languages.insertBefore('sass', 'punctuation', {
	      selector: {
	        pattern: /([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,
	        lookbehind: true
	      }
	    });
	  })(Prism);
	}


/***/ }),
/* 966 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var java = __webpack_require__(351);
	module.exports = scala;
	scala.displayName = 'scala';
	scala.aliases = [];
	function scala(Prism) {
	  Prism.register(java);
	  Prism.languages.scala = Prism.languages.extend('java', {
	    keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
	    string: [
	      {
	        pattern: /"""[\s\S]*?"""/,
	        greedy: true
	      },
	      {
	        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      }
	    ],
	    builtin: /\b(?:String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\b/,
	    number: /\b(?:0x[\da-f]*\.?[\da-f]+|\d*\.?\d+e?\d*[dfl]?)\b/i,
	    symbol: /'[^\d\s\\]\w*/
	  });
	  delete Prism.languages.scala['class-name'];
	  delete Prism.languages.scala['function'];
	}


/***/ }),
/* 967 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = scheme;
	scheme.displayName = 'scheme';
	scheme.aliases = [];
	function scheme(Prism) {
	  Prism.languages.scheme = {
	    comment: /;.*/,
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\.)*"|'[^('\s]*/,
	      greedy: true
	    },
	    keyword: {
	      pattern: /(\()(?:define(?:-syntax|-library|-values)?|(?:case-)?lambda|let(?:\*|rec)?(?:-values)?|else|if|cond|begin|delay(?:-force)?|parameterize|guard|set!|(?:quasi-)?quote|syntax-rules)/,
	      lookbehind: true
	    },
	    builtin: {
	      pattern: /(\()(?:(?:cons|car|cdr|list|call-with-current-continuation|call\/cc|append|abs|apply|eval)\b|null\?|pair\?|boolean\?|eof-object\?|char\?|procedure\?|number\?|port\?|string\?|vector\?|symbol\?|bytevector\?)/,
	      lookbehind: true
	    },
	    number: {
	      pattern: /(\s|\))[-+]?\d*\.?\d+(?:\s*[-+]\s*\d*\.?\d+i)?\b/,
	      lookbehind: true
	    },
	    boolean: /#[tf]/,
	    operator: {
	      pattern: /(\()(?:[-+*%\/]|[<>]=?|=>?)/,
	      lookbehind: true
	    },
	    function: {
	      pattern: /(\()[^\s()]*(?=\s)/,
	      lookbehind: true
	    },
	    punctuation: /[()]/
	  };
	}


/***/ }),
/* 968 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = scss;
	scss.displayName = 'scss';
	scss.aliases = [];
	function scss(Prism) {
	  Prism.languages.scss = Prism.languages.extend('css', {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	      lookbehind: true
	    },
	    atrule: {
	      pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,
	      inside: {
	        rule: /@[\w-]+/
	        // See rest below
	      }
	    },
	    // url, compassified
	    url: /(?:[-a-z]+-)*url(?=\()/i,
	    // CSS selector regex is not appropriate for Sass
	    // since there can be lot more things (var, @ directive, nesting..)
	    // a selector must start at the end of a property or after a brace (end of other rules or nesting)
	    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
	    // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
	    // can "pass" as a selector- e.g: proper#{$erty})
	    // this one was hard to do, so please be careful if you edit this one :)
	    selector: {
	      // Initial look-ahead is used to prevent matching of blank selectors
	      pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,
	      inside: {
	        parent: {
	          pattern: /&/,
	          alias: 'important'
	        },
	        placeholder: /%[-\w]+/,
	        variable: /\$[-\w]+|#\{\$[-\w]+\}/
	      }
	    }
	  });
	  Prism.languages.insertBefore('scss', 'atrule', {
	    keyword: [
	      /@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,
	      {
	        pattern: /( +)(?:from|through)(?= )/,
	        lookbehind: true
	      }
	    ]
	  });
	  Prism.languages.scss.property = {
	    pattern: /(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i,
	    inside: {
	      variable: /\$[-\w]+|#\{\$[-\w]+\}/
	    }
	  };
	  Prism.languages.insertBefore('scss', 'important', {
	    // var and interpolated vars
	    variable: /\$[-\w]+|#\{\$[-\w]+\}/
	  });
	  Prism.languages.insertBefore('scss', 'function', {
	    placeholder: {
	      pattern: /%[-\w]+/,
	      alias: 'selector'
	    },
	    statement: {
	      pattern: /\B!(?:default|optional)\b/i,
	      alias: 'keyword'
	    },
	    boolean: /\b(?:true|false)\b/,
	    null: /\bnull\b/,
	    operator: {
	      pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
	      lookbehind: true
	    }
	  });
	  Prism.languages.scss['atrule'].inside.rest = Prism.util.clone(
	    Prism.languages.scss
	  );
	}


/***/ }),
/* 969 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = smalltalk;
	smalltalk.displayName = 'smalltalk';
	smalltalk.aliases = [];
	function smalltalk(Prism) {
	  Prism.languages.smalltalk = {
	    comment: /"(?:""|[^"])+"/,
	    string: /'(?:''|[^'])+'/,
	    symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
	    'block-arguments': {
	      pattern: /(\[\s*):[^\[|]*\|/,
	      lookbehind: true,
	      inside: {
	        variable: /:[\da-z]+/i,
	        punctuation: /\|/
	      }
	    },
	    'temporary-variables': {
	      pattern: /\|[^|]+\|/,
	      inside: {
	        variable: /[\da-z]+/i,
	        punctuation: /\|/
	      }
	    },
	    keyword: /\b(?:nil|true|false|self|super|new)\b/,
	    character: {
	      pattern: /\$./,
	      alias: 'string'
	    },
	    number: [
	      /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
	      /(?:\B-|\b)\d+(?:\.\d+)?(?:e-?\d+)?/
	    ],
	    operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
	    punctuation: /[.;:?\[\](){}]/
	  };
	}


/***/ }),
/* 970 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = smarty;
	smarty.displayName = 'smarty';
	smarty.aliases = [];
	function smarty(Prism) {
	  /* TODO
	Add support for variables inside double quoted strings
	Add support for {php}
	*/
	  (function(Prism) {
	    var smarty_pattern = /\{\*[\s\S]+?\*\}|\{[\s\S]+?\}/g;
	    var smarty_litteral_start = '{literal}';
	    var smarty_litteral_end = '{/literal}';
	    var smarty_litteral_mode = false;
	    Prism.languages.smarty = Prism.languages.extend('markup', {
	      smarty: {
	        pattern: smarty_pattern,
	        inside: {
	          delimiter: {
	            pattern: /^\{|\}$/i,
	            alias: 'punctuation'
	          },
	          string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	          number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][-+]?\d+)?)\b/,
	          variable: [
	            /\$(?!\d)\w+/,
	            /#(?!\d)\w+#/,
	            {
	              pattern: /(\.|->)(?!\d)\w+/,
	              lookbehind: true
	            },
	            {
	              pattern: /(\[)(?!\d)\w+(?=\])/,
	              lookbehind: true
	            }
	          ],
	          function: [
	            {
	              pattern: /(\|\s*)@?(?!\d)\w+/,
	              lookbehind: true
	            },
	            /^\/?(?!\d)\w+/,
	            /(?!\d)\w+(?=\()/
	          ],
	          'attr-name': {
	            // Value is made optional because it may have already been tokenized
	            pattern: /\w+\s*=\s*(?:(?!\d)\w+)?/,
	            inside: {
	              variable: {
	                pattern: /(=\s*)(?!\d)\w+/,
	                lookbehind: true
	              },
	              operator: /=/
	            }
	          },
	          punctuation: [/[\[\]().,:`]|->/],
	          operator: [
	            /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
	            /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
	            /\b(?:eq|neq?|gt|lt|gt?e|lt?e|not|mod|or|and)\b/
	          ],
	          keyword: /\b(?:false|off|on|no|true|yes)\b/
	        }
	      }
	    });
	    // Comments are inserted at top so that they can
	    // surround markup
	    Prism.languages.insertBefore('smarty', 'tag', {
	      'smarty-comment': {
	        pattern: /\{\*[\s\S]*?\*\}/,
	        alias: ['smarty', 'comment']
	      }
	    });
	    // Tokenize all inline Smarty expressions
	    Prism.hooks.add('before-highlight', function(env) {
	      if (env.language !== 'smarty') {
	        return;
	      }
	      env.tokenStack = [];
	      env.backupCode = env.code;
	      env.code = env.code.replace(smarty_pattern, function(match) {
	        // Smarty tags inside {literal} block are ignored
	        if (match === smarty_litteral_end) {
	          smarty_litteral_mode = false;
	        }
	        if (!smarty_litteral_mode) {
	          if (match === smarty_litteral_start) {
	            smarty_litteral_mode = true;
	          }
	          var i = env.tokenStack.length;
	          // Check for existing strings
	          while (env.backupCode.indexOf('___SMARTY' + i + '___') !== -1) ++i;
	          // Create a sparse array
	          env.tokenStack[i] = match;
	          return '___SMARTY' + i + '___';
	        }
	        return match;
	      });
	    });
	    // Restore env.code for other plugins (e.g. line-numbers)
	    Prism.hooks.add('before-insert', function(env) {
	      if (env.language === 'smarty') {
	        env.code = env.backupCode;
	        delete env.backupCode;
	      }
	    });
	    // Re-insert the tokens after highlighting
	    // and highlight them with defined grammar
	    Prism.hooks.add('after-highlight', function(env) {
	      if (env.language !== 'smarty') {
	        return;
	      }
	      for (
	        var i = 0, keys = Object.keys(env.tokenStack);
	        i < keys.length;
	        ++i
	      ) {
	        var k = keys[i];
	        var t = env.tokenStack[k];
	        // The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
	        env.highlightedCode = env.highlightedCode.replace(
	          '___SMARTY' + k + '___',
	          Prism.highlight(t, env.grammar, 'smarty').replace(/\$/g, '$$$$')
	        );
	      }
	      env.element.innerHTML = env.highlightedCode;
	    });
	  })(Prism);
	}


/***/ }),
/* 971 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = sql;
	sql.displayName = 'sql';
	sql.aliases = [];
	function sql(Prism) {
	  Prism.languages.sql = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\])*\2/,
	      greedy: true,
	      lookbehind: true
	    },
	    variable: /@[\w.$]+|@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
	    function: /\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\s*\()/i, // Should we highlight user defined functions too?
	    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR VARYING|CHARACTER (?:SET|VARYING)|CHARSET|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|DATA(?:BASES?)?|DATE(?:TIME)?|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITER(?:S)?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE(?: PRECISION)?|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE(?:D BY)?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEYS?|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL(?: CHAR VARYING| CHARACTER(?: VARYING)?| VARCHAR)?|NATURAL|NCHAR(?: VARCHAR)?|NEXT|NO(?: SQL|CHECK|CYCLE)?|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READ(?:S SQL DATA|TEXT)?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START(?:ING BY)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED BY|TEXT(?:SIZE)?|THEN|TIMESTAMP|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?)\b/i,
	    boolean: /\b(?:TRUE|FALSE|NULL)\b/i,
	    number: /\b-?(?:0x)?\d*\.?[\da-f]+\b/,
	    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
	    punctuation: /[;[\]()`,.]/
	  };
	}


/***/ }),
/* 972 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = stylus;
	stylus.displayName = 'stylus';
	stylus.aliases = [];
	function stylus(Prism) {
	  (function(Prism) {
	    var inside = {
	      url: /url\((["']?).*?\1\)/i,
	      string: {
	        pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
	        greedy: true
	      },
	      interpolation: null, // See below
	      func: null, // See below
	      important: /\B!(?:important|optional)\b/i,
	      keyword: {
	        pattern: /(^|\s+)(?:(?:if|else|for|return|unless)(?=\s+|$)|@[\w-]+)/,
	        lookbehind: true
	      },
	      hexcode: /#[\da-f]{3,6}/i,
	      number: /\b\d+(?:\.\d+)?%?/,
	      boolean: /\b(?:true|false)\b/,
	      operator: [
	        // We want non-word chars around "-" because it is
	        // accepted in property names.
	        /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.+|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
	      ],
	      punctuation: /[{}()\[\];:,]/
	    };
	    inside['interpolation'] = {
	      pattern: /\{[^\r\n}:]+\}/,
	      alias: 'variable',
	      inside: Prism.util.clone(inside)
	    };
	    inside['func'] = {
	      pattern: /[\w-]+\([^)]*\).*/,
	      inside: {
	        function: /^[^(]+/,
	        rest: Prism.util.clone(inside)
	      }
	    };
	    Prism.languages.stylus = {
	      comment: {
	        pattern: /(^|[^\\])(\/\*[\s\S]*?\*\/|\/\/.*)/,
	        lookbehind: true
	      },
	      'atrule-declaration': {
	        pattern: /(^\s*)@.+/m,
	        lookbehind: true,
	        inside: {
	          atrule: /^@[\w-]+/,
	          rest: inside
	        }
	      },
	      'variable-declaration': {
	        pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:(?:\{[^}]*\}|.+)|$)/m,
	        lookbehind: true,
	        inside: {
	          variable: /^\S+/,
	          rest: inside
	        }
	      },
	      statement: {
	        pattern: /(^[ \t]*)(?:if|else|for|return|unless)[ \t]+.+/m,
	        lookbehind: true,
	        inside: {
	          keyword: /^\S+/,
	          rest: inside
	        }
	      },
	      // A property/value pair cannot end with a comma or a brace
	      // It cannot have indented content unless it ended with a semicolon
	      'property-declaration': {
	        pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)[^{\r\n]*(?:;|[^{\r\n,](?=$)(?!(\r?\n|\r)(?:\{|\2[ \t]+)))/m,
	        lookbehind: true,
	        inside: {
	          property: {
	            pattern: /^[^\s:]+/,
	            inside: {
	              interpolation: inside.interpolation
	            }
	          },
	          rest: inside
	        }
	      },
	      // A selector can contain parentheses only as part of a pseudo-element
	      // It can span multiple lines.
	      // It must end with a comma or an accolade or have indented content.
	      selector: {
	        pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t]+)))/m,
	        lookbehind: true,
	        inside: {
	          interpolation: inside.interpolation,
	          punctuation: /[{},]/
	        }
	      },
	      func: inside.func,
	      string: inside.string,
	      interpolation: inside.interpolation,
	      punctuation: /[{}()\[\];:.]/
	    };
	  })(Prism);
	}


/***/ }),
/* 973 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = swift;
	swift.displayName = 'swift';
	swift.aliases = [];
	function swift(Prism) {
	  // issues: nested multiline comments
	  Prism.languages.swift = Prism.languages.extend('clike', {
	    string: {
	      pattern: /("|')(\\(?:\((?:[^()]|\([^)]+\))+\)|\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /\\\((?:[^()]|\([^)]+\))+\)/,
	          inside: {
	            delimiter: {
	              pattern: /^\\\(|\)$/,
	              alias: 'variable'
	            }
	            // See rest below
	          }
	        }
	      }
	    },
	    keyword: /\b(?:as|associativity|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic(?:Type)?|else|enum|extension|fallthrough|final|for|func|get|guard|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|Protocol|public|repeat|required|rethrows|return|right|safe|self|Self|set|static|struct|subscript|super|switch|throws?|try|Type|typealias|unowned|unsafe|var|weak|where|while|willSet|__(?:COLUMN__|FILE__|FUNCTION__|LINE__))\b/,
	    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
	    constant: /\b(?:nil|[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
	    atrule: /@\b(?:IB(?:Outlet|Designable|Action|Inspectable)|class_protocol|exported|noreturn|NS(?:Copying|Managed)|objc|UIApplicationMain|auto_closure)\b/,
	    builtin: /\b(?:[A-Z]\S+|abs|advance|alignof(?:Value)?|assert|contains|count(?:Elements)?|debugPrint(?:ln)?|distance|drop(?:First|Last)|dump|enumerate|equal|filter|find|first|getVaList|indices|isEmpty|join|last|lexicographicalCompare|map|max(?:Element)?|min(?:Element)?|numericCast|overlaps|partition|print(?:ln)?|reduce|reflect|reverse|sizeof(?:Value)?|sort(?:ed)?|split|startsWith|stride(?:of(?:Value)?)?|suffix|swap|toDebugString|toString|transcode|underestimateCount|unsafeBitCast|with(?:ExtendedLifetime|Unsafe(?:MutablePointers?|Pointers?)|VaList))\b/
	  });
	  Prism.languages.swift['string'].inside[
	    'interpolation'
	  ].inside.rest = Prism.util.clone(Prism.languages.swift);
	}


/***/ }),
/* 974 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = tcl;
	tcl.displayName = 'tcl';
	tcl.aliases = [];
	function tcl(Prism) {
	  Prism.languages.tcl = {
	    comment: {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
	      greedy: true
	    },
	    variable: [
	      {
	        pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
	        lookbehind: true
	      },
	      {
	        pattern: /(\$){[^}]+}/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^\s*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
	        lookbehind: true
	      }
	    ],
	    function: {
	      pattern: /(^\s*proc[ \t]+)[^\s]+/m,
	      lookbehind: true
	    },
	    builtin: [
	      {
	        pattern: /(^\s*)(?:proc|return|class|error|eval|exit|for|foreach|if|switch|while|break|continue)\b/m,
	        lookbehind: true
	      },
	      /\b(?:elseif|else)\b/
	    ],
	    scope: {
	      pattern: /(^\s*)(?:global|upvar|variable)\b/m,
	      lookbehind: true,
	      alias: 'constant'
	    },
	    keyword: {
	      pattern: /(^\s*|\[)(?:after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|Safe_Base|scan|seek|set|socket|source|split|string|subst|Tcl|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|wordBreak(?:After|Before)|test|vars)|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
	      lookbehind: true
	    },
	    operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|ne|in|ni)\b/,
	    punctuation: /[{}()\[\]]/
	  };
	}


/***/ }),
/* 975 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = textile;
	textile.displayName = 'textile';
	textile.aliases = [];
	function textile(Prism) {
	  (function(Prism) {
	    // We don't allow for pipes inside parentheses
	    // to not break table pattern |(. foo |). bar |
	    var modifierRegex = '(?:\\([^|)]+\\)|\\[[^\\]]+\\]|\\{[^}]+\\})+';
	    var modifierTokens = {
	      css: {
	        pattern: /\{[^}]+\}/,
	        inside: {
	          rest: Prism.languages.css
	        }
	      },
	      'class-id': {
	        pattern: /(\()[^)]+(?=\))/,
	        lookbehind: true,
	        alias: 'attr-value'
	      },
	      lang: {
	        pattern: /(\[)[^\]]+(?=\])/,
	        lookbehind: true,
	        alias: 'attr-value'
	      },
	      // Anything else is punctuation (the first pattern is for row/col spans inside tables)
	      punctuation: /[\\\/]\d+|\S/
	    };
	    Prism.languages.textile = Prism.languages.extend('markup', {
	      phrase: {
	        pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
	        lookbehind: true,
	        inside: {
	          // h1. Header 1
	          'block-tag': {
	            pattern: RegExp('^[a-z]\\w*(?:' + modifierRegex + '|[<>=()])*\\.'),
	            inside: {
	              modifier: {
	                pattern: RegExp(
	                  '(^[a-z]\\w*)(?:' + modifierRegex + '|[<>=()])+(?=\\.)'
	                ),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              tag: /^[a-z]\w*/,
	              punctuation: /\.$/
	            }
	          },
	          // # List item
	          // * List item
	          list: {
	            pattern: RegExp('^[*#]+(?:' + modifierRegex + ')?\\s+.+', 'm'),
	            inside: {
	              modifier: {
	                pattern: RegExp('(^[*#]+)' + modifierRegex),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              punctuation: /^[*#]+/
	            }
	          },
	          // | cell | cell | cell |
	          table: {
	            // Modifiers can be applied to the row: {color:red}.|1|2|3|
	            // or the cell: |{color:red}.1|2|3|
	            pattern: RegExp(
	              '^(?:(?:' +
	                modifierRegex +
	                '|[<>=()^~])+\\.\\s*)?(?:\\|(?:(?:' +
	                modifierRegex +
	                '|[<>=()^~_]|[\\\\/]\\d+)+\\.)?[^|]*)+\\|',
	              'm'
	            ),
	            inside: {
	              modifier: {
	                // Modifiers for rows after the first one are
	                // preceded by a pipe and a line feed
	                pattern: RegExp(
	                  '(^|\\|(?:\\r?\\n|\\r)?)(?:' +
	                    modifierRegex +
	                    '|[<>=()^~_]|[\\\\/]\\d+)+(?=\\.)'
	                ),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              punctuation: /\||^\./
	            }
	          },
	          inline: {
	            pattern: RegExp(
	              '(\\*\\*|__|\\?\\?|[*_%@+\\-^~])(?:' + modifierRegex + ')?.+?\\1'
	            ),
	            inside: {
	              // Note: superscripts and subscripts are not handled specifically
	              // *bold*, **bold**
	              bold: {
	                pattern: RegExp(
	                  '(^(\\*\\*?)(?:' + modifierRegex + ')?).+?(?=\\2)'
	                ),
	                lookbehind: true
	              },
	              // _italic_, __italic__
	              italic: {
	                pattern: RegExp('(^(__?)(?:' + modifierRegex + ')?).+?(?=\\2)'),
	                lookbehind: true
	              },
	              // ??cite??
	              cite: {
	                pattern: RegExp(
	                  '(^\\?\\?(?:' + modifierRegex + ')?).+?(?=\\?\\?)'
	                ),
	                lookbehind: true,
	                alias: 'string'
	              },
	              // @code@
	              code: {
	                pattern: RegExp('(^@(?:' + modifierRegex + ')?).+?(?=@)'),
	                lookbehind: true,
	                alias: 'keyword'
	              },
	              // +inserted+
	              inserted: {
	                pattern: RegExp('(^\\+(?:' + modifierRegex + ')?).+?(?=\\+)'),
	                lookbehind: true
	              },
	              // -deleted-
	              deleted: {
	                pattern: RegExp('(^-(?:' + modifierRegex + ')?).+?(?=-)'),
	                lookbehind: true
	              },
	              // %span%
	              span: {
	                pattern: RegExp('(^%(?:' + modifierRegex + ')?).+?(?=%)'),
	                lookbehind: true
	              },
	              modifier: {
	                pattern: RegExp(
	                  '(^\\*\\*|__|\\?\\?|[*_%@+\\-^~])' + modifierRegex
	                ),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              punctuation: /[*_%?@+\-^~]+/
	            }
	          },
	          // [alias]http://example.com
	          'link-ref': {
	            pattern: /^\[[^\]]+\]\S+$/m,
	            inside: {
	              string: {
	                pattern: /(\[)[^\]]+(?=\])/,
	                lookbehind: true
	              },
	              url: {
	                pattern: /(\])\S+$/,
	                lookbehind: true
	              },
	              punctuation: /[\[\]]/
	            }
	          },
	          // "text":http://example.com
	          // "text":link-ref
	          link: {
	            pattern: RegExp(
	              '"(?:' + modifierRegex + ')?[^"]+":.+?(?=[^\\w/]?(?:\\s|$))'
	            ),
	            inside: {
	              text: {
	                pattern: RegExp('(^"(?:' + modifierRegex + ')?)[^"]+(?=")'),
	                lookbehind: true
	              },
	              modifier: {
	                pattern: RegExp('(^")' + modifierRegex),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              url: {
	                pattern: /(:).+/,
	                lookbehind: true
	              },
	              punctuation: /[":]/
	            }
	          },
	          // !image.jpg!
	          // !image.jpg(Title)!:http://example.com
	          image: {
	            pattern: RegExp(
	              '!(?:' +
	                modifierRegex +
	                '|[<>=()])*[^!\\s()]+(?:\\([^)]+\\))?!(?::.+?(?=[^\\w/]?(?:\\s|$)))?'
	            ),
	            inside: {
	              source: {
	                pattern: RegExp(
	                  '(^!(?:' +
	                    modifierRegex +
	                    '|[<>=()])*)[^!\\s()]+(?:\\([^)]+\\))?(?=!)'
	                ),
	                lookbehind: true,
	                alias: 'url'
	              },
	              modifier: {
	                pattern: RegExp('(^!)(?:' + modifierRegex + '|[<>=()])+'),
	                lookbehind: true,
	                inside: Prism.util.clone(modifierTokens)
	              },
	              url: {
	                pattern: /(:).+/,
	                lookbehind: true
	              },
	              punctuation: /[!:]/
	            }
	          },
	          // Footnote[1]
	          footnote: {
	            pattern: /\b\[\d+\]/,
	            alias: 'comment',
	            inside: {
	              punctuation: /\[|\]/
	            }
	          },
	          // CSS(Cascading Style Sheet)
	          acronym: {
	            pattern: /\b[A-Z\d]+\([^)]+\)/,
	            inside: {
	              comment: {
	                pattern: /(\()[^)]+(?=\))/,
	                lookbehind: true
	              },
	              punctuation: /[()]/
	            }
	          },
	          // Prism(C)
	          mark: {
	            pattern: /\b\((?:TM|R|C)\)/,
	            alias: 'comment',
	            inside: {
	              punctuation: /[()]/
	            }
	          }
	        }
	      }
	    });
	    var nestedPatterns = {
	      inline: Prism.util.clone(
	        Prism.languages.textile['phrase'].inside['inline']
	      ),
	      link: Prism.util.clone(Prism.languages.textile['phrase'].inside['link']),
	      image: Prism.util.clone(
	        Prism.languages.textile['phrase'].inside['image']
	      ),
	      footnote: Prism.util.clone(
	        Prism.languages.textile['phrase'].inside['footnote']
	      ),
	      acronym: Prism.util.clone(
	        Prism.languages.textile['phrase'].inside['acronym']
	      ),
	      mark: Prism.util.clone(Prism.languages.textile['phrase'].inside['mark'])
	    };
	    // Only allow alpha-numeric HTML tags, not XML tags
	    Prism.languages.textile.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
	    // Allow some nesting
	    Prism.languages.textile['phrase'].inside['inline'].inside[
	      'bold'
	    ].inside = nestedPatterns;
	    Prism.languages.textile['phrase'].inside['inline'].inside[
	      'italic'
	    ].inside = nestedPatterns;
	    Prism.languages.textile['phrase'].inside['inline'].inside[
	      'inserted'
	    ].inside = nestedPatterns;
	    Prism.languages.textile['phrase'].inside['inline'].inside[
	      'deleted'
	    ].inside = nestedPatterns;
	    Prism.languages.textile['phrase'].inside['inline'].inside[
	      'span'
	    ].inside = nestedPatterns;
	    // Allow some styles inside table cells
	    Prism.languages.textile['phrase'].inside['table'].inside['inline'] =
	      nestedPatterns['inline'];
	    Prism.languages.textile['phrase'].inside['table'].inside['link'] =
	      nestedPatterns['link'];
	    Prism.languages.textile['phrase'].inside['table'].inside['image'] =
	      nestedPatterns['image'];
	    Prism.languages.textile['phrase'].inside['table'].inside['footnote'] =
	      nestedPatterns['footnote'];
	    Prism.languages.textile['phrase'].inside['table'].inside['acronym'] =
	      nestedPatterns['acronym'];
	    Prism.languages.textile['phrase'].inside['table'].inside['mark'] =
	      nestedPatterns['mark'];
	  })(Prism);
	}


/***/ }),
/* 976 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = twig;
	twig.displayName = 'twig';
	twig.aliases = [];
	function twig(Prism) {
	  Prism.languages.twig = {
	    comment: /\{#[\s\S]*?#\}/,
	    tag: {
	      pattern: /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}/,
	      inside: {
	        ld: {
	          pattern: /^(?:\{\{-?|\{%-?\s*\w+)/,
	          inside: {
	            punctuation: /^(?:\{\{|\{%)-?/,
	            keyword: /\w+/
	          }
	        },
	        rd: {
	          pattern: /-?(?:%\}|\}\})$/,
	          inside: {
	            punctuation: /.*/
	          }
	        },
	        string: {
	          pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	          inside: {
	            punctuation: /^['"]|['"]$/
	          }
	        },
	        keyword: /\b(?:even|if|odd)\b/,
	        boolean: /\b(?:true|false|null)\b/,
	        number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][-+]?\d+)?)\b/,
	        operator: [
	          {
	            pattern: /(\s)(?:and|b-and|b-xor|b-or|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
	            lookbehind: true
	          },
	          /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
	        ],
	        property: /\b[a-zA-Z_]\w*\b/,
	        punctuation: /[()\[\]{}:.,]/
	      }
	    },
	    // The rest can be parsed as HTML
	    other: {
	      // We want non-blank matches
	      pattern: /\S(?:[\s\S]*\S)?/,
	      inside: Prism.languages.markup
	    }
	  };
	}


/***/ }),
/* 977 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = typescript;
	typescript.displayName = 'typescript';
	typescript.aliases = ['ts'];
	function typescript(Prism) {
	  Prism.languages.typescript = Prism.languages.extend('javascript', {
	    // From JavaScript Prism keyword list and TypeScript language spec: https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#221-reserved-words
	    keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|false|true|module|declare|constructor|string|Function|any|number|boolean|Array|symbol|namespace|abstract|require|type)\b/
	  });
	  Prism.languages.ts = Prism.languages.typescript;
	}


/***/ }),
/* 978 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = vbnet;
	vbnet.displayName = 'vbnet';
	vbnet.aliases = [];
	function vbnet(Prism) {
	  Prism.languages.vbnet = Prism.languages.extend('basic', {
	    keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDEC|CDBL|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEFAULT|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LINE INPUT|LET|LIB|LIKE|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPERATOR|OPEN|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHORT|SINGLE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SYNCLOCK|SWAP|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
	    comment: [
	      {
	        pattern: /(?:!|REM\b).+/i,
	        inside: {
	          keyword: /^REM/i
	        }
	      },
	      {
	        pattern: /(^|[^\\:])'.*/,
	        lookbehind: true
	      }
	    ]
	  });
	}


/***/ }),
/* 979 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = verilog;
	verilog.displayName = 'verilog';
	verilog.aliases = [];
	function verilog(Prism) {
	  Prism.languages.verilog = {
	    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
	    string: {
	      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
	      greedy: true
	    },
	    // support for any kernel function (ex: $display())
	    property: /\B\$\w+\b/,
	    // support for user defined constants (ex: `define)
	    constant: /\B`\w+\b/,
	    function: /\w+(?=\()/,
	    // support for verilog and system verilog keywords
	    keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|class|case|casex|casez|cell|chandle|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_onevent|pulsestyle_ondetect|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
	    // bold highlighting for all verilog and system verilog logic blocks
	    important: /\b(?:always_latch|always_comb|always_ff|always)\b ?@?/,
	    // support for time ticks, vectors, and real numbers
	    number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b\d*[._]?\d+(?:e[-+]?\d+)?/i,
	    operator: /[-+{}^~%*\/?=!<>&|]+/,
	    punctuation: /[[\];(),.:]/
	  };
	}


/***/ }),
/* 980 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = vhdl;
	vhdl.displayName = 'vhdl';
	vhdl.aliases = [];
	function vhdl(Prism) {
	  Prism.languages.vhdl = {
	    comment: /--.+/,
	    // support for all logic vectors
	    'vhdl-vectors': {
	      pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
	      alias: 'number'
	    },
	    // support for operator overloading included
	    'quoted-function': {
	      pattern: /"\S+?"(?=\()/,
	      alias: 'function'
	    },
	    string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
	    constant: /\b(?:use|library)\b/i,
	    // support for predefined attributes included
	    keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
	    boolean: /\b(?:true|false)\b/i,
	    function: /\w+(?=\()/,
	    // decimal, based, physical, and exponential numbers supported
	    number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
	    operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|not|mod|rem|sll|srl|sla|sra|rol|ror|and|or|nand|xnor|xor|nor)\b/i,
	    punctuation: /[{}[\];(),.:]/
	  };
	}


/***/ }),
/* 981 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = vim;
	vim.displayName = 'vim';
	vim.aliases = [];
	function vim(Prism) {
	  Prism.languages.vim = {
	    string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
	    comment: /".*/,
	    function: /\w+(?=\()/,
	    keyword: /\b(?:ab|abbreviate|abc|abclear|abo|aboveleft|al|all|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|ar|args|argu|argument|as|ascii|bad|badd|ba|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bN|bNext|bo|botright|bp|bprevious|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|br|brewind|bro|browse|bufdo|b|buffer|buffers|bun|bunload|bw|bwipeout|ca|cabbrev|cabc|cabclear|caddb|caddbuffer|cad|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cgetb|cgetbuffer|cgete|cgetexpr|cg|cgetfile|c|change|changes|chd|chdir|che|checkpath|checkt|checktime|cla|clast|cl|clist|clo|close|cmapc|cmapclear|cnew|cnewer|cn|cnext|cN|cNext|cnf|cnfile|cNfcNfile|cnorea|cnoreabbrev|col|colder|colo|colorscheme|comc|comclear|comp|compiler|conf|confirm|con|continue|cope|copen|co|copy|cpf|cpfile|cp|cprevious|cq|cquit|cr|crewind|cuna|cunabbrev|cu|cunmap|cw|cwindow|debugg|debuggreedy|delc|delcommand|d|delete|delf|delfunction|delm|delmarks|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|di|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|earlier|echoe|echoerr|echom|echomsg|echon|e|edit|el|else|elsei|elseif|em|emenu|endfo|endfor|endf|endfunction|endfun|en|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fina|finally|fin|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|folddoc|folddoclosed|foldd|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|ha|hardcopy|h|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iuna|iunabbrev|iu|iunmap|j|join|ju|jumps|k|keepalt|keepj|keepjumps|kee|keepmarks|laddb|laddbuffer|lad|laddexpr|laddf|laddfile|lan|language|la|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|let|left|lefta|leftabove|lex|lexpr|lf|lfile|lfir|lfirst|lgetb|lgetbuffer|lgete|lgetexpr|lg|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|l|list|ll|lla|llast|lli|llist|lmak|lmake|lm|lmap|lmapc|lmapclear|lnew|lnewer|lne|lnext|lN|lNext|lnf|lnfile|lNf|lNfile|ln|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lpf|lpfile|lp|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|mak|make|ma|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkvie|mkview|mkv|mkvimrc|mod|mode|m|move|mzf|mzfile|mz|mzscheme|nbkey|new|n|next|N|Next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|omapc|omapclear|on|only|o|open|opt|options|ou|ounmap|pc|pclose|ped|pedit|pe|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|p|print|P|Print|profd|profdel|prof|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptN|ptNext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|pyf|pyfile|py|python|qa|qall|q|quit|quita|quitall|r|read|rec|recover|redi|redir|red|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|rub|ruby|rubyd|rubydo|rubyf|rubyfile|ru|runtime|rv|rviminfo|sal|sall|san|sandbox|sa|sargument|sav|saveas|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbN|sbNext|sbp|sbprevious|sbr|sbrewind|sb|sbuffer|scripte|scriptencoding|scrip|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sla|slast|sl|sleep|sm|smagic|sm|smap|smapc|smapclear|sme|smenu|sn|snext|sN|sNext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|sor|sort|so|source|spelld|spelldump|spe|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|sp|split|spr|sprevious|sre|srewind|sta|stag|startg|startgreplace|star|startinsert|startr|startreplace|stj|stjump|st|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tab|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabnew|tabn|tabnext|tabN|tabNext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|ta|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tm|tmenu|tn|tnext|tN|tNext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tu|tunmenu|una|unabbreviate|u|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|verb|verbose|ve|version|vert|vertical|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|vi|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|wa|wall|wh|while|winc|wincmd|windo|winp|winpos|win|winsize|wn|wnext|wN|wNext|wp|wprevious|wq|wqa|wqall|w|write|ws|wsverb|wv|wviminfo|X|xa|xall|x|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|XMLent|XMLns|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
	    builtin: /\b(?:autocmd|acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|t_AB|t_AF|t_al|t_AL|t_bc|t_cd|t_ce|t_Ce|t_cl|t_cm|t_Co|t_cs|t_Cs|t_CS|t_CV|t_da|t_db|t_dl|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_fs|t_IE|t_IS|t_k1|t_K1|t_k2|t_k3|t_K3|t_k4|t_K4|t_k5|t_K5|t_k6|t_K6|t_k7|t_K7|t_k8|t_K8|t_k9|t_K9|t_KA|t_kb|t_kB|t_KB|t_KC|t_kd|t_kD|t_KD|t_ke|t_KE|t_KF|t_KG|t_kh|t_KH|t_kI|t_KI|t_KJ|t_KK|t_kl|t_KL|t_kN|t_kP|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_RI|t_RV|t_Sb|t_se|t_Sf|t_SI|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_WP|t_WS|t_xs|t_ZH|t_ZR)\b/,
	    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
	    operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
	    punctuation: /[{}[\](),;:]/
	  };
	}


/***/ }),
/* 982 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = wiki;
	wiki.displayName = 'wiki';
	wiki.aliases = [];
	function wiki(Prism) {
	  Prism.languages.wiki = Prism.languages.extend('markup', {
	    'block-comment': {
	      pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    heading: {
	      pattern: /^(=+).+?\1/m,
	      inside: {
	        punctuation: /^=+|=+$/,
	        important: /.+/
	      }
	    },
	    emphasis: {
	      // TODO Multi-line
	      pattern: /('{2,5}).+?\1/,
	      inside: {
	        'bold italic': {
	          pattern: /(''''').+?(?=\1)/,
	          lookbehind: true
	        },
	        bold: {
	          pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
	          lookbehind: true
	        },
	        italic: {
	          pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
	          lookbehind: true
	        },
	        punctuation: /^''+|''+$/
	      }
	    },
	    hr: {
	      pattern: /^-{4,}/m,
	      alias: 'punctuation'
	    },
	    url: [
	      /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:RFC|PMID) +\d+/i,
	      /\[\[.+?\]\]|\[.+?\]/
	    ],
	    variable: [
	      /__[A-Z]+__/,
	      // FIXME Nested structures should be handled
	      // {{formatnum:{{#expr:{{{3}}}}}}}
	      /\{{3}.+?\}{3}/,
	      /\{\{.+?\}\}/
	    ],
	    symbol: [/^#redirect/im, /~{3,5}/],
	    // Handle table attrs:
	    // {|
	    // ! style="text-align:left;"| Item
	    // |}
	    'table-tag': {
	      pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
	      lookbehind: true,
	      inside: {
	        'table-bar': {
	          pattern: /\|$/,
	          alias: 'punctuation'
	        },
	        rest: Prism.languages.markup['tag'].inside
	      }
	    },
	    punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
	  });
	  Prism.languages.insertBefore('wiki', 'tag', {
	    // Prevent highlighting inside <nowiki>, <source> and <pre> tags
	    nowiki: {
	      pattern: /<(nowiki|pre|source)\b[\s\S]*?>[\s\S]*?<\/\1>/i,
	      inside: {
	        tag: {
	          pattern: /<(?:nowiki|pre|source)\b[\s\S]*?>|<\/(?:nowiki|pre|source)>/i,
	          inside: Prism.languages.markup['tag'].inside
	        }
	      }
	    }
	  });
	}


/***/ }),
/* 983 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = xojo;
	xojo.displayName = 'xojo';
	xojo.aliases = [];
	function xojo(Prism) {
	  Prism.languages.xojo = {
	    comment: {
	      pattern: /(?:'|\/\/|Rem\b).+/i,
	      inside: {
	        keyword: /^Rem/i
	      }
	    },
	    string: {
	      pattern: /"(?:""|[^"])*"/,
	      greedy: true
	    },
	    number: [/(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
	    symbol: /#(?:If|Else|ElseIf|Endif|Pragma)\b/i,
	    keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|By(?:Ref|Val)|Break|Call|Case|Catch|Const|Continue|CurrentMethodName|Declare|Dim|Do(?:wnTo)?|Each|Else(?:If)?|End|Exit|Extends|False|Finally|For|Global|If|In|Lib|Loop|Me|Next|Nil|Optional|ParamArray|Raise(?:Event)?|ReDim|Rem|RemoveHandler|Return|Select|Self|Soft|Static|Step|Super|Then|To|True|Try|Ubound|Until|Using|Wend|While)\b/i,
	    operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|Xor|WeakAddressOf)\b/i,
	    punctuation: /[.,;:()]/
	  };
	}


/***/ }),
/* 984 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = yaml;
	yaml.displayName = 'yaml';
	yaml.aliases = [];
	function yaml(Prism) {
	  Prism.languages.yaml = {
	    scalar: {
	      pattern: /([\-:]\s*(?:![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\2[^\r\n]+)*)/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    comment: /#.*/,
	    key: {
	      pattern: /(\s*(?:^|[:\-,[{\r\n?])[ \t]*(?:![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,
	      lookbehind: true,
	      alias: 'atrule'
	    },
	    directive: {
	      pattern: /(^[ \t]*)%.+/m,
	      lookbehind: true,
	      alias: 'important'
	    },
	    datetime: {
	      pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?)(?=[ \t]*(?:$|,|]|}))/m,
	      lookbehind: true,
	      alias: 'number'
	    },
	    boolean: {
	      pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:true|false)[ \t]*(?=$|,|]|})/im,
	      lookbehind: true,
	      alias: 'important'
	    },
	    null: {
	      pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:null|~)[ \t]*(?=$|,|]|})/im,
	      lookbehind: true,
	      alias: 'important'
	    },
	    string: {
	      pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)("|')(?:(?!\2)[^\\\r\n]|\\.)*\2(?=[ \t]*(?:$|,|]|}))/m,
	      lookbehind: true,
	      greedy: true
	    },
	    number: {
	      pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)[+\-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+\.?\d*|\.?\d+)(?:e[+-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,
	      lookbehind: true
	    },
	    tag: /![^\s]+/,
	    important: /[&*][\w]+/,
	    punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
	  };
	}


/***/ }),
/* 985 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var unherit = __webpack_require__(1055);
	var xtend = __webpack_require__(44);
	var Parser = __webpack_require__(995);
	
	module.exports = parse;
	parse.Parser = Parser;
	
	function parse(options) {
	  var Local = unherit(Parser);
	  Local.prototype.options = xtend(Local.prototype.options, this.data('settings'), options);
	  this.Parser = Local;
	}


/***/ }),
/* 986 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var entities = __webpack_require__(175);
	
	module.exports = factory;
	
	/* Factory to create an entity decoder. */
	function factory(ctx) {
	  decoder.raw = decodeRaw;
	
	  return decoder;
	
	  /* Normalize `position` to add an `indent`. */
	  function normalize(position) {
	    var offsets = ctx.offset;
	    var line = position.line;
	    var result = [];
	
	    while (++line) {
	      if (!(line in offsets)) {
	        break;
	      }
	
	      result.push((offsets[line] || 0) + 1);
	    }
	
	    return {
	      start: position,
	      indent: result
	    };
	  }
	
	  /* Handle a warning.
	   * See https://github.com/wooorm/parse-entities
	   * for the warnings. */
	  function handleWarning(reason, position, code) {
	    if (code === 3) {
	      return;
	    }
	
	    ctx.file.message(reason, position);
	  }
	
	  /* Decode `value` (at `position`) into text-nodes. */
	  function decoder(value, position, handler) {
	    entities(value, {
	      position: normalize(position),
	      warning: handleWarning,
	      text: handler,
	      reference: handler,
	      textContext: ctx,
	      referenceContext: ctx
	    });
	  }
	
	  /* Decode `value` (at `position`) into a string. */
	  function decodeRaw(value, position) {
	    return entities(value, {
	      position: normalize(position),
	      warning: handleWarning
	    });
	  }
	}


/***/ }),
/* 987 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  var index = value.indexOf('\n', fromIndex);
	
	  while (index > fromIndex) {
	    if (value.charAt(index - 1) !== ' ') {
	      break;
	    }
	
	    index--;
	  }
	
	  return index;
	}


/***/ }),
/* 988 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  return value.indexOf('`', fromIndex);
	}


/***/ }),
/* 989 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  return value.indexOf('~~', fromIndex);
	}


/***/ }),
/* 990 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  var asterisk = value.indexOf('*', fromIndex);
	  var underscore = value.indexOf('_', fromIndex);
	
	  if (underscore === -1) {
	    return asterisk;
	  }
	
	  if (asterisk === -1) {
	    return underscore;
	  }
	
	  return underscore < asterisk ? underscore : asterisk;
	}


/***/ }),
/* 991 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  return value.indexOf('\\', fromIndex);
	}


/***/ }),
/* 992 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	function locate(value, fromIndex) {
	  var asterisk = value.indexOf('**', fromIndex);
	  var underscore = value.indexOf('__', fromIndex);
	
	  if (underscore === -1) {
	    return asterisk;
	  }
	
	  if (asterisk === -1) {
	    return underscore;
	  }
	
	  return underscore < asterisk ? underscore : asterisk;
	}


/***/ }),
/* 993 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = locate;
	
	var PROTOCOLS = ['https://', 'http://', 'mailto:'];
	
	function locate(value, fromIndex) {
	  var length = PROTOCOLS.length;
	  var index = -1;
	  var min = -1;
	  var position;
	
	  if (!this.options.gfm) {
	    return -1;
	  }
	
	  while (++index < length) {
	    position = value.indexOf(PROTOCOLS[index], fromIndex);
	
	    if (position !== -1 && (position < min || min === -1)) {
	      min = position;
	    }
	  }
	
	  return min;
	}


/***/ }),
/* 994 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var xtend = __webpack_require__(44);
	var removePosition = __webpack_require__(1058);
	
	module.exports = parse;
	
	var C_NEWLINE = '\n';
	var EXPRESSION_LINE_BREAKS = /\r\n|\r/g;
	
	/* Parse the bound file. */
	function parse() {
	  var self = this;
	  var value = String(self.file);
	  var start = {line: 1, column: 1, offset: 0};
	  var content = xtend(start);
	  var node;
	
	  /* Clean non-unix newlines: `\r\n` and `\r` are all
	   * changed to `\n`.  This should not affect positional
	   * information. */
	  value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE);
	
	  if (value.charCodeAt(0) === 0xFEFF) {
	    value = value.slice(1);
	
	    content.column++;
	    content.offset++;
	  }
	
	  node = {
	    type: 'root',
	    children: self.tokenizeBlock(value, content),
	    position: {
	      start: start,
	      end: self.eof || xtend(start)
	    }
	  };
	
	  if (!self.options.position) {
	    removePosition(node, true);
	  }
	
	  return node;
	}


/***/ }),
/* 995 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var xtend = __webpack_require__(44);
	var toggle = __webpack_require__(1042);
	var vfileLocation = __webpack_require__(1067);
	var unescape = __webpack_require__(1023);
	var decode = __webpack_require__(986);
	var tokenizer = __webpack_require__(1022);
	
	module.exports = Parser;
	
	function Parser(doc, file) {
	  this.file = file;
	  this.offset = {};
	  this.options = xtend(this.options);
	  this.setOptions({});
	
	  this.inList = false;
	  this.inBlock = false;
	  this.inLink = false;
	  this.atStart = true;
	
	  this.toOffset = vfileLocation(file).toOffset;
	  this.unescape = unescape(this, 'escape');
	  this.decode = decode(this);
	}
	
	var proto = Parser.prototype;
	
	/* Expose core. */
	proto.setOptions = __webpack_require__(996);
	proto.parse = __webpack_require__(994);
	
	/* Expose `defaults`. */
	proto.options = __webpack_require__(353);
	
	/* Enter and exit helpers. */
	proto.exitStart = toggle('atStart', true);
	proto.enterList = toggle('inList', false);
	proto.enterLink = toggle('inLink', false);
	proto.enterBlock = toggle('inBlock', false);
	
	/* Nodes that can interupt a paragraph:
	 *
	 * ```markdown
	 * A paragraph, followed by a thematic break.
	 * ___
	 * ```
	 *
	 * In the above example, the thematic break “interupts”
	 * the paragraph. */
	proto.interruptParagraph = [
	  ['thematicBreak'],
	  ['atxHeading'],
	  ['fencedCode'],
	  ['blockquote'],
	  ['html'],
	  ['setextHeading', {commonmark: false}],
	  ['definition', {commonmark: false}],
	  ['footnote', {commonmark: false}]
	];
	
	/* Nodes that can interupt a list:
	 *
	 * ```markdown
	 * - One
	 * ___
	 * ```
	 *
	 * In the above example, the thematic break “interupts”
	 * the list. */
	proto.interruptList = [
	  ['fencedCode', {pedantic: false}],
	  ['thematicBreak', {pedantic: false}],
	  ['definition', {commonmark: false}],
	  ['footnote', {commonmark: false}]
	];
	
	/* Nodes that can interupt a blockquote:
	 *
	 * ```markdown
	 * > A paragraph.
	 * ___
	 * ```
	 *
	 * In the above example, the thematic break “interupts”
	 * the blockquote. */
	proto.interruptBlockquote = [
	  ['indentedCode', {commonmark: true}],
	  ['fencedCode', {commonmark: true}],
	  ['atxHeading', {commonmark: true}],
	  ['setextHeading', {commonmark: true}],
	  ['thematicBreak', {commonmark: true}],
	  ['html', {commonmark: true}],
	  ['list', {commonmark: true}],
	  ['definition', {commonmark: false}],
	  ['footnote', {commonmark: false}]
	];
	
	/* Handlers. */
	proto.blockTokenizers = {
	  newline: __webpack_require__(1014),
	  indentedCode: __webpack_require__(1001),
	  fencedCode: __webpack_require__(1000),
	  blockquote: __webpack_require__(998),
	  atxHeading: __webpack_require__(1008),
	  thematicBreak: __webpack_require__(1020),
	  list: __webpack_require__(1013),
	  setextHeading: __webpack_require__(1009),
	  html: __webpack_require__(1010),
	  footnote: __webpack_require__(1007),
	  definition: __webpack_require__(1003),
	  table: __webpack_require__(1018),
	  paragraph: __webpack_require__(1015)
	};
	
	proto.inlineTokenizers = {
	  escape: __webpack_require__(1006),
	  autoLink: __webpack_require__(997),
	  url: __webpack_require__(1021),
	  html: __webpack_require__(1011),
	  link: __webpack_require__(1012),
	  reference: __webpack_require__(1016),
	  strong: __webpack_require__(1017),
	  emphasis: __webpack_require__(1005),
	  deletion: __webpack_require__(1004),
	  code: __webpack_require__(1002),
	  break: __webpack_require__(999),
	  text: __webpack_require__(1019)
	};
	
	/* Expose precedence. */
	proto.blockMethods = keys(proto.blockTokenizers);
	proto.inlineMethods = keys(proto.inlineTokenizers);
	
	/* Tokenizers. */
	proto.tokenizeBlock = tokenizer('block');
	proto.tokenizeInline = tokenizer('inline');
	proto.tokenizeFactory = tokenizer;
	
	/* Get all keys in `value`. */
	function keys(value) {
	  var result = [];
	  var key;
	
	  for (key in value) {
	    result.push(key);
	  }
	
	  return result;
	}


/***/ }),
/* 996 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var xtend = __webpack_require__(44);
	var escapes = __webpack_require__(668);
	var defaults = __webpack_require__(353);
	
	module.exports = setOptions;
	
	function setOptions(options) {
	  var self = this;
	  var current = self.options;
	  var key;
	  var value;
	
	  if (options == null) {
	    options = {};
	  } else if (typeof options === 'object') {
	    options = xtend(options);
	  } else {
	    throw new Error(
	      'Invalid value `' + options + '` ' +
	      'for setting `options`'
	    );
	  }
	
	  for (key in defaults) {
	    value = options[key];
	
	    if (value == null) {
	      value = current[key];
	    }
	
	    if (
	      (key !== 'blocks' && typeof value !== 'boolean') ||
	      (key === 'blocks' && typeof value !== 'object')
	    ) {
	      throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');
	    }
	
	    options[key] = value;
	  }
	
	  self.options = options;
	  self.escape = escapes(options);
	
	  return self;
	}


/***/ }),
/* 997 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var decode = __webpack_require__(175);
	var locate = __webpack_require__(355);
	
	module.exports = autoLink;
	autoLink.locator = locate;
	autoLink.notInLink = true;
	
	var C_LT = '<';
	var C_GT = '>';
	var C_AT_SIGN = '@';
	var C_SLASH = '/';
	var MAILTO = 'mailto:';
	var MAILTO_LENGTH = MAILTO.length;
	
	/* Tokenise a link. */
	function autoLink(eat, value, silent) {
	  var self;
	  var subvalue;
	  var length;
	  var index;
	  var queue;
	  var character;
	  var hasAtCharacter;
	  var link;
	  var now;
	  var content;
	  var tokenize;
	  var exit;
	
	  if (value.charAt(0) !== C_LT) {
	    return;
	  }
	
	  self = this;
	  subvalue = '';
	  length = value.length;
	  index = 0;
	  queue = '';
	  hasAtCharacter = false;
	  link = '';
	
	  index++;
	  subvalue = C_LT;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (
	      whitespace(character) ||
	      character === C_GT ||
	      character === C_AT_SIGN ||
	      (character === ':' && value.charAt(index + 1) === C_SLASH)
	    ) {
	      break;
	    }
	
	    queue += character;
	    index++;
	  }
	
	  if (!queue) {
	    return;
	  }
	
	  link += queue;
	  queue = '';
	
	  character = value.charAt(index);
	  link += character;
	  index++;
	
	  if (character === C_AT_SIGN) {
	    hasAtCharacter = true;
	  } else {
	    if (
	      character !== ':' ||
	      value.charAt(index + 1) !== C_SLASH
	    ) {
	      return;
	    }
	
	    link += C_SLASH;
	    index++;
	  }
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (whitespace(character) || character === C_GT) {
	      break;
	    }
	
	    queue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	
	  if (!queue || character !== C_GT) {
	    return;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  link += queue;
	  content = link;
	  subvalue += link + character;
	  now = eat.now();
	  now.column++;
	  now.offset++;
	
	  if (hasAtCharacter) {
	    if (link.slice(0, MAILTO_LENGTH).toLowerCase() === MAILTO) {
	      content = content.substr(MAILTO_LENGTH);
	      now.column += MAILTO_LENGTH;
	      now.offset += MAILTO_LENGTH;
	    } else {
	      link = MAILTO + link;
	    }
	  }
	
	  /* Temporarily remove support for escapes in autolinks. */
	  tokenize = self.inlineTokenizers.escape;
	  self.inlineTokenizers.escape = null;
	  exit = self.enterLink();
	
	  content = self.tokenizeInline(content, now);
	
	  self.inlineTokenizers.escape = tokenize;
	  exit();
	
	  return eat(subvalue)({
	    type: 'link',
	    title: null,
	    url: decode(link),
	    children: content
	  });
	}


/***/ }),
/* 998 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	var interrupt = __webpack_require__(200);
	
	module.exports = blockquote;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_GT = '>';
	
	/* Tokenise a blockquote. */
	function blockquote(eat, value, silent) {
	  var self = this;
	  var offsets = self.offset;
	  var tokenizers = self.blockTokenizers;
	  var interruptors = self.interruptBlockquote;
	  var now = eat.now();
	  var currentLine = now.line;
	  var length = value.length;
	  var values = [];
	  var contents = [];
	  var indents = [];
	  var add;
	  var index = 0;
	  var character;
	  var rest;
	  var nextIndex;
	  var content;
	  var line;
	  var startIndex;
	  var prefixed;
	  var exit;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      break;
	    }
	
	    index++;
	  }
	
	  if (value.charAt(index) !== C_GT) {
	    return;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  index = 0;
	
	  while (index < length) {
	    nextIndex = value.indexOf(C_NEWLINE, index);
	    startIndex = index;
	    prefixed = false;
	
	    if (nextIndex === -1) {
	      nextIndex = length;
	    }
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character !== C_SPACE && character !== C_TAB) {
	        break;
	      }
	
	      index++;
	    }
	
	    if (value.charAt(index) === C_GT) {
	      index++;
	      prefixed = true;
	
	      if (value.charAt(index) === C_SPACE) {
	        index++;
	      }
	    } else {
	      index = startIndex;
	    }
	
	    content = value.slice(index, nextIndex);
	
	    if (!prefixed && !trim(content)) {
	      index = startIndex;
	      break;
	    }
	
	    if (!prefixed) {
	      rest = value.slice(index);
	
	      /* Check if the following code contains a possible
	       * block. */
	      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {
	        break;
	      }
	    }
	
	    line = startIndex === index ? content : value.slice(startIndex, nextIndex);
	
	    indents.push(index - startIndex);
	    values.push(line);
	    contents.push(content);
	
	    index = nextIndex + 1;
	  }
	
	  index = -1;
	  length = indents.length;
	  add = eat(values.join(C_NEWLINE));
	
	  while (++index < length) {
	    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
	    currentLine++;
	  }
	
	  exit = self.enterBlock();
	  contents = self.tokenizeBlock(contents.join(C_NEWLINE), now);
	  exit();
	
	  return add({
	    type: 'blockquote',
	    children: contents
	  });
	}


/***/ }),
/* 999 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var locate = __webpack_require__(987);
	
	module.exports = hardBreak;
	hardBreak.locator = locate;
	
	var MIN_BREAK_LENGTH = 2;
	
	function hardBreak(eat, value, silent) {
	  var length = value.length;
	  var index = -1;
	  var queue = '';
	  var character;
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character === '\n') {
	      if (index < MIN_BREAK_LENGTH) {
	        return;
	      }
	
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true;
	      }
	
	      queue += character;
	
	      return eat(queue)({type: 'break'});
	    }
	
	    if (character !== ' ') {
	      return;
	    }
	
	    queue += character;
	  }
	}


/***/ }),
/* 1000 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(204);
	
	module.exports = fencedCode;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_TILDE = '~';
	var C_TICK = '`';
	
	var MIN_FENCE_COUNT = 3;
	var CODE_INDENT_COUNT = 4;
	
	function fencedCode(eat, value, silent) {
	  var self = this;
	  var settings = self.options;
	  var length = value.length + 1;
	  var index = 0;
	  var subvalue = '';
	  var fenceCount;
	  var marker;
	  var character;
	  var flag;
	  var queue;
	  var content;
	  var exdentedContent;
	  var closing;
	  var exdentedClosing;
	  var indent;
	  var now;
	
	  if (!settings.gfm) {
	    return;
	  }
	
	  /* Eat initial spacing. */
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  indent = index;
	
	  /* Eat the fence. */
	  character = value.charAt(index);
	
	  if (character !== C_TILDE && character !== C_TICK) {
	    return;
	  }
	
	  index++;
	  marker = character;
	  fenceCount = 1;
	  subvalue += character;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== marker) {
	      break;
	    }
	
	    subvalue += character;
	    fenceCount++;
	    index++;
	  }
	
	  if (fenceCount < MIN_FENCE_COUNT) {
	    return;
	  }
	
	  /* Eat spacing before flag. */
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  /* Eat flag. */
	  flag = '';
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (
	      character === C_NEWLINE ||
	      character === C_TILDE ||
	      character === C_TICK
	    ) {
	      break;
	    }
	
	    if (character === C_SPACE || character === C_TAB) {
	      queue += character;
	    } else {
	      flag += queue + character;
	      queue = '';
	    }
	
	    index++;
	  }
	
	  character = value.charAt(index);
	
	  if (character && character !== C_NEWLINE) {
	    return;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  now = eat.now();
	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	
	  subvalue += flag;
	  flag = self.decode.raw(self.unescape(flag), now);
	
	  if (queue) {
	    subvalue += queue;
	  }
	
	  queue = '';
	  closing = '';
	  exdentedClosing = '';
	  content = '';
	  exdentedContent = '';
	
	  /* Eat content. */
	  while (index < length) {
	    character = value.charAt(index);
	    content += closing;
	    exdentedContent += exdentedClosing;
	    closing = '';
	    exdentedClosing = '';
	
	    if (character !== C_NEWLINE) {
	      content += character;
	      exdentedClosing += character;
	      index++;
	      continue;
	    }
	
	    /* Add the newline to `subvalue` if its the first
	     * character.  Otherwise, add it to the `closing`
	     * queue. */
	    if (content) {
	      closing += character;
	      exdentedClosing += character;
	    } else {
	      subvalue += character;
	    }
	
	    queue = '';
	    index++;
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character !== C_SPACE) {
	        break;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    closing += queue;
	    exdentedClosing += queue.slice(indent);
	
	    if (queue.length >= CODE_INDENT_COUNT) {
	      continue;
	    }
	
	    queue = '';
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character !== marker) {
	        break;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    closing += queue;
	    exdentedClosing += queue;
	
	    if (queue.length < fenceCount) {
	      continue;
	    }
	
	    queue = '';
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character !== C_SPACE && character !== C_TAB) {
	        break;
	      }
	
	      closing += character;
	      exdentedClosing += character;
	      index++;
	    }
	
	    if (!character || character === C_NEWLINE) {
	      break;
	    }
	  }
	
	  subvalue += content + closing;
	
	  return eat(subvalue)({
	    type: 'code',
	    lang: flag || null,
	    value: trim(exdentedContent)
	  });
	}


/***/ }),
/* 1001 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var repeat = __webpack_require__(202);
	var trim = __webpack_require__(204);
	
	module.exports = indentedCode;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	
	var CODE_INDENT_COUNT = 4;
	var CODE_INDENT = repeat(C_SPACE, CODE_INDENT_COUNT);
	
	/* Tokenise indented code. */
	function indentedCode(eat, value, silent) {
	  var index = -1;
	  var length = value.length;
	  var subvalue = '';
	  var content = '';
	  var subvalueQueue = '';
	  var contentQueue = '';
	  var character;
	  var blankQueue;
	  var indent;
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (indent) {
	      indent = false;
	
	      subvalue += subvalueQueue;
	      content += contentQueue;
	      subvalueQueue = '';
	      contentQueue = '';
	
	      if (character === C_NEWLINE) {
	        subvalueQueue = character;
	        contentQueue = character;
	      } else {
	        subvalue += character;
	        content += character;
	
	        while (++index < length) {
	          character = value.charAt(index);
	
	          if (!character || character === C_NEWLINE) {
	            contentQueue = character;
	            subvalueQueue = character;
	            break;
	          }
	
	          subvalue += character;
	          content += character;
	        }
	      }
	    } else if (
	      character === C_SPACE &&
	      value.charAt(index + 1) === character &&
	      value.charAt(index + 2) === character &&
	      value.charAt(index + 3) === character
	    ) {
	      subvalueQueue += CODE_INDENT;
	      index += 3;
	      indent = true;
	    } else if (character === C_TAB) {
	      subvalueQueue += character;
	      indent = true;
	    } else {
	      blankQueue = '';
	
	      while (character === C_TAB || character === C_SPACE) {
	        blankQueue += character;
	        character = value.charAt(++index);
	      }
	
	      if (character !== C_NEWLINE) {
	        break;
	      }
	
	      subvalueQueue += blankQueue + character;
	      contentQueue += character;
	    }
	  }
	
	  if (content) {
	    if (silent) {
	      return true;
	    }
	
	    return eat(subvalue)({
	      type: 'code',
	      lang: null,
	      value: trim(content)
	    });
	  }
	}


/***/ }),
/* 1002 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(988);
	
	module.exports = inlineCode;
	inlineCode.locator = locate;
	
	var C_TICK = '`';
	
	/* Tokenise inline code. */
	function inlineCode(eat, value, silent) {
	  var length = value.length;
	  var index = 0;
	  var queue = '';
	  var tickQueue = '';
	  var contentQueue;
	  var subqueue;
	  var count;
	  var openingCount;
	  var subvalue;
	  var character;
	  var found;
	  var next;
	
	  while (index < length) {
	    if (value.charAt(index) !== C_TICK) {
	      break;
	    }
	
	    queue += C_TICK;
	    index++;
	  }
	
	  if (!queue) {
	    return;
	  }
	
	  subvalue = queue;
	  openingCount = index;
	  queue = '';
	  next = value.charAt(index);
	  count = 0;
	
	  while (index < length) {
	    character = next;
	    next = value.charAt(index + 1);
	
	    if (character === C_TICK) {
	      count++;
	      tickQueue += character;
	    } else {
	      count = 0;
	      queue += character;
	    }
	
	    if (count && next !== C_TICK) {
	      if (count === openingCount) {
	        subvalue += queue + tickQueue;
	        found = true;
	        break;
	      }
	
	      queue += tickQueue;
	      tickQueue = '';
	    }
	
	    index++;
	  }
	
	  if (!found) {
	    if (openingCount % 2 !== 0) {
	      return;
	    }
	
	    queue = '';
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  contentQueue = '';
	  subqueue = '';
	  length = queue.length;
	  index = -1;
	
	  while (++index < length) {
	    character = queue.charAt(index);
	
	    if (whitespace(character)) {
	      subqueue += character;
	      continue;
	    }
	
	    if (subqueue) {
	      if (contentQueue) {
	        contentQueue += subqueue;
	      }
	
	      subqueue = '';
	    }
	
	    contentQueue += character;
	  }
	
	  return eat(subvalue)({
	    type: 'inlineCode',
	    value: contentQueue
	  });
	}


/***/ }),
/* 1003 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var normalize = __webpack_require__(201);
	
	module.exports = definition;
	definition.notInList = true;
	definition.notInBlock = true;
	
	var C_DOUBLE_QUOTE = '"';
	var C_SINGLE_QUOTE = '\'';
	var C_BACKSLASH = '\\';
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_BRACKET_OPEN = '[';
	var C_BRACKET_CLOSE = ']';
	var C_PAREN_OPEN = '(';
	var C_PAREN_CLOSE = ')';
	var C_COLON = ':';
	var C_LT = '<';
	var C_GT = '>';
	
	function definition(eat, value, silent) {
	  var self = this;
	  var commonmark = self.options.commonmark;
	  var index = 0;
	  var length = value.length;
	  var subvalue = '';
	  var beforeURL;
	  var beforeTitle;
	  var queue;
	  var character;
	  var test;
	  var identifier;
	  var url;
	  var title;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	
	  if (character !== C_BRACKET_OPEN) {
	    return;
	  }
	
	  index++;
	  subvalue += character;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character === C_BRACKET_CLOSE) {
	      break;
	    } else if (character === C_BACKSLASH) {
	      queue += character;
	      index++;
	      character = value.charAt(index);
	    }
	
	    queue += character;
	    index++;
	  }
	
	  if (
	    !queue ||
	    value.charAt(index) !== C_BRACKET_CLOSE ||
	    value.charAt(index + 1) !== C_COLON
	  ) {
	    return;
	  }
	
	  identifier = queue;
	  subvalue += queue + C_BRACKET_CLOSE + C_COLON;
	  index = subvalue.length;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (
	      character !== C_TAB &&
	      character !== C_SPACE &&
	      character !== C_NEWLINE
	    ) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	  queue = '';
	  beforeURL = subvalue;
	
	  if (character === C_LT) {
	    index++;
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (!isEnclosedURLCharacter(character)) {
	        break;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    character = value.charAt(index);
	
	    if (character === isEnclosedURLCharacter.delimiter) {
	      subvalue += C_LT + queue + character;
	      index++;
	    } else {
	      if (commonmark) {
	        return;
	      }
	
	      index -= queue.length + 1;
	      queue = '';
	    }
	  }
	
	  if (!queue) {
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (!isUnclosedURLCharacter(character)) {
	        break;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    subvalue += queue;
	  }
	
	  if (!queue) {
	    return;
	  }
	
	  url = queue;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (
	      character !== C_TAB &&
	      character !== C_SPACE &&
	      character !== C_NEWLINE
	    ) {
	      break;
	    }
	
	    queue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	  test = null;
	
	  if (character === C_DOUBLE_QUOTE) {
	    test = C_DOUBLE_QUOTE;
	  } else if (character === C_SINGLE_QUOTE) {
	    test = C_SINGLE_QUOTE;
	  } else if (character === C_PAREN_OPEN) {
	    test = C_PAREN_CLOSE;
	  }
	
	  if (!test) {
	    queue = '';
	    index = subvalue.length;
	  } else if (queue) {
	    subvalue += queue + character;
	    index = subvalue.length;
	    queue = '';
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character === test) {
	        break;
	      }
	
	      if (character === C_NEWLINE) {
	        index++;
	        character = value.charAt(index);
	
	        if (character === C_NEWLINE || character === test) {
	          return;
	        }
	
	        queue += C_NEWLINE;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    character = value.charAt(index);
	
	    if (character !== test) {
	      return;
	    }
	
	    beforeTitle = subvalue;
	    subvalue += queue + character;
	    index++;
	    title = queue;
	    queue = '';
	  } else {
	    return;
	  }
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_TAB && character !== C_SPACE) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	
	  if (!character || character === C_NEWLINE) {
	    if (silent) {
	      return true;
	    }
	
	    beforeURL = eat(beforeURL).test().end;
	    url = self.decode.raw(self.unescape(url), beforeURL);
	
	    if (title) {
	      beforeTitle = eat(beforeTitle).test().end;
	      title = self.decode.raw(self.unescape(title), beforeTitle);
	    }
	
	    return eat(subvalue)({
	      type: 'definition',
	      identifier: normalize(identifier),
	      title: title || null,
	      url: url
	    });
	  }
	}
	
	/* Check if `character` can be inside an enclosed URI. */
	function isEnclosedURLCharacter(character) {
	  return character !== C_GT &&
	    character !== C_BRACKET_OPEN &&
	    character !== C_BRACKET_CLOSE;
	}
	
	isEnclosedURLCharacter.delimiter = C_GT;
	
	/* Check if `character` can be inside an unclosed URI. */
	function isUnclosedURLCharacter(character) {
	  return character !== C_BRACKET_OPEN &&
	    character !== C_BRACKET_CLOSE &&
	    !whitespace(character);
	}


/***/ }),
/* 1004 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(989);
	
	module.exports = strikethrough;
	strikethrough.locator = locate;
	
	var C_TILDE = '~';
	var DOUBLE = '~~';
	
	function strikethrough(eat, value, silent) {
	  var self = this;
	  var character = '';
	  var previous = '';
	  var preceding = '';
	  var subvalue = '';
	  var index;
	  var length;
	  var now;
	
	  if (
	    !self.options.gfm ||
	    value.charAt(0) !== C_TILDE ||
	    value.charAt(1) !== C_TILDE ||
	    whitespace(value.charAt(2))
	  ) {
	    return;
	  }
	
	  index = 1;
	  length = value.length;
	  now = eat.now();
	  now.column += 2;
	  now.offset += 2;
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (
	      character === C_TILDE &&
	      previous === C_TILDE &&
	      (!preceding || !whitespace(preceding))
	    ) {
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true;
	      }
	
	      return eat(DOUBLE + subvalue + DOUBLE)({
	        type: 'delete',
	        children: self.tokenizeInline(subvalue, now)
	      });
	    }
	
	    subvalue += previous;
	    preceding = previous;
	    previous = character;
	  }
	}


/***/ }),
/* 1005 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	var word = __webpack_require__(641);
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(990);
	
	module.exports = emphasis;
	emphasis.locator = locate;
	
	var C_ASTERISK = '*';
	var C_UNDERSCORE = '_';
	
	function emphasis(eat, value, silent) {
	  var self = this;
	  var index = 0;
	  var character = value.charAt(index);
	  var now;
	  var pedantic;
	  var marker;
	  var queue;
	  var subvalue;
	  var length;
	  var prev;
	
	  if (character !== C_ASTERISK && character !== C_UNDERSCORE) {
	    return;
	  }
	
	  pedantic = self.options.pedantic;
	  subvalue = character;
	  marker = character;
	  length = value.length;
	  index++;
	  queue = '';
	  character = '';
	
	  if (pedantic && whitespace(value.charAt(index))) {
	    return;
	  }
	
	  while (index < length) {
	    prev = character;
	    character = value.charAt(index);
	
	    if (character === marker && (!pedantic || !whitespace(prev))) {
	      character = value.charAt(++index);
	
	      if (character !== marker) {
	        if (!trim(queue) || prev === marker) {
	          return;
	        }
	
	        if (!pedantic && marker === C_UNDERSCORE && word(character)) {
	          queue += marker;
	          continue;
	        }
	
	        /* istanbul ignore if - never used (yet) */
	        if (silent) {
	          return true;
	        }
	
	        now = eat.now();
	        now.column++;
	        now.offset++;
	
	        return eat(subvalue + queue + marker)({
	          type: 'emphasis',
	          children: self.tokenizeInline(queue, now)
	        });
	      }
	
	      queue += marker;
	    }
	
	    if (!pedantic && character === '\\') {
	      queue += character;
	      character = value.charAt(++index);
	    }
	
	    queue += character;
	    index++;
	  }
	}


/***/ }),
/* 1006 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var locate = __webpack_require__(991);
	
	module.exports = escape;
	escape.locator = locate;
	
	function escape(eat, value, silent) {
	  var self = this;
	  var character;
	  var node;
	
	  if (value.charAt(0) === '\\') {
	    character = value.charAt(1);
	
	    if (self.escape.indexOf(character) !== -1) {
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true;
	      }
	
	      if (character === '\n') {
	        node = {type: 'break'};
	      } else {
	        node = {
	          type: 'text',
	          value: character
	        };
	      }
	
	      return eat('\\' + character)(node);
	    }
	  }
	}


/***/ }),
/* 1007 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var normalize = __webpack_require__(201);
	
	module.exports = footnoteDefinition;
	footnoteDefinition.notInList = true;
	footnoteDefinition.notInBlock = true;
	
	var C_BACKSLASH = '\\';
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_BRACKET_OPEN = '[';
	var C_BRACKET_CLOSE = ']';
	var C_CARET = '^';
	var C_COLON = ':';
	
	var EXPRESSION_INITIAL_TAB = /^( {4}|\t)?/gm;
	
	function footnoteDefinition(eat, value, silent) {
	  var self = this;
	  var offsets = self.offset;
	  var index;
	  var length;
	  var subvalue;
	  var now;
	  var currentLine;
	  var content;
	  var queue;
	  var subqueue;
	  var character;
	  var identifier;
	  var add;
	  var exit;
	
	  if (!self.options.footnotes) {
	    return;
	  }
	
	  index = 0;
	  length = value.length;
	  subvalue = '';
	  now = eat.now();
	  currentLine = now.line;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (!whitespace(character)) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  if (
	    value.charAt(index) !== C_BRACKET_OPEN ||
	    value.charAt(index + 1) !== C_CARET
	  ) {
	    return;
	  }
	
	  subvalue += C_BRACKET_OPEN + C_CARET;
	  index = subvalue.length;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character === C_BRACKET_CLOSE) {
	      break;
	    } else if (character === C_BACKSLASH) {
	      queue += character;
	      index++;
	      character = value.charAt(index);
	    }
	
	    queue += character;
	    index++;
	  }
	
	  if (
	    !queue ||
	    value.charAt(index) !== C_BRACKET_CLOSE ||
	    value.charAt(index + 1) !== C_COLON
	  ) {
	    return;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  identifier = normalize(queue);
	  subvalue += queue + C_BRACKET_CLOSE + C_COLON;
	  index = subvalue.length;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_TAB && character !== C_SPACE) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	  queue = '';
	  content = '';
	  subqueue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character === C_NEWLINE) {
	      subqueue = character;
	      index++;
	
	      while (index < length) {
	        character = value.charAt(index);
	
	        if (character !== C_NEWLINE) {
	          break;
	        }
	
	        subqueue += character;
	        index++;
	      }
	
	      queue += subqueue;
	      subqueue = '';
	
	      while (index < length) {
	        character = value.charAt(index);
	
	        if (character !== C_SPACE) {
	          break;
	        }
	
	        subqueue += character;
	        index++;
	      }
	
	      if (subqueue.length === 0) {
	        break;
	      }
	
	      queue += subqueue;
	    }
	
	    if (queue) {
	      content += queue;
	      queue = '';
	    }
	
	    content += character;
	    index++;
	  }
	
	  subvalue += content;
	
	  content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {
	    offsets[currentLine] = (offsets[currentLine] || 0) + line.length;
	    currentLine++;
	
	    return '';
	  });
	
	  add = eat(subvalue);
	
	  exit = self.enterBlock();
	  content = self.tokenizeBlock(content, now);
	  exit();
	
	  return add({
	    type: 'footnoteDefinition',
	    identifier: identifier,
	    children: content
	  });
	}


/***/ }),
/* 1008 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = atxHeading;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_HASH = '#';
	
	var MAX_ATX_COUNT = 6;
	
	function atxHeading(eat, value, silent) {
	  var self = this;
	  var settings = self.options;
	  var length = value.length + 1;
	  var index = -1;
	  var now = eat.now();
	  var subvalue = '';
	  var content = '';
	  var character;
	  var queue;
	  var depth;
	
	  /* Eat initial spacing. */
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      index--;
	      break;
	    }
	
	    subvalue += character;
	  }
	
	  /* Eat hashes. */
	  depth = 0;
	
	  while (++index <= length) {
	    character = value.charAt(index);
	
	    if (character !== C_HASH) {
	      index--;
	      break;
	    }
	
	    subvalue += character;
	    depth++;
	  }
	
	  if (depth > MAX_ATX_COUNT) {
	    return;
	  }
	
	  if (
	    !depth ||
	    (!settings.pedantic && value.charAt(index + 1) === C_HASH)
	  ) {
	    return;
	  }
	
	  length = value.length + 1;
	
	  /* Eat intermediate white-space. */
	  queue = '';
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE && character !== C_TAB) {
	      index--;
	      break;
	    }
	
	    queue += character;
	  }
	
	  /* Exit when not in pedantic mode without spacing. */
	  if (
	    !settings.pedantic &&
	    queue.length === 0 &&
	    character &&
	    character !== C_NEWLINE
	  ) {
	    return;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  /* Eat content. */
	  subvalue += queue;
	  queue = '';
	  content = '';
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (!character || character === C_NEWLINE) {
	      break;
	    }
	
	    if (
	      character !== C_SPACE &&
	      character !== C_TAB &&
	      character !== C_HASH
	    ) {
	      content += queue + character;
	      queue = '';
	      continue;
	    }
	
	    while (character === C_SPACE || character === C_TAB) {
	      queue += character;
	      character = value.charAt(++index);
	    }
	
	    while (character === C_HASH) {
	      queue += character;
	      character = value.charAt(++index);
	    }
	
	    while (character === C_SPACE || character === C_TAB) {
	      queue += character;
	      character = value.charAt(++index);
	    }
	
	    index--;
	  }
	
	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	  subvalue += content + queue;
	
	  return eat(subvalue)({
	    type: 'heading',
	    depth: depth,
	    children: self.tokenizeInline(content, now)
	  });
	}


/***/ }),
/* 1009 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = setextHeading;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_EQUALS = '=';
	var C_DASH = '-';
	
	var MAX_HEADING_INDENT = 3;
	
	/* Map of characters which can be used to mark setext
	 * headers, mapping to their corresponding depth. */
	var SETEXT_MARKERS = {};
	
	SETEXT_MARKERS[C_EQUALS] = 1;
	SETEXT_MARKERS[C_DASH] = 2;
	
	function setextHeading(eat, value, silent) {
	  var self = this;
	  var now = eat.now();
	  var length = value.length;
	  var index = -1;
	  var subvalue = '';
	  var content;
	  var queue;
	  var character;
	  var marker;
	  var depth;
	
	  /* Eat initial indentation. */
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {
	      index--;
	      break;
	    }
	
	    subvalue += character;
	  }
	
	  /* Eat content. */
	  content = '';
	  queue = '';
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character === C_NEWLINE) {
	      index--;
	      break;
	    }
	
	    if (character === C_SPACE || character === C_TAB) {
	      queue += character;
	    } else {
	      content += queue + character;
	      queue = '';
	    }
	  }
	
	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	  subvalue += content + queue;
	
	  /* Ensure the content is followed by a newline and a
	   * valid marker. */
	  character = value.charAt(++index);
	  marker = value.charAt(++index);
	
	  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {
	    return;
	  }
	
	  subvalue += character;
	
	  /* Eat Setext-line. */
	  queue = marker;
	  depth = SETEXT_MARKERS[marker];
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character !== marker) {
	      if (character !== C_NEWLINE) {
	        return;
	      }
	
	      index--;
	      break;
	    }
	
	    queue += character;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  return eat(subvalue + queue)({
	    type: 'heading',
	    depth: depth,
	    children: self.tokenizeInline(content, now)
	  });
	}


/***/ }),
/* 1010 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var openCloseTag = __webpack_require__(357).openCloseTag;
	
	module.exports = blockHTML;
	
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_NEWLINE = '\n';
	var C_LT = '<';
	
	function blockHTML(eat, value, silent) {
	  var self = this;
	  var blocks = self.options.blocks;
	  var length = value.length;
	  var index = 0;
	  var next;
	  var line;
	  var offset;
	  var character;
	  var count;
	  var sequence;
	  var subvalue;
	
	  var sequences = [
	    [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
	    [/^<!--/, /-->/, true],
	    [/^<\?/, /\?>/, true],
	    [/^<![A-Za-z]/, />/, true],
	    [/^<!\[CDATA\[/, /\]\]>/, true],
	    [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true],
	    [new RegExp(openCloseTag.source + '\\s*$'), /^$/, false]
	  ];
	
	  /* Eat initial spacing. */
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_TAB && character !== C_SPACE) {
	      break;
	    }
	
	    index++;
	  }
	
	  if (value.charAt(index) !== C_LT) {
	    return;
	  }
	
	  next = value.indexOf(C_NEWLINE, index + 1);
	  next = next === -1 ? length : next;
	  line = value.slice(index, next);
	  offset = -1;
	  count = sequences.length;
	
	  while (++offset < count) {
	    if (sequences[offset][0].test(line)) {
	      sequence = sequences[offset];
	      break;
	    }
	  }
	
	  if (!sequence) {
	    return;
	  }
	
	  if (silent) {
	    return sequence[2];
	  }
	
	  index = next;
	
	  if (!sequence[1].test(line)) {
	    while (index < length) {
	      next = value.indexOf(C_NEWLINE, index + 1);
	      next = next === -1 ? length : next;
	      line = value.slice(index + 1, next);
	
	      if (sequence[1].test(line)) {
	        if (line) {
	          index = next;
	        }
	
	        break;
	      }
	
	      index = next;
	    }
	  }
	
	  subvalue = value.slice(0, index);
	
	  return eat(subvalue)({type: 'html', value: subvalue});
	}


/***/ }),
/* 1011 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var alphabetical = __webpack_require__(295);
	var locate = __webpack_require__(355);
	var tag = __webpack_require__(357).tag;
	
	module.exports = inlineHTML;
	inlineHTML.locator = locate;
	
	var EXPRESSION_HTML_LINK_OPEN = /^<a /i;
	var EXPRESSION_HTML_LINK_CLOSE = /^<\/a>/i;
	
	function inlineHTML(eat, value, silent) {
	  var self = this;
	  var length = value.length;
	  var character;
	  var subvalue;
	
	  if (value.charAt(0) !== '<' || length < 3) {
	    return;
	  }
	
	  character = value.charAt(1);
	
	  if (
	    !alphabetical(character) &&
	    character !== '?' &&
	    character !== '!' &&
	    character !== '/'
	  ) {
	    return;
	  }
	
	  subvalue = value.match(tag);
	
	  if (!subvalue) {
	    return;
	  }
	
	  /* istanbul ignore if - not used yet. */
	  if (silent) {
	    return true;
	  }
	
	  subvalue = subvalue[0];
	
	  if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {
	    self.inLink = true;
	  } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {
	    self.inLink = false;
	  }
	
	  return eat(subvalue)({type: 'html', value: subvalue});
	}


/***/ }),
/* 1012 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(354);
	
	module.exports = link;
	link.locator = locate;
	
	var own = {}.hasOwnProperty;
	
	var C_BACKSLASH = '\\';
	var C_BRACKET_OPEN = '[';
	var C_BRACKET_CLOSE = ']';
	var C_PAREN_OPEN = '(';
	var C_PAREN_CLOSE = ')';
	var C_LT = '<';
	var C_GT = '>';
	var C_TICK = '`';
	var C_DOUBLE_QUOTE = '"';
	var C_SINGLE_QUOTE = '\'';
	
	/* Map of characters, which can be used to mark link
	 * and image titles. */
	var LINK_MARKERS = {};
	
	LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
	LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;
	
	/* Map of characters, which can be used to mark link
	 * and image titles in commonmark-mode. */
	var COMMONMARK_LINK_MARKERS = {};
	
	COMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
	COMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;
	COMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;
	
	function link(eat, value, silent) {
	  var self = this;
	  var subvalue = '';
	  var index = 0;
	  var character = value.charAt(0);
	  var pedantic = self.options.pedantic;
	  var commonmark = self.options.commonmark;
	  var gfm = self.options.gfm;
	  var closed;
	  var count;
	  var opening;
	  var beforeURL;
	  var beforeTitle;
	  var subqueue;
	  var hasMarker;
	  var markers;
	  var isImage;
	  var content;
	  var marker;
	  var length;
	  var title;
	  var depth;
	  var queue;
	  var url;
	  var now;
	  var exit;
	  var node;
	
	  /* Detect whether this is an image. */
	  if (character === '!') {
	    isImage = true;
	    subvalue = character;
	    character = value.charAt(++index);
	  }
	
	  /* Eat the opening. */
	  if (character !== C_BRACKET_OPEN) {
	    return;
	  }
	
	  /* Exit when this is a link and we’re already inside
	   * a link. */
	  if (!isImage && self.inLink) {
	    return;
	  }
	
	  subvalue += character;
	  queue = '';
	  index++;
	
	  /* Eat the content. */
	  length = value.length;
	  now = eat.now();
	  depth = 0;
	
	  now.column += index;
	  now.offset += index;
	
	  while (index < length) {
	    character = value.charAt(index);
	    subqueue = character;
	
	    if (character === C_TICK) {
	      /* Inline-code in link content. */
	      count = 1;
	
	      while (value.charAt(index + 1) === C_TICK) {
	        subqueue += character;
	        index++;
	        count++;
	      }
	
	      if (!opening) {
	        opening = count;
	      } else if (count >= opening) {
	        opening = 0;
	      }
	    } else if (character === C_BACKSLASH) {
	      /* Allow brackets to be escaped. */
	      index++;
	      subqueue += value.charAt(index);
	    /* In GFM mode, brackets in code still count.
	     * In all other modes, they don’t.  This empty
	     * block prevents the next statements are
	     * entered. */
	    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {
	      depth++;
	    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {
	      if (depth) {
	        depth--;
	      } else {
	        /* Allow white-space between content and
	         * url in GFM mode. */
	        if (!pedantic) {
	          while (index < length) {
	            character = value.charAt(index + 1);
	
	            if (!whitespace(character)) {
	              break;
	            }
	
	            subqueue += character;
	            index++;
	          }
	        }
	
	        if (value.charAt(index + 1) !== C_PAREN_OPEN) {
	          return;
	        }
	
	        subqueue += C_PAREN_OPEN;
	        closed = true;
	        index++;
	
	        break;
	      }
	    }
	
	    queue += subqueue;
	    subqueue = '';
	    index++;
	  }
	
	  /* Eat the content closing. */
	  if (!closed) {
	    return;
	  }
	
	  content = queue;
	  subvalue += queue + subqueue;
	  index++;
	
	  /* Eat white-space. */
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (!whitespace(character)) {
	      break;
	    }
	
	    subvalue += character;
	    index++;
	  }
	
	  /* Eat the URL. */
	  character = value.charAt(index);
	  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;
	  queue = '';
	  beforeURL = subvalue;
	
	  if (character === C_LT) {
	    index++;
	    beforeURL += C_LT;
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character === C_GT) {
	        break;
	      }
	
	      if (commonmark && character === '\n') {
	        return;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    if (value.charAt(index) !== C_GT) {
	      return;
	    }
	
	    subvalue += C_LT + queue + C_GT;
	    url = queue;
	    index++;
	  } else {
	    character = null;
	    subqueue = '';
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (subqueue && own.call(markers, character)) {
	        break;
	      }
	
	      if (whitespace(character)) {
	        if (!pedantic) {
	          break;
	        }
	
	        subqueue += character;
	      } else {
	        if (character === C_PAREN_OPEN) {
	          depth++;
	        } else if (character === C_PAREN_CLOSE) {
	          if (depth === 0) {
	            break;
	          }
	
	          depth--;
	        }
	
	        queue += subqueue;
	        subqueue = '';
	
	        if (character === C_BACKSLASH) {
	          queue += C_BACKSLASH;
	          character = value.charAt(++index);
	        }
	
	        queue += character;
	      }
	
	      index++;
	    }
	
	    subvalue += queue;
	    url = queue;
	    index = subvalue.length;
	  }
	
	  /* Eat white-space. */
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (!whitespace(character)) {
	      break;
	    }
	
	    queue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	  subvalue += queue;
	
	  /* Eat the title. */
	  if (queue && own.call(markers, character)) {
	    index++;
	    subvalue += character;
	    queue = '';
	    marker = markers[character];
	    beforeTitle = subvalue;
	
	    /* In commonmark-mode, things are pretty easy: the
	     * marker cannot occur inside the title.
	     *
	     * Non-commonmark does, however, support nested
	     * delimiters. */
	    if (commonmark) {
	      while (index < length) {
	        character = value.charAt(index);
	
	        if (character === marker) {
	          break;
	        }
	
	        if (character === C_BACKSLASH) {
	          queue += C_BACKSLASH;
	          character = value.charAt(++index);
	        }
	
	        index++;
	        queue += character;
	      }
	
	      character = value.charAt(index);
	
	      if (character !== marker) {
	        return;
	      }
	
	      title = queue;
	      subvalue += queue + character;
	      index++;
	
	      while (index < length) {
	        character = value.charAt(index);
	
	        if (!whitespace(character)) {
	          break;
	        }
	
	        subvalue += character;
	        index++;
	      }
	    } else {
	      subqueue = '';
	
	      while (index < length) {
	        character = value.charAt(index);
	
	        if (character === marker) {
	          if (hasMarker) {
	            queue += marker + subqueue;
	            subqueue = '';
	          }
	
	          hasMarker = true;
	        } else if (!hasMarker) {
	          queue += character;
	        } else if (character === C_PAREN_CLOSE) {
	          subvalue += queue + marker + subqueue;
	          title = queue;
	          break;
	        } else if (whitespace(character)) {
	          subqueue += character;
	        } else {
	          queue += marker + subqueue + character;
	          subqueue = '';
	          hasMarker = false;
	        }
	
	        index++;
	      }
	    }
	  }
	
	  if (value.charAt(index) !== C_PAREN_CLOSE) {
	    return;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  subvalue += C_PAREN_CLOSE;
	
	  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end);
	
	  if (title) {
	    beforeTitle = eat(beforeTitle).test().end;
	    title = self.decode.raw(self.unescape(title), beforeTitle);
	  }
	
	  node = {
	    type: isImage ? 'image' : 'link',
	    title: title || null,
	    url: url
	  };
	
	  if (isImage) {
	    node.alt = self.decode.raw(self.unescape(content), now) || null;
	  } else {
	    exit = self.enterLink();
	    node.children = self.tokenizeInline(content, now);
	    exit();
	  }
	
	  return eat(subvalue)(node);
	}


/***/ }),
/* 1013 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* eslint-disable max-params */
	
	var trim = __webpack_require__(43);
	var repeat = __webpack_require__(202);
	var decimal = __webpack_require__(113);
	var getIndent = __webpack_require__(356);
	var removeIndent = __webpack_require__(1024);
	var interrupt = __webpack_require__(200);
	
	module.exports = list;
	
	var C_ASTERISK = '*';
	var C_UNDERSCORE = '_';
	var C_PLUS = '+';
	var C_DASH = '-';
	var C_DOT = '.';
	var C_SPACE = ' ';
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_PAREN_CLOSE = ')';
	var C_X_LOWER = 'x';
	
	var TAB_SIZE = 4;
	var EXPRESSION_LOOSE_LIST_ITEM = /\n\n(?!\s*$)/;
	var EXPRESSION_TASK_ITEM = /^\[([ \t]|x|X)][ \t]/;
	var EXPRESSION_BULLET = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
	var EXPRESSION_PEDANTIC_BULLET = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
	var EXPRESSION_INITIAL_INDENT = /^( {1,4}|\t)?/gm;
	
	/* Map of characters which can be used to mark
	 * list-items. */
	var LIST_UNORDERED_MARKERS = {};
	
	LIST_UNORDERED_MARKERS[C_ASTERISK] = true;
	LIST_UNORDERED_MARKERS[C_PLUS] = true;
	LIST_UNORDERED_MARKERS[C_DASH] = true;
	
	/* Map of characters which can be used to mark
	 * list-items after a digit. */
	var LIST_ORDERED_MARKERS = {};
	
	LIST_ORDERED_MARKERS[C_DOT] = true;
	
	/* Map of characters which can be used to mark
	 * list-items after a digit. */
	var LIST_ORDERED_COMMONMARK_MARKERS = {};
	
	LIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;
	LIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;
	
	function list(eat, value, silent) {
	  var self = this;
	  var commonmark = self.options.commonmark;
	  var pedantic = self.options.pedantic;
	  var tokenizers = self.blockTokenizers;
	  var interuptors = self.interruptList;
	  var markers;
	  var index = 0;
	  var length = value.length;
	  var start = null;
	  var size = 0;
	  var queue;
	  var ordered;
	  var character;
	  var marker;
	  var nextIndex;
	  var startIndex;
	  var prefixed;
	  var currentMarker;
	  var content;
	  var line;
	  var prevEmpty;
	  var empty;
	  var items;
	  var allLines;
	  var emptyLines;
	  var item;
	  var enterTop;
	  var exitBlockquote;
	  var isLoose;
	  var node;
	  var now;
	  var end;
	  var indented;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character === C_TAB) {
	      size += TAB_SIZE - (size % TAB_SIZE);
	    } else if (character === C_SPACE) {
	      size++;
	    } else {
	      break;
	    }
	
	    index++;
	  }
	
	  if (size >= TAB_SIZE) {
	    return;
	  }
	
	  character = value.charAt(index);
	
	  markers = commonmark ?
	    LIST_ORDERED_COMMONMARK_MARKERS :
	    LIST_ORDERED_MARKERS;
	
	  if (LIST_UNORDERED_MARKERS[character] === true) {
	    marker = character;
	    ordered = false;
	  } else {
	    ordered = true;
	    queue = '';
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (!decimal(character)) {
	        break;
	      }
	
	      queue += character;
	      index++;
	    }
	
	    character = value.charAt(index);
	
	    if (!queue || markers[character] !== true) {
	      return;
	    }
	
	    start = parseInt(queue, 10);
	    marker = character;
	  }
	
	  character = value.charAt(++index);
	
	  if (character !== C_SPACE && character !== C_TAB) {
	    return;
	  }
	
	  if (silent) {
	    return true;
	  }
	
	  index = 0;
	  items = [];
	  allLines = [];
	  emptyLines = [];
	
	  while (index < length) {
	    nextIndex = value.indexOf(C_NEWLINE, index);
	    startIndex = index;
	    prefixed = false;
	    indented = false;
	
	    if (nextIndex === -1) {
	      nextIndex = length;
	    }
	
	    end = index + TAB_SIZE;
	    size = 0;
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character === C_TAB) {
	        size += TAB_SIZE - (size % TAB_SIZE);
	      } else if (character === C_SPACE) {
	        size++;
	      } else {
	        break;
	      }
	
	      index++;
	    }
	
	    if (size >= TAB_SIZE) {
	      indented = true;
	    }
	
	    if (item && size >= item.indent) {
	      indented = true;
	    }
	
	    character = value.charAt(index);
	    currentMarker = null;
	
	    if (!indented) {
	      if (LIST_UNORDERED_MARKERS[character] === true) {
	        currentMarker = character;
	        index++;
	        size++;
	      } else {
	        queue = '';
	
	        while (index < length) {
	          character = value.charAt(index);
	
	          if (!decimal(character)) {
	            break;
	          }
	
	          queue += character;
	          index++;
	        }
	
	        character = value.charAt(index);
	        index++;
	
	        if (queue && markers[character] === true) {
	          currentMarker = character;
	          size += queue.length + 1;
	        }
	      }
	
	      if (currentMarker) {
	        character = value.charAt(index);
	
	        if (character === C_TAB) {
	          size += TAB_SIZE - (size % TAB_SIZE);
	          index++;
	        } else if (character === C_SPACE) {
	          end = index + TAB_SIZE;
	
	          while (index < end) {
	            if (value.charAt(index) !== C_SPACE) {
	              break;
	            }
	
	            index++;
	            size++;
	          }
	
	          if (index === end && value.charAt(index) === C_SPACE) {
	            index -= TAB_SIZE - 1;
	            size -= TAB_SIZE - 1;
	          }
	        } else if (character !== C_NEWLINE && character !== '') {
	          currentMarker = null;
	        }
	      }
	    }
	
	    if (currentMarker) {
	      if (!pedantic && marker !== currentMarker) {
	        break;
	      }
	
	      prefixed = true;
	    } else {
	      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {
	        indented = true;
	      } else if (commonmark && item) {
	        indented = size >= item.indent || size > TAB_SIZE;
	      }
	
	      prefixed = false;
	      index = startIndex;
	    }
	
	    line = value.slice(startIndex, nextIndex);
	    content = startIndex === index ? line : value.slice(index, nextIndex);
	
	    if (
	      currentMarker === C_ASTERISK ||
	      currentMarker === C_UNDERSCORE ||
	      currentMarker === C_DASH
	    ) {
	      if (tokenizers.thematicBreak.call(self, eat, line, true)) {
	        break;
	      }
	    }
	
	    prevEmpty = empty;
	    empty = !trim(content).length;
	
	    if (indented && item) {
	      item.value = item.value.concat(emptyLines, line);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    } else if (prefixed) {
	      if (emptyLines.length !== 0) {
	        item.value.push('');
	        item.trail = emptyLines.concat();
	      }
	
	      item = {
	        value: [line],
	        indent: size,
	        trail: []
	      };
	
	      items.push(item);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    } else if (empty) {
	      if (prevEmpty) {
	        break;
	      }
	
	      emptyLines.push(line);
	    } else {
	      if (prevEmpty) {
	        break;
	      }
	
	      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {
	        break;
	      }
	
	      item.value = item.value.concat(emptyLines, line);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    }
	
	    index = nextIndex + 1;
	  }
	
	  node = eat(allLines.join(C_NEWLINE)).reset({
	    type: 'list',
	    ordered: ordered,
	    start: start,
	    loose: null,
	    children: []
	  });
	
	  enterTop = self.enterList();
	  exitBlockquote = self.enterBlock();
	  isLoose = false;
	  index = -1;
	  length = items.length;
	
	  while (++index < length) {
	    item = items[index].value.join(C_NEWLINE);
	    now = eat.now();
	
	    item = eat(item)(listItem(self, item, now), node);
	
	    if (item.loose) {
	      isLoose = true;
	    }
	
	    item = items[index].trail.join(C_NEWLINE);
	
	    if (index !== length - 1) {
	      item += C_NEWLINE;
	    }
	
	    eat(item);
	  }
	
	  enterTop();
	  exitBlockquote();
	
	  node.loose = isLoose;
	
	  return node;
	}
	
	function listItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
	  var checked = null;
	  var task;
	  var indent;
	
	  value = fn.apply(null, arguments);
	
	  if (ctx.options.gfm) {
	    task = value.match(EXPRESSION_TASK_ITEM);
	
	    if (task) {
	      indent = task[0].length;
	      checked = task[1].toLowerCase() === C_X_LOWER;
	      offsets[position.line] += indent;
	      value = value.slice(indent);
	    }
	  }
	
	  return {
	    type: 'listItem',
	    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||
	      value.charAt(value.length - 1) === C_NEWLINE,
	    checked: checked,
	    children: ctx.tokenizeBlock(value, position)
	  };
	}
	
	/* Create a list-item using overly simple mechanics. */
	function pedanticListItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var line = position.line;
	
	  /* Remove the list-item’s bullet. */
	  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);
	
	  /* The initial line was also matched by the below, so
	   * we reset the `line`. */
	  line = position.line;
	
	  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);
	
	  /* A simple replacer which removed all matches,
	   * and adds their length to `offset`. */
	  function replacer($0) {
	    offsets[line] = (offsets[line] || 0) + $0.length;
	    line++;
	
	    return '';
	  }
	}
	
	/* Create a list-item using sane mechanics. */
	function normalListItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var line = position.line;
	  var max;
	  var bullet;
	  var rest;
	  var lines;
	  var trimmedLines;
	  var index;
	  var length;
	
	  /* Remove the list-item’s bullet. */
	  value = value.replace(EXPRESSION_BULLET, replacer);
	
	  lines = value.split(C_NEWLINE);
	
	  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);
	
	  /* We replaced the initial bullet with something
	   * else above, which was used to trick
	   * `removeIndentation` into removing some more
	   * characters when possible.  However, that could
	   * result in the initial line to be stripped more
	   * than it should be. */
	  trimmedLines[0] = rest;
	
	  offsets[line] = (offsets[line] || 0) + bullet.length;
	  line++;
	
	  index = 0;
	  length = lines.length;
	
	  while (++index < length) {
	    offsets[line] = (offsets[line] || 0) +
	      lines[index].length - trimmedLines[index].length;
	    line++;
	  }
	
	  return trimmedLines.join(C_NEWLINE);
	
	  function replacer($0, $1, $2, $3, $4) {
	    bullet = $1 + $2 + $3;
	    rest = $4;
	
	    /* Make sure that the first nine numbered list items
	     * can indent with an extra space.  That is, when
	     * the bullet did not receive an extra final space. */
	    if (Number($2) < 10 && bullet.length % 2 === 1) {
	      $2 = C_SPACE + $2;
	    }
	
	    max = $1 + repeat(C_SPACE, $2.length) + $3;
	
	    return max + rest;
	  }
	}


/***/ }),
/* 1014 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	
	module.exports = newline;
	
	/* Tokenise newline. */
	function newline(eat, value, silent) {
	  var character = value.charAt(0);
	  var length;
	  var subvalue;
	  var queue;
	  var index;
	
	  if (character !== '\n') {
	    return;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  index = 1;
	  length = value.length;
	  subvalue = character;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (!whitespace(character)) {
	      break;
	    }
	
	    queue += character;
	
	    if (character === '\n') {
	      subvalue += queue;
	      queue = '';
	    }
	
	    index++;
	  }
	
	  eat(subvalue);
	}


/***/ }),
/* 1015 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	var decimal = __webpack_require__(113);
	var trimTrailingLines = __webpack_require__(204);
	var interrupt = __webpack_require__(200);
	
	module.exports = paragraph;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	
	var TAB_SIZE = 4;
	
	/* Tokenise paragraph. */
	function paragraph(eat, value, silent) {
	  var self = this;
	  var settings = self.options;
	  var commonmark = settings.commonmark;
	  var gfm = settings.gfm;
	  var tokenizers = self.blockTokenizers;
	  var interruptors = self.interruptParagraph;
	  var index = value.indexOf(C_NEWLINE);
	  var length = value.length;
	  var position;
	  var subvalue;
	  var character;
	  var size;
	  var now;
	
	  while (index < length) {
	    /* Eat everything if there’s no following newline. */
	    if (index === -1) {
	      index = length;
	      break;
	    }
	
	    /* Stop if the next character is NEWLINE. */
	    if (value.charAt(index + 1) === C_NEWLINE) {
	      break;
	    }
	
	    /* In commonmark-mode, following indented lines
	     * are part of the paragraph. */
	    if (commonmark) {
	      size = 0;
	      position = index + 1;
	
	      while (position < length) {
	        character = value.charAt(position);
	
	        if (character === C_TAB) {
	          size = TAB_SIZE;
	          break;
	        } else if (character === C_SPACE) {
	          size++;
	        } else {
	          break;
	        }
	
	        position++;
	      }
	
	      if (size >= TAB_SIZE) {
	        index = value.indexOf(C_NEWLINE, index + 1);
	        continue;
	      }
	    }
	
	    subvalue = value.slice(index + 1);
	
	    /* Check if the following code contains a possible
	     * block. */
	    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {
	      break;
	    }
	
	    /* Break if the following line starts a list, when
	     * already in a list, or when in commonmark, or when
	     * in gfm mode and the bullet is *not* numeric. */
	    if (
	      tokenizers.list.call(self, eat, subvalue, true) &&
	      (
	        self.inList ||
	        commonmark ||
	        (gfm && !decimal(trim.left(subvalue).charAt(0)))
	      )
	    ) {
	      break;
	    }
	
	    position = index;
	    index = value.indexOf(C_NEWLINE, index + 1);
	
	    if (index !== -1 && trim(value.slice(position, index)) === '') {
	      index = position;
	      break;
	    }
	  }
	
	  subvalue = value.slice(0, index);
	
	  if (trim(subvalue) === '') {
	    eat(subvalue);
	
	    return null;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  now = eat.now();
	  subvalue = trimTrailingLines(subvalue);
	
	  return eat(subvalue)({
	    type: 'paragraph',
	    children: self.tokenizeInline(subvalue, now)
	  });
	}


/***/ }),
/* 1016 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(354);
	var normalize = __webpack_require__(201);
	
	module.exports = reference;
	reference.locator = locate;
	
	var T_LINK = 'link';
	var T_IMAGE = 'image';
	var T_FOOTNOTE = 'footnote';
	var REFERENCE_TYPE_SHORTCUT = 'shortcut';
	var REFERENCE_TYPE_COLLAPSED = 'collapsed';
	var REFERENCE_TYPE_FULL = 'full';
	var C_CARET = '^';
	var C_BACKSLASH = '\\';
	var C_BRACKET_OPEN = '[';
	var C_BRACKET_CLOSE = ']';
	
	function reference(eat, value, silent) {
	  var self = this;
	  var character = value.charAt(0);
	  var index = 0;
	  var length = value.length;
	  var subvalue = '';
	  var intro = '';
	  var type = T_LINK;
	  var referenceType = REFERENCE_TYPE_SHORTCUT;
	  var content;
	  var identifier;
	  var now;
	  var node;
	  var exit;
	  var queue;
	  var bracketed;
	  var depth;
	
	  /* Check whether we’re eating an image. */
	  if (character === '!') {
	    type = T_IMAGE;
	    intro = character;
	    character = value.charAt(++index);
	  }
	
	  if (character !== C_BRACKET_OPEN) {
	    return;
	  }
	
	  index++;
	  intro += character;
	  queue = '';
	
	  /* Check whether we’re eating a footnote. */
	  if (
	    self.options.footnotes &&
	    type === T_LINK &&
	    value.charAt(index) === C_CARET
	  ) {
	    intro += C_CARET;
	    index++;
	    type = T_FOOTNOTE;
	  }
	
	  /* Eat the text. */
	  depth = 0;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (character === C_BRACKET_OPEN) {
	      bracketed = true;
	      depth++;
	    } else if (character === C_BRACKET_CLOSE) {
	      if (!depth) {
	        break;
	      }
	
	      depth--;
	    }
	
	    if (character === C_BACKSLASH) {
	      queue += C_BACKSLASH;
	      character = value.charAt(++index);
	    }
	
	    queue += character;
	    index++;
	  }
	
	  subvalue = queue;
	  content = queue;
	  character = value.charAt(index);
	
	  if (character !== C_BRACKET_CLOSE) {
	    return;
	  }
	
	  index++;
	  subvalue += character;
	  queue = '';
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (!whitespace(character)) {
	      break;
	    }
	
	    queue += character;
	    index++;
	  }
	
	  character = value.charAt(index);
	
	  /* Inline footnotes cannot have an identifier. */
	  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {
	    identifier = '';
	    queue += character;
	    index++;
	
	    while (index < length) {
	      character = value.charAt(index);
	
	      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {
	        break;
	      }
	
	      if (character === C_BACKSLASH) {
	        identifier += C_BACKSLASH;
	        character = value.charAt(++index);
	      }
	
	      identifier += character;
	      index++;
	    }
	
	    character = value.charAt(index);
	
	    if (character === C_BRACKET_CLOSE) {
	      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;
	      queue += identifier + character;
	      index++;
	    } else {
	      identifier = '';
	    }
	
	    subvalue += queue;
	    queue = '';
	  } else {
	    if (!content) {
	      return;
	    }
	
	    identifier = content;
	  }
	
	  /* Brackets cannot be inside the identifier. */
	  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {
	    return;
	  }
	
	  subvalue = intro + subvalue;
	
	  if (type === T_LINK && self.inLink) {
	    return null;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {
	    return eat(subvalue)({
	      type: 'footnote',
	      children: this.tokenizeInline(content, eat.now())
	    });
	  }
	
	  now = eat.now();
	  now.column += intro.length;
	  now.offset += intro.length;
	  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;
	
	  node = {
	    type: type + 'Reference',
	    identifier: normalize(identifier)
	  };
	
	  if (type === T_LINK || type === T_IMAGE) {
	    node.referenceType = referenceType;
	  }
	
	  if (type === T_LINK) {
	    exit = self.enterLink();
	    node.children = self.tokenizeInline(content, now);
	    exit();
	  } else if (type === T_IMAGE) {
	    node.alt = self.decode.raw(self.unescape(content), now) || null;
	  }
	
	  return eat(subvalue)(node);
	}


/***/ }),
/* 1017 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(992);
	
	module.exports = strong;
	strong.locator = locate;
	
	var C_ASTERISK = '*';
	var C_UNDERSCORE = '_';
	
	function strong(eat, value, silent) {
	  var self = this;
	  var index = 0;
	  var character = value.charAt(index);
	  var now;
	  var pedantic;
	  var marker;
	  var queue;
	  var subvalue;
	  var length;
	  var prev;
	
	  if (
	    (character !== C_ASTERISK && character !== C_UNDERSCORE) ||
	    value.charAt(++index) !== character
	  ) {
	    return;
	  }
	
	  pedantic = self.options.pedantic;
	  marker = character;
	  subvalue = marker + marker;
	  length = value.length;
	  index++;
	  queue = '';
	  character = '';
	
	  if (pedantic && whitespace(value.charAt(index))) {
	    return;
	  }
	
	  while (index < length) {
	    prev = character;
	    character = value.charAt(index);
	
	    if (
	      character === marker &&
	      value.charAt(index + 1) === marker &&
	      (!pedantic || !whitespace(prev))
	    ) {
	      character = value.charAt(index + 2);
	
	      if (character !== marker) {
	        if (!trim(queue)) {
	          return;
	        }
	
	        /* istanbul ignore if - never used (yet) */
	        if (silent) {
	          return true;
	        }
	
	        now = eat.now();
	        now.column += 2;
	        now.offset += 2;
	
	        return eat(subvalue + queue + subvalue)({
	          type: 'strong',
	          children: self.tokenizeInline(queue, now)
	        });
	      }
	    }
	
	    if (!pedantic && character === '\\') {
	      queue += character;
	      character = value.charAt(++index);
	    }
	
	    queue += character;
	    index++;
	  }
	}


/***/ }),
/* 1018 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var whitespace = __webpack_require__(25);
	
	module.exports = table;
	
	var C_BACKSLASH = '\\';
	var C_TICK = '`';
	var C_DASH = '-';
	var C_PIPE = '|';
	var C_COLON = ':';
	var C_SPACE = ' ';
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	
	var MIN_TABLE_COLUMNS = 1;
	var MIN_TABLE_ROWS = 2;
	
	var TABLE_ALIGN_LEFT = 'left';
	var TABLE_ALIGN_CENTER = 'center';
	var TABLE_ALIGN_RIGHT = 'right';
	var TABLE_ALIGN_NONE = null;
	
	function table(eat, value, silent) {
	  var self = this;
	  var index;
	  var alignments;
	  var alignment;
	  var subvalue;
	  var row;
	  var length;
	  var lines;
	  var queue;
	  var character;
	  var hasDash;
	  var align;
	  var cell;
	  var preamble;
	  var count;
	  var opening;
	  var now;
	  var position;
	  var lineCount;
	  var line;
	  var rows;
	  var table;
	  var lineIndex;
	  var pipeIndex;
	  var first;
	
	  /* Exit when not in gfm-mode. */
	  if (!self.options.gfm) {
	    return;
	  }
	
	  /* Get the rows.
	   * Detecting tables soon is hard, so there are some
	   * checks for performance here, such as the minimum
	   * number of rows, and allowed characters in the
	   * alignment row. */
	  index = 0;
	  lineCount = 0;
	  length = value.length + 1;
	  lines = [];
	
	  while (index < length) {
	    lineIndex = value.indexOf(C_NEWLINE, index);
	    pipeIndex = value.indexOf(C_PIPE, index + 1);
	
	    if (lineIndex === -1) {
	      lineIndex = value.length;
	    }
	
	    if (pipeIndex === -1 || pipeIndex > lineIndex) {
	      if (lineCount < MIN_TABLE_ROWS) {
	        return;
	      }
	
	      break;
	    }
	
	    lines.push(value.slice(index, lineIndex));
	    lineCount++;
	    index = lineIndex + 1;
	  }
	
	  /* Parse the alignment row. */
	  subvalue = lines.join(C_NEWLINE);
	  alignments = lines.splice(1, 1)[0] || [];
	  index = 0;
	  length = alignments.length;
	  lineCount--;
	  alignment = false;
	  align = [];
	
	  while (index < length) {
	    character = alignments.charAt(index);
	
	    if (character === C_PIPE) {
	      hasDash = null;
	
	      if (alignment === false) {
	        if (first === false) {
	          return;
	        }
	      } else {
	        align.push(alignment);
	        alignment = false;
	      }
	
	      first = false;
	    } else if (character === C_DASH) {
	      hasDash = true;
	      alignment = alignment || TABLE_ALIGN_NONE;
	    } else if (character === C_COLON) {
	      if (alignment === TABLE_ALIGN_LEFT) {
	        alignment = TABLE_ALIGN_CENTER;
	      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {
	        alignment = TABLE_ALIGN_RIGHT;
	      } else {
	        alignment = TABLE_ALIGN_LEFT;
	      }
	    } else if (!whitespace(character)) {
	      return;
	    }
	
	    index++;
	  }
	
	  if (alignment !== false) {
	    align.push(alignment);
	  }
	
	  /* Exit when without enough columns. */
	  if (align.length < MIN_TABLE_COLUMNS) {
	    return;
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  /* Parse the rows. */
	  position = -1;
	  rows = [];
	
	  table = eat(subvalue).reset({
	    type: 'table',
	    align: align,
	    children: rows
	  });
	
	  while (++position < lineCount) {
	    line = lines[position];
	    row = {type: 'tableRow', children: []};
	
	    /* Eat a newline character when this is not the
	     * first row. */
	    if (position) {
	      eat(C_NEWLINE);
	    }
	
	    /* Eat the row. */
	    eat(line).reset(row, table);
	
	    length = line.length + 1;
	    index = 0;
	    queue = '';
	    cell = '';
	    preamble = true;
	    count = null;
	    opening = null;
	
	    while (index < length) {
	      character = line.charAt(index);
	
	      if (character === C_TAB || character === C_SPACE) {
	        if (cell) {
	          queue += character;
	        } else {
	          eat(character);
	        }
	
	        index++;
	        continue;
	      }
	
	      if (character === '' || character === C_PIPE) {
	        if (preamble) {
	          eat(character);
	        } else {
	          if (character && opening) {
	            queue += character;
	            index++;
	            continue;
	          }
	
	          if ((cell || character) && !preamble) {
	            subvalue = cell;
	
	            if (queue.length > 1) {
	              if (character) {
	                subvalue += queue.slice(0, queue.length - 1);
	                queue = queue.charAt(queue.length - 1);
	              } else {
	                subvalue += queue;
	                queue = '';
	              }
	            }
	
	            now = eat.now();
	
	            eat(subvalue)({
	              type: 'tableCell',
	              children: self.tokenizeInline(cell, now)
	            }, row);
	          }
	
	          eat(queue + character);
	
	          queue = '';
	          cell = '';
	        }
	      } else {
	        if (queue) {
	          cell += queue;
	          queue = '';
	        }
	
	        cell += character;
	
	        if (character === C_BACKSLASH && index !== length - 2) {
	          cell += line.charAt(index + 1);
	          index++;
	        }
	
	        if (character === C_TICK) {
	          count = 1;
	
	          while (line.charAt(index + 1) === character) {
	            cell += character;
	            index++;
	            count++;
	          }
	
	          if (!opening) {
	            opening = count;
	          } else if (count >= opening) {
	            opening = 0;
	          }
	        }
	      }
	
	      preamble = false;
	      index++;
	    }
	
	    /* Eat the alignment row. */
	    if (!position) {
	      eat(C_NEWLINE + alignments);
	    }
	  }
	
	  return table;
	}


/***/ }),
/* 1019 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = text;
	
	function text(eat, value, silent) {
	  var self = this;
	  var methods;
	  var tokenizers;
	  var index;
	  var length;
	  var subvalue;
	  var position;
	  var tokenizer;
	  var name;
	  var min;
	  var now;
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  methods = self.inlineMethods;
	  length = methods.length;
	  tokenizers = self.inlineTokenizers;
	  index = -1;
	  min = value.length;
	
	  while (++index < length) {
	    name = methods[index];
	
	    if (name === 'text' || !tokenizers[name]) {
	      continue;
	    }
	
	    tokenizer = tokenizers[name].locator;
	
	    if (!tokenizer) {
	      eat.file.fail('Missing locator: `' + name + '`');
	    }
	
	    position = tokenizer.call(self, value, 1);
	
	    if (position !== -1 && position < min) {
	      min = position;
	    }
	  }
	
	  subvalue = value.slice(0, min);
	  now = eat.now();
	
	  self.decode(subvalue, now, function (content, position, source) {
	    eat(source || content)({
	      type: 'text',
	      value: content
	    });
	  });
	}


/***/ }),
/* 1020 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = thematicBreak;
	
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	var C_SPACE = ' ';
	var C_ASTERISK = '*';
	var C_UNDERSCORE = '_';
	var C_DASH = '-';
	
	var THEMATIC_BREAK_MARKER_COUNT = 3;
	
	function thematicBreak(eat, value, silent) {
	  var index = -1;
	  var length = value.length + 1;
	  var subvalue = '';
	  var character;
	  var marker;
	  var markerCount;
	  var queue;
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character !== C_TAB && character !== C_SPACE) {
	      break;
	    }
	
	    subvalue += character;
	  }
	
	  if (
	    character !== C_ASTERISK &&
	    character !== C_DASH &&
	    character !== C_UNDERSCORE
	  ) {
	    return;
	  }
	
	  marker = character;
	  subvalue += character;
	  markerCount = 1;
	  queue = '';
	
	  while (++index < length) {
	    character = value.charAt(index);
	
	    if (character === marker) {
	      markerCount++;
	      subvalue += queue + marker;
	      queue = '';
	    } else if (character === C_SPACE) {
	      queue += character;
	    } else if (
	      markerCount >= THEMATIC_BREAK_MARKER_COUNT &&
	      (!character || character === C_NEWLINE)
	    ) {
	      subvalue += queue;
	
	      if (silent) {
	        return true;
	      }
	
	      return eat(subvalue)({type: 'thematicBreak'});
	    } else {
	      return;
	    }
	  }
	}


/***/ }),
/* 1021 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var decode = __webpack_require__(175);
	var whitespace = __webpack_require__(25);
	var locate = __webpack_require__(993);
	
	module.exports = url;
	url.locator = locate;
	url.notInLink = true;
	
	var C_BRACKET_OPEN = '[';
	var C_BRACKET_CLOSE = ']';
	var C_PAREN_OPEN = '(';
	var C_PAREN_CLOSE = ')';
	var C_LT = '<';
	var C_AT_SIGN = '@';
	
	var HTTP_PROTOCOL = 'http://';
	var HTTPS_PROTOCOL = 'https://';
	var MAILTO_PROTOCOL = 'mailto:';
	
	var PROTOCOLS = [
	  HTTP_PROTOCOL,
	  HTTPS_PROTOCOL,
	  MAILTO_PROTOCOL
	];
	
	var PROTOCOLS_LENGTH = PROTOCOLS.length;
	
	function url(eat, value, silent) {
	  var self = this;
	  var subvalue;
	  var content;
	  var character;
	  var index;
	  var position;
	  var protocol;
	  var match;
	  var length;
	  var queue;
	  var parenCount;
	  var nextCharacter;
	  var exit;
	
	  if (!self.options.gfm) {
	    return;
	  }
	
	  subvalue = '';
	  index = -1;
	  length = PROTOCOLS_LENGTH;
	
	  while (++index < length) {
	    protocol = PROTOCOLS[index];
	    match = value.slice(0, protocol.length);
	
	    if (match.toLowerCase() === protocol) {
	      subvalue = match;
	      break;
	    }
	  }
	
	  if (!subvalue) {
	    return;
	  }
	
	  index = subvalue.length;
	  length = value.length;
	  queue = '';
	  parenCount = 0;
	
	  while (index < length) {
	    character = value.charAt(index);
	
	    if (whitespace(character) || character === C_LT) {
	      break;
	    }
	
	    if (
	      character === '.' ||
	      character === ',' ||
	      character === ':' ||
	      character === ';' ||
	      character === '"' ||
	      character === '\'' ||
	      character === ')' ||
	      character === ']'
	    ) {
	      nextCharacter = value.charAt(index + 1);
	
	      if (!nextCharacter || whitespace(nextCharacter)) {
	        break;
	      }
	    }
	
	    if (character === C_PAREN_OPEN || character === C_BRACKET_OPEN) {
	      parenCount++;
	    }
	
	    if (character === C_PAREN_CLOSE || character === C_BRACKET_CLOSE) {
	      parenCount--;
	
	      if (parenCount < 0) {
	        break;
	      }
	    }
	
	    queue += character;
	    index++;
	  }
	
	  if (!queue) {
	    return;
	  }
	
	  subvalue += queue;
	  content = subvalue;
	
	  if (protocol === MAILTO_PROTOCOL) {
	    position = queue.indexOf(C_AT_SIGN);
	
	    if (position === -1 || position === length - 1) {
	      return;
	    }
	
	    content = content.substr(MAILTO_PROTOCOL.length);
	  }
	
	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true;
	  }
	
	  exit = self.enterLink();
	  content = self.tokenizeInline(content, eat.now());
	  exit();
	
	  return eat(subvalue)({
	    type: 'link',
	    title: null,
	    url: decode(subvalue),
	    children: content
	  });
	}


/***/ }),
/* 1022 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = factory;
	
	var MERGEABLE_NODES = {
	  text: mergeText,
	  blockquote: mergeBlockquote
	};
	
	/* Check whether a node is mergeable with adjacent nodes. */
	function mergeable(node) {
	  var start;
	  var end;
	
	  if (node.type !== 'text' || !node.position) {
	    return true;
	  }
	
	  start = node.position.start;
	  end = node.position.end;
	
	  /* Only merge nodes which occupy the same size as their
	   * `value`. */
	  return start.line !== end.line ||
	      end.column - start.column === node.value.length;
	}
	
	/* Merge two text nodes: `node` into `prev`. */
	function mergeText(prev, node) {
	  prev.value += node.value;
	
	  return prev;
	}
	
	/* Merge two blockquotes: `node` into `prev`, unless in
	 * CommonMark mode. */
	function mergeBlockquote(prev, node) {
	  if (this.options.commonmark) {
	    return node;
	  }
	
	  prev.children = prev.children.concat(node.children);
	
	  return prev;
	}
	
	/* Construct a tokenizer.  This creates both
	 * `tokenizeInline` and `tokenizeBlock`. */
	function factory(type) {
	  return tokenize;
	
	  /* Tokenizer for a bound `type`. */
	  function tokenize(value, location) {
	    var self = this;
	    var offset = self.offset;
	    var tokens = [];
	    var methods = self[type + 'Methods'];
	    var tokenizers = self[type + 'Tokenizers'];
	    var line = location.line;
	    var column = location.column;
	    var index;
	    var length;
	    var method;
	    var name;
	    var matched;
	    var valueLength;
	
	    /* Trim white space only lines. */
	    if (!value) {
	      return tokens;
	    }
	
	    /* Expose on `eat`. */
	    eat.now = now;
	    eat.file = self.file;
	
	    /* Sync initial offset. */
	    updatePosition('');
	
	    /* Iterate over `value`, and iterate over all
	     * tokenizers.  When one eats something, re-iterate
	     * with the remaining value.  If no tokenizer eats,
	     * something failed (should not happen) and an
	     * exception is thrown. */
	    while (value) {
	      index = -1;
	      length = methods.length;
	      matched = false;
	
	      while (++index < length) {
	        name = methods[index];
	        method = tokenizers[name];
	
	        if (
	          method &&
	          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&
	          (!method.notInList || !self.inList) &&
	          (!method.notInBlock || !self.inBlock) &&
	          (!method.notInLink || !self.inLink)
	        ) {
	          valueLength = value.length;
	
	          method.apply(self, [eat, value]);
	
	          matched = valueLength !== value.length;
	
	          if (matched) {
	            break;
	          }
	        }
	      }
	
	      /* istanbul ignore if */
	      if (!matched) {
	        self.file.fail(new Error('Infinite loop'), eat.now());
	      }
	    }
	
	    self.eof = now();
	
	    return tokens;
	
	    /* Update line, column, and offset based on
	     * `value`. */
	    function updatePosition(subvalue) {
	      var lastIndex = -1;
	      var index = subvalue.indexOf('\n');
	
	      while (index !== -1) {
	        line++;
	        lastIndex = index;
	        index = subvalue.indexOf('\n', index + 1);
	      }
	
	      if (lastIndex === -1) {
	        column += subvalue.length;
	      } else {
	        column = subvalue.length - lastIndex;
	      }
	
	      if (line in offset) {
	        if (lastIndex !== -1) {
	          column += offset[line];
	        } else if (column <= offset[line]) {
	          column = offset[line] + 1;
	        }
	      }
	    }
	
	    /* Get offset.  Called before the first character is
	     * eaten to retrieve the range's offsets. */
	    function getOffset() {
	      var indentation = [];
	      var pos = line + 1;
	
	      /* Done.  Called when the last character is
	       * eaten to retrieve the range’s offsets. */
	      return function () {
	        var last = line + 1;
	
	        while (pos < last) {
	          indentation.push((offset[pos] || 0) + 1);
	
	          pos++;
	        }
	
	        return indentation;
	      };
	    }
	
	    /* Get the current position. */
	    function now() {
	      var pos = {line: line, column: column};
	
	      pos.offset = self.toOffset(pos);
	
	      return pos;
	    }
	
	    /* Store position information for a node. */
	    function Position(start) {
	      this.start = start;
	      this.end = now();
	    }
	
	    /* Throw when a value is incorrectly eaten.
	     * This shouldn’t happen but will throw on new,
	     * incorrect rules. */
	    function validateEat(subvalue) {
	      /* istanbul ignore if */
	      if (value.substring(0, subvalue.length) !== subvalue) {
	        /* Capture stack-trace. */
	        self.file.fail(
	          new Error(
	            'Incorrectly eaten value: please report this ' +
	            'warning on http://git.io/vg5Ft'
	          ),
	          now()
	        );
	      }
	    }
	
	    /* Mark position and patch `node.position`. */
	    function position() {
	      var before = now();
	
	      return update;
	
	      /* Add the position to a node. */
	      function update(node, indent) {
	        var prev = node.position;
	        var start = prev ? prev.start : before;
	        var combined = [];
	        var n = prev && prev.end.line;
	        var l = before.line;
	
	        node.position = new Position(start);
	
	        /* If there was already a `position`, this
	         * node was merged.  Fixing `start` wasn’t
	         * hard, but the indent is different.
	         * Especially because some information, the
	         * indent between `n` and `l` wasn’t
	         * tracked.  Luckily, that space is
	         * (should be?) empty, so we can safely
	         * check for it now. */
	        if (prev && indent && prev.indent) {
	          combined = prev.indent;
	
	          if (n < l) {
	            while (++n < l) {
	              combined.push((offset[n] || 0) + 1);
	            }
	
	            combined.push(before.column);
	          }
	
	          indent = combined.concat(indent);
	        }
	
	        node.position.indent = indent || [];
	
	        return node;
	      }
	    }
	
	    /* Add `node` to `parent`s children or to `tokens`.
	     * Performs merges where possible. */
	    function add(node, parent) {
	      var children = parent ? parent.children : tokens;
	      var prev = children[children.length - 1];
	
	      if (
	        prev &&
	        node.type === prev.type &&
	        node.type in MERGEABLE_NODES &&
	        mergeable(prev) &&
	        mergeable(node)
	      ) {
	        node = MERGEABLE_NODES[node.type].call(self, prev, node);
	      }
	
	      if (node !== prev) {
	        children.push(node);
	      }
	
	      if (self.atStart && tokens.length !== 0) {
	        self.exitStart();
	      }
	
	      return node;
	    }
	
	    /* Remove `subvalue` from `value`.
	     * `subvalue` must be at the start of `value`. */
	    function eat(subvalue) {
	      var indent = getOffset();
	      var pos = position();
	      var current = now();
	
	      validateEat(subvalue);
	
	      apply.reset = reset;
	      reset.test = test;
	      apply.test = test;
	
	      value = value.substring(subvalue.length);
	
	      updatePosition(subvalue);
	
	      indent = indent();
	
	      return apply;
	
	      /* Add the given arguments, add `position` to
	       * the returned node, and return the node. */
	      function apply(node, parent) {
	        return pos(add(pos(node), parent), indent);
	      }
	
	      /* Functions just like apply, but resets the
	       * content:  the line and column are reversed,
	       * and the eaten value is re-added.
	       * This is useful for nodes with a single
	       * type of content, such as lists and tables.
	       * See `apply` above for what parameters are
	       * expected. */
	      function reset() {
	        var node = apply.apply(null, arguments);
	
	        line = current.line;
	        column = current.column;
	        value = subvalue + value;
	
	        return node;
	      }
	
	      /* Test the position, after eating, and reverse
	       * to a not-eaten state. */
	      function test() {
	        var result = pos({});
	
	        line = current.line;
	        column = current.column;
	        value = subvalue + value;
	
	        return result.position;
	      }
	    }
	  }
	}


/***/ }),
/* 1023 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = factory;
	
	/* Factory to de-escape a value, based on a list at `key`
	 * in `ctx`. */
	function factory(ctx, key) {
	  return unescape;
	
	  /* De-escape a string using the expression at `key`
	   * in `ctx`. */
	  function unescape(value) {
	    var prev = 0;
	    var index = value.indexOf('\\');
	    var escape = ctx[key];
	    var queue = [];
	    var character;
	
	    while (index !== -1) {
	      queue.push(value.slice(prev, index));
	      prev = index + 1;
	      character = value.charAt(prev);
	
	      /* If the following character is not a valid escape,
	       * add the slash. */
	      if (!character || escape.indexOf(character) === -1) {
	        queue.push('\\');
	      }
	
	      index = value.indexOf('\\', prev);
	    }
	
	    queue.push(value.slice(prev));
	
	    return queue.join('');
	  }
	}


/***/ }),
/* 1024 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	var repeat = __webpack_require__(202);
	var getIndent = __webpack_require__(356);
	
	module.exports = indentation;
	
	var C_SPACE = ' ';
	var C_NEWLINE = '\n';
	var C_TAB = '\t';
	
	/* Remove the minimum indent from every line in `value`.
	 * Supports both tab, spaced, and mixed indentation (as
	 * well as possible). */
	function indentation(value, maximum) {
	  var values = value.split(C_NEWLINE);
	  var position = values.length + 1;
	  var minIndent = Infinity;
	  var matrix = [];
	  var index;
	  var indentation;
	  var stops;
	  var padding;
	
	  values.unshift(repeat(C_SPACE, maximum) + '!');
	
	  while (position--) {
	    indentation = getIndent(values[position]);
	
	    matrix[position] = indentation.stops;
	
	    if (trim(values[position]).length === 0) {
	      continue;
	    }
	
	    if (indentation.indent) {
	      if (indentation.indent > 0 && indentation.indent < minIndent) {
	        minIndent = indentation.indent;
	      }
	    } else {
	      minIndent = Infinity;
	
	      break;
	    }
	  }
	
	  if (minIndent !== Infinity) {
	    position = values.length;
	
	    while (position--) {
	      stops = matrix[position];
	      index = minIndent;
	
	      while (index && !(index in stops)) {
	        index--;
	      }
	
	      if (
	        trim(values[position]).length !== 0 &&
	        minIndent &&
	        index !== minIndent
	      ) {
	        padding = C_TAB;
	      } else {
	        padding = '';
	      }
	
	      values[position] = padding + values[position].slice(
	        index in stops ? stops[index] + 1 : 0
	      );
	    }
	  }
	
	  values.shift();
	
	  return values.join(C_NEWLINE);
	}


/***/ }),
/* 1025 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var path = __webpack_require__(300);
	
	function replaceExt(npath, ext) {
	  if (typeof npath !== 'string') {
	    return npath;
	  }
	
	  if (npath.length === 0) {
	    return npath;
	  }
	
	  var nFileName = path.basename(npath, path.extname(npath)) + ext;
	  return path.join(path.dirname(npath), nFileName);
	}
	
	module.exports = replaceExt;


/***/ }),
/* 1026 */,
/* 1027 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(203);
	var toSubscriber_1 = __webpack_require__(1036);
	var observable_1 = __webpack_require__(1030);
	var pipe_1 = __webpack_require__(1035);
	/**
	 * A representation of any set of values over any amount of time. This is the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
	     *
	     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
	     *
	     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
	     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
	     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
	     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
	     * thought.
	     *
	     * Apart from starting the execution of an Observable, this method allows you to listen for values
	     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
	     * following ways.
	     *
	     * The first way is creating an object that implements {@link Observer} interface. It should have methods
	     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
	     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
	     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
	     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
	     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
	     * be left uncaught.
	     *
	     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
	     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
	     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
	     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
	     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
	     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
	     *
	     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
	     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
	     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
	     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
	     *
	     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
	     * It is an Observable itself that decides when these functions will be called. For example {@link of}
	     * by default emits all its values synchronously. Always check documentation for how given Observable
	     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
	     *
	     * @example <caption>Subscribe with an Observer</caption>
	     * const sumObserver = {
	     *   sum: 0,
	     *   next(value) {
	     *     console.log('Adding: ' + value);
	     *     this.sum = this.sum + value;
	     *   },
	     *   error() { // We actually could just remove this method,
	     *   },        // since we do not really care about errors right now.
	     *   complete() {
	     *     console.log('Sum equals: ' + this.sum);
	     *   }
	     * };
	     *
	     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
	     * .subscribe(sumObserver);
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Subscribe with functions</caption>
	     * let sum = 0;
	     *
	     * Rx.Observable.of(1, 2, 3)
	     * .subscribe(
	     *   function(value) {
	     *     console.log('Adding: ' + value);
	     *     sum = sum + value;
	     *   },
	     *   undefined,
	     *   function() {
	     *     console.log('Sum equals: ' + sum);
	     *   }
	     * );
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Cancel a subscription</caption>
	     * const subscription = Rx.Observable.interval(1000).subscribe(
	     *   num => console.log(num),
	     *   undefined,
	     *   () => console.log('completed!') // Will not be called, even
	     * );                                // when cancelling subscription
	     *
	     *
	     * setTimeout(() => {
	     *   subscription.unsubscribe();
	     *   console.log('unsubscribed!');
	     * }, 2500);
	     *
	     * // Logs:
	     * // 0 after 1s
	     * // 1 after 2s
	     * // "unsubscribed!" after 2.5s
	     *
	     *
	     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
	     *  Observable.
	     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled.
	     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     * @method subscribe
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    /* tslint:enable:max-line-length */
	    /**
	     * Used to stitch together functional operators into a chain.
	     * @method pipe
	     * @return {Observable} the Observable result of all of the operators having
	     * been called in the order they were passed in.
	     *
	     * @example
	     *
	     * import { map, filter, scan } from 'rxjs/operators';
	     *
	     * Rx.Observable.interval(1000)
	     *   .pipe(
	     *     filter(x => x % 2 === 0),
	     *     map(x => x + x),
	     *     scan((acc, x) => acc + x)
	     *   )
	     *   .subscribe(x => console.log(x))
	     */
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i - 0] = arguments[_i];
	        }
	        if (operations.length === 0) {
	            return this;
	        }
	        return pipe_1.pipeFromArray(operations)(this);
	    };
	    /* tslint:enable:max-line-length */
	    Observable.prototype.toPromise = function (PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ }),
/* 1028 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(361);
	var Subscription_1 = __webpack_require__(1029);
	var Observer_1 = __webpack_require__(358);
	var rxSubscriber_1 = __webpack_require__(359);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 1029 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(1032);
	var isObject_1 = __webpack_require__(1033);
	var isFunction_1 = __webpack_require__(361);
	var tryCatch_1 = __webpack_require__(1037);
	var errorObject_1 = __webpack_require__(360);
	var UnsubscriptionError_1 = __webpack_require__(1031);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 1030 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(203);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ }),
/* 1031 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 1032 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ }),
/* 1033 */
/***/ (function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ }),
/* 1034 */
/***/ (function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ }),
/* 1035 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var noop_1 = __webpack_require__(1034);
	/* tslint:enable:max-line-length */
	function pipe() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i - 0] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	exports.pipe = pipe;
	/* @internal */
	function pipeFromArray(fns) {
	    if (!fns) {
	        return noop_1.noop;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}
	exports.pipeFromArray = pipeFromArray;
	//# sourceMappingURL=pipe.js.map

/***/ }),
/* 1036 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(1028);
	var rxSubscriber_1 = __webpack_require__(359);
	var Observer_1 = __webpack_require__(358);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 1037 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(360);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 1038 */,
/* 1039 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))

/***/ }),
/* 1040 */,
/* 1041 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var trim = __webpack_require__(43);
	
	exports.parse = parse;
	exports.stringify = stringify;
	
	var empty = '';
	var space = ' ';
	var whiteSpace = /[ \t\n\r\f]+/g;
	
	function parse(value) {
	  var input = trim(String(value || empty));
	
	  if (input === empty) {
	    return [];
	  }
	
	  return input.split(whiteSpace);
	}
	
	function stringify(values) {
	  return trim(values.join(space));
	}


/***/ }),
/* 1042 */
/***/ (function(module, exports) {

	/**
	 * @author Titus Wormer
	 * @copyright 2016 Titus Wormer
	 * @license MIT
	 * @module state-toggle
	 * @fileoverview Enter/exit a state.
	 */
	
	'use strict';
	
	/* eslint-env commonjs */
	
	/* Expose. */
	module.exports = factory;
	
	/**
	 * Construct a state `toggler`: a function which inverses
	 * `property` in context based on its current value.
	 * The by `toggler` returned function restores that value.
	 *
	 * @param {string} key - Property to toggle.
	 * @param {boolean} state - Default state.
	 * @param {Object?} [ctx] - Context object.
	 * @return {Function} - Enter.
	 */
	function factory(key, state, ctx) {
	  /**
	   * Enter a state.
	   *
	   * @return {Function} - Exit state.
	   */
	  return function () {
	    var context = ctx || this;
	    var current = context[key];
	
	    context[key] = !state;
	
	    /**
	     * Cancel state to its value before entering.
	     */
	    return function () {
	      context[key] = current;
	    };
	  };
	}


/***/ }),
/* 1043 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _object = __webpack_require__(672);
	
	var _object2 = _interopRequireDefault(_object);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var tags = {};
	var prevStyles = {};
	
	exports.default = typeof window === 'undefined' ? renderOnServer : renderOnClient;
	
	
	function renderOnServer() {}
	
	function renderOnClient(components) {
	  var styles = {};
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var c = _step.value;
	
	      styles[c.props.styleId] = c;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  patch(diff(prevStyles, styles));
	
	  prevStyles = styles;
	}
	
	function diff(a, b) {
	  var added = (0, _object2.default)(b).filter(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 1),
	        k = _ref2[0];
	
	    return !hasOwnProperty.call(a, k);
	  });
	  var removed = (0, _object2.default)(a).filter(function (_ref3) {
	    var _ref4 = _slicedToArray(_ref3, 1),
	        k = _ref4[0];
	
	    return !hasOwnProperty.call(b, k);
	  });
	  return [added, removed];
	}
	
	var fromServer = {};
	
	function patch(_ref5) {
	  var _ref6 = _slicedToArray(_ref5, 2),
	      added = _ref6[0],
	      removed = _ref6[1];
	
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = added[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _step2$value = _slicedToArray(_step2.value, 2),
	          id = _step2$value[0],
	          c = _step2$value[1];
	
	      // avoid duplicates from server-rendered markup
	      if (undefined === fromServer[id]) {
	        fromServer[id] = document.getElementById('__jsx-style-' + id);
	      }
	
	      tags[id] = fromServer[id] || makeStyleTag(c.props.css);
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = removed[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var _step3$value = _slicedToArray(_step3.value, 1),
	          id = _step3$value[0];
	
	      var t = tags[id];
	      delete tags[id];
	      t.parentNode.removeChild(t);
	      // avoid checking the DOM later on
	      fromServer[id] = null;
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	}
	
	function makeStyleTag(str) {
	  // based on implementation by glamor
	  var tag = document.createElement('style');
	  tag.appendChild(document.createTextNode(str));
	
	  var head = document.head || document.getElementsByTagName('head')[0];
	  head.appendChild(tag);
	
	  return tag;
	}

/***/ }),
/* 1044 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.flush = flush;
	
	var _react = __webpack_require__(2);
	
	var _render = __webpack_require__(1043);
	
	var _render2 = _interopRequireDefault(_render);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var update = typeof window === 'undefined' ? doRender : updateOnClient;
	var components = [];
	var updatePromise = void 0;
	
	// includes desktop and iOS, based on
	// https://github.com/DamonOehlman/detect-browser/blob/master/lib/detectBrowser.js
	var isSafari = typeof window === 'undefined' ? false : /Version\/[0-9._]+.*Safari/.test(window.navigator.userAgent);
	
	var _class = function (_Component) {
	  _inherits(_class, _Component);
	
	  function _class() {
	    _classCallCheck(this, _class);
	
	    return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	  }
	
	  _createClass(_class, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      mount(this);
	    }
	  }, {
	    key: 'componentWillUpdate',
	    value: function componentWillUpdate() {
	      update();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      unmount(this);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return null;
	    }
	  }]);
	
	  return _class;
	}(_react.Component);
	
	exports.default = _class;
	function flush() {
	  var ret = {};
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var props = _step.value.props;
	
	      ret[props.styleId] = props.css;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  components = [];
	
	  return ret;
	}
	
	function mount(component) {
	  components.push(component);
	  update();
	}
	
	function unmount(component) {
	  var i = components.indexOf(component);
	  if (i < 0) {
	    return;
	  }
	
	  components.splice(i, 1);
	  update();
	}
	
	function updateOnClient() {
	  if (isSafari) {
	    // debouncing causes FOUC in Safari
	    doRender();
	    return;
	  }
	
	  // Debounce calls and only render once the latest promise resolves.
	  // Promise#then() ensures micro task enqueuing of styles update before paint.
	  var promise = updatePromise = Promise.resolve().then(function () {
	    if (promise === updatePromise) {
	      updatePromise = null;
	      doRender();
	    }
	  });
	}
	
	function doRender() {
	  (0, _render2.default)(components);
	}

/***/ }),
/* 1045 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	var _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});
	var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
	var Backoff = __webpack_require__(387);
	var eventemitter3_1 = __webpack_require__(493);
	var isString = __webpack_require__(666);
	var isObject = __webpack_require__(665);
	var printer_1 = __webpack_require__(27);
	var getOperationAST_1 = __webpack_require__(262);
	var symbol_observable_1 = __webpack_require__(1050);
	var protocol_1 = __webpack_require__(1049);
	var defaults_1 = __webpack_require__(1046);
	var message_types_1 = __webpack_require__(1048);
	__export(__webpack_require__(1047));
	var SubscriptionClient = (function () {
	    function SubscriptionClient(url, options, webSocketImpl) {
	        var _a = (options || {}), _b = _a.connectionCallback, connectionCallback = _b === void 0 ? undefined : _b, _c = _a.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a.timeout, timeout = _d === void 0 ? defaults_1.WS_TIMEOUT : _d, _e = _a.reconnect, reconnect = _e === void 0 ? false : _e, _f = _a.reconnectionAttempts, reconnectionAttempts = _f === void 0 ? Infinity : _f, _g = _a.lazy, lazy = _g === void 0 ? false : _g;
	        this.wsImpl = webSocketImpl || NativeWebSocket;
	        if (!this.wsImpl) {
	            throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');
	        }
	        this.connectionParams = connectionParams;
	        this.connectionCallback = connectionCallback;
	        this.url = url;
	        this.operations = {};
	        this.nextOperationId = 0;
	        this.wsTimeout = timeout;
	        this.unsentMessagesQueue = [];
	        this.reconnect = reconnect;
	        this.reconnecting = false;
	        this.reconnectionAttempts = reconnectionAttempts;
	        this.lazy = !!lazy;
	        this.closedByUser = false;
	        this.backoff = new Backoff({ jitter: 0.5 });
	        this.eventEmitter = new eventemitter3_1.EventEmitter();
	        this.middlewares = [];
	        this.client = null;
	        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
	        if (!this.lazy) {
	            this.connect();
	        }
	    }
	    Object.defineProperty(SubscriptionClient.prototype, "status", {
	        get: function () {
	            if (this.client === null) {
	                return this.wsImpl.CLOSED;
	            }
	            return this.client.readyState;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SubscriptionClient.prototype.close = function (isForced, closedByUser) {
	        if (isForced === void 0) { isForced = true; }
	        if (closedByUser === void 0) { closedByUser = true; }
	        if (this.client !== null) {
	            this.closedByUser = closedByUser;
	            if (isForced) {
	                this.clearCheckConnectionInterval();
	                this.clearMaxConnectTimeout();
	                this.clearTryReconnectTimeout();
	                this.unsubscribeAll();
	                this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);
	            }
	            this.client.close();
	            this.client = null;
	            this.eventEmitter.emit('disconnected');
	            if (!isForced) {
	                this.tryReconnect();
	            }
	        }
	    };
	    SubscriptionClient.prototype.request = function (request) {
	        var getObserver = this.getObserver.bind(this);
	        var executeOperation = this.executeOperation.bind(this);
	        var unsubscribe = this.unsubscribe.bind(this);
	        var opId;
	        return _a = {},
	            _a[symbol_observable_1.default] = function () {
	                return this;
	            },
	            _a.subscribe = function (observerOrNext, onError, onComplete) {
	                var observer = getObserver(observerOrNext, onError, onComplete);
	                opId = executeOperation({
	                    query: request.query,
	                    variables: request.variables,
	                    operationName: request.operationName,
	                }, function (error, result) {
	                    if (error === null && result === null) {
	                        if (observer.complete) {
	                            observer.complete();
	                        }
	                    }
	                    else if (error) {
	                        if (observer.error) {
	                            observer.error(error[0]);
	                        }
	                    }
	                    else {
	                        if (observer.next) {
	                            observer.next(result);
	                        }
	                    }
	                });
	                return {
	                    unsubscribe: function () {
	                        if (opId) {
	                            unsubscribe(opId);
	                            opId = null;
	                        }
	                    },
	                };
	            },
	            _a;
	        var _a;
	    };
	    SubscriptionClient.prototype.query = function (options) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var handler = function (error, result) {
	                if (result) {
	                    resolve(result);
	                }
	                else {
	                    reject(error);
	                }
	            };
	            _this.executeOperation(options, handler);
	        });
	    };
	    SubscriptionClient.prototype.subscribe = function (options, handler) {
	        var legacyHandler = function (error, result) {
	            var operationPayloadData = result && result.data || null;
	            var operationPayloadErrors = result && result.errors || null;
	            if (error) {
	                operationPayloadErrors = error;
	                operationPayloadData = null;
	            }
	            if (error !== null || result !== null) {
	                handler(operationPayloadErrors, operationPayloadData);
	            }
	        };
	        if (this.client === null) {
	            this.connect();
	        }
	        if (!handler) {
	            throw new Error('Must provide an handler.');
	        }
	        return this.executeOperation(options, legacyHandler);
	    };
	    SubscriptionClient.prototype.on = function (eventName, callback, context) {
	        var handler = this.eventEmitter.on(eventName, callback, context);
	        return function () {
	            handler.off(eventName, callback, context);
	        };
	    };
	    SubscriptionClient.prototype.onConnect = function (callback, context) {
	        this.logWarningOnNonProductionEnv('This method will become deprecated in the next release. ' +
	            'You can use onConnecting and onConnected instead.');
	        return this.onConnecting(callback, context);
	    };
	    SubscriptionClient.prototype.onDisconnect = function (callback, context) {
	        this.logWarningOnNonProductionEnv('This method will become deprecated in the next release. ' +
	            'You can use onDisconnected instead.');
	        return this.onDisconnected(callback, context);
	    };
	    SubscriptionClient.prototype.onReconnect = function (callback, context) {
	        this.logWarningOnNonProductionEnv('This method will become deprecated in the next release. ' +
	            'You can use onReconnecting and onReconnected instead.');
	        return this.onReconnecting(callback, context);
	    };
	    SubscriptionClient.prototype.onConnected = function (callback, context) {
	        return this.on('connected', callback, context);
	    };
	    SubscriptionClient.prototype.onConnecting = function (callback, context) {
	        return this.on('connecting', callback, context);
	    };
	    SubscriptionClient.prototype.onDisconnected = function (callback, context) {
	        return this.on('disconnected', callback, context);
	    };
	    SubscriptionClient.prototype.onReconnected = function (callback, context) {
	        return this.on('reconnected', callback, context);
	    };
	    SubscriptionClient.prototype.onReconnecting = function (callback, context) {
	        return this.on('reconnecting', callback, context);
	    };
	    SubscriptionClient.prototype.unsubscribe = function (opId) {
	        if (this.operations[opId]) {
	            delete this.operations[opId];
	            this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);
	        }
	    };
	    SubscriptionClient.prototype.unsubscribeAll = function () {
	        var _this = this;
	        Object.keys(this.operations).forEach(function (subId) {
	            _this.unsubscribe(subId);
	        });
	    };
	    SubscriptionClient.prototype.applyMiddlewares = function (options) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var queue = function (funcs, scope) {
	                var next = function (error) {
	                    if (error) {
	                        reject(error);
	                    }
	                    else {
	                        if (funcs.length > 0) {
	                            var f = funcs.shift();
	                            if (f) {
	                                f.applyMiddleware.apply(scope, [options, next]);
	                            }
	                        }
	                        else {
	                            resolve(options);
	                        }
	                    }
	                };
	                next();
	            };
	            queue(_this.middlewares.slice(), _this);
	        });
	    };
	    SubscriptionClient.prototype.use = function (middlewares) {
	        var _this = this;
	        middlewares.map(function (middleware) {
	            if (typeof middleware.applyMiddleware === 'function') {
	                _this.middlewares.push(middleware);
	            }
	            else {
	                throw new Error('Middleware must implement the applyMiddleware function.');
	            }
	        });
	        return this;
	    };
	    SubscriptionClient.prototype.executeOperation = function (options, handler) {
	        var _this = this;
	        var opId = this.generateOperationId();
	        this.operations[opId] = { options: options, handler: handler };
	        this.applyMiddlewares(options)
	            .then(function (processedOptions) {
	            _this.checkOperationOptions(processedOptions, handler);
	            if (_this.operations[opId]) {
	                _this.operations[opId] = { options: processedOptions, handler: handler };
	                _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);
	            }
	        })
	            .catch(function (error) {
	            _this.unsubscribe(opId);
	            handler(_this.formatErrors(error));
	        });
	        return opId;
	    };
	    SubscriptionClient.prototype.getObserver = function (observerOrNext, error, complete) {
	        if (typeof observerOrNext === 'function') {
	            return {
	                next: function (v) { return observerOrNext(v); },
	                error: function (e) { return error && error(e); },
	                complete: function () { return complete && complete(); },
	            };
	        }
	        return observerOrNext;
	    };
	    SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {
	        var minValue = 1000;
	        var maxValue = this.wsTimeout;
	        return new Backoff({
	            min: minValue,
	            max: maxValue,
	            factor: 1.2,
	        });
	    };
	    SubscriptionClient.prototype.clearCheckConnectionInterval = function () {
	        if (this.checkConnectionIntervalId) {
	            clearInterval(this.checkConnectionIntervalId);
	            this.checkConnectionIntervalId = null;
	        }
	    };
	    SubscriptionClient.prototype.clearMaxConnectTimeout = function () {
	        if (this.maxConnectTimeoutId) {
	            clearTimeout(this.maxConnectTimeoutId);
	            this.maxConnectTimeoutId = null;
	        }
	    };
	    SubscriptionClient.prototype.clearTryReconnectTimeout = function () {
	        if (this.tryReconnectTimeoutId) {
	            clearTimeout(this.tryReconnectTimeoutId);
	            this.tryReconnectTimeoutId = null;
	        }
	    };
	    SubscriptionClient.prototype.logWarningOnNonProductionEnv = function (warning) {
	        if (process && ({"NODE_ENV":"production","PUBLIC_DIR":"/Users/home/Development/veritone-docs/public"}) && ("production") !== 'production') {
	            console.warn(warning);
	        }
	    };
	    SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {
	        var query = options.query, variables = options.variables, operationName = options.operationName;
	        if (!query) {
	            throw new Error('Must provide a query.');
	        }
	        if (!handler) {
	            throw new Error('Must provide an handler.');
	        }
	        if ((!isString(query) && !getOperationAST_1.getOperationAST(query, operationName)) ||
	            (operationName && !isString(operationName)) ||
	            (variables && !isObject(variables))) {
	            throw new Error('Incorrect option types. query must be a string or a document,' +
	                '`operationName` must be a string, and `variables` must be an object.');
	        }
	    };
	    SubscriptionClient.prototype.buildMessage = function (id, type, payload) {
	        var payloadToReturn = payload && payload.query ? __assign({}, payload, { query: typeof payload.query === 'string' ? payload.query : printer_1.print(payload.query) }) :
	            payload;
	        return {
	            id: id,
	            type: type,
	            payload: payloadToReturn,
	        };
	    };
	    SubscriptionClient.prototype.formatErrors = function (errors) {
	        if (Array.isArray(errors)) {
	            return errors;
	        }
	        if (errors && errors.errors) {
	            return this.formatErrors(errors.errors);
	        }
	        if (errors && errors.message) {
	            return [errors];
	        }
	        return [{
	                name: 'FormatedError',
	                message: 'Unknown error',
	                originalError: errors,
	            }];
	    };
	    SubscriptionClient.prototype.sendMessage = function (id, type, payload) {
	        this.sendMessageRaw(this.buildMessage(id, type, payload));
	    };
	    SubscriptionClient.prototype.sendMessageRaw = function (message) {
	        switch (this.status) {
	            case this.wsImpl.OPEN:
	                var serializedMessage = JSON.stringify(message);
	                var parsedMessage = void 0;
	                try {
	                    parsedMessage = JSON.parse(serializedMessage);
	                }
	                catch (e) {
	                    throw new Error("Message must be JSON-serializable. Got: " + message);
	                }
	                this.client.send(serializedMessage);
	                break;
	            case this.wsImpl.CONNECTING:
	                this.unsentMessagesQueue.push(message);
	                break;
	            default:
	                if (!this.reconnecting) {
	                    throw new Error('A message was not sent because socket is not connected, is closing or ' +
	                        'is already closed. Message was: ' + JSON.stringify(message));
	                }
	        }
	    };
	    SubscriptionClient.prototype.generateOperationId = function () {
	        return String(++this.nextOperationId);
	    };
	    SubscriptionClient.prototype.tryReconnect = function () {
	        var _this = this;
	        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
	            return;
	        }
	        if (!this.reconnecting) {
	            Object.keys(this.operations).forEach(function (key) {
	                _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));
	            });
	            this.reconnecting = true;
	        }
	        this.clearTryReconnectTimeout();
	        var delay = this.backoff.duration();
	        this.tryReconnectTimeoutId = setTimeout(function () {
	            _this.connect();
	        }, delay);
	    };
	    SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {
	        var _this = this;
	        this.unsentMessagesQueue.forEach(function (message) {
	            _this.sendMessageRaw(message);
	        });
	        this.unsentMessagesQueue = [];
	    };
	    SubscriptionClient.prototype.checkConnection = function () {
	        if (this.wasKeepAliveReceived) {
	            this.wasKeepAliveReceived = false;
	            return;
	        }
	        if (!this.reconnecting) {
	            this.close(false, true);
	        }
	    };
	    SubscriptionClient.prototype.checkMaxConnectTimeout = function () {
	        var _this = this;
	        this.clearMaxConnectTimeout();
	        this.maxConnectTimeoutId = setTimeout(function () {
	            if (_this.status !== _this.wsImpl.OPEN) {
	                _this.close(false, true);
	            }
	        }, this.maxConnectTimeGenerator.duration());
	    };
	    SubscriptionClient.prototype.connect = function () {
	        var _this = this;
	        this.client = new this.wsImpl(this.url, protocol_1.GRAPHQL_WS);
	        this.checkMaxConnectTimeout();
	        this.client.onopen = function () {
	            _this.clearMaxConnectTimeout();
	            _this.closedByUser = false;
	            _this.eventEmitter.emit(_this.reconnecting ? 'reconnecting' : 'connecting');
	            var payload = typeof _this.connectionParams === 'function' ? _this.connectionParams() : _this.connectionParams;
	            _this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, payload);
	            _this.flushUnsentMessagesQueue();
	        };
	        this.client.onclose = function () {
	            if (!_this.closedByUser) {
	                _this.close(false, false);
	            }
	        };
	        this.client.onerror = function () {
	        };
	        this.client.onmessage = function (_a) {
	            var data = _a.data;
	            _this.processReceivedData(data);
	        };
	    };
	    SubscriptionClient.prototype.processReceivedData = function (receivedData) {
	        var parsedMessage;
	        var opId;
	        try {
	            parsedMessage = JSON.parse(receivedData);
	            opId = parsedMessage.id;
	        }
	        catch (e) {
	            throw new Error("Message must be JSON-parseable. Got: " + receivedData);
	        }
	        if ([message_types_1.default.GQL_DATA,
	            message_types_1.default.GQL_COMPLETE,
	            message_types_1.default.GQL_ERROR,
	        ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
	            this.unsubscribe(opId);
	            return;
	        }
	        switch (parsedMessage.type) {
	            case message_types_1.default.GQL_CONNECTION_ERROR:
	                if (this.connectionCallback) {
	                    this.connectionCallback(parsedMessage.payload);
	                }
	                break;
	            case message_types_1.default.GQL_CONNECTION_ACK:
	                this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected');
	                this.reconnecting = false;
	                this.backoff.reset();
	                this.maxConnectTimeGenerator.reset();
	                if (this.connectionCallback) {
	                    this.connectionCallback();
	                }
	                break;
	            case message_types_1.default.GQL_COMPLETE:
	                this.operations[opId].handler(null, null);
	                delete this.operations[opId];
	                break;
	            case message_types_1.default.GQL_ERROR:
	                this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
	                delete this.operations[opId];
	                break;
	            case message_types_1.default.GQL_DATA:
	                var parsedPayload = !parsedMessage.payload.errors ?
	                    parsedMessage.payload : __assign({}, parsedMessage.payload, { errors: this.formatErrors(parsedMessage.payload.errors) });
	                this.operations[opId].handler(null, parsedPayload);
	                break;
	            case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:
	                var firstKA = typeof this.wasKeepAliveReceived === 'undefined';
	                this.wasKeepAliveReceived = true;
	                if (firstKA) {
	                    this.checkConnection();
	                }
	                if (this.checkConnectionIntervalId) {
	                    clearInterval(this.checkConnectionIntervalId);
	                    this.checkConnection();
	                }
	                this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
	                break;
	            default:
	                throw new Error('Invalid message type!');
	        }
	    };
	    return SubscriptionClient;
	}());
	exports.SubscriptionClient = SubscriptionClient;
	//# sourceMappingURL=client.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))

/***/ }),
/* 1046 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var WS_TIMEOUT = 10000;
	exports.WS_TIMEOUT = WS_TIMEOUT;
	//# sourceMappingURL=defaults.js.map

/***/ }),
/* 1047 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assign = __webpack_require__(663);
	function addGraphQLSubscriptions(networkInterface, wsClient) {
	    if (process && ({"NODE_ENV":"production","PUBLIC_DIR":"/Users/home/Development/veritone-docs/public"}) && ("production") !== 'production') {
	        console.warn('Notice that addGraphQLSubscriptions method will become deprecated in the new package ' +
	            'graphql-transport-ws that will be released soon. Keep track for the new hybrid network release here: ' +
	            'https://github.com/apollographql/subscriptions-transport-ws/issues/169');
	    }
	    return assign(networkInterface, {
	        subscribe: function (request, handler) {
	            return wsClient.subscribe(request, handler);
	        },
	        unsubscribe: function (id) {
	            wsClient.unsubscribe(id);
	        },
	    });
	}
	exports.addGraphQLSubscriptions = addGraphQLSubscriptions;
	//# sourceMappingURL=helpers.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 1048 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var MessageTypes = (function () {
	    function MessageTypes() {
	        throw new Error('Static Class');
	    }
	    MessageTypes.GQL_CONNECTION_INIT = 'connection_init';
	    MessageTypes.GQL_CONNECTION_ACK = 'connection_ack';
	    MessageTypes.GQL_CONNECTION_ERROR = 'connection_error';
	    MessageTypes.GQL_CONNECTION_KEEP_ALIVE = 'ka';
	    MessageTypes.GQL_CONNECTION_TERMINATE = 'connection_terminate';
	    MessageTypes.GQL_START = 'start';
	    MessageTypes.GQL_DATA = 'data';
	    MessageTypes.GQL_ERROR = 'error';
	    MessageTypes.GQL_COMPLETE = 'complete';
	    MessageTypes.GQL_STOP = 'stop';
	    MessageTypes.SUBSCRIPTION_START = 'subscription_start';
	    MessageTypes.SUBSCRIPTION_DATA = 'subscription_data';
	    MessageTypes.SUBSCRIPTION_SUCCESS = 'subscription_success';
	    MessageTypes.SUBSCRIPTION_FAIL = 'subscription_fail';
	    MessageTypes.SUBSCRIPTION_END = 'subscription_end';
	    MessageTypes.INIT = 'init';
	    MessageTypes.INIT_SUCCESS = 'init_success';
	    MessageTypes.INIT_FAIL = 'init_fail';
	    return MessageTypes;
	}());
	exports.default = MessageTypes;
	//# sourceMappingURL=message-types.js.map

/***/ }),
/* 1049 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var GRAPHQL_WS = 'graphql-ws';
	exports.GRAPHQL_WS = GRAPHQL_WS;
	var GRAPHQL_SUBSCRIPTIONS = 'graphql-subscriptions';
	exports.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;
	//# sourceMappingURL=protocol.js.map

/***/ }),
/* 1050 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1051);


/***/ }),
/* 1051 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ponyfill = __webpack_require__(1052);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var root; /* global window */
	
	
	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (true) {
	  root = module;
	} else {
	  root = Function('return this')();
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(207)(module)))

/***/ }),
/* 1052 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ }),
/* 1053 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(1039);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ }),
/* 1054 */
/***/ (function(module, exports) {

	'use strict';
	
	/* Expose. */
	module.exports = trough;
	
	/* Methods. */
	var slice = [].slice;
	
	/* Create new middleware. */
	function trough() {
	  var fns = [];
	  var middleware = {};
	
	  middleware.run = run;
	  middleware.use = use;
	
	  return middleware;
	
	  /* Run `fns`.  Last argument must be
	   * a completion handler. */
	  function run() {
	    var index = -1;
	    var input = slice.call(arguments, 0, -1);
	    var done = arguments[arguments.length - 1];
	
	    if (typeof done !== 'function') {
	      throw new Error('Expected function as last argument, not ' + done);
	    }
	
	    next.apply(null, [null].concat(input));
	
	    /* Run the next `fn`, if any. */
	    function next(err) {
	      var fn = fns[++index];
	      var params = slice.call(arguments, 0);
	      var values = params.slice(1);
	      var length = input.length;
	      var pos = -1;
	
	      if (err) {
	        done(err);
	        return;
	      }
	
	      /* Copy non-nully input into values. */
	      while (++pos < length) {
	        if (values[pos] === null || values[pos] === undefined) {
	          values[pos] = input[pos];
	        }
	      }
	
	      input = values;
	
	      /* Next or done. */
	      if (fn) {
	        wrap(fn, next).apply(null, input);
	      } else {
	        done.apply(null, [null].concat(input));
	      }
	    }
	  }
	
	  /* Add `fn` to the list. */
	  function use(fn) {
	    if (typeof fn !== 'function') {
	      throw new Error('Expected `fn` to be a function, not ' + fn);
	    }
	
	    fns.push(fn);
	
	    return middleware;
	  }
	}
	
	/* Wrap `fn`.  Can be sync or async; return a promise,
	 * receive a completion handler, return new values and
	 * errors. */
	function wrap(fn, next) {
	  var invoked;
	
	  return wrapped;
	
	  function wrapped() {
	    var params = slice.call(arguments, 0);
	    var callback = fn.length > params.length;
	    var result;
	
	    if (callback) {
	      params.push(done);
	    }
	
	    try {
	      result = fn.apply(null, params);
	    } catch (err) {
	      /* Well, this is quite the pickle.  `fn` received
	       * a callback and invoked it (thus continuing the
	       * pipeline), but later also threw an error.
	       * We’re not about to restart the pipeline again,
	       * so the only thing left to do is to throw the
	       * thing instea. */
	      if (callback && invoked) {
	        throw err;
	      }
	
	      return done(err);
	    }
	
	    if (!callback) {
	      if (result && typeof result.then === 'function') {
	        result.then(then, done);
	      } else if (result instanceof Error) {
	        done(result);
	      } else {
	        then(result);
	      }
	    }
	  }
	
	  /* Invoke `next`, only once. */
	  function done() {
	    if (!invoked) {
	      invoked = true;
	
	      next.apply(null, arguments);
	    }
	  }
	
	  /* Invoke `done` with one value.
	   * Tracks if an error is passed, too. */
	  function then(value) {
	    done(null, value);
	  }
	}


/***/ }),
/* 1055 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @author Titus Wormer
	 * @copyright 2015 Titus Wormer
	 * @license MIT
	 * @module unherit
	 * @fileoverview Create a custom constructor which can be modified
	 *   without affecting the original class.
	 */
	
	'use strict';
	
	/* Dependencies. */
	var xtend = __webpack_require__(44);
	var inherits = __webpack_require__(633);
	
	/* Expose. */
	module.exports = unherit;
	
	/**
	 * Create a custom constructor which can be modified
	 * without affecting the original class.
	 *
	 * @param {Function} Super - Super-class.
	 * @return {Function} - Constructor acting like `Super`,
	 *   which can be modified without affecting the original
	 *   class.
	 */
	function unherit(Super) {
	  var result;
	  var key;
	  var value;
	
	  inherits(Of, Super);
	  inherits(From, Of);
	
	  /* Clone values. */
	  result = Of.prototype;
	
	  for (key in result) {
	    value = result[key];
	
	    if (value && typeof value === 'object') {
	      result[key] = 'concat' in value ? value.concat() : xtend(value);
	    }
	  }
	
	  return Of;
	
	  /**
	   * Constructor accepting a single argument,
	   * which itself is an `arguments` object.
	   */
	  function From(parameters) {
	    return Super.apply(this, parameters);
	  }
	
	  /**
	   * Constructor accepting variadic arguments.
	   */
	  function Of() {
	    if (!(this instanceof Of)) {
	      return new From(arguments);
	    }
	
	    return Super.apply(this, arguments);
	  }
	}


/***/ }),
/* 1056 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/* Dependencies. */
	var extend = __webpack_require__(494);
	var bail = __webpack_require__(388);
	var vfile = __webpack_require__(1070);
	var trough = __webpack_require__(1054);
	var string = __webpack_require__(1073);
	var func = __webpack_require__(1072);
	var plain = __webpack_require__(638);
	
	/* Expose a frozen processor. */
	module.exports = unified().freeze();
	
	var slice = [].slice;
	var own = {}.hasOwnProperty;
	
	/* Process pipeline. */
	var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
	
	function pipelineParse(p, ctx) {
	  ctx.tree = p.parse(ctx.file);
	}
	
	function pipelineRun(p, ctx, next) {
	  p.run(ctx.tree, ctx.file, done);
	
	  function done(err, tree, file) {
	    if (err) {
	      next(err);
	    } else {
	      ctx.tree = tree;
	      ctx.file = file;
	      next();
	    }
	  }
	}
	
	function pipelineStringify(p, ctx) {
	  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
	}
	
	/* Function to create the first processor. */
	function unified() {
	  var attachers = [];
	  var transformers = trough();
	  var namespace = {};
	  var frozen = false;
	  var freezeIndex = -1;
	
	  /* Data management. */
	  processor.data = data;
	
	  /* Lock. */
	  processor.freeze = freeze;
	
	  /* Plug-ins. */
	  processor.attachers = attachers;
	  processor.use = use;
	
	  /* API. */
	  processor.parse = parse;
	  processor.stringify = stringify;
	  processor.run = run;
	  processor.runSync = runSync;
	  processor.process = process;
	  processor.processSync = processSync;
	
	  /* Expose. */
	  return processor;
	
	  /* Create a new processor based on the processor
	   * in the current scope. */
	  function processor() {
	    var destination = unified();
	    var length = attachers.length;
	    var index = -1;
	
	    while (++index < length) {
	      destination.use.apply(null, attachers[index]);
	    }
	
	    destination.data(extend(true, {}, namespace));
	
	    return destination;
	  }
	
	  /* Freeze: used to signal a processor that has finished
	   * configuration.
	   *
	   * For example, take unified itself.  It’s frozen.
	   * Plug-ins should not be added to it.  Rather, it should
	   * be extended, by invoking it, before modifying it.
	   *
	   * In essence, always invoke this when exporting a
	   * processor. */
	  function freeze() {
	    var values;
	    var plugin;
	    var options;
	    var transformer;
	
	    if (frozen) {
	      return processor;
	    }
	
	    while (++freezeIndex < attachers.length) {
	      values = attachers[freezeIndex];
	      plugin = values[0];
	      options = values[1];
	      transformer = null;
	
	      if (options === false) {
	        continue;
	      }
	
	      if (options === true) {
	        values[1] = undefined;
	      }
	
	      transformer = plugin.apply(processor, values.slice(1));
	
	      if (func(transformer)) {
	        transformers.use(transformer);
	      }
	    }
	
	    frozen = true;
	    freezeIndex = Infinity;
	
	    return processor;
	  }
	
	  /* Data management.
	   * Getter / setter for processor-specific informtion. */
	  function data(key, value) {
	    if (string(key)) {
	      /* Set `key`. */
	      if (arguments.length === 2) {
	        assertUnfrozen('data', frozen);
	
	        namespace[key] = value;
	
	        return processor;
	      }
	
	      /* Get `key`. */
	      return (own.call(namespace, key) && namespace[key]) || null;
	    }
	
	    /* Set space. */
	    if (key) {
	      assertUnfrozen('data', frozen);
	      namespace = key;
	      return processor;
	    }
	
	    /* Get space. */
	    return namespace;
	  }
	
	  /* Plug-in management.
	   *
	   * Pass it:
	   * *   an attacher and options,
	   * *   a preset,
	   * *   a list of presets, attachers, and arguments (list
	   *     of attachers and options). */
	  function use(value) {
	    var settings;
	
	    assertUnfrozen('use', frozen);
	
	    if (value === null || value === undefined) {
	      /* Empty */
	    } else if (func(value)) {
	      addPlugin.apply(null, arguments);
	    } else if (typeof value === 'object') {
	      if ('length' in value) {
	        addList(value);
	      } else {
	        addPreset(value);
	      }
	    } else {
	      throw new Error('Expected usable value, not `' + value + '`');
	    }
	
	    if (settings) {
	      namespace.settings = extend(namespace.settings || {}, settings);
	    }
	
	    return processor;
	
	    function addPreset(result) {
	      addList(result.plugins);
	
	      if (result.settings) {
	        settings = extend(settings || {}, result.settings);
	      }
	    }
	
	    function add(value) {
	      if (func(value)) {
	        addPlugin(value);
	      } else if (typeof value === 'object') {
	        if ('length' in value) {
	          addPlugin.apply(null, value);
	        } else {
	          addPreset(value);
	        }
	      } else {
	        throw new Error('Expected usable value, not `' + value + '`');
	      }
	    }
	
	    function addList(plugins) {
	      var length;
	      var index;
	
	      if (plugins === null || plugins === undefined) {
	        /* Empty */
	      } else if (typeof plugins === 'object' && 'length' in plugins) {
	        length = plugins.length;
	        index = -1;
	
	        while (++index < length) {
	          add(plugins[index]);
	        }
	      } else {
	        throw new Error('Expected a list of plugins, not `' + plugins + '`');
	      }
	    }
	
	    function addPlugin(plugin, value) {
	      var entry = find(plugin);
	
	      if (entry) {
	        if (plain(entry[1]) && plain(value)) {
	          value = extend(entry[1], value);
	        }
	
	        entry[1] = value;
	      } else {
	        attachers.push(slice.call(arguments));
	      }
	    }
	  }
	
	  function find(plugin) {
	    var length = attachers.length;
	    var index = -1;
	    var entry;
	
	    while (++index < length) {
	      entry = attachers[index];
	
	      if (entry[0] === plugin) {
	        return entry;
	      }
	    }
	  }
	
	  /* Parse a file (in string or VFile representation)
	   * into a Unist node using the `Parser` on the
	   * processor. */
	  function parse(doc) {
	    var file = vfile(doc);
	    var Parser;
	
	    freeze();
	    Parser = processor.Parser;
	    assertParser('parse', Parser);
	
	    if (newable(Parser)) {
	      return new Parser(String(file), file).parse();
	    }
	
	    return Parser(String(file), file); // eslint-disable-line new-cap
	  }
	
	  /* Run transforms on a Unist node representation of a file
	   * (in string or VFile representation), async. */
	  function run(node, file, cb) {
	    assertNode(node);
	    freeze();
	
	    if (!cb && func(file)) {
	      cb = file;
	      file = null;
	    }
	
	    if (!cb) {
	      return new Promise(executor);
	    }
	
	    executor(null, cb);
	
	    function executor(resolve, reject) {
	      transformers.run(node, vfile(file), done);
	
	      function done(err, tree, file) {
	        tree = tree || node;
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(tree);
	        } else {
	          cb(null, tree, file);
	        }
	      }
	    }
	  }
	
	  /* Run transforms on a Unist node representation of a file
	   * (in string or VFile representation), sync. */
	  function runSync(node, file) {
	    var complete = false;
	    var result;
	
	    run(node, file, done);
	
	    assertDone('runSync', 'run', complete);
	
	    return result;
	
	    function done(err, tree) {
	      complete = true;
	      bail(err);
	      result = tree;
	    }
	  }
	
	  /* Stringify a Unist node representation of a file
	   * (in string or VFile representation) into a string
	   * using the `Compiler` on the processor. */
	  function stringify(node, doc) {
	    var file = vfile(doc);
	    var Compiler;
	
	    freeze();
	    Compiler = processor.Compiler;
	    assertCompiler('stringify', Compiler);
	    assertNode(node);
	
	    if (newable(Compiler)) {
	      return new Compiler(node, file).compile();
	    }
	
	    return Compiler(node, file); // eslint-disable-line new-cap
	  }
	
	  /* Parse a file (in string or VFile representation)
	   * into a Unist node using the `Parser` on the processor,
	   * then run transforms on that node, and compile the
	   * resulting node using the `Compiler` on the processor,
	   * and store that result on the VFile. */
	  function process(doc, cb) {
	    freeze();
	    assertParser('process', processor.Parser);
	    assertCompiler('process', processor.Compiler);
	
	    if (!cb) {
	      return new Promise(executor);
	    }
	
	    executor(null, cb);
	
	    function executor(resolve, reject) {
	      var file = vfile(doc);
	
	      pipeline.run(processor, {file: file}, done);
	
	      function done(err) {
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(file);
	        } else {
	          cb(null, file);
	        }
	      }
	    }
	  }
	
	  /* Process the given document (in string or VFile
	   * representation), sync. */
	  function processSync(doc) {
	    var complete = false;
	    var file;
	
	    freeze();
	    assertParser('processSync', processor.Parser);
	    assertCompiler('processSync', processor.Compiler);
	    file = vfile(doc);
	
	    process(file, done);
	
	    assertDone('processSync', 'process', complete);
	
	    return file;
	
	    function done(err) {
	      complete = true;
	      bail(err);
	    }
	  }
	}
	
	/* Check if `func` is a constructor. */
	function newable(value) {
	  return func(value) && keys(value.prototype);
	}
	
	/* Check if `value` is an object with keys. */
	function keys(value) {
	  var key;
	  for (key in value) {
	    return true;
	  }
	  return false;
	}
	
	/* Assert a parser is available. */
	function assertParser(name, Parser) {
	  if (!func(Parser)) {
	    throw new Error('Cannot `' + name + '` without `Parser`');
	  }
	}
	
	/* Assert a compiler is available. */
	function assertCompiler(name, Compiler) {
	  if (!func(Compiler)) {
	    throw new Error('Cannot `' + name + '` without `Compiler`');
	  }
	}
	
	/* Assert the processor is not frozen. */
	function assertUnfrozen(name, frozen) {
	  if (frozen) {
	    throw new Error(
	      'Cannot invoke `' + name + '` on a frozen processor.\n' +
	      'Create a new processor first, by invoking it: ' +
	      'use `processor()` instead of `processor`.'
	    );
	  }
	}
	
	/* Assert `node` is a Unist node. */
	function assertNode(node) {
	  if (!node || !string(node.type)) {
	    throw new Error('Expected node, got `' + node + '`');
	  }
	}
	
	/* Assert that `complete` is `true`. */
	function assertDone(name, asyncName, complete) {
	  if (!complete) {
	    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 1057 */
/***/ (function(module, exports) {

	'use strict';
	
	/* eslint-disable max-params */
	
	/* Expose. */
	module.exports = is;
	
	/* Assert if `test` passes for `node`.
	 * When a `parent` node is known the `index` of node */
	function is(test, node, index, parent, context) {
	  var hasParent = parent !== null && parent !== undefined;
	  var hasIndex = index !== null && index !== undefined;
	  var check = convert(test);
	
	  if (
	    hasIndex &&
	    (typeof index !== 'number' || index < 0 || index === Infinity)
	  ) {
	    throw new Error('Expected positive finite index or child node');
	  }
	
	  if (hasParent && (!is(null, parent) || !parent.children)) {
	    throw new Error('Expected parent node');
	  }
	
	  if (!node || !node.type || typeof node.type !== 'string') {
	    return false;
	  }
	
	  if (hasParent !== hasIndex) {
	    throw new Error('Expected both parent and index');
	  }
	
	  return Boolean(check.call(context, node, index, parent));
	}
	
	function convert(test) {
	  if (typeof test === 'string') {
	    return typeFactory(test);
	  }
	
	  if (test === null || test === undefined) {
	    return ok;
	  }
	
	  if (typeof test === 'object') {
	    return ('length' in test ? anyFactory : matchesFactory)(test);
	  }
	
	  if (typeof test === 'function') {
	    return test;
	  }
	
	  throw new Error('Expected function, string, or object as test');
	}
	
	function convertAll(tests) {
	  var results = [];
	  var length = tests.length;
	  var index = -1;
	
	  while (++index < length) {
	    results[index] = convert(tests[index]);
	  }
	
	  return results;
	}
	
	/* Utility assert each property in `test` is represented
	 * in `node`, and each values are strictly equal. */
	function matchesFactory(test) {
	  return matches;
	
	  function matches(node) {
	    var key;
	
	    for (key in test) {
	      if (node[key] !== test[key]) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	}
	
	function anyFactory(tests) {
	  var checks = convertAll(tests);
	  var length = checks.length;
	
	  return matches;
	
	  function matches() {
	    var index = -1;
	
	    while (++index < length) {
	      if (checks[index].apply(this, arguments)) {
	        return true;
	      }
	    }
	
	    return false;
	  }
	}
	
	/* Utility to convert a string into a function which checks
	 * a given node’s type for said string. */
	function typeFactory(test) {
	  return type;
	
	  function type(node) {
	    return Boolean(node && node.type === test);
	  }
	}
	
	/* Utility to return true. */
	function ok() {
	  return true;
	}


/***/ }),
/* 1058 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var visit = __webpack_require__(121);
	
	module.exports = removePosition;
	
	/* Remove `position`s from `tree`. */
	function removePosition(node, force) {
	  visit(node, force ? hard : soft);
	  return node;
	}
	
	function hard(node) {
	  delete node.position;
	}
	
	function soft(node) {
	  node.position = undefined;
	}


/***/ }),
/* 1059 */
/***/ (function(module, exports) {

	'use strict';
	
	var own = {}.hasOwnProperty;
	
	module.exports = stringify;
	
	function stringify(value) {
	  /* Nothing. */
	  if (!value || typeof value !== 'object') {
	    return null;
	  }
	
	  /* Node. */
	  if (own.call(value, 'position') || own.call(value, 'type')) {
	    return location(value.position);
	  }
	
	  /* Location. */
	  if (own.call(value, 'start') || own.call(value, 'end')) {
	    return location(value);
	  }
	
	  /* Position. */
	  if (own.call(value, 'line') || own.call(value, 'column')) {
	    return position(value);
	  }
	
	  /* ? */
	  return null;
	}
	
	function position(pos) {
	  if (!pos || typeof pos !== 'object') {
	    pos = {};
	  }
	
	  return index(pos.line) + ':' + index(pos.column);
	}
	
	function location(loc) {
	  if (!loc || typeof loc !== 'object') {
	    loc = {};
	  }
	
	  return position(loc.start) + '-' + position(loc.end);
	}
	
	function index(value) {
	  return value && typeof value === 'number' ? value : 1;
	}


/***/ }),
/* 1060 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTRweCIgaGVpZ2h0PSIxMXB4IiB2aWV3Qm94PSItMSAtMSAxNCAxMSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDxwYXRoCiAgICAgICAgZD0iTTUsOC43OTgyNTU3OSBMNSwtMS43OTQwMjA4OSIKICAgICAgICBpZD0iU3Ryb2tlLTMiCiAgICAgICAgc3Ryb2tlPSIjRkZGRkZGIgogICAgICAgIHN0cm9rZS13aWR0aD0iMS41IgogICAgICAgIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIKICAgICAgICBzdHJva2UtbGluZWpvaW49InJvdW5kIgogICAgICAgIGZpbGw9Im5vbmUiCiAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS43NTAwMDAsIDMuNTAyMTE3KSByb3RhdGUoLTkwLjAwMDAwMCkgdHJhbnNsYXRlKC01Ljc1MDAwMCwgLTMuNTAyMTE3KSAiCiAgICA+PC9wYXRoPgogICAgPHBvbHlsaW5lIGlkPSJTdHJva2UtNSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBmaWxsPSJub25lIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5Ljg2ODI5NSwgNC4zMzM5OTIpIHJvdGF0ZSgtOTAuMDAwMDAwKSB0cmFuc2xhdGUoLTkuODY4Mjk1LCAtNC4zMzM5OTIpICIgcG9pbnRzPSIxNC4yMDIyODY4IDIuMTY2OTk2MDUgOS44NjgyOTQ3NSA2LjUwMDk4ODE0IDUuNTM0MzAyNjUgMi4xNjY5OTYwNSI+PC9wb2x5bGluZT4KPC9zdmc+"

/***/ }),
/* 1061 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjxzdmcgd2lkdGg9IjUwcHgiIGhlaWdodD0iNTBweCIgdmlld0JveD0iMCAwIDUwIDUwIj4NCgk8Y2lyY2xlIGN4PSIxNy44MiIgY3k9IjE4LjExIiByPSIxNi4yMSIvPg0KCTxsaW5lIHgxPSIyOS4yOCIgeTE9IjI5LjU3IiB4Mj0iNDguMjEiIHkyPSI0OC41Ii8+DQo8L3N2Zz4NCg=="

/***/ }),
/* 1062 */,
/* 1063 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }),
/* 1064 */
/***/ (function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ }),
/* 1065 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = ({"NODE_ENV":"production","PUBLIC_DIR":"/Users/home/Development/veritone-docs/public"}).NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(1064);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(1063);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))

/***/ }),
/* 1066 */,
/* 1067 */
/***/ (function(module, exports) {

	'use strict';
	
	/* Expose. */
	module.exports = factory;
	
	/* Factory. */
	function factory(file) {
	  var contents = indices(String(file));
	
	  return {
	    toPosition: offsetToPositionFactory(contents),
	    toOffset: positionToOffsetFactory(contents)
	  };
	}
	
	/* Factory to get the line and column-based `position` for
	 * `offset` in the bound indices. */
	function offsetToPositionFactory(indices) {
	  return offsetToPosition;
	
	  /* Get the line and column-based `position` for
	   * `offset` in the bound indices. */
	  function offsetToPosition(offset) {
	    var index = -1;
	    var length = indices.length;
	
	    if (offset < 0) {
	      return {};
	    }
	
	    while (++index < length) {
	      if (indices[index] > offset) {
	        return {
	          line: index + 1,
	          column: (offset - (indices[index - 1] || 0)) + 1,
	          offset: offset
	        };
	      }
	    }
	
	    return {};
	  }
	}
	
	/* Factory to get the `offset` for a line and column-based
	 * `position` in the bound indices. */
	function positionToOffsetFactory(indices) {
	  return positionToOffset;
	
	  /* Get the `offset` for a line and column-based
	   * `position` in the bound indices. */
	  function positionToOffset(position) {
	    var line = position && position.line;
	    var column = position && position.column;
	
	    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
	      return ((indices[line - 2] || 0) + column - 1) || 0;
	    }
	
	    return -1;
	  }
	}
	
	/* Get indices of line-breaks in `value`. */
	function indices(value) {
	  var result = [];
	  var index = value.indexOf('\n');
	
	  while (index !== -1) {
	    result.push(index + 1);
	    index = value.indexOf('\n', index + 1);
	  }
	
	  result.push(value.length + 1);
	
	  return result;
	}


/***/ }),
/* 1068 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var stringify = __webpack_require__(1059);
	
	module.exports = VMessage;
	
	/* Inherit from `Error#`. */
	function VMessagePrototype() {}
	VMessagePrototype.prototype = Error.prototype;
	VMessage.prototype = new VMessagePrototype();
	
	/* Message properties. */
	var proto = VMessage.prototype;
	
	proto.file = '';
	proto.name = '';
	proto.reason = '';
	proto.message = '';
	proto.stack = '';
	proto.fatal = null;
	proto.column = null;
	proto.line = null;
	
	/* Construct a new VMessage.
	 *
	 * Note: We cannot invoke `Error` on the created context,
	 * as that adds readonly `line` and `column` attributes on
	 * Safari 9, thus throwing and failing the data. */
	function VMessage(reason, position, origin) {
	  var parts;
	  var range;
	  var location;
	
	  if (typeof position === 'string') {
	    origin = position;
	    position = null;
	  }
	
	  parts = parseOrigin(origin);
	  range = stringify(position) || '1:1';
	
	  location = {
	    start: {line: null, column: null},
	    end: {line: null, column: null}
	  };
	
	  /* Node. */
	  if (position && position.position) {
	    position = position.position;
	  }
	
	  if (position) {
	    /* Position. */
	    if (position.start) {
	      location = position;
	      position = position.start;
	    } else {
	      /* Point. */
	      location.start = position;
	    }
	  }
	
	  if (reason.stack) {
	    this.stack = reason.stack;
	    reason = reason.message;
	  }
	
	  this.message = reason;
	  this.name = range;
	  this.reason = reason;
	  this.line = position ? position.line : null;
	  this.column = position ? position.column : null;
	  this.location = location;
	  this.source = parts[0];
	  this.ruleId = parts[1];
	}
	
	function parseOrigin(origin) {
	  var result = [null, null];
	  var index;
	
	  if (typeof origin === 'string') {
	    index = origin.indexOf(':');
	
	    if (index === -1) {
	      result[1] = origin;
	    } else {
	      result[0] = origin.slice(0, index);
	      result[1] = origin.slice(index + 1);
	    }
	  }
	
	  return result;
	}


/***/ }),
/* 1069 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var path = __webpack_require__(300);
	var replace = __webpack_require__(1025);
	var buffer = __webpack_require__(635);
	
	module.exports = VFile;
	
	var own = {}.hasOwnProperty;
	var proto = VFile.prototype;
	
	proto.toString = toString;
	
	/* Order of setting (least specific to most), we need this because
	 * otherwise `{stem: 'a', path: '~/b.js'}` would throw, as a path
	 * is needed before a stem can be set. */
	var order = [
	  'history',
	  'path',
	  'basename',
	  'stem',
	  'extname',
	  'dirname'
	];
	
	/* Construct a new file. */
	function VFile(options) {
	  var prop;
	  var index;
	  var length;
	
	  if (!options) {
	    options = {};
	  } else if (typeof options === 'string' || buffer(options)) {
	    options = {contents: options};
	  } else if ('message' in options && 'messages' in options) {
	    return options;
	  }
	
	  if (!(this instanceof VFile)) {
	    return new VFile(options);
	  }
	
	  this.data = {};
	  this.messages = [];
	  this.history = [];
	  this.cwd = process.cwd();
	
	  /* Set path related properties in the correct order. */
	  index = -1;
	  length = order.length;
	
	  while (++index < length) {
	    prop = order[index];
	
	    if (own.call(options, prop)) {
	      this[prop] = options[prop];
	    }
	  }
	
	  /* Set non-path related properties. */
	  for (prop in options) {
	    if (order.indexOf(prop) === -1) {
	      this[prop] = options[prop];
	    }
	  }
	}
	
	/* Access full path (`~/index.min.js`). */
	Object.defineProperty(proto, 'path', {
	  get: function () {
	    return this.history[this.history.length - 1];
	  },
	  set: function (path) {
	    assertNonEmpty(path, 'path');
	
	    if (path !== this.path) {
	      this.history.push(path);
	    }
	  }
	});
	
	/* Access parent path (`~`). */
	Object.defineProperty(proto, 'dirname', {
	  get: function () {
	    return typeof this.path === 'string' ? path.dirname(this.path) : undefined;
	  },
	  set: function (dirname) {
	    assertPath(this.path, 'dirname');
	    this.path = path.join(dirname || '', this.basename);
	  }
	});
	
	/* Access basename (`index.min.js`). */
	Object.defineProperty(proto, 'basename', {
	  get: function () {
	    return typeof this.path === 'string' ? path.basename(this.path) : undefined;
	  },
	  set: function (basename) {
	    assertNonEmpty(basename, 'basename');
	    assertPart(basename, 'basename');
	    this.path = path.join(this.dirname || '', basename);
	  }
	});
	
	/* Access extname (`.js`). */
	Object.defineProperty(proto, 'extname', {
	  get: function () {
	    return typeof this.path === 'string' ? path.extname(this.path) : undefined;
	  },
	  set: function (extname) {
	    var ext = extname || '';
	
	    assertPart(ext, 'extname');
	    assertPath(this.path, 'extname');
	
	    if (ext) {
	      if (ext.charAt(0) !== '.') {
	        throw new Error('`extname` must start with `.`');
	      }
	
	      if (ext.indexOf('.', 1) !== -1) {
	        throw new Error('`extname` cannot contain multiple dots');
	      }
	    }
	
	    this.path = replace(this.path, ext);
	  }
	});
	
	/* Access stem (`index.min`). */
	Object.defineProperty(proto, 'stem', {
	  get: function () {
	    return typeof this.path === 'string' ? path.basename(this.path, this.extname) : undefined;
	  },
	  set: function (stem) {
	    assertNonEmpty(stem, 'stem');
	    assertPart(stem, 'stem');
	    this.path = path.join(this.dirname || '', stem + (this.extname || ''));
	  }
	});
	
	/* Get the value of the file. */
	function toString(encoding) {
	  var value = this.contents || '';
	  return buffer(value) ? value.toString(encoding) : String(value);
	}
	
	/* Assert that `part` is not a path (i.e., does
	 * not contain `path.sep`). */
	function assertPart(part, name) {
	  if (part.indexOf(path.sep) !== -1) {
	    throw new Error('`' + name + '` cannot be a path: did not expect `' + path.sep + '`');
	  }
	}
	
	/* Assert that `part` is not empty. */
	function assertNonEmpty(part, name) {
	  if (!part) {
	    throw new Error('`' + name + '` cannot be empty');
	  }
	}
	
	/* Assert `path` exists. */
	function assertPath(path, name) {
	  if (!path) {
	    throw new Error('Setting `' + name + '` requires `path` to be set too');
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 1070 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var VMessage = __webpack_require__(1068);
	var VFile = __webpack_require__(1069);
	
	module.exports = VFile;
	
	var proto = VFile.prototype;
	
	proto.message = message;
	proto.info = info;
	proto.fail = fail;
	
	/* Slight backwards compatibility.  Remove in the future. */
	proto.warn = message;
	
	/* Create a message with `reason` at `position`.
	 * When an error is passed in as `reason`, copies the stack. */
	function message(reason, position, origin) {
	  var filePath = this.path;
	  var message = new VMessage(reason, position, origin);
	
	  if (filePath) {
	    message.name = filePath + ':' + message.name;
	    message.file = filePath;
	  }
	
	  message.fatal = false;
	
	  this.messages.push(message);
	
	  return message;
	}
	
	/* Fail. Creates a vmessage, associates it with the file,
	 * and throws it. */
	function fail() {
	  var message = this.message.apply(this, arguments);
	
	  message.fatal = true;
	
	  throw message;
	}
	
	/* Info. Creates a vmessage, associates it with the file,
	 * and marks the fatality as null. */
	function info() {
	  var message = this.message.apply(this, arguments);
	
	  message.fatal = null;
	
	  return message;
	}


/***/ }),
/* 1071 */
/***/ (function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	    } else if (Array.isArray(headers)) {
	      headers.forEach(function(header) {
	        this.append(header[0], header[1])
	      }, this)
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 1072 */
/***/ (function(module, exports) {

	module.exports = function isFunction (fn) {
	  return Object.prototype.toString.call(fn) === '[object Function]'
	}


/***/ }),
/* 1073 */
/***/ (function(module, exports) {

	var toString = Object.prototype.toString
	
	module.exports = isString
	
	function isString(obj) {
	    return toString.call(obj) === "[object String]"
	}


/***/ })
]);
//# sourceMappingURL=component---src-templates-markdown-js-f3ed095207cde9f29b00.js.map